"""
ACGS-2 Core Message Schemas

Implementation of the core message schemas defined in the architecture manifest.
All inter-component communication uses these standardized envelopes and payloads.
"""

import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional

# =============================================================================
# Core Envelopes
# =============================================================================


@dataclass
class CoreEnvelope:
    """Common envelope for all inter-component messages with traceability."""

    request_id: str
    session_id: str
    timestamp: str
    actor: str
    payload: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def create(
        cls,
        actor: str,
        payload: Dict[str, Any],
        session_id: Optional[str] = None,
        request_id: Optional[str] = None,
    ) -> "CoreEnvelope":
        """Factory method to create a new envelope."""
        return cls(
            request_id=request_id or str(uuid.uuid4()),
            session_id=session_id or str(uuid.uuid4()),
            timestamp=datetime.now(timezone.utc).isoformat(),
            actor=actor,
            payload=payload,
        )


# =============================================================================
# Safety Decision Types
# =============================================================================


class SafetyDecisionType(Enum):
    """Types of safety decisions."""

    ALLOW = "ALLOW"
    DENY = "DENY"
    ALLOW_WITH_CONSTRAINTS = "ALLOW_WITH_CONSTRAINTS"


@dataclass
class SafetyDecision:
    """Response from SAS safety checks."""

    decision: SafetyDecisionType
    policy_version: str
    rationale_codes: List[str]
    constraints: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# Tool Execution Types
# =============================================================================


class ToolStatus(Enum):
    """Status of tool execution."""

    OK = "OK"
    ERROR = "ERROR"


@dataclass
class ToolCallRequest:
    """Request to TMS for tool execution."""

    tool_name: str
    capability: str
    args: Dict[str, Any]
    idempotency_key: str
    sandbox_profile: str = "default"


@dataclass
class ToolResult:
    """Response from TMS after tool execution."""

    tool_name: str
    status: ToolStatus
    result: Dict[str, Any] = field(default_factory=dict)
    error: Dict[str, Any] = field(default_factory=dict)
    telemetry: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# Memory Types
# =============================================================================


class RecordType(Enum):
    """Types of memory records."""

    FACT = "FACT"
    SUMMARY = "SUMMARY"
    PREFERENCE = "PREFERENCE"
    TASK_ARTIFACT = "TASK_ARTIFACT"


@dataclass
class MemoryRecord:
    """Record for DMS storage with provenance."""

    record_type: RecordType
    content: str
    provenance: Dict[str, Any]
    retention: Dict[str, Any]


# =============================================================================
# User Request Types
# =============================================================================


@dataclass
class UserRequest:
    """Incoming user request."""

    query: str
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class UserResponse:
    """Response to user."""

    status: str
    response: str
    request_id: str
    session_id: str
    tool_result: Optional[Dict[str, Any]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# Reasoning Types
# =============================================================================


@dataclass
class ReasoningPlan:
    """Plan generated by CRE."""

    requires_tool: bool
    tool: Optional[str] = None
    capability: Optional[str] = None
    args: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ContextBundle:
    """Context retrieved from DMS."""

    session_history: List[str]
    rag_content: str
    facts: List[Dict[str, Any]] = field(default_factory=list)


# =============================================================================
# Audit and Observability Types
# =============================================================================


@dataclass
class AuditEntry:
    """Entry in the audit ledger."""

    entry_id: str
    timestamp: str
    request_id: str
    session_id: str
    actor: str
    action_type: str
    payload: Dict[str, Any]
    previous_hash: str = ""
    entry_hash: str = ""


@dataclass
class TelemetryEvent:
    """Telemetry event for observability."""

    timestamp: str
    request_id: str
    component: str
    event_type: str
    latency_ms: Optional[int] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# Learning and Orchestration Types
# =============================================================================


@dataclass
class TrainingEvent:
    """Event for machine learning training."""

    timestamp: str
    request_id: str
    component: str
    event_type: str
    data: Dict[str, Any]
    redacted: bool = True  # Whether PII has been redacted


@dataclass
class MultiStepPlan:
    """Plan for multi-step task orchestration."""

    plan_id: str
    request_id: str
    session_id: str
    steps: List[ReasoningPlan]
    dependencies: Dict[int, List[int]]  # step_index -> list of dependency step indices
    checkpoints: List[str]  # checkpoint IDs in DMS
    created_at: str
    status: str = "pending"  # pending, executing, completed, failed


# =============================================================================
# Configuration Types
# =============================================================================


@dataclass
class PolicyConfig:
    """Safety policy configuration."""

    version: str
    blocked_patterns: List[str]
    blocked_tools: List[str]
    risk_threshold: int
    max_denials_per_session: int


@dataclass
class SwarmConfig:
    """Swarm topology configuration."""

    topology_type: str
    max_agents: int
    agent_roles: Dict[str, Dict[str, Any]]
