import hashlib
from typing import List, Optional, Tuple
import math


class MerkleNode:
    """Merkle Tree节点类"""

    def __init__(self, left: Optional['MerkleNode'] = None,
                 right: Optional['MerkleNode'] = None,
                 data: Optional[bytes] = None):
        self.left = left
        self.right = right
        self.data = data
        self.hash = self._calculate_hash()

    def _calculate_hash(self) -> str:
        """计算节点的哈希值"""
        if self.data is not None:
            # 叶子节点：直接哈希数据
            return hashlib.sha256(self.data).hexdigest()
        elif self.left and self.right:
            # 内部节点：哈希左右子节点的组合
            combined = self.left.hash + self.right.hash
            return hashlib.sha256(combined.encode()).hexdigest()
        else:
            raise ValueError("Invalid Merkle node configuration")


class MerkleTree:
    """Merkle Tree实现，用于批量验证"""

    def __init__(self, data_list: Optional[List[bytes]] = None):
        self.leaves: List[MerkleNode] = []
        self.root: Optional[MerkleNode] = None

        if data_list:
            self.build_tree(data_list)

    def build_tree(self, data_list: List[bytes]) -> None:
        """构建Merkle Tree"""
        if not data_list:
            return

        # 创建叶子节点
        self.leaves = [MerkleNode(data=data) for data in data_list]

        # 如果只有一个叶子，直接作为根
        if len(self.leaves) == 1:
            self.root = self.leaves[0]
            return

        # 构建树结构
        current_level = self.leaves[:]

        while len(current_level) > 1:
            next_level = []

            # 两两配对创建父节点
            for i in range(0, len(current_level), 2):
                left = current_level[i]
                right = current_level[i + 1] if i + 1 < len(current_level) else left
                parent = MerkleNode(left=left, right=right)
                next_level.append(parent)

            current_level = next_level

        self.root = current_level[0]

    def get_root_hash(self) -> Optional[str]:
        """获取根哈希"""
        return self.root.hash if self.root else None

    def get_proof(self, index: int) -> List[Tuple[str, bool]]:
        """
        生成证明路径
        返回：[(sibling_hash, is_left), ...]
        """
        if not self.root or index >= len(self.leaves):
            return []

        proof = []
        current_index = index

        # 从叶子节点开始向上遍历
        current_level = self.leaves[:]
        level_size = len(current_level)

        while level_size > 1:
            sibling_index = current_index ^ 1  # 切换左右兄弟
            if sibling_index < level_size:
                sibling = current_level[sibling_index]
                is_left = current_index % 2 == 0
                proof.append((sibling.hash, is_left))

            # 移动到父节点层级
            current_index //= 2
            level_size = math.ceil(level_size / 2)

            # 构建下一层
            next_level = []
            for i in range(0, len(current_level), 2):
                left = current_level[i]
                right = current_level[i + 1] if i + 1 < len(current_level) else left
                parent = MerkleNode(left=left, right=right)
                next_level.append(parent)
            current_level = next_level

        return proof

    def verify_proof(self, leaf_data: bytes, proof: List[Tuple[str, bool]],
                    root_hash: str) -> bool:
        """
        验证证明路径
        """
        leaf_hash = hashlib.sha256(leaf_data).hexdigest()
        current_hash = leaf_hash

        for sibling_hash, is_left in proof:
            if is_left:
                # 当前节点是左子节点
                combined = current_hash + sibling_hash
            else:
                # 当前节点是右子节点
                combined = sibling_hash + current_hash
            current_hash = hashlib.sha256(combined.encode()).hexdigest()

        return current_hash == root_hash

    def add_leaf(self, data: bytes) -> None:
        """添加新的叶子节点（需要重建树）"""
        self.leaves.append(MerkleNode(data=data))
        self._rebuild_tree()

    def _rebuild_tree(self) -> None:
        """重建树结构"""
        if not self.leaves:
            self.root = None
            return

        current_level = self.leaves[:]

        while len(current_level) > 1:
            next_level = []
            for i in range(0, len(current_level), 2):
                left = current_level[i]
                right = current_level[i + 1] if i + 1 < len(current_level) else left
                parent = MerkleNode(left=left, right=right)
                next_level.append(parent)
            current_level = next_level

        self.root = current_level[0]

    def get_tree_height(self) -> int:
        """获取树的高度"""
        if not self.root:
            return 0
        height = 0
        current = self.root
        while current.left:
            height += 1
            current = current.left
        return height

    def get_leaf_count(self) -> int:
        """获取叶子节点数量"""
        return len(self.leaves)