# =============================================================================
# ACGS-2 Secrets Detection Allow-list Configuration
# =============================================================================
# Constitutional Hash: cdd01ef066bc6cf2
#
# This file configures the allow-list for scripts/check-secrets-pre-commit.py
# Used to distinguish safe development placeholders from real secrets
#
# THREE-TIER ALLOW-LIST SYSTEM:
# 1. Pattern-Based: Broad exclusions via prefixes/markers (fast, global)
# 2. Path-Based: Exclude specific files/directories (targeted)
# 3. Value-Based: Known-safe specific values (precise)
#
# WHEN TO ADD TO THIS FILE:
# - Adding new safe placeholder patterns (e.g., "staging-*")
# - Excluding new test/example directories
# - Documenting known-safe development values
#
# WHEN NOT TO ADD TO THIS FILE:
# - Real production secrets (use environment variables + secrets_manager)
# - Secrets that should only be in specific locations (use .gitleaksignore)
# - Binary/media files (already excluded by extension)
#
# DOCUMENTATION: See docs/SECRETS_DETECTION.md for details
# =============================================================================

# -----------------------------------------------------------------------------
# Tier 1: Pattern-Based Allow-list (Broad)
# -----------------------------------------------------------------------------
# These patterns apply globally across all files to identify safe placeholders

placeholder_patterns:
  # Prefix-based placeholders - values starting with these are considered safe
  prefixes:
    - "dev-" # Development placeholders (e.g., dev-jwt-secret-min-32-chars-required)
    - "test-" # Test data (e.g., test-api-key-12345)
    - "your-" # Instructional placeholders (e.g., your-api-key-here)
    - "placeholder-" # Explicit placeholders (e.g., placeholder-secret)
    - "example-" # Example values (e.g., example-token-abc123)
    - "sample-" # Sample data (e.g., sample-password)
    - "staging-" # Staging environment safe values
    - "local-" # Local development values

  # Instructional markers - values containing these are considered safe
  markers:
    - "<" # Angle bracket placeholders (e.g., <your-api-key>)
    - ">" # Angle bracket placeholders
    - "xxx" # Redacted format (e.g., sk-ant-xxx...xxx)
    - "***" # Redacted format (e.g., ***hidden***)
    - "[redacted]" # Explicit redaction marker
    - "<hidden>" # Hidden value marker
    - "example" # Example indicator
    - "template" # Template indicator
    - "changeme" # Placeholder requiring change
    - "replace" # Placeholder requiring replacement
    - "todo" # Placeholder to be filled
    - "fixme" # Placeholder to be fixed

  # Redaction patterns - regex patterns for redacted examples
  # These are checked with re.match() for full string matching
  redaction_patterns:
    - "^[X*\\-._]+$" # Only special chars (e.g., XXXXXXXX, ********, -----)
    - "^sk-[a-z]+-XXX.*XXX$" # Redacted API keys (e.g., sk-ant-XXX...XXX)
    - "^.*\\[REDACTED\\].*$" # Explicit redaction
    - "^.*<REDACTED>.*$" # Explicit redaction
    - "^.*\\*\\*\\*.*\\*\\*\\*.*$" # Stars redaction

# -----------------------------------------------------------------------------
# Tier 2: Path-Based Allow-list (Targeted)
# -----------------------------------------------------------------------------
# Files and directories that should be excluded from strict scanning

excluded_paths:
  # Development directories - never contain real secrets
  directories:
    - "node_modules/"
    - ".venv/"
    - "venv/"
    - "__pycache__/"
    - "dist/"
    - "build/"
    - ".git/"
    - ".pytest_cache/"
    - ".mypy_cache/"
    - ".ruff_cache/"
    - "htmlcov/"
    - "coverage/"

  # Test fixtures - may contain fake secrets for testing
  test_paths:
    - "tests/fixtures/"
    - "test/fixtures/"
    - "__fixtures__/"
    - "**/test_data/"
    - "**/testdata/"
    - "**/__mocks__/"

  # File patterns that are safe by definition
  file_patterns:
    - ".env.example" # Example configuration (intentionally has placeholders)
    - ".env.template" # Template configuration
    - ".example." # Any file with .example. in name
    - ".template." # Any file with .template. in name
    - ".sample." # Sample files
    - "*.md" # Markdown docs (may have example secrets in documentation)
    - "*.txt" # Text files (usually documentation or test data)
    - "LICENSE" # License files
    - "CHANGELOG" # Changelog files
    - "*.log" # Log files (excluded from git anyway)
    - "post_quantum_crypto.py" # Cryptographic algorithm implementation (false positives)

# -----------------------------------------------------------------------------
# Tier 3: Value-Based Allow-list (Precise)
# -----------------------------------------------------------------------------
# Specific known-safe values from .env.dev, .env.example, and test fixtures

known_safe_values:
  # Development secrets from .env.dev (safe development-only placeholders)
  development:
    - value: "dev-jwt-secret-min-32-chars-required"
      context: ".env.dev JWT_SECRET"
      why_safe: "Development placeholder, meets minimum length requirement"
      production_mitigation: "Real JWT secrets are loaded from Vault in production"

    - value: "dev_password"
      context: ".env.dev REDIS_PASSWORD"
      why_safe: "Development-only Redis password, not used in production"
      production_mitigation: "Production Redis uses strong generated passwords from secrets manager"

    - value: "mlflow_password"
      context: ".env.dev POSTGRES_ML_PASSWORD"
      why_safe: "Development-only ML database password, local environment"
      production_mitigation: "Production uses managed database with IAM authentication"

  # Generic placeholder values found in .env.example and test files
  generic:
    - value: "password"
      context: "Generic placeholder in examples"
      why_safe: "Obviously insecure, used as example only"
      production_mitigation: "Never used in production"

    - value: "acgs2_pass"
      context: "Generic placeholder in examples"
      why_safe: "Example password value"
      production_mitigation: "Never used in production"

    - value: "changeme"
      context: "Instructional placeholder"
      why_safe: "Explicitly indicates user should replace"
      production_mitigation: "Template value only"

    - value: "secret"
      context: "Generic placeholder in examples"
      why_safe: "Obviously generic, not a real secret"
      production_mitigation: "Never used in production"

    - value: "test-secret"
      context: "Test fixtures and examples"
      why_safe: "Explicitly marked as test value"
      production_mitigation: "Only used in test environments"

  # Empty or null values (always safe)
  empty_values:
    - ""
    - "null"
    - "None"
    - "nil"
    - "undefined"

  # Known test/example API keys and tokens (for test fixtures)
  test_fixtures:
    - value: "sk-test-123456789012345678901234567890123456789012345678901234567890"
      context: "Test fixture for API key validation"
      why_safe: "Explicitly uses 'test' prefix, documented as fixture"
      production_mitigation: "Only in tests/ directory"

# -----------------------------------------------------------------------------
# File-Specific Overrides
# -----------------------------------------------------------------------------
# Special handling for specific file types or names

file_specific_rules:
  # .env.dev - relaxed rules, known development file
  ".env.dev":
    scan_level: "RELAXED"
    allow_generic_passwords: true
    reason: "Development environment file, all values are safe placeholders"

  # .env.example - very relaxed, intentionally has placeholders
  ".env.example":
    scan_level: "VERY_RELAXED"
    allow_all_placeholders: true
    reason: "Example file, designed to show placeholder formats"

  # .env.template - same as .env.example
  ".env.template":
    scan_level: "VERY_RELAXED"
    allow_all_placeholders: true
    reason: "Template file, designed to show placeholder formats"

  # Markdown documentation - allow redacted examples
  "*.md":
    scan_level: "RELAXED"
    allow_redacted_examples: true
    reason: "Documentation may contain redacted real-world examples"

  # Python source - strictest rules
  "*.py":
    scan_level: "VERY_STRICT"
    allow_generic_passwords: false
    reason: "Source code should never contain hardcoded secrets"

  # Environment files (production) - strict rules
  ".env":
    scan_level: "STRICT"
    allow_generic_passwords: false
    reason: "Actual environment file, must not contain real secrets"

# -----------------------------------------------------------------------------
# Binary/Media File Extensions to Skip
# -----------------------------------------------------------------------------
# These files are skipped entirely for performance (unlikely to contain text secrets)

skip_extensions:
  # Images
  - ".png"
  - ".jpg"
  - ".jpeg"
  - ".gif"
  - ".svg"
  - ".ico"
  - ".webp"

  # Documents
  - ".pdf"

  # Archives
  - ".zip"
  - ".tar"
  - ".gz"
  - ".bz2"
  - ".xz"
  - ".7z"
  - ".rar"

  # Fonts
  - ".woff"
  - ".woff2"
  - ".ttf"
  - ".eot"
  - ".otf"

  # Media
  - ".mp4"
  - ".webm"
  - ".ogg"
  - ".mp3"
  - ".wav"

  # Compiled/Binary
  - ".pyc"
  - ".pyo"
  - ".so"
  - ".dylib"
  - ".dll"
  - ".exe"
  - ".bin"
  - ".class"
  - ".o"
  - ".a"

  # Lock files
  - ".lock"
  - "-lock.json"

# -----------------------------------------------------------------------------
# Additional Configuration
# -----------------------------------------------------------------------------

# Enable/disable specific checks
feature_flags:
  check_entropy: true # Check for high-entropy strings (possible secrets)
  check_base64: true # Check for base64-encoded potential secrets
  check_hex_strings: true # Check for long hex strings
  strict_mode: false # If true, fail on warnings (not just errors)

# Entropy thresholds for high-entropy detection
entropy_config:
  min_length: 20 # Minimum string length to check entropy
  threshold: 4.5 # Entropy threshold (bits per character)
  charset: "base64" # Character set to use: base64, hex, alphanumeric

# Base64 detection configuration
base64_config:
  min_length: 40 # Minimum base64 string length to flag
  check_decoded: true # Check if decoded content looks like a secret

# Performance settings
performance:
  max_file_size_bytes: 1048576 # Skip files larger than 1MB (unlikely to be config)
  max_line_length: 10000 # Skip lines longer than 10k chars (likely data/minified)
  parallel_scan: false # Enable parallel file scanning (experimental)

# -----------------------------------------------------------------------------
# Metadata
# -----------------------------------------------------------------------------

metadata:
  version: "1.0.0"
  last_updated: "2026-01-03"
  maintained_by: "ACGS-2 Security Team"
  review_frequency: "quarterly"
  next_review: "2026-04-03"
  constitutional_hash: "cdd01ef066bc6cf2"
# -----------------------------------------------------------------------------
# Documentation and Best Practices
# -----------------------------------------------------------------------------

# HOW TO ADD NEW EXCEPTIONS:
#
# 1. Determine the appropriate tier:
#    - Pattern-based: If it's a common format (e.g., new prefix like "ci-*")
#    - Path-based: If it's a specific file/directory
#    - Value-based: If it's a specific known-safe value
#
# 2. Document WHY it's safe:
#    - Always add 'why_safe' explanation
#    - Always add 'production_mitigation' notes
#    - Include context about where it's used
#
# 3. Consider alternatives:
#    - Could this use environment variables instead?
#    - Could this use the secrets_manager.py instead?
#    - Is this truly necessary, or a workaround?
#
# 4. Review regularly:
#    - Quarterly review of all exceptions
#    - Remove exceptions that are no longer needed
#    - Update documentation as patterns change
#
# EXAMPLES:
#
# Adding a new prefix pattern:
#   placeholder_patterns:
#     prefixes:
#       - "ci-"  # CI/CD pipeline placeholders
#
# Adding a new known-safe value:
#   known_safe_values:
#     development:
#       - value: "new-dev-secret-value"
#         context: ".env.dev NEW_SECRET"
#         why_safe: "Development placeholder for new feature"
#         production_mitigation: "Loaded from Vault in production"
#
# Adding a file exclusion:
#   excluded_paths:
#     file_patterns:
#       - "*.fixture.json"  # Test fixture files
#
# IMPORTANT NOTES:
#
# - This file is YAML - indentation matters!
# - Comments start with #
# - Strings with special characters should be quoted
# - Regex patterns need proper escaping (use single quotes or double backslashes)
# - Test changes with: python scripts/check-secrets-pre-commit.py --verbose
# - Validate YAML syntax before committing
#
# =============================================================================
# End of Configuration
# =============================================================================
