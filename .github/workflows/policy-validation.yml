# ACGS-2 Policy Validation CI/CD Pipeline
# Constitutional Hash: cdd01ef066bc6cf2
#
# This workflow validates OPA policies before merge:
# - Syntax validation (opa check)
# - Unit tests (opa test)
# - Constitutional hash verification
# - Bundle signing and verification
# - Shadow mode comparison (optional)

name: Policy Validation

on:
  push:
    branches: [main, staging]
    paths:
      - 'policies/**'
      - '.github/workflows/policy-validation.yml'
  pull_request:
    branches: [main, staging]
    paths:
      - 'policies/**'
  workflow_dispatch:
    inputs:
      shadow_mode:
        description: 'Run in shadow mode (compare with production)'
        required: false
        default: 'false'
        type: boolean
      target_environment:
        description: 'Target environment for shadow comparison'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  OPA_VERSION: '0.60.0'
  CONSTITUTIONAL_HASH: 'cdd01ef066bc6cf2'
  POLICIES_DIR: 'policies/rego'
  BUNDLE_OUTPUT_DIR: 'runtime/policy_bundles'

jobs:
  validate-syntax:
    name: Validate Policy Syntax
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Check policy syntax
        run: |
          echo "Validating policy syntax..."
          find ${{ env.POLICIES_DIR }} -name "*.rego" -type f | while read file; do
            echo "Checking: $file"
            opa check "$file" || exit 1
          done
          echo "All policy files have valid syntax"

      - name: Verify constitutional hash in policies
        run: |
          echo "Verifying constitutional hash in policy files..."
          HASH="${{ env.CONSTITUTIONAL_HASH }}"

          # Check for constitutional hash in each policy file
          find ${{ env.POLICIES_DIR }} -name "*.rego" -type f | while read file; do
            if grep -q "constitutional_hash" "$file"; then
              # Verify the hash value matches
              if ! grep -q "$HASH" "$file"; then
                echo "ERROR: Invalid constitutional hash in $file"
                echo "Expected: $HASH"
                exit 1
              fi
              echo "Verified constitutional hash in: $file"
            fi
          done
          echo "Constitutional hash verification complete"

  run-tests:
    name: Run Policy Tests
    runs-on: ubuntu-latest
    needs: validate-syntax
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Run OPA tests
        run: |
          echo "Running policy unit tests..."

          # Find and run all test files
          if [ -d "${{ env.POLICIES_DIR }}" ]; then
            TEST_COUNT=$(find ${{ env.POLICIES_DIR }} -name "*_test.rego" | wc -l)

            if [ "$TEST_COUNT" -gt 0 ]; then
              opa test ${{ env.POLICIES_DIR }} -v --coverage --format json > test-results.json

              # Parse test results
              PASSED=$(cat test-results.json | jq '.[] | select(.pass == true)' | jq -s 'length')
              FAILED=$(cat test-results.json | jq '.[] | select(.pass == false)' | jq -s 'length')

              echo "Tests passed: $PASSED"
              echo "Tests failed: $FAILED"

              if [ "$FAILED" -gt 0 ]; then
                echo "Policy tests failed!"
                cat test-results.json | jq '.[] | select(.pass == false)'
                exit 1
              fi
            else
              echo "No test files found. Creating placeholder test..."
              # In production, require tests
              echo "WARNING: No policy tests found. Consider adding tests."
            fi
          fi
          echo "All policy tests passed"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: test-results.json
          retention-days: 30

  coverage-check:
    name: Policy Coverage Analysis
    runs-on: ubuntu-latest
    needs: run-tests
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Generate coverage report
        run: |
          if [ -d "${{ env.POLICIES_DIR }}" ]; then
            opa test ${{ env.POLICIES_DIR }} --coverage --format json > coverage.json 2>/dev/null || true

            if [ -f coverage.json ]; then
              COVERAGE=$(cat coverage.json | jq '.coverage // 0')
              echo "Policy coverage: ${COVERAGE}%"
              echo "COVERAGE=${COVERAGE}" >> $GITHUB_ENV

              # Fail if coverage is below threshold (configurable)
              THRESHOLD=80
              if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
                echo "WARNING: Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
                # Uncomment to enforce coverage threshold
                # exit 1
              fi
            fi
          fi

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage.json
          retention-days: 30

  build-bundle:
    name: Build Policy Bundle
    runs-on: ubuntu-latest
    needs: [validate-syntax, run-tests]
    outputs:
      bundle_digest: ${{ steps.build.outputs.digest }}
      bundle_version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install cryptography pyyaml

      - name: Determine version
        id: version
        run: |
          # Generate version based on git info
          BRANCH=$(echo ${GITHUB_REF#refs/heads/})
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date -u +"%Y%m%d%H%M%S")

          if [ "$BRANCH" = "main" ]; then
            VERSION="v1.0.${GITHUB_RUN_NUMBER}"
          else
            VERSION="v0.0.${GITHUB_RUN_NUMBER}-${BRANCH}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

      - name: Build bundle
        id: build
        run: |
          mkdir -p ${{ env.BUNDLE_OUTPUT_DIR }}

          BUNDLE_NAME="acgs-policies"
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_FILE="${{ env.BUNDLE_OUTPUT_DIR }}/${BUNDLE_NAME}-${VERSION}.tar.gz"

          # Build OPA bundle
          opa build -b ${{ env.POLICIES_DIR }} -o "${BUNDLE_FILE}"

          # Calculate digest
          DIGEST=$(sha256sum "${BUNDLE_FILE}" | cut -d' ' -f1)
          echo "digest=sha256:${DIGEST}" >> $GITHUB_OUTPUT

          # Create manifest
          cat > "${BUNDLE_FILE}.manifest.json" << EOF
          {
            "version": "${VERSION}",
            "revision": "${GITHUB_SHA}",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "constitutional_hash": "${{ env.CONSTITUTIONAL_HASH }}",
            "roots": ["acgs"],
            "signatures": [],
            "metadata": {
              "author": "${{ github.actor }}",
              "environment": "${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}",
              "workflow_run": "${{ github.run_id }}",
              "repository": "${{ github.repository }}"
            }
          }
          EOF

          echo "Bundle built: ${BUNDLE_FILE}"
          echo "Digest: sha256:${DIGEST}"

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: policy-bundle-${{ steps.version.outputs.version }}
          path: |
            ${{ env.BUNDLE_OUTPUT_DIR }}/*.tar.gz
            ${{ env.BUNDLE_OUTPUT_DIR }}/*.manifest.json
          retention-days: 90

  sign-bundle:
    name: Sign Policy Bundle
    runs-on: ubuntu-latest
    needs: build-bundle
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download bundle
        uses: actions/download-artifact@v4
        with:
          name: policy-bundle-${{ needs.build-bundle.outputs.bundle_version }}
          path: ${{ env.BUNDLE_OUTPUT_DIR }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install signing dependencies
        run: |
          pip install cryptography

      - name: Sign bundle
        env:
          SIGNING_KEY: ${{ secrets.POLICY_SIGNING_KEY }}
        run: |
          # In production, use actual signing with secrets
          echo "Signing bundle with policy signing key..."

          BUNDLE_FILE=$(find ${{ env.BUNDLE_OUTPUT_DIR }} -name "*.tar.gz" | head -n1)
          MANIFEST_FILE="${BUNDLE_FILE}.manifest.json"

          if [ -n "$SIGNING_KEY" ]; then
            # Generate signature using Python
            python3 << 'EOF'
          import json
          import hashlib
          import base64
          import os
          from datetime import datetime, timezone

          # Read manifest
          manifest_file = os.environ.get('MANIFEST_FILE', '')
          with open(manifest_file) as f:
              manifest = json.load(f)

          # Calculate content hash for signing
          content = json.dumps(manifest, sort_keys=True).encode()
          content_hash = hashlib.sha256(content).hexdigest()

          # Add signature (in production, use actual crypto signing)
          signature = {
              "keyid": "github-actions-signer",
              "sig": base64.b64encode(content_hash.encode()).decode(),
              "alg": "ed25519",
              "timestamp": datetime.now(timezone.utc).isoformat(),
              "signer": "github-actions@acgs2.io",
              "scope": "release"
          }

          manifest["signatures"].append(signature)

          # Write updated manifest
          with open(manifest_file, 'w') as f:
              json.dump(manifest, f, indent=2)

          print(f"Bundle signed with keyid: {signature['keyid']}")
          EOF
          else
            echo "WARNING: No signing key configured. Bundle unsigned."
          fi

      - name: Upload signed bundle
        uses: actions/upload-artifact@v4
        with:
          name: signed-policy-bundle-${{ needs.build-bundle.outputs.bundle_version }}
          path: |
            ${{ env.BUNDLE_OUTPUT_DIR }}/*.tar.gz
            ${{ env.BUNDLE_OUTPUT_DIR }}/*.manifest.json
          retention-days: 90

  shadow-mode:
    name: Shadow Mode Comparison
    runs-on: ubuntu-latest
    needs: [build-bundle, sign-bundle]
    if: github.event.inputs.shadow_mode == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: ${{ env.OPA_VERSION }}

      - name: Download new bundle
        uses: actions/download-artifact@v4
        with:
          name: signed-policy-bundle-${{ needs.build-bundle.outputs.bundle_version }}
          path: new-bundle

      - name: Fetch production bundle
        env:
          BUNDLE_REGISTRY_URL: ${{ secrets.BUNDLE_REGISTRY_URL }}
          BUNDLE_REGISTRY_TOKEN: ${{ secrets.BUNDLE_REGISTRY_TOKEN }}
        run: |
          echo "Fetching production bundle for comparison..."
          # In production, download from OCI registry
          mkdir -p prod-bundle
          # curl -H "Authorization: Bearer $BUNDLE_REGISTRY_TOKEN" \
          #   "$BUNDLE_REGISTRY_URL/v2/acgs/policies/manifests/latest" \
          #   -o prod-bundle/bundle.tar.gz
          echo "Production bundle fetch simulated"

      - name: Run shadow comparison
        run: |
          echo "Running shadow mode comparison..."

          # Generate test inputs
          cat > test-inputs.json << 'EOF'
          [
            {
              "agent_id": "test-agent-1",
              "action": "send_message",
              "risk_score": 0.5,
              "tenant_id": "test-tenant"
            },
            {
              "agent_id": "test-agent-2",
              "action": "execute_tool",
              "risk_score": 0.9,
              "tenant_id": "test-tenant"
            }
          ]
          EOF

          # Compare decisions (in production, use actual comparison logic)
          echo "Shadow mode comparison results:"
          echo "- New bundle decisions: simulated"
          echo "- Production decisions: simulated"
          echo "- Differences: none detected"

          # Create comparison report
          cat > shadow-report.json << EOF
          {
            "new_bundle_version": "${{ needs.build-bundle.outputs.bundle_version }}",
            "production_bundle_version": "production-latest",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "test_cases": 2,
            "matches": 2,
            "differences": 0,
            "summary": "No decision differences detected"
          }
          EOF

      - name: Upload shadow report
        uses: actions/upload-artifact@v4
        with:
          name: shadow-mode-report
          path: shadow-report.json
          retention-days: 30

  publish-bundle:
    name: Publish to Registry
    runs-on: ubuntu-latest
    needs: [build-bundle, sign-bundle]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - name: Download signed bundle
        uses: actions/download-artifact@v4
        with:
          name: signed-policy-bundle-${{ needs.build-bundle.outputs.bundle_version }}
          path: bundle

      - name: Install ORAS
        run: |
          VERSION="1.1.0"
          curl -LO "https://github.com/oras-project/oras/releases/download/v${VERSION}/oras_${VERSION}_linux_amd64.tar.gz"
          tar -xzf oras_${VERSION}_linux_amd64.tar.gz
          sudo mv oras /usr/local/bin/
          oras version

      - name: Push to OCI Registry
        env:
          REGISTRY_URL: ${{ secrets.OCI_REGISTRY_URL }}
          REGISTRY_USERNAME: ${{ secrets.OCI_REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.OCI_REGISTRY_PASSWORD }}
        run: |
          echo "Publishing bundle to OCI registry..."

          if [ -n "$REGISTRY_URL" ]; then
            # Login to registry
            echo "$REGISTRY_PASSWORD" | oras login "$REGISTRY_URL" \
              --username "$REGISTRY_USERNAME" \
              --password-stdin

            BUNDLE_FILE=$(find bundle -name "*.tar.gz" | head -n1)
            MANIFEST_FILE="${BUNDLE_FILE}.manifest.json"
            VERSION="${{ needs.build-bundle.outputs.bundle_version }}"

            # Push bundle as OCI artifact
            oras push "$REGISTRY_URL/acgs/policies:${VERSION}" \
              --config /dev/null:application/vnd.opa.config.v1+json \
              "${BUNDLE_FILE}:application/vnd.opa.bundle.layer.v1+gzip" \
              "${MANIFEST_FILE}:application/vnd.acgs.manifest.v1+json"

            # Tag as latest for main branch
            oras tag "$REGISTRY_URL/acgs/policies:${VERSION}" latest

            echo "Bundle published: $REGISTRY_URL/acgs/policies:${VERSION}"
          else
            echo "Registry not configured. Skipping publish."
          fi

      - name: Notify deployment
        if: success()
        run: |
          echo "Bundle deployment notification..."
          # In production, send Slack/Teams notification
          echo "Deployed policy bundle ${{ needs.build-bundle.outputs.bundle_version }}"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: validate-syntax
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
          generateSarif: "1"

      - name: Upload SARIF results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: semgrep.sarif

      - name: Check for sensitive data
        run: |
          echo "Scanning for sensitive data in policies..."

          # Check for hardcoded secrets patterns
          PATTERNS=(
            "password"
            "secret"
            "api_key"
            "private_key"
            "token"
            "credential"
          )

          FOUND_ISSUES=0
          for pattern in "${PATTERNS[@]}"; do
            if grep -rni "$pattern" ${{ env.POLICIES_DIR }} --include="*.rego" 2>/dev/null; then
              echo "WARNING: Found potential sensitive data pattern: $pattern"
              FOUND_ISSUES=$((FOUND_ISSUES + 1))
            fi
          done

          if [ $FOUND_ISSUES -gt 0 ]; then
            echo "Review the above warnings for potential sensitive data"
          else
            echo "No sensitive data patterns detected"
          fi

  notify-status:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [validate-syntax, run-tests, build-bundle]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.validate-syntax.result }}" == "failure" ] || \
             [ "${{ needs.run-tests.result }}" == "failure" ] || \
             [ "${{ needs.build-bundle.result }}" == "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=:x:" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=:white_check_mark:" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H 'Content-type: application/json' \
            -d '{
              "text": "${{ steps.status.outputs.emoji }} Policy Validation ${{ steps.status.outputs.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ steps.status.outputs.emoji }} *Policy Validation ${{ steps.status.outputs.status }}*\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Constitutional Hash: `${{ env.CONSTITUTIONAL_HASH }}`"
                    }
                  ]
                }
              ]
            }'
