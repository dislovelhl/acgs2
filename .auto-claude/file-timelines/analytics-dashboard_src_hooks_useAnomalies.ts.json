{
  "file_path": "analytics-dashboard/src/hooks/useAnomalies.ts",
  "main_branch_history": [],
  "task_views": {
    "033-add-useanomalies-hook-to-analytics-dashboard": {
      "task_id": "033-add-useanomalies-hook-to-analytics-dashboard",
      "branch_point": {
        "commit_hash": "4a99fe22e8e0087919301b1aa185d4e2c6da716c",
        "content": "",
        "timestamp": "2026-01-03T18:32:21.773146"
      },
      "worktree_state": {
        "content": "/**\n * Analytics Dashboard - Anomaly Detection Hook\n *\n * Custom React hook for fetching and managing anomaly detection data from the analytics API.\n * Follows the UseDataResult<T> pattern for consistent data-fetching behavior across the application.\n *\n * @module hooks/useAnomalies\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport type { AnomaliesResponse } from \"../types/anomalies\";\nimport type { UseDataResult } from \"./types\";\n\n/**\n * API base URL configured from environment variables.\n * Defaults to localhost:8080 if VITE_ANALYTICS_API_URL is not set.\n */\nconst API_BASE_URL =\n  import.meta.env.VITE_ANALYTICS_API_URL || \"http://localhost:8080\";\n\n/**\n * Custom hook for fetching anomaly detection data from the analytics API.\n *\n * This hook provides a simple interface for fetching anomaly data with optional severity filtering.\n * It automatically fetches data on mount and provides a refetch function for manual updates.\n * The hook manages loading states, error handling, and data caching internally.\n *\n * @param {string | null} [severityFilter] - Optional severity level to filter anomalies.\n *   Valid values: \"critical\", \"high\", \"medium\", \"low\"\n *   Pass null or undefined to fetch all anomalies regardless of severity.\n *\n * @returns {UseDataResult<AnomaliesResponse>} Object containing:\n *   - data: The anomalies response data, or null if not yet loaded\n *   - loading: Boolean indicating if data is currently being fetched\n *   - error: Error object if fetch failed, or null if no error\n *   - refetch: Async function to manually trigger a data refresh\n *\n * @example\n * ```tsx\n * // Fetch all anomalies\n * function AllAnomaliesView() {\n *   const { data, loading, error, refetch } = useAnomalies();\n *\n *   if (loading) return <div>Loading anomalies...</div>;\n *   if (error) return <div>Error: {error.message}</div>;\n *   if (!data) return null;\n *\n *   return (\n *     <div>\n *       <h2>Total Anomalies: {data.total_anomalies}</h2>\n *       <button onClick={refetch}>Refresh</button>\n *       <AnomalyList items={data.anomalies} />\n *     </div>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // Fetch only critical anomalies\n * function CriticalAnomaliesWidget() {\n *   const { data, loading, error } = useAnomalies(\"critical\");\n *\n *   return (\n *     <Widget title=\"Critical Anomalies\">\n *       {loading && <Spinner />}\n *       {error && <ErrorMessage error={error} />}\n *       {data && (\n *         <div>\n *           <Badge count={data.total_anomalies} severity=\"critical\" />\n *           <AnomalyList items={data.anomalies} />\n *         </div>\n *       )}\n *     </Widget>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // Dynamic severity filtering with state\n * function AnomalyDashboard() {\n *   const [severity, setSeverity] = useState<string | null>(\"high\");\n *   const { data, loading, error, refetch } = useAnomalies(severity);\n *\n *   const handleSeverityChange = (newSeverity: string | null) => {\n *     setSeverity(newSeverity);\n *     // Hook automatically refetches when severityFilter changes\n *   };\n *\n *   return (\n *     <div>\n *       <SeverityFilter value={severity} onChange={handleSeverityChange} />\n *       <RefreshButton onClick={refetch} disabled={loading} />\n *       {data && <AnomalyGrid anomalies={data.anomalies} />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useAnomalies(\n  severityFilter?: string | null\n): UseDataResult<AnomaliesResponse> {\n  const [data, setData] = useState<AnomaliesResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchAnomalies = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const url = new URL(`${API_BASE_URL}/anomalies`);\n      if (severityFilter) {\n        url.searchParams.set(\"severity\", severityFilter);\n      }\n\n      const response = await window.fetch(url.toString(), {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\",\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(\n          errorData.detail || `Failed to fetch anomalies: ${response.status}`\n        );\n      }\n\n      const responseData: AnomaliesResponse = await response.json();\n      setData(responseData);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Failed to load anomalies\"));\n    } finally {\n      setLoading(false);\n    }\n  }, [severityFilter]);\n\n  useEffect(() => {\n    fetchAnomalies();\n  }, [fetchAnomalies]);\n\n  return { data, loading, error, refetch: fetchAnomalies };\n}\n",
        "last_modified": "2026-01-03T18:36:09.855719"
      },
      "task_intent": {
        "title": "033-add-useanomalies-hook-to-analytics-dashboard",
        "description": "Extract the anomaly fetching logic from AnomalyWidget.tsx into a reusable useAnomalies hook following the existing UseDataResult<T> pattern established in acgs2-observability/monitoring/dashboard/src/hooks/useDashboard.ts. This enables anomaly data to be consumed by other components without duplicating fetch logic.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T18:32:21.790063",
  "last_updated": "2026-01-03T18:32:21.792268"
}