{
  "file_path": "src/core/enhanced_agent_bus/verification/sagallm_transactions.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 SagaLLM Transaction System\nConstitutional Hash: cdd01ef066bc6cf2\n\nSagaLLM provides transaction guarantees for constitutional governance operations:\n- Compensable actions with LIFO rollback on failure\n- Checkpoint-based transaction state management\n- Automatic compensation execution\n- Transaction consistency guarantees\n\nThis breakthrough addresses Challenge 2: Self-Verification & Formal Methods\nby ensuring governance decisions maintain state consistency.\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Awaitable, Callable, Dict, List, Optional\n\n# Import centralized constitutional hash\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\n\nclass TransactionState(Enum):\n    \"\"\"States of a SagaLLM transaction.\"\"\"\n    INITIALIZED = \"initialized\"\n    ACTIVE = \"active\"\n    COMPENSATING = \"compensating\"\n    COMPENSATED = \"compensated\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    TIMED_OUT = \"timed_out\"\n\n\nclass TransactionAction(Enum):\n    \"\"\"Types of actions in a transaction.\"\"\"\n    GOVERNANCE_DECISION = \"governance_decision\"\n    POLICY_VALIDATION = \"policy_validation\"\n    ACCESS_CONTROL = \"access_control\"\n    AUDIT_LOGGING = \"audit_logging\"\n    RESOURCE_ALLOCATION = \"resource_allocation\"\n    CONSTITUTIONAL_CHECK = \"constitutional_check\"\n\n\n@dataclass\nclass SagaAction:\n    \"\"\"An action in a SagaLLM transaction.\"\"\"\n    action_id: str\n    action_type: TransactionAction\n    description: str\n    execute_func: Callable[[], Awaitable[Any]]\n    compensate_func: Optional[Callable[[], Awaitable[Any]]] = None\n    timeout_s: float = 30.0\n    retry_count: int = 0\n    max_retries: int = 3\n    executed_at: Optional[datetime] = None\n    compensated_at: Optional[datetime] = None\n    execution_result: Any = None\n    compensation_result: Any = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert action to dictionary.\"\"\"\n        return {\n            \"action_id\": self.action_id,\n            \"action_type\": self.action_type.value,\n            \"description\": self.description,\n            \"timeout_s\": self.timeout_s,\n            \"retry_count\": self.retry_count,\n            \"max_retries\": self.max_retries,\n            \"executed_at\": self.executed_at.isoformat() if self.executed_at else None,\n            \"compensated_at\": self.compensated_at.isoformat() if self.compensated_at else None,\n            \"metadata\": self.metadata,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass TransactionCheckpoint:\n    \"\"\"A checkpoint in the transaction execution.\"\"\"\n    checkpoint_id: str\n    checkpoint_name: str\n    state_before: Dict[str, Any]\n    actions_executed: List[str]  # Action IDs executed so far\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert checkpoint to dictionary.\"\"\"\n        return {\n            \"checkpoint_id\": self.checkpoint_id,\n            \"checkpoint_name\": self.checkpoint_name,\n            \"state_before\": self.state_before,\n            \"actions_executed\": self.actions_executed,\n            \"created_at\": self.created_at.isoformat(),\n            \"metadata\": self.metadata,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass SagaTransaction:\n    \"\"\"A SagaLLM transaction with compensable actions.\"\"\"\n    transaction_id: str\n    description: str\n    actions: List[SagaAction] = field(default_factory=list)\n    checkpoints: List[TransactionCheckpoint] = field(default_factory=list)\n    state: TransactionState = TransactionState.INITIALIZED\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    failed_at: Optional[datetime] = None\n    failure_reason: Optional[str] = None\n    compensation_log: List[Dict[str, Any]] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert transaction to dictionary.\"\"\"\n        return {\n            \"transaction_id\": self.transaction_id,\n            \"description\": self.description,\n            \"actions\": [a.to_dict() for a in self.actions],\n            \"checkpoints\": [c.to_dict() for c in self.checkpoints],\n            \"state\": self.state.value,\n            \"created_at\": self.created_at.isoformat(),\n            \"started_at\": self.started_at.isoformat() if self.started_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"failed_at\": self.failed_at.isoformat() if self.failed_at else None,\n            \"failure_reason\": self.failure_reason,\n            \"compensation_log\": self.compensation_log,\n            \"metadata\": self.metadata,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\nclass SagaLLMEngine:\n    \"\"\"\n    SagaLLM Transaction Engine\n\n    Provides transaction guarantees for constitutional governance:\n    - Automatic compensation on failure (LIFO rollback)\n    - Checkpoint-based state management\n    - Timeout handling and retry logic\n    - Transaction consistency guarantees\n    \"\"\"\n\n    def __init__(\n        self,\n        max_transaction_time: float = 300.0,  # 5 minutes\n        default_action_timeout: float = 30.0,\n        compensation_timeout: float = 60.0,\n    ):\n        self.max_transaction_time = max_transaction_time\n        self.default_action_timeout = default_action_timeout\n        self.compensation_timeout = compensation_timeout\n\n        # Transaction storage (in practice, use persistent storage)\n        self._active_transactions: Dict[str, SagaTransaction] = {}\n        self._completed_transactions: Dict[str, SagaTransaction] = {}\n\n        logger.info(\"Initialized SagaLLM Transaction Engine\")\n        logger.info(f\"Constitutional Hash: {CONSTITUTIONAL_HASH}\")\n\n    def create_transaction(\n        self,\n        description: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> SagaTransaction:\n        \"\"\"Create a new SagaLLM transaction.\"\"\"\n        transaction = SagaTransaction(\n            transaction_id=str(uuid.uuid4()),\n            description=description,\n            metadata=metadata or {},\n        )\n\n        self._active_transactions[transaction.transaction_id] = transaction\n\n        logger.info(f\"Created SagaLLM transaction: {transaction.transaction_id}\")\n        return transaction\n\n    def add_action(\n        self,\n        transaction: SagaTransaction,\n        action_type: TransactionAction,\n        description: str,\n        execute_func: Callable[[], Awaitable[Any]],\n        compensate_func: Optional[Callable[[], Awaitable[Any]]] = None,\n        timeout_s: Optional[float] = None,\n        max_retries: int = 3,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> SagaAction:\n        \"\"\"Add an action to a transaction.\"\"\"\n        if transaction.state != TransactionState.INITIALIZED:\n            raise ValueError(f\"Cannot add actions to transaction in state: {transaction.state.value}\")\n\n        action = SagaAction(\n            action_id=str(uuid.uuid4()),\n            action_type=action_type,\n            description=description,\n            execute_func=execute_func,\n            compensate_func=compensate_func,\n            timeout_s=timeout_s or self.default_action_timeout,\n            max_retries=max_retries,\n            metadata=metadata or {},\n        )\n\n        transaction.actions.append(action)\n\n        logger.debug(f\"Added action to transaction {transaction.transaction_id}: {action.action_id}\")\n        return action\n\n    def add_checkpoint(\n        self,\n        transaction: SagaTransaction,\n        checkpoint_name: str,\n        state_before: Dict[str, Any],\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> TransactionCheckpoint:\n        \"\"\"Add a checkpoint to the transaction.\"\"\"\n        checkpoint = TransactionCheckpoint(\n            checkpoint_id=str(uuid.uuid4()),\n            checkpoint_name=checkpoint_name,\n            state_before=state_before,\n            actions_executed=[a.action_id for a in transaction.actions if a.executed_at],\n            metadata=metadata or {},\n        )\n\n        transaction.checkpoints.append(checkpoint)\n\n        logger.debug(f\"Added checkpoint to transaction {transaction.transaction_id}: {checkpoint.checkpoint_name}\")\n        return checkpoint\n\n    async def execute_transaction(self, transaction: SagaTransaction) -> bool:\n        \"\"\"\n        Execute a SagaLLM transaction with compensation guarantees.\n\n        Returns True if transaction completed successfully, False if compensated.\n        \"\"\"\n        if transaction.state != TransactionState.INITIALIZED:\n            raise ValueError(f\"Cannot execute transaction in state: {transaction.state.value}\")\n\n        transaction.state = TransactionState.ACTIVE\n        transaction.started_at = datetime.now(timezone.utc)\n\n        logger.info(f\"Executing SagaLLM transaction: {transaction.transaction_id}\")\n\n        try:\n            # Execute all actions\n            for i, action in enumerate(transaction.actions):\n                success = await self._execute_action_with_retry(transaction, action, i)\n                if not success:\n                    # Action failed - start compensation\n                    logger.warning(f\"Action failed, starting compensation for transaction: {transaction.transaction_id}\")\n                    await self._compensate_transaction(transaction)\n                    return False\n\n            # All actions succeeded\n            transaction.state = TransactionState.COMPLETED\n            transaction.completed_at = datetime.now(timezone.utc)\n\n            # Move to completed\n            self._completed_transactions[transaction.transaction_id] = transaction\n            del self._active_transactions[transaction.transaction_id]\n\n            logger.info(f\"SagaLLM transaction completed successfully: {transaction.transaction_id}\")\n            return True\n\n        except asyncio.TimeoutError:\n            transaction.state = TransactionState.TIMED_OUT\n            transaction.failure_reason = \"Transaction timeout\"\n            await self._compensate_transaction(transaction)\n            return False\n\n        except Exception as e:\n            transaction.state = TransactionState.FAILED\n            transaction.failed_at = datetime.now(timezone.utc)\n            transaction.failure_reason = str(e)\n\n            logger.error(f\"SagaLLM transaction failed: {transaction.transaction_id} - {e}\")\n            await self._compensate_transaction(transaction)\n            return False\n\n    async def _execute_action_with_retry(\n        self,\n        transaction: SagaTransaction,\n        action: SagaAction,\n        action_index: int\n    ) -> bool:\n        \"\"\"Execute an action with retry logic.\"\"\"\n        for attempt in range(action.max_retries + 1):\n            try:\n                action.retry_count = attempt\n\n                # Execute with timeout\n                result = await asyncio.wait_for(\n                    action.execute_func(),\n                    timeout=action.timeout_s\n                )\n\n                # Success\n                action.executed_at = datetime.now(timezone.utc)\n                action.execution_result = result\n\n                logger.debug(f\"Action executed successfully: {action.action_id} (attempt {attempt + 1})\")\n                return True\n\n            except asyncio.TimeoutError:\n                logger.warning(f\"Action timeout (attempt {attempt + 1}): {action.action_id}\")\n                if attempt == action.max_retries:\n                    return False\n\n            except Exception as e:\n                logger.warning(f\"Action failed (attempt {attempt + 1}): {action.action_id} - {e}\")\n                if attempt == action.max_retries:\n                    return False\n\n            # Wait before retry (exponential backoff)\n            await asyncio.sleep(0.1 * (2 ** attempt))\n\n        return False\n\n    async def _compensate_transaction(self, transaction: SagaTransaction) -> None:\n        \"\"\"Execute compensation actions in LIFO order (reverse execution order).\"\"\"\n        transaction.state = TransactionState.COMPENSATING\n\n        logger.info(f\"Starting compensation for transaction: {transaction.transaction_id}\")\n\n        # Execute compensations in reverse order (LIFO)\n        compensation_log = []\n\n        for action in reversed(transaction.actions):\n            if action.executed_at and action.compensate_func:\n                try:\n                    # Execute compensation with timeout\n                    result = await asyncio.wait_for(\n                        action.compensate_func(),\n                        timeout=self.compensation_timeout\n                    )\n\n                    action.compensated_at = datetime.now(timezone.utc)\n                    action.compensation_result = result\n\n                    compensation_log.append({\n                        \"action_id\": action.action_id,\n                        \"status\": \"compensated\",\n                        \"result\": str(result),\n                        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                    })\n\n                    logger.debug(f\"Compensation executed: {action.action_id}\")\n\n                except Exception as e:\n                    compensation_log.append({\n                        \"action_id\": action.action_id,\n                        \"status\": \"compensation_failed\",\n                        \"error\": str(e),\n                        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                    })\n\n                    logger.error(f\"Compensation failed: {action.action_id} - {e}\")\n\n            elif action.executed_at and not action.compensate_func:\n                # Action executed but no compensation function\n                compensation_log.append({\n                    \"action_id\": action.action_id,\n                    \"status\": \"no_compensation\",\n                    \"warning\": \"Action executed but no compensation function provided\",\n                    \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                })\n\n                logger.warning(f\"No compensation for executed action: {action.action_id}\")\n\n        transaction.compensation_log = compensation_log\n        transaction.state = TransactionState.COMPENSATED\n\n        logger.info(f\"Compensation completed for transaction: {transaction.transaction_id}\")\n\n    def get_transaction(self, transaction_id: str) -> Optional[SagaTransaction]:\n        \"\"\"Get a transaction by ID.\"\"\"\n        if transaction_id in self._active_transactions:\n            return self._active_transactions[transaction_id]\n        if transaction_id in self._completed_transactions:\n            return self._completed_transactions[transaction_id]\n        return None\n\n    def list_active_transactions(self) -> List[SagaTransaction]:\n        \"\"\"List all active transactions.\"\"\"\n        return list(self._active_transactions.values())\n\n    def list_completed_transactions(self) -> List[SagaTransaction]:\n        \"\"\"List all completed transactions.\"\"\"\n        return list(self._completed_transactions.values())\n\n    async def get_engine_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine status and statistics.\"\"\"\n        active_count = len(self._active_transactions)\n        completed_count = len(self._completed_transactions)\n\n        return {\n            \"engine\": \"SagaLLM Transaction Engine\",\n            \"status\": \"operational\",\n            \"active_transactions\": active_count,\n            \"completed_transactions\": completed_count,\n            \"max_transaction_time\": self.max_transaction_time,\n            \"default_action_timeout\": self.default_action_timeout,\n            \"compensation_timeout\": self.compensation_timeout,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n\n@asynccontextmanager\nasync def saga_transaction(\n    engine: SagaLLMEngine,\n    description: str,\n    metadata: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Context manager for SagaLLM transactions.\n\n    Usage:\n        async with saga_transaction(engine, \"Governance decision\") as saga:\n            saga.add_action(...)\n            saga.checkpoint(\"pre_validation\", state)\n            await saga.execute()\n    \"\"\"\n    transaction = engine.create_transaction(description, metadata)\n\n    try:\n        yield transaction\n\n        # Execute the transaction\n        success = await engine.execute_transaction(transaction)\n        if not success:\n            raise RuntimeError(f\"SagaLLM transaction failed and was compensated: {transaction.transaction_id}\")\n\n    except Exception as e:\n        logger.error(f\"SagaLLM transaction context failed: {e}\")\n        raise\n\n\n# Convenience functions for common governance operations\nasync def create_governance_transaction(\n    engine: SagaLLMEngine,\n    decision_description: str,\n) -> SagaTransaction:\n    \"\"\"\n    Create a transaction for governance decision with standard actions.\n\n    This provides a high-level API for constitutional governance transactions.\n    \"\"\"\n    transaction = engine.create_transaction(\n        f\"Governance Decision: {decision_description}\",\n        {\"type\": \"governance\", \"decision\": decision_description}\n    )\n\n    # Add standard governance actions (these would be implemented by the caller)\n    # This is a template - actual implementation would provide real functions\n\n    async def validate_constitutional_compliance():\n        \"\"\"Validate decision against constitutional principles.\"\"\"\n        # Implementation would call MACI verification\n        return {\"status\": \"validated\", \"timestamp\": datetime.now(timezone.utc).isoformat()}\n\n    async def compensate_validation():\n        \"\"\"Compensation for validation (typically a no-op).\"\"\"\n        return {\"status\": \"validation_rolled_back\"}\n\n    engine.add_action(\n        transaction,\n        TransactionAction.CONSTITUTIONAL_CHECK,\n        \"Validate constitutional compliance\",\n        validate_constitutional_compliance,\n        compensate_validation,\n    )\n\n    async def execute_decision():\n        \"\"\"Execute the governance decision.\"\"\"\n        return {\"status\": \"executed\", \"decision\": decision_description}\n\n    async def compensate_decision():\n        \"\"\"Compensation: revert the decision.\"\"\"\n        return {\"status\": \"decision_reverted\", \"decision\": decision_description}\n\n    engine.add_action(\n        transaction,\n        TransactionAction.GOVERNANCE_DECISION,\n        f\"Execute governance decision: {decision_description}\",\n        execute_decision,\n        compensate_decision,\n    )\n\n    async def log_audit():\n        \"\"\"Log the decision to audit trail.\"\"\"\n        return {\"status\": \"logged\", \"audit_id\": str(uuid.uuid4())}\n\n    # Audit logging typically doesn't need compensation (it's append-only)\n    engine.add_action(\n        transaction,\n        TransactionAction.AUDIT_LOGGING,\n        \"Log decision to audit trail\",\n        log_audit,\n        None,  # No compensation needed for audit logs\n    )\n\n    return transaction\n\n\n# Global SagaLLM engine instance\nsaga_engine = SagaLLMEngine()\n\n\ndef get_saga_engine() -> SagaLLMEngine:\n    \"\"\"Get the global SagaLLM engine instance.\"\"\"\n    return saga_engine\n\n\nif __name__ == \"__main__\":\n    # Example usage and testing\n    logging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n\n    async def main():\n        logger.info(\"Testing SagaLLM Transaction Engine...\")\n\n        engine = SagaLLMEngine()\n\n        # Test engine status\n        status = await engine.get_engine_status()\n        logger.info(\"Engine status: %s\", status['status'])\n        logger.info(\"Constitutional hash: %s\", status['constitutional_hash'])\n\n        # Test transaction creation\n        transaction = engine.create_transaction(\"Test governance decision\")\n        logger.info(\"Transaction created: %s\", transaction.transaction_id)\n        logger.info(\"Initial state: %s\", transaction.state.value)\n\n        # Test adding actions\n        async def mock_execute():\n            return {\"result\": \"executed\"}\n\n        async def mock_compensate():\n            return {\"result\": \"compensated\"}\n\n        action = engine.add_action(\n            transaction,\n            TransactionAction.GOVERNANCE_DECISION,\n            \"Test action\",\n            mock_execute,\n            mock_compensate,\n        )\n\n        logger.info(\"Action added: %s\", action.action_id)\n        logger.info(\"Actions in transaction: %d\", len(transaction.actions))\n\n        # Test transaction execution\n        success = await engine.execute_transaction(transaction)\n        logger.info(\"Transaction execution: %s\", 'success' if success else 'compensated')\n        logger.info(\"Final state: %s\", transaction.state.value)\n\n        # Test context manager\n        async def test_context_manager():\n            async with saga_transaction(engine, \"Context manager test\") as saga:\n                engine.add_action(\n                    saga,\n                    TransactionAction.POLICY_VALIDATION,\n                    \"Test policy validation\",\n                    mock_execute,\n                    mock_compensate,\n                )\n                return await engine.execute_transaction(saga)\n\n        context_success = await test_context_manager()\n        logger.info(\"Context manager: %s\", 'success' if context_success else 'compensated')\n\n        logger.info(\"SagaLLM Transaction Engine test completed!\")\n\n    # Run test\n    asyncio.run(main())\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.311269",
  "last_updated": "2026-01-04T05:35:58.561860"
}