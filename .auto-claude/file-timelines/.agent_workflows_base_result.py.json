{
  "file_path": ".agent/workflows/base/result.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Workflow Result\nConstitutional Hash: cdd01ef066bc6cf2\n\nWorkflow execution outcome with audit information.\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\nclass WorkflowStatus(Enum):\n    \"\"\"Status of workflow execution.\"\"\"\n\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    COMPENSATING = \"compensating\"\n    COMPENSATED = \"compensated\"\n    PARTIALLY_COMPENSATED = \"partially_compensated\"\n    TIMED_OUT = \"timed_out\"\n    CANCELLED = \"cancelled\"\n\n\n@dataclass\nclass WorkflowResult:\n    \"\"\"\n    Result of workflow execution with full audit information.\n\n    Attributes:\n        workflow_id: Unique workflow instance identifier\n        status: Final execution status\n        output: Workflow output data (if successful)\n        execution_time_ms: Total execution time in milliseconds\n        steps_completed: List of successfully completed steps\n        steps_failed: List of failed steps\n        compensations_executed: List of executed compensations\n        audit_hash: Blockchain audit trail hash\n        constitutional_hash: Constitutional hash used\n        errors: List of errors during execution\n        metadata: Additional result metadata\n    \"\"\"\n\n    workflow_id: str\n    status: WorkflowStatus\n    output: Optional[Any] = None\n    execution_time_ms: float = 0.0\n    steps_completed: List[str] = field(default_factory=list)\n    steps_failed: List[str] = field(default_factory=list)\n    compensations_executed: List[str] = field(default_factory=list)\n    compensations_failed: List[str] = field(default_factory=list)\n    audit_hash: Optional[str] = None\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    errors: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    completed_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    @property\n    def is_successful(self) -> bool:\n        \"\"\"Check if workflow completed successfully.\"\"\"\n        return self.status == WorkflowStatus.COMPLETED\n\n    @property\n    def is_failed(self) -> bool:\n        \"\"\"Check if workflow failed.\"\"\"\n        return self.status in (\n            WorkflowStatus.FAILED,\n            WorkflowStatus.TIMED_OUT,\n            WorkflowStatus.PARTIALLY_COMPENSATED,\n        )\n\n    @property\n    def is_compensated(self) -> bool:\n        \"\"\"Check if compensations were executed.\"\"\"\n        return self.status in (\n            WorkflowStatus.COMPENSATED,\n            WorkflowStatus.PARTIALLY_COMPENSATED,\n        )\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert result to dictionary for serialization.\"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"status\": self.status.value,\n            \"output\": self.output,\n            \"execution_time_ms\": self.execution_time_ms,\n            \"steps_completed\": self.steps_completed.copy(),\n            \"steps_failed\": self.steps_failed.copy(),\n            \"compensations_executed\": self.compensations_executed.copy(),\n            \"compensations_failed\": self.compensations_failed.copy(),\n            \"audit_hash\": self.audit_hash,\n            \"constitutional_hash\": self.constitutional_hash,\n            \"errors\": self.errors.copy(),\n            \"metadata\": self.metadata.copy(),\n            \"completed_at\": self.completed_at.isoformat(),\n            \"is_successful\": self.is_successful,\n            \"is_failed\": self.is_failed,\n            \"is_compensated\": self.is_compensated,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"WorkflowResult\":\n        \"\"\"Create result from dictionary.\"\"\"\n        completed_at = data.get(\"completed_at\")\n        if isinstance(completed_at, str):\n            completed_at = datetime.fromisoformat(completed_at.replace(\"Z\", \"+00:00\"))\n        elif completed_at is None:\n            completed_at = datetime.now(timezone.utc)\n\n        return cls(\n            workflow_id=data[\"workflow_id\"],\n            status=WorkflowStatus(data[\"status\"]),\n            output=data.get(\"output\"),\n            execution_time_ms=data.get(\"execution_time_ms\", 0.0),\n            steps_completed=data.get(\"steps_completed\", []),\n            steps_failed=data.get(\"steps_failed\", []),\n            compensations_executed=data.get(\"compensations_executed\", []),\n            compensations_failed=data.get(\"compensations_failed\", []),\n            audit_hash=data.get(\"audit_hash\"),\n            constitutional_hash=data.get(\"constitutional_hash\", CONSTITUTIONAL_HASH),\n            errors=data.get(\"errors\", []),\n            metadata=data.get(\"metadata\", {}),\n            completed_at=completed_at,\n        )\n\n    @classmethod\n    def success(\n        cls,\n        workflow_id: str,\n        output: Any,\n        execution_time_ms: float,\n        steps_completed: List[str],\n        audit_hash: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"WorkflowResult\":\n        \"\"\"Factory method for successful result.\"\"\"\n        return cls(\n            workflow_id=workflow_id,\n            status=WorkflowStatus.COMPLETED,\n            output=output,\n            execution_time_ms=execution_time_ms,\n            steps_completed=steps_completed,\n            audit_hash=audit_hash,\n            metadata=metadata or {},\n        )\n\n    @classmethod\n    def failure(\n        cls,\n        workflow_id: str,\n        errors: List[str],\n        execution_time_ms: float,\n        steps_completed: List[str],\n        steps_failed: List[str],\n        compensations_executed: Optional[List[str]] = None,\n        compensations_failed: Optional[List[str]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"WorkflowResult\":\n        \"\"\"Factory method for failed result.\"\"\"\n        status = WorkflowStatus.FAILED\n        if compensations_executed:\n            if compensations_failed:\n                status = WorkflowStatus.PARTIALLY_COMPENSATED\n            else:\n                status = WorkflowStatus.COMPENSATED\n\n        return cls(\n            workflow_id=workflow_id,\n            status=status,\n            execution_time_ms=execution_time_ms,\n            steps_completed=steps_completed,\n            steps_failed=steps_failed,\n            compensations_executed=compensations_executed or [],\n            compensations_failed=compensations_failed or [],\n            errors=errors,\n            metadata=metadata or {},\n        )\n\n    @classmethod\n    def timeout(\n        cls,\n        workflow_id: str,\n        execution_time_ms: float,\n        steps_completed: List[str],\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"WorkflowResult\":\n        \"\"\"Factory method for timeout result.\"\"\"\n        return cls(\n            workflow_id=workflow_id,\n            status=WorkflowStatus.TIMED_OUT,\n            execution_time_ms=execution_time_ms,\n            steps_completed=steps_completed,\n            errors=[\"Workflow timed out\"],\n            metadata=metadata or {},\n        )\n\n\n__all__ = [\"WorkflowStatus\", \"WorkflowResult\"]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.189138",
  "last_updated": "2026-01-04T05:35:58.641347"
}