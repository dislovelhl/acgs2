{
  "file_path": "analytics-dashboard/src/test/hooks/useAnomalies.test.ts",
  "main_branch_history": [],
  "task_views": {
    "033-add-useanomalies-hook-to-analytics-dashboard": {
      "task_id": "033-add-useanomalies-hook-to-analytics-dashboard",
      "branch_point": {
        "commit_hash": "4a99fe22e8e0087919301b1aa185d4e2c6da716c",
        "content": "",
        "timestamp": "2026-01-03T18:32:21.773146"
      },
      "worktree_state": {
        "content": "/**\n * Unit Tests for useAnomalies Hook\n *\n * Comprehensive tests covering:\n * - Successful data fetch\n * - Error handling\n * - Severity filtering\n * - Refetch functionality\n * - Loading states\n */\n\nimport { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport { renderHook, waitFor } from \"@testing-library/react\";\nimport { http, HttpResponse } from \"msw\";\nimport { server } from \"../mocks/server\";\nimport { useAnomalies } from \"../../hooks/useAnomalies\";\nimport type { AnomaliesResponse } from \"../../types/anomalies\";\n\nconst API_BASE_URL = \"http://localhost:8080\";\n\n// Sample anomalies data for testing\nconst mockAnomaliesData: AnomaliesResponse = {\n  analysis_timestamp: new Date().toISOString(),\n  total_records_analyzed: 150,\n  anomalies_detected: 3,\n  contamination_rate: 0.1,\n  model_trained: true,\n  anomalies: [\n    {\n      anomaly_id: \"anomaly-001\",\n      timestamp: new Date().toISOString(),\n      severity_score: 0.85,\n      severity_label: \"critical\",\n      affected_metrics: {\n        violation_count: 45,\n        user_count: 12,\n        policy_changes: 3,\n      },\n      description: \"Unusual spike in policy violations detected\",\n    },\n    {\n      anomaly_id: \"anomaly-002\",\n      timestamp: new Date().toISOString(),\n      severity_score: 0.65,\n      severity_label: \"medium\",\n      affected_metrics: {\n        violation_count: 22,\n        user_count: 5,\n      },\n      description: \"Moderate increase in access control violations\",\n    },\n    {\n      anomaly_id: \"anomaly-003\",\n      timestamp: new Date().toISOString(),\n      severity_score: 0.45,\n      severity_label: \"low\",\n      affected_metrics: {\n        violation_count: 8,\n        user_count: 2,\n      },\n      description: \"Minor anomaly in user activity patterns\",\n    },\n  ],\n};\n\ndescribe(\"useAnomalies Hook\", () => {\n  beforeEach(() => {\n    server.resetHandlers();\n  });\n\n  afterEach(() => {\n    server.resetHandlers();\n  });\n\n  describe(\"Successful Data Fetch\", () => {\n    it(\"fetches anomalies successfully without filter\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      // Initially loading\n      expect(result.current.loading).toBe(true);\n      expect(result.current.data).toBeNull();\n      expect(result.current.error).toBeNull();\n\n      // Wait for data to load\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      // Verify data was fetched\n      expect(result.current.data).toEqual(mockAnomaliesData);\n      expect(result.current.error).toBeNull();\n      expect(result.current.data?.anomalies_detected).toBe(3);\n      expect(result.current.data?.anomalies).toHaveLength(3);\n    });\n\n    it(\"provides refetch function in return value\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(typeof result.current.refetch).toBe(\"function\");\n    });\n\n    it(\"fetches anomalies with all response properties\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const data = result.current.data;\n      expect(data).toBeDefined();\n      expect(data?.analysis_timestamp).toBeDefined();\n      expect(data?.total_records_analyzed).toBe(150);\n      expect(data?.anomalies_detected).toBe(3);\n      expect(data?.contamination_rate).toBe(0.1);\n      expect(data?.model_trained).toBe(true);\n    });\n\n    it(\"fetches anomaly items with correct structure\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const anomaly = result.current.data?.anomalies[0];\n      expect(anomaly).toBeDefined();\n      expect(anomaly?.anomaly_id).toBe(\"anomaly-001\");\n      expect(anomaly?.severity_score).toBe(0.85);\n      expect(anomaly?.severity_label).toBe(\"critical\");\n      expect(anomaly?.description).toBe(\"Unusual spike in policy violations detected\");\n      expect(anomaly?.affected_metrics).toEqual({\n        violation_count: 45,\n        user_count: 12,\n        policy_changes: 3,\n      });\n    });\n  });\n\n  describe(\"Severity Filtering\", () => {\n    it(\"fetches anomalies filtered by critical severity\", async () => {\n      const { result } = renderHook(() => useAnomalies(\"critical\"));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      // MSW handler filters by severity\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"critical\");\n      expect(result.current.data?.anomalies_detected).toBe(1);\n    });\n\n    it(\"fetches anomalies filtered by medium severity\", async () => {\n      const { result } = renderHook(() => useAnomalies(\"medium\"));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"medium\");\n      expect(result.current.data?.anomalies_detected).toBe(1);\n    });\n\n    it(\"fetches anomalies filtered by low severity\", async () => {\n      const { result } = renderHook(() => useAnomalies(\"low\"));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"low\");\n      expect(result.current.data?.anomalies_detected).toBe(1);\n    });\n\n    it(\"handles null severity filter (fetches all anomalies)\", async () => {\n      const { result } = renderHook(() => useAnomalies(null));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(3);\n      expect(result.current.data?.anomalies_detected).toBe(3);\n    });\n\n    it(\"re-fetches when severity filter changes\", async () => {\n      const { result, rerender } = renderHook(\n        ({ filter }) => useAnomalies(filter),\n        { initialProps: { filter: \"critical\" } }\n      );\n\n      // Wait for initial fetch with critical filter\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"critical\");\n\n      // Change filter to medium\n      rerender({ filter: \"medium\" });\n\n      // Should be loading again\n      await waitFor(() => {\n        expect(result.current.loading).toBe(true);\n      });\n\n      // Wait for new data\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"medium\");\n    });\n  });\n\n  describe(\"Error Handling\", () => {\n    it(\"handles 500 server error\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json(\n            { detail: \"Anomaly detection service unavailable\" },\n            { status: 500 }\n          );\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\n        \"Anomaly detection service unavailable\"\n      );\n      expect(result.current.data).toBeNull();\n    });\n\n    it(\"handles 503 service unavailable error\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json(\n            { detail: \"Service temporarily unavailable\" },\n            { status: 503 }\n          );\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\n        \"Service temporarily unavailable\"\n      );\n      expect(result.current.data).toBeNull();\n    });\n\n    it(\"handles 400 bad request error\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json(\n            { detail: \"Invalid severity parameter\" },\n            { status: 400 }\n          );\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies(\"invalid\"));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\"Invalid severity parameter\");\n      expect(result.current.data).toBeNull();\n    });\n\n    it(\"handles network error\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.error();\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\"Failed to load anomalies\");\n      expect(result.current.data).toBeNull();\n    });\n\n    it(\"handles response without detail property\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json({}, { status: 500 });\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\"Failed to fetch anomalies: 500\");\n      expect(result.current.data).toBeNull();\n    });\n\n    it(\"handles non-JSON error response\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return new HttpResponse(\"Internal Server Error\", { status: 500 });\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeDefined();\n      expect(result.current.error?.message).toContain(\"Failed to fetch anomalies: 500\");\n      expect(result.current.data).toBeNull();\n    });\n  });\n\n  describe(\"Loading States\", () => {\n    it(\"starts with loading true\", () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      expect(result.current.loading).toBe(true);\n      expect(result.current.data).toBeNull();\n      expect(result.current.error).toBeNull();\n    });\n\n    it(\"sets loading to false after successful fetch\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      expect(result.current.loading).toBe(true);\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data).toBeDefined();\n      expect(result.current.error).toBeNull();\n    });\n\n    it(\"sets loading to false after error\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json({ detail: \"Error\" }, { status: 500 });\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      expect(result.current.loading).toBe(true);\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data).toBeNull();\n      expect(result.current.error).toBeDefined();\n    });\n\n    it(\"sets loading to true during refetch\", async () => {\n      const { result } = renderHook(() => useAnomalies());\n\n      // Wait for initial load\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data).toBeDefined();\n\n      // Trigger refetch\n      result.current.refetch();\n\n      // Should be loading again\n      await waitFor(() => {\n        expect(result.current.loading).toBe(true);\n      });\n\n      // Should complete loading\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data).toBeDefined();\n    });\n  });\n\n  describe(\"Refetch Functionality\", () => {\n    it(\"refetches data when refetch is called\", async () => {\n      let callCount = 0;\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          callCount++;\n          return HttpResponse.json(mockAnomaliesData);\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      // Wait for initial fetch\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(callCount).toBe(1);\n      expect(result.current.data).toBeDefined();\n\n      // Refetch\n      result.current.refetch();\n\n      // Wait for refetch to complete\n      await waitFor(() => {\n        expect(callCount).toBe(2);\n      });\n\n      expect(result.current.data).toBeDefined();\n    });\n\n    it(\"clears error state when refetch is called\", async () => {\n      // First request fails\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          return HttpResponse.json({ detail: \"Error\" }, { status: 500 });\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      // Wait for error\n      await waitFor(() => {\n        expect(result.current.error).toBeDefined();\n      });\n\n      // Reset to working handler\n      server.resetHandlers();\n\n      // Refetch\n      result.current.refetch();\n\n      // Should clear error and load data\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBeNull();\n      expect(result.current.data).toBeDefined();\n    });\n\n    it(\"maintains severity filter during refetch\", async () => {\n      const { result } = renderHook(() => useAnomalies(\"critical\"));\n\n      // Wait for initial fetch\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"critical\");\n\n      // Refetch\n      result.current.refetch();\n\n      // Wait for refetch\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      // Should still have filtered data\n      expect(result.current.data?.anomalies).toHaveLength(1);\n      expect(result.current.data?.anomalies[0].severity_label).toBe(\"critical\");\n    });\n\n    it(\"updates data when refetch returns new results\", async () => {\n      let requestCount = 0;\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, () => {\n          requestCount++;\n          if (requestCount === 1) {\n            return HttpResponse.json({\n              ...mockAnomaliesData,\n              anomalies_detected: 3,\n              anomalies: mockAnomaliesData.anomalies,\n            });\n          }\n          // Second request returns different data\n          return HttpResponse.json({\n            ...mockAnomaliesData,\n            anomalies_detected: 1,\n            anomalies: [mockAnomaliesData.anomalies[0]],\n          });\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      // Wait for initial fetch\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.data?.anomalies_detected).toBe(3);\n\n      // Refetch\n      result.current.refetch();\n\n      // Wait for refetch\n      await waitFor(() => {\n        expect(result.current.data?.anomalies_detected).toBe(1);\n      });\n\n      expect(result.current.data?.anomalies).toHaveLength(1);\n    });\n  });\n\n  describe(\"Request URL Formation\", () => {\n    it(\"sends GET request to /anomalies without query params when no filter\", async () => {\n      let requestUrl = \"\";\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, ({ request }) => {\n          requestUrl = request.url;\n          return HttpResponse.json(mockAnomaliesData);\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(requestUrl).toBe(`${API_BASE_URL}/anomalies`);\n    });\n\n    it(\"includes severity query parameter when filter is provided\", async () => {\n      let requestUrl = \"\";\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, ({ request }) => {\n          requestUrl = request.url;\n          return HttpResponse.json(mockAnomaliesData);\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies(\"critical\"));\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(requestUrl).toContain(\"severity=critical\");\n    });\n\n    it(\"sends Accept: application/json header\", async () => {\n      let acceptHeader = \"\";\n      server.use(\n        http.get(`${API_BASE_URL}/anomalies`, ({ request }) => {\n          acceptHeader = request.headers.get(\"Accept\") || \"\";\n          return HttpResponse.json(mockAnomaliesData);\n        })\n      );\n\n      const { result } = renderHook(() => useAnomalies());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(acceptHeader).toBe(\"application/json\");\n    });\n  });\n});\n",
        "last_modified": "2026-01-03T18:36:09.855943"
      },
      "task_intent": {
        "title": "033-add-useanomalies-hook-to-analytics-dashboard",
        "description": "Extract the anomaly fetching logic from AnomalyWidget.tsx into a reusable useAnomalies hook following the existing UseDataResult<T> pattern established in acgs2-observability/monitoring/dashboard/src/hooks/useDashboard.ts. This enables anomaly data to be consumed by other components without duplicating fetch logic.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T18:32:21.792593",
  "last_updated": "2026-01-03T18:32:21.794550"
}