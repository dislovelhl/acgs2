{
  "file_path": "src/core/enhanced_agent_bus/deliberation_layer/interfaces.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Deliberation Layer - Interfaces\nConstitutional Hash: cdd01ef066bc6cf2\n\nProtocol definitions for dependency injection in the deliberation layer.\n\"\"\"\n\nfrom typing import Any, Callable, Dict, List, Optional, Protocol, runtime_checkable\n\n# Import centralized constitutional hash from shared module\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\n@runtime_checkable\nclass ImpactScorerProtocol(Protocol):\n    \"\"\"Protocol for impact scoring implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def calculate_impact_score(\n        self, content: Dict[str, Any], context: Optional[Dict[str, Any]] = None\n    ) -> float:\n        \"\"\"Calculate impact score for message content.\n\n        Args:\n            content: Message content to analyze\n            context: Optional context (agent_id, tenant_id, etc.)\n\n        Returns:\n            Impact score between 0.0 and 1.0\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass AdaptiveRouterProtocol(Protocol):\n    \"\"\"Protocol for adaptive routing implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def route_message(\n        self,\n        message: Any,\n        context: Optional[Dict[str, Any]] = None,  # AgentMessage\n    ) -> Dict[str, Any]:\n        \"\"\"Route a message based on impact assessment.\n\n        Args:\n            message: The message to route\n            context: Optional routing context\n\n        Returns:\n            Routing decision with 'lane' key ('fast' or 'deliberation')\n        \"\"\"\n        ...\n\n    async def force_deliberation(self, message: Any, reason: str) -> Dict[str, Any]:\n        \"\"\"Force a message into deliberation.\n\n        Args:\n            message: The message to route\n            reason: Reason for forcing deliberation\n\n        Returns:\n            Routing result\n        \"\"\"\n        ...\n\n    async def update_performance_feedback(\n        self,\n        message_id: str,\n        actual_outcome: str,\n        processing_time: float,\n        feedback_score: Optional[float] = None,\n    ) -> None:\n        \"\"\"Update performance feedback for learning.\n\n        Args:\n            message_id: ID of the processed message\n            actual_outcome: Actual outcome of processing\n            processing_time: Time taken to process\n            feedback_score: Optional feedback score\n        \"\"\"\n        ...\n\n    def get_routing_stats(self) -> Dict[str, Any]:\n        \"\"\"Get routing statistics.\n\n        Returns:\n            Dictionary of routing statistics\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass DeliberationQueueProtocol(Protocol):\n    \"\"\"Protocol for deliberation queue implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def enqueue_for_deliberation(\n        self,\n        message: Any,\n        requires_human_review: bool = False,\n        requires_multi_agent_vote: bool = False,\n        timeout_seconds: int = 300,\n    ) -> str:\n        \"\"\"Enqueue a message for deliberation.\n\n        Args:\n            message: The message to enqueue\n            requires_human_review: Whether human review is required\n            requires_multi_agent_vote: Whether multi-agent vote is required\n            timeout_seconds: Timeout for deliberation\n\n        Returns:\n            Item ID for the enqueued message\n        \"\"\"\n        ...\n\n    async def submit_human_decision(\n        self,\n        item_id: str,\n        reviewer: str,\n        decision: Any,\n        reasoning: str,  # DeliberationStatus\n    ) -> bool:\n        \"\"\"Submit a human decision for a deliberation item.\n\n        Args:\n            item_id: ID of the deliberation item\n            reviewer: ID of the human reviewer\n            decision: The decision made\n            reasoning: Reasoning for the decision\n\n        Returns:\n            True if decision was submitted successfully\n        \"\"\"\n        ...\n\n    async def submit_agent_vote(\n        self,\n        item_id: str,\n        agent_id: str,\n        vote: Any,  # VoteType\n        reasoning: str,\n        confidence: float = 1.0,\n    ) -> bool:\n        \"\"\"Submit an agent vote for a deliberation item.\n\n        Args:\n            item_id: ID of the deliberation item\n            agent_id: ID of the voting agent\n            vote: The vote\n            reasoning: Reasoning for the vote\n            confidence: Confidence level\n\n        Returns:\n            True if vote was submitted successfully\n        \"\"\"\n        ...\n\n    def get_item_details(self, item_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get details of a deliberation item.\n\n        Args:\n            item_id: ID of the deliberation item\n\n        Returns:\n            Item details or None if not found\n        \"\"\"\n        ...\n\n    def get_queue_status(self) -> Dict[str, Any]:\n        \"\"\"Get queue status.\n\n        Returns:\n            Dictionary with queue stats, queue_size, processing_count\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass LLMAssistantProtocol(Protocol):\n    \"\"\"Protocol for LLM assistant implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def analyze_deliberation_trends(self, history: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Analyze deliberation trends.\n\n        Args:\n            history: Historical deliberation data\n\n        Returns:\n            Analysis results\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass RedisQueueProtocol(Protocol):\n    \"\"\"Protocol for Redis queue implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to Redis.\"\"\"\n        ...\n\n    async def close(self) -> None:\n        \"\"\"Close the Redis connection.\"\"\"\n        ...\n\n    async def enqueue_deliberation_item(\n        self, message: Any, item_id: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> bool:\n        \"\"\"Enqueue a deliberation item in Redis.\n\n        Args:\n            message: The message to enqueue\n            item_id: ID of the deliberation item\n            metadata: Optional metadata\n\n        Returns:\n            True if item was enqueued successfully\n        \"\"\"\n        ...\n\n    async def get_stream_info(self) -> Dict[str, Any]:\n        \"\"\"Get stream information.\n\n        Returns:\n            Stream info dictionary\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass RedisVotingProtocol(Protocol):\n    \"\"\"Protocol for Redis voting implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to Redis.\"\"\"\n        ...\n\n    async def close(self) -> None:\n        \"\"\"Close the Redis connection.\"\"\"\n        ...\n\n    async def submit_vote(\n        self, item_id: str, agent_id: str, vote: str, reasoning: str, confidence: float = 1.0\n    ) -> bool:\n        \"\"\"Submit a vote.\n\n        Args:\n            item_id: ID of the deliberation item\n            agent_id: ID of the voting agent\n            vote: The vote\n            reasoning: Reasoning for the vote\n            confidence: Confidence level\n\n        Returns:\n            True if vote was submitted successfully\n        \"\"\"\n        ...\n\n\n@runtime_checkable\nclass OPAGuardProtocol(Protocol):\n    \"\"\"Protocol for OPA Guard implementations.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize the OPA Guard.\"\"\"\n        ...\n\n    async def close(self) -> None:\n        \"\"\"Close the OPA Guard.\"\"\"\n        ...\n\n    async def verify_action(\n        self, agent_id: str, action: Dict[str, Any], context: Optional[Dict[str, Any]] = None\n    ) -> Any:  # GuardResult\n        \"\"\"Verify an action with OPA Guard.\n\n        Args:\n            agent_id: ID of the agent performing the action\n            action: Action details\n            context: Additional context\n\n        Returns:\n            GuardResult with verification outcome\n        \"\"\"\n        ...\n\n    async def collect_signatures(\n        self,\n        decision_id: str,\n        required_signers: List[str],\n        threshold: float = 1.0,\n        timeout: int = 300,\n    ) -> Any:  # SignatureResult\n        \"\"\"Collect multi-signatures for a decision.\n\n        Args:\n            decision_id: Unique ID for the decision\n            required_signers: List of required signer IDs\n            threshold: Percentage of signatures required\n            timeout: Timeout in seconds\n\n        Returns:\n            SignatureResult\n        \"\"\"\n        ...\n\n    async def submit_signature(\n        self, decision_id: str, signer_id: str, reasoning: str = \"\", confidence: float = 1.0\n    ) -> bool:\n        \"\"\"Submit a signature for a pending decision.\"\"\"\n        ...\n\n    async def submit_for_review(\n        self,\n        decision: Dict[str, Any],\n        critic_agents: List[str],\n        review_types: Optional[List[str]] = None,\n        timeout: int = 300,\n    ) -> Any:  # ReviewResult\n        \"\"\"Submit a decision for critic agent review.\"\"\"\n        ...\n\n    async def submit_review(\n        self,\n        decision_id: str,\n        critic_id: str,\n        verdict: str,\n        reasoning: str = \"\",\n        concerns: Optional[List[str]] = None,\n        recommendations: Optional[List[str]] = None,\n        confidence: float = 1.0,\n    ) -> bool:\n        \"\"\"Submit a critic review for a pending decision.\"\"\"\n        ...\n\n    def register_critic_agent(\n        self,\n        critic_id: str,\n        review_types: List[str],\n        callback: Optional[Callable] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"Register a critic agent for reviews.\"\"\"\n        ...\n\n    def unregister_critic_agent(self, critic_id: str) -> None:\n        \"\"\"Unregister a critic agent.\"\"\"\n        ...\n\n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get OPA Guard statistics.\"\"\"\n        ...\n\n    def get_audit_log(\n        self, limit: int = 100, offset: int = 0, agent_id: Optional[str] = None\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Get audit log entries.\"\"\"\n        ...\n\n\n__all__ = [\n    \"CONSTITUTIONAL_HASH\",\n    \"ImpactScorerProtocol\",\n    \"AdaptiveRouterProtocol\",\n    \"DeliberationQueueProtocol\",\n    \"LLMAssistantProtocol\",\n    \"RedisQueueProtocol\",\n    \"RedisVotingProtocol\",\n    \"OPAGuardProtocol\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.339003",
  "last_updated": "2026-01-04T05:35:58.793704"
}