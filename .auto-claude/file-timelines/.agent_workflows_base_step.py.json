{
  "file_path": ".agent/workflows/base/step.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Workflow Step\nConstitutional Hash: cdd01ef066bc6cf2\n\nIndividual workflow step with compensation support.\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Awaitable, Callable, Dict, Optional, TypeVar\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\nT = TypeVar(\"T\")\n\n\nclass StepStatus(Enum):\n    \"\"\"Status of individual workflow step.\"\"\"\n\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    SKIPPED = \"skipped\"\n    COMPENSATING = \"compensating\"\n    COMPENSATED = \"compensated\"\n    COMPENSATION_FAILED = \"compensation_failed\"\n\n\n@dataclass\nclass StepCompensation:\n    \"\"\"\n    Compensation action for a workflow step.\n\n    Compensations are idempotent operations that undo the effects of a step.\n    They must be safe to call multiple times.\n\n    CRITICAL: Register compensation BEFORE executing the step.\n\n    Attributes:\n        name: Unique name for the compensation\n        execute: Async function that performs the compensation\n        description: Human-readable description\n        idempotency_key: Key for deduplication\n        max_retries: Maximum retry attempts\n        retry_delay_seconds: Delay between retries\n    \"\"\"\n\n    name: str\n    execute: Callable[[Dict[str, Any]], Awaitable[bool]]\n    description: str = \"\"\n    idempotency_key: Optional[str] = None\n    max_retries: int = 3\n    retry_delay_seconds: float = 1.0\n\n    def __hash__(self):\n        return hash(self.name)\n\n\n@dataclass\nclass WorkflowStep:\n    \"\"\"\n    Represents a single step in a workflow.\n\n    Each step has:\n    - An execution function (activity)\n    - An optional compensation function (for rollback)\n    - Configuration for retries and timeouts\n    - Constitutional validation option\n\n    IMPORTANT: The saga pattern requires registering compensation BEFORE\n    executing the step. This ensures proper LIFO rollback on failure.\n\n    Attributes:\n        name: Unique step name within workflow\n        execute: Async function that performs the step\n        compensation: Optional compensation for rollback\n        description: Human-readable description\n        timeout_seconds: Maximum execution time\n        max_retries: Maximum retry attempts\n        is_optional: If True, failure doesn't stop workflow\n        requires_constitutional_check: Validate hash before execution\n        depends_on: List of step names this step depends on\n    \"\"\"\n\n    name: str\n    execute: Callable[[Dict[str, Any]], Awaitable[T]]\n    compensation: Optional[StepCompensation] = None\n    description: str = \"\"\n    timeout_seconds: int = 30\n    max_retries: int = 3\n    retry_delay_seconds: float = 1.0\n    is_optional: bool = False\n    requires_constitutional_check: bool = True\n    requires_previous: bool = True\n    depends_on: list = field(default_factory=list)\n\n    # Runtime state (not for initialization)\n    status: StepStatus = field(default=StepStatus.PENDING, init=False)\n    result: Optional[Any] = field(default=None, init=False)\n    error: Optional[str] = field(default=None, init=False)\n    started_at: Optional[datetime] = field(default=None, init=False)\n    completed_at: Optional[datetime] = field(default=None, init=False)\n    execution_time_ms: float = field(default=0.0, init=False)\n    attempt_count: int = field(default=0, init=False)\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def mark_executing(self) -> None:\n        \"\"\"Mark step as executing.\"\"\"\n        self.status = StepStatus.EXECUTING\n        self.started_at = datetime.now(timezone.utc)\n        self.attempt_count += 1\n\n    def mark_completed(self, result: Any) -> None:\n        \"\"\"Mark step as completed with result.\"\"\"\n        self.status = StepStatus.COMPLETED\n        self.result = result\n        self.completed_at = datetime.now(timezone.utc)\n        if self.started_at:\n            self.execution_time_ms = (self.completed_at - self.started_at).total_seconds() * 1000\n\n    def mark_failed(self, error: str) -> None:\n        \"\"\"Mark step as failed with error.\"\"\"\n        self.status = StepStatus.FAILED\n        self.error = error\n        self.completed_at = datetime.now(timezone.utc)\n        if self.started_at:\n            self.execution_time_ms = (self.completed_at - self.started_at).total_seconds() * 1000\n\n    def mark_skipped(self) -> None:\n        \"\"\"Mark step as skipped.\"\"\"\n        self.status = StepStatus.SKIPPED\n\n    def mark_compensating(self) -> None:\n        \"\"\"Mark step compensation as in progress.\"\"\"\n        self.status = StepStatus.COMPENSATING\n\n    def mark_compensated(self) -> None:\n        \"\"\"Mark step as compensated.\"\"\"\n        self.status = StepStatus.COMPENSATED\n\n    def mark_compensation_failed(self) -> None:\n        \"\"\"Mark step compensation as failed.\"\"\"\n        self.status = StepStatus.COMPENSATION_FAILED\n\n    def can_retry(self) -> bool:\n        \"\"\"Check if step can be retried.\"\"\"\n        return self.attempt_count < self.max_retries\n\n    def reset(self) -> None:\n        \"\"\"Reset step state for re-execution.\"\"\"\n        self.status = StepStatus.PENDING\n        self.result = None\n        self.error = None\n        self.started_at = None\n        self.completed_at = None\n        self.execution_time_ms = 0.0\n        self.attempt_count = 0\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert step to dictionary for serialization.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"status\": self.status.value,\n            \"result\": self.result,\n            \"error\": self.error,\n            \"started_at\": self.started_at.isoformat() if self.started_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"execution_time_ms\": self.execution_time_ms,\n            \"attempt_count\": self.attempt_count,\n            \"timeout_seconds\": self.timeout_seconds,\n            \"max_retries\": self.max_retries,\n            \"is_optional\": self.is_optional,\n            \"requires_constitutional_check\": self.requires_constitutional_check,\n            \"has_compensation\": self.compensation is not None,\n            \"depends_on\": self.depends_on,\n        }\n\n\ndef step(\n    name: str,\n    description: str = \"\",\n    timeout_seconds: int = 30,\n    max_retries: int = 3,\n    is_optional: bool = False,\n    requires_constitutional_check: bool = True,\n    depends_on: Optional[list] = None,\n):\n    \"\"\"\n    Decorator to create a workflow step from a function.\n\n    Example:\n        @step(\"validate_input\", description=\"Validate input data\")\n        async def validate_input(context: Dict[str, Any]) -> bool:\n            return context.get(\"input\") is not None\n    \"\"\"\n\n    def decorator(func: Callable[[Dict[str, Any]], Awaitable[T]]) -> WorkflowStep:\n        return WorkflowStep(\n            name=name,\n            execute=func,\n            description=description,\n            timeout_seconds=timeout_seconds,\n            max_retries=max_retries,\n            is_optional=is_optional,\n            requires_constitutional_check=requires_constitutional_check,\n            depends_on=depends_on or [],\n        )\n\n    return decorator\n\n\ndef with_compensation(\n    compensation_name: str,\n    description: str = \"\",\n    max_retries: int = 3,\n):\n    \"\"\"\n    Decorator to add compensation to a workflow step.\n\n    Example:\n        @with_compensation(\"release_lock\", description=\"Release acquired lock\")\n        async def release_lock(context: Dict[str, Any]) -> bool:\n            lock_id = context.get(\"acquire_lock\", {}).get(\"lock_id\")\n            return await release(lock_id)\n    \"\"\"\n\n    def decorator(func: Callable[[Dict[str, Any]], Awaitable[bool]]) -> StepCompensation:\n        return StepCompensation(\n            name=compensation_name,\n            execute=func,\n            description=description,\n            max_retries=max_retries,\n        )\n\n    return decorator\n\n\n__all__ = [\n    \"StepStatus\",\n    \"StepCompensation\",\n    \"WorkflowStep\",\n    \"step\",\n    \"with_compensation\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.113985",
  "last_updated": "2026-01-04T05:35:58.533545"
}