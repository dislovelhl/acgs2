{
  "file_path": ".agent/workflows/coordination/supervisor.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Supervisor Node\nConstitutional Hash: cdd01ef066bc6cf2\n\nImplement the Supervisor-Worker topology for CEOS.\nThe Supervisor plans, delegates, and critiques.\n\"\"\"\n\nimport logging\nfrom typing import Any, Awaitable, Callable\n\nfrom ..cyclic.state_schema import GlobalState\nfrom .signatures import CEOSPoncho, CritiqueSignature, PlanningSignature\n\nlogger = logging.getLogger(__name__)\n\n\nclass SupervisorNode:\n    \"\"\"\n    Refined Supervisor Node for CEOS Orchestration.\n\n    Uses CEOS Signatures (DSPy-style) for structured planning and critiquing.\n    Maintains a planning-execution-critique loop with constitutional feedback.\n    \"\"\"\n\n    def __init__(self, name: str = \"supervisor\", llm_client: Any = None):\n        self.name = name\n        self.orchestrator = CEOSPoncho(llm_client)\n\n    async def __call__(self, state: GlobalState) -> GlobalState:\n        \"\"\"\n        State Reducer for the Supervisor.\n        \"\"\"\n        state.update_timestamp()\n\n        # 1. Critique Phase\n        if state.history and state.history[-1][\"node\"].startswith(\"worker_\"):\n            last_worker_node = state.history[-1][\"node\"]\n            last_worker_result = state.context.get(f\"{last_worker_node}_result\", {})\n\n            # Use Critique Signature\n            critique = await self.orchestrator(\n                CritiqueSignature,\n                task_desc=f\"Execute step for {last_worker_node}\",\n                worker_output=last_worker_result,\n                constitutional_constraints=[state.metadata.constitutional_hash],\n            )\n\n            if not critique[\"is_passed\"]:\n                state.log_event(\n                    self.name,\n                    {\"action\": \"critique\", \"status\": \"fail\", \"feedback\": critique[\"feedback\"]},\n                )\n                # Re-run the node with feedback\n                state.next_node = last_worker_node\n                state.context[\"last_feedback\"] = critique[\"feedback\"]\n                return state\n\n            state.log_event(self.name, {\"action\": \"critique\", \"status\": \"pass\"})\n\n        # 2. Planning Phase\n        plan = state.context.get(\"ceos_plan\", [])\n        plan_idx = state.context.get(\"ceos_plan_idx\", 0)\n\n        if not plan:\n            user_request = state.context.get(\"user_request\", \"\")\n            # Use Planning Signature\n            planning_result = await self.orchestrator(\n                PlanningSignature,\n                user_request=user_request,\n                context=state.context,\n                available_workers=[\n                    \"worker_research\",\n                    \"worker_coder\",\n                    \"worker_validator\",\n                    \"worker_analyst\",\n                ],\n            )\n\n            plan = planning_result[\"plan\"]\n            state.context[\"ceos_plan\"] = plan\n            state.context[\"ceos_plan_idx\"] = 0\n            state.context[\"planning_reasoning\"] = planning_result[\"reasoning\"]\n            state.log_event(\n                self.name,\n                {\"action\": \"planning\", \"steps\": plan, \"reasoning\": planning_result[\"reasoning\"]},\n            )\n\n        # 3. Delegation Phase\n        if plan_idx < len(plan):\n            next_worker = plan[plan_idx]\n            state.next_node = next_worker\n            state.context[\"ceos_plan_idx\"] = plan_idx + 1\n            state.log_event(self.name, {\"action\": \"delegation\", \"target\": next_worker})\n        else:\n            state.is_finished = True\n            state.log_event(self.name, {\"action\": \"completion\"})\n\n        return state\n\n\nclass WorkerNode:\n    \"\"\"\n    A specialized worker node that performs a specific task.\n    \"\"\"\n\n    def __init__(self, name: str, task_fn: Callable[[GlobalState], Awaitable[GlobalState]]):\n        self.name = name\n        self.task_fn = task_fn\n\n    async def __call__(self, state: GlobalState) -> GlobalState:\n        state.log_event(self.name, {\"status\": \"started\"})\n        try:\n            state = await self.task_fn(state)\n            state.log_event(self.name, {\"status\": \"completed\"})\n        except Exception as e:\n            state.log_event(self.name, {\"status\": \"error\", \"error\": str(e)})\n            state.context[f\"{self.name}_result\"] = {\"status\": \"error\", \"message\": str(e)}\n            # Do NOT finish here; let supervisor handle failure\n\n        # Always return to supervisor unless specified\n        state.next_node = \"supervisor\"\n        return state\n\n\n__all__ = [\"SupervisorNode\", \"WorkerNode\"]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.148292",
  "last_updated": "2026-01-04T05:35:58.409809"
}