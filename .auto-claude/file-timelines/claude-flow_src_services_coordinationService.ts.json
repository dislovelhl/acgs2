{
  "file_path": "claude-flow/src/services/coordinationService.ts",
  "main_branch_history": [],
  "task_views": {
    "059-add-jsdoc-coverage-for-claude-flow-typescript-serv": {
      "task_id": "059-add-jsdoc-coverage-for-claude-flow-typescript-serv",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "import { spawn } from \"child_process\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport logger from \"../utils/logger.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport interface CoordinationTaskFilters {\n  priority?: string;\n  agentType?: string;\n  status?: string;\n}\n\nexport interface CoordinationTaskExecution {\n  taskId: string;\n  dryRun?: boolean;\n  force?: boolean;\n  parallel?: boolean;\n}\n\nexport interface CoordinationStatusOptions {\n  taskId?: string;\n  verbose?: boolean;\n  progress?: boolean;\n}\n\nexport interface CoordinationReportOptions {\n  format: string;\n  period: number;\n  includeCompleted?: boolean;\n}\n\n// Type definitions for coordination tasks\nexport interface CoordinationTask {\n  id: string;\n  name?: string;\n  priority?: string;\n  status?: string;\n  agentType?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface TaskExecutionResult {\n  success: boolean;\n  taskId: string;\n  status?: string;\n  executionTime?: number;\n  agentAssigned?: string;\n  details?: Record<string, unknown>;\n  error?: string;\n}\n\nexport interface CoordinationStatus {\n  activeTasks?: number;\n  completedTasks?: number;\n  pendingTasks?: number;\n  agentStatuses?: Record<string, string>;\n  lastUpdate?: string;\n}\n\nexport interface CoordinationReport {\n  period: number;\n  format: string;\n  summary?: {\n    totalTasks: number;\n    completedTasks: number;\n    failedTasks: number;\n  };\n  details?: CoordinationTask[];\n}\n\n// Script result type for internal use\ninterface ScriptResult {\n  success: boolean;\n  tasks?: CoordinationTask[];\n  status?: CoordinationStatus;\n  report?: CoordinationReport;\n  executionTime?: number;\n  agentAssigned?: string;\n  details?: Record<string, unknown>;\n  error?: string;\n}\n\nexport async function listCoordinationTasks(\n  filters: CoordinationTaskFilters = {}\n): Promise<CoordinationTask[]> {\n  try {\n    const args = [\"list\"];\n    if (filters.priority) args.push(\"--priority\", filters.priority);\n    if (filters.agentType) args.push(\"--agent-type\", filters.agentType);\n    if (filters.status) args.push(\"--status\", filters.status);\n\n    const result = await runCoordinationScript(args);\n\n    if (result.success) {\n      return result.tasks || [];\n    } else if (result.error) {\n      logger.warn({ error: result.error }, \"Failed to list coordination tasks\");\n      return [];\n    } else {\n      logger.warn(\"Failed to list coordination tasks with unknown error\");\n      return [];\n    }\n  } catch (error) {\n    logger.error({ error }, \"Error listing coordination tasks\");\n    return [];\n  }\n}\n\nexport async function executeCoordinationTask(\n  options: CoordinationTaskExecution\n): Promise<TaskExecutionResult> {\n  try {\n    const args = [\"execute\", options.taskId];\n    if (options.dryRun) args.push(\"--dry-run\");\n    if (options.force) args.push(\"--force\");\n    if (options.parallel) args.push(\"--parallel\");\n\n    const result = await runCoordinationScript(args);\n\n    if (result.success) {\n      return {\n        success: true,\n        taskId: options.taskId,\n        status:\n          typeof result.status === \"object\"\n            ? \"completed\"\n            : (result.status as string) || \"completed\",\n        executionTime: result.executionTime,\n        agentAssigned: result.agentAssigned,\n        details: result.details,\n      };\n    } else {\n      logger.error(\n        { error: result.error, taskId: options.taskId },\n        \"Failed to execute coordination task\"\n      );\n      return {\n        success: false,\n        taskId: options.taskId,\n        error: result.error,\n        details: result.details,\n      };\n    }\n  } catch (error) {\n    logger.error(\n      { error, taskId: options.taskId },\n      \"Error executing coordination task\"\n    );\n    return {\n      success: false,\n      taskId: options.taskId,\n      error: error instanceof Error ? error.message : \"Unknown error occurred\",\n    };\n  }\n}\n\nexport async function getCoordinationStatus(\n  options: CoordinationStatusOptions = {}\n): Promise<CoordinationStatus | CoordinationTask[]> {\n  try {\n    const args = [\"status\"];\n    if (options.taskId) args.push(\"--task-id\", options.taskId);\n    if (options.verbose) args.push(\"--verbose\");\n    if (options.progress) args.push(\"--progress\");\n\n    const result = await runCoordinationScript(args);\n\n    if (result.success) {\n      return result.status || result.tasks || {};\n    } else if (result.error) {\n      logger.warn({ error: result.error }, \"Failed to get coordination status\");\n      return {};\n    } else {\n      logger.warn(\"Failed to get coordination status with unknown error\");\n      return {};\n    }\n  } catch (error) {\n    logger.error({ error }, \"Error getting coordination status\");\n    return {};\n  }\n}\n\nexport async function generateCoordinationReport(\n  options: CoordinationReportOptions\n): Promise<CoordinationReport> {\n  try {\n    const args = [\n      \"report\",\n      \"--format\",\n      options.format,\n      \"--period\",\n      options.period.toString(),\n    ];\n    if (options.includeCompleted) args.push(\"--include-completed\");\n\n    const result = await runCoordinationScript(args);\n\n    if (result.success) {\n      return (\n        result.report || { period: options.period, format: options.format }\n      );\n    } else {\n      throw new Error(result.error || \"Failed to generate report\");\n    }\n  } catch (error) {\n    throw new Error(\n      error instanceof Error\n        ? error.message\n        : \"Failed to generate coordination report\"\n    );\n  }\n}\n\nasync function runCoordinationScript(args: string[]): Promise<ScriptResult> {\n  return new Promise((resolve, reject) => {\n    // Path to the Python coordination script\n    let scriptPath = path.join(__dirname, \"coordinationManager.py\");\n    if (!require(\"fs\").existsSync(scriptPath)) {\n      // Try the src path from dist\n      scriptPath = path.join(\n        __dirname,\n        \"../../src/services/coordinationManager.py\"\n      );\n    }\n\n    const pythonProcess = spawn(\"python3\", [scriptPath, ...args], {\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n      cwd: path.dirname(scriptPath),\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n\n    pythonProcess.stdout.on(\"data\", (data) => {\n      stdout += data.toString();\n    });\n\n    pythonProcess.stderr.on(\"data\", (data) => {\n      stderr += data.toString();\n    });\n\n    pythonProcess.on(\"close\", (code) => {\n      if (code === 0) {\n        try {\n          const result = JSON.parse(stdout.trim());\n          resolve(result);\n        } catch (e) {\n          reject(new Error(`Failed to parse Python output: ${stdout}`));\n        }\n      } else {\n        reject(new Error(`Python script failed with code ${code}: ${stderr}`));\n      }\n    });\n\n    pythonProcess.on(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n",
        "timestamp": "2026-01-04T05:35:52.969195"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Add JSDoc coverage for claude-flow TypeScript service public exports",
        "description": "Add comprehensive JSDoc documentation to the 45 exported functions/classes across 17 TypeScript files in the claude-flow CLI tool to improve API documentation for enterprise users",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T05:35:53.054007",
  "last_updated": "2026-01-04T05:35:53.056266"
}