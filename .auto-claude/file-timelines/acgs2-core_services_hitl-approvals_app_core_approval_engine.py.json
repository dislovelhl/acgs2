{
  "file_path": "acgs2-core/services/hitl-approvals/app/core/approval_engine.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nHITL Approval Chain Engine\n\nOrchestrates approval workflows with role-based routing, escalation tracking,\nand integration with notification providers.\n\nPattern from: acgs2-core/enhanced_agent_bus/deliberation_layer/hitl_manager.py\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import Callable, Dict, List, Optional\n\nfrom acgs2_core.shared.types import ErrorDetails, JSONDict\n\nfrom app.config import settings\nfrom app.models import (\n    ApprovalChain,\n    ApprovalDecision,\n    ApprovalLevel,\n    ApprovalPriority,\n    ApprovalRequest,\n    ApprovalStatus,\n    AuditEvent,\n    EscalationPolicy,\n    NotificationPayload,\n)\nfrom app.notifications.base import NotificationProvider, NotificationResult, NotificationStatus\nfrom app.notifications.retry import RetryableNotificationSender\n\nlogger = logging.getLogger(__name__)\n\n\n# =============================================================================\n# Notification Manager\n# =============================================================================\n\n\nclass NotificationManager:\n    \"\"\"\n    Manages notification providers and dispatches notifications.\n\n    Handles:\n    - Provider initialization and health checking\n    - Channel-based notification routing\n    - Retry logic with exponential backoff\n    - PagerDuty integration for critical/escalated approvals\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the NotificationManager.\"\"\"\n        self._providers: Dict[str, NotificationProvider] = {}\n        self._sender = RetryableNotificationSender()\n        self._initialized = False\n\n    async def initialize(self) -> None:\n        \"\"\"\n        Initialize all configured notification providers.\n\n        Loads providers based on settings configuration and validates\n        connectivity via health checks.\n        \"\"\"\n        if self._initialized:\n            return\n\n        logger.info(\"Initializing notification providers...\")\n\n        # Import providers here to avoid circular imports\n        from app.notifications.pagerduty import PagerDutyProvider\n        from app.notifications.slack import SlackProvider\n        from app.notifications.teams import TeamsProvider\n\n        # Initialize Slack provider\n        if settings.slack_webhook_url:\n            slack = SlackProvider()\n            if await slack.initialize():\n                self._providers[\"slack\"] = slack\n                logger.info(\"Slack provider initialized successfully\")\n            else:\n                logger.warning(\"Slack provider failed to initialize\")\n        else:\n            logger.info(\"Slack provider not configured (SLACK_WEBHOOK_URL not set)\")\n\n        # Initialize Teams provider\n        if settings.ms_teams_webhook_url:\n            teams = TeamsProvider()\n            if await teams.initialize():\n                self._providers[\"teams\"] = teams\n                logger.info(\"Teams provider initialized successfully\")\n            else:\n                logger.warning(\"Teams provider failed to initialize\")\n        else:\n            logger.info(\"Teams provider not configured (MS_TEAMS_WEBHOOK_URL not set)\")\n\n        # Initialize PagerDuty provider\n        if settings.pagerduty_routing_key:\n            pagerduty = PagerDutyProvider()\n            if await pagerduty.initialize():\n                self._providers[\"pagerduty\"] = pagerduty\n                logger.info(\"PagerDuty provider initialized successfully\")\n            else:\n                logger.warning(\"PagerDuty provider failed to initialize\")\n        else:\n            logger.info(\"PagerDuty provider not configured (PAGERDUTY_ROUTING_KEY not set)\")\n\n        self._initialized = True\n        logger.info(\n            f\"Notification manager initialized with {len(self._providers)} provider(s): \"\n            f\"{list(self._providers.keys())}\"\n        )\n\n    def get_provider(self, channel: str) -> Optional[NotificationProvider]:\n        \"\"\"\n        Get a provider by channel name.\n\n        Args:\n            channel: Channel name (slack, teams, pagerduty)\n\n        Returns:\n            The notification provider if available\n        \"\"\"\n        return self._providers.get(channel.lower())\n\n    @property\n    def available_providers(self) -> List[str]:\n        \"\"\"Get list of available provider names.\"\"\"\n        return list(self._providers.keys())\n\n    @property\n    def is_initialized(self) -> bool:\n        \"\"\"Check if the manager has been initialized.\"\"\"\n        return self._initialized\n\n    async def send_notification(\n        self, payload: NotificationPayload\n    ) -> Dict[str, NotificationResult]:\n        \"\"\"\n        Send a notification to all channels specified in the payload.\n\n        Args:\n            payload: The notification payload with target channels\n\n        Returns:\n            Dictionary mapping channel names to their results\n        \"\"\"\n        if not self._initialized:\n            logger.warning(\"NotificationManager not initialized, initializing now...\")\n            await self.initialize()\n\n        results: Dict[str, NotificationResult] = {}\n\n        # Determine which channels to notify\n        channels = payload.channels if payload.channels else [\"slack\"]\n\n        # Check if PagerDuty should be triggered for critical/escalated requests\n        is_critical = payload.priority == ApprovalPriority.CRITICAL\n        is_escalation = payload.metadata.get(\"is_escalation\", False)\n\n        if (is_critical or is_escalation) and \"pagerduty\" not in channels:\n            if self._providers.get(\"pagerduty\"):\n                channels = list(channels) + [\"pagerduty\"]\n                logger.info(\n                    f\"Adding PagerDuty to channels for critical/escalated request \"\n                    f\"{payload.request_id}\"\n                )\n\n        # Send to each channel\n        for channel in channels:\n            provider = self._providers.get(channel.lower())\n\n            if not provider:\n                logger.debug(f\"Provider not available for channel: {channel}\")\n                results[channel] = NotificationResult(\n                    status=NotificationStatus.INVALID_CONFIG,\n                    provider=channel,\n                    error=f\"Provider not configured: {channel}\",\n                )\n                continue\n\n            if not provider.is_enabled:\n                logger.warning(f\"Provider {channel} is disabled, skipping\")\n                results[channel] = NotificationResult(\n                    status=NotificationStatus.INVALID_CONFIG,\n                    provider=channel,\n                    error=f\"Provider disabled: {channel}\",\n                )\n                continue\n\n            try:\n                # Use retry sender for reliable delivery\n                result = await self._sender.send(provider, payload)\n                results[channel] = result\n\n                if result.is_success:\n                    logger.info(f\"Notification sent via {channel} for request {payload.request_id}\")\n                else:\n                    logger.warning(\n                        f\"Notification failed via {channel} for request \"\n                        f\"{payload.request_id}: {result.error}\"\n                    )\n\n            except Exception as e:\n                logger.error(\n                    f\"Unexpected error sending notification via {channel} \"\n                    f\"for request {payload.request_id}: {e}\"\n                )\n                results[channel] = NotificationResult(\n                    status=NotificationStatus.FAILED,\n                    provider=channel,\n                    error=str(e),\n                )\n\n        return results\n\n    async def health_check(self) -> Dict[str, bool]:\n        \"\"\"\n        Check health of all providers.\n\n        Returns:\n            Dictionary mapping provider names to their health status\n        \"\"\"\n        health_status: Dict[str, bool] = {}\n\n        for name, provider in self._providers.items():\n            try:\n                is_healthy = await provider.health_check()\n                health_status[name] = is_healthy\n            except Exception as e:\n                logger.error(f\"Health check failed for {name}: {e}\")\n                health_status[name] = False\n\n        return health_status\n\n    def get_statistics(self) -> JSONDict:\n        \"\"\"\n        Get statistics about the notification manager.\n\n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        return {\n            \"initialized\": self._initialized,\n            \"providers_count\": len(self._providers),\n            \"providers\": {\n                name: {\n                    \"enabled\": provider.is_enabled,\n                    \"healthy\": provider.is_healthy,\n                }\n                for name, provider in self._providers.items()\n            },\n        }\n\n\n# Global notification manager instance\n_notification_manager: Optional[NotificationManager] = None\n\n\ndef get_notification_manager() -> NotificationManager:\n    \"\"\"\n    Get the global NotificationManager instance.\n\n    Returns:\n        The singleton NotificationManager instance\n    \"\"\"\n    global _notification_manager\n    if _notification_manager is None:\n        _notification_manager = NotificationManager()\n    return _notification_manager\n\n\nasync def initialize_notification_manager() -> NotificationManager:\n    \"\"\"\n    Initialize and return the global NotificationManager.\n\n    Returns:\n        The initialized NotificationManager instance\n    \"\"\"\n    manager = get_notification_manager()\n    await manager.initialize()\n    return manager\n\n\ndef reset_notification_manager() -> None:\n    \"\"\"\n    Reset the global NotificationManager instance.\n\n    Used primarily for test isolation.\n    \"\"\"\n    global _notification_manager\n    _notification_manager = None\n\n\nclass ApprovalEngineError(Exception):\n    \"\"\"Base exception for approval engine errors.\"\"\"\n\n    pass\n\n\nclass ApprovalNotFoundError(ApprovalEngineError):\n    \"\"\"Raised when an approval request is not found.\"\"\"\n\n    pass\n\n\nclass ChainNotFoundError(ApprovalEngineError):\n    \"\"\"Raised when an approval chain is not found.\"\"\"\n\n    pass\n\n\nclass ApprovalStateError(ApprovalEngineError):\n    \"\"\"Raised when an operation is invalid for the current state.\"\"\"\n\n    pass\n\n\nclass ApprovalEngine:\n    \"\"\"\n    Manages the approval chain lifecycle.\n\n    Handles:\n    - Creating and tracking approval requests\n    - Routing requests through approval chains\n    - Processing approval/rejection decisions\n    - Triggering escalation when needed\n    - Emitting audit events for all state changes\n    \"\"\"\n\n    def __init__(\n        self,\n        approval_chains: Optional[Dict[str, ApprovalChain]] = None,\n        escalation_policies: Optional[Dict[str, EscalationPolicy]] = None,\n        notification_callback: Optional[Callable[[NotificationPayload], None]] = None,\n        audit_callback: Optional[Callable[[AuditEvent], None]] = None,\n    ):\n        \"\"\"\n        Initialize the Approval Engine.\n\n        Args:\n            approval_chains: Pre-loaded approval chain definitions\n            escalation_policies: Pre-loaded escalation policies\n            notification_callback: Async function to call when notifications are needed\n            audit_callback: Async function to call for audit logging\n        \"\"\"\n        self._approval_chains: Dict[str, ApprovalChain] = approval_chains or {}\n        self._escalation_policies: Dict[str, EscalationPolicy] = escalation_policies or {}\n        self._pending_requests: Dict[str, ApprovalRequest] = {}\n        self._decision_history: Dict[str, List[ApprovalDecision]] = {}\n        self._notification_callback = notification_callback\n        self._audit_callback = audit_callback\n        self._lock = asyncio.Lock()\n\n        logger.info(\"ApprovalEngine initialized\")\n\n    # =========================================================================\n    # Approval Chain Management\n    # =========================================================================\n\n    def register_chain(self, chain: ApprovalChain) -> None:\n        \"\"\"\n        Register an approval chain definition.\n\n        Args:\n            chain: The approval chain to register\n        \"\"\"\n        self._approval_chains[chain.chain_id] = chain\n        logger.info(f\"Registered approval chain: {chain.chain_id} ({chain.name})\")\n\n    def get_chain(self, chain_id: str) -> Optional[ApprovalChain]:\n        \"\"\"\n        Get an approval chain by ID.\n\n        Args:\n            chain_id: The chain identifier\n\n        Returns:\n            The approval chain if found, None otherwise\n        \"\"\"\n        return self._approval_chains.get(chain_id)\n\n    def list_chains(self) -> List[ApprovalChain]:\n        \"\"\"\n        List all registered approval chains.\n\n        Returns:\n            List of all approval chains\n        \"\"\"\n        return list(self._approval_chains.values())\n\n    # =========================================================================\n    # Escalation Policy Management\n    # =========================================================================\n\n    def register_escalation_policy(self, policy: EscalationPolicy) -> None:\n        \"\"\"\n        Register an escalation policy.\n\n        Args:\n            policy: The escalation policy to register\n        \"\"\"\n        self._escalation_policies[policy.policy_id] = policy\n        logger.info(f\"Registered escalation policy: {policy.policy_id} ({policy.name})\")\n\n    def get_escalation_policy_for_priority(\n        self, priority: ApprovalPriority\n    ) -> Optional[EscalationPolicy]:\n        \"\"\"\n        Get the escalation policy for a given priority level.\n\n        Args:\n            priority: The priority level\n\n        Returns:\n            The matching escalation policy if found\n        \"\"\"\n        for policy in self._escalation_policies.values():\n            if policy.priority == priority:\n                return policy\n        return None\n\n    def get_timeout_for_request(self, request: ApprovalRequest) -> int:\n        \"\"\"\n        Get the timeout in minutes for a request based on its priority.\n\n        Args:\n            request: The approval request\n\n        Returns:\n            Timeout in minutes\n        \"\"\"\n        # Check for custom timeout in chain level\n        chain = self.get_chain(request.chain_id)\n        if chain:\n            current_level = self._get_level_from_chain(chain, request.current_level)\n            if current_level and current_level.timeout_minutes:\n                return current_level.timeout_minutes\n\n        # Check for priority-based escalation policy\n        policy = self.get_escalation_policy_for_priority(request.priority)\n        if policy:\n            return policy.timeout_minutes\n\n        # Fall back to settings-based defaults\n        if request.priority == ApprovalPriority.CRITICAL:\n            return settings.critical_escalation_timeout_minutes\n        return settings.default_escalation_timeout_minutes\n\n    # =========================================================================\n    # Approval Request Lifecycle\n    # =========================================================================\n\n    async def create_request(\n        self,\n        chain_id: str,\n        decision_type: str,\n        decision_context: JSONDict,\n        impact_level: str,\n        requestor_id: str,\n        requestor_service: Optional[str] = None,\n        priority: ApprovalPriority = ApprovalPriority.MEDIUM,\n    ) -> ApprovalRequest:\n        \"\"\"\n        Create a new approval request.\n\n        Args:\n            chain_id: The approval chain to use\n            decision_type: Type of decision requiring approval\n            decision_context: Context data for the decision\n            impact_level: Impact level (low, medium, high, critical)\n            requestor_id: ID of the requestor\n            requestor_service: Optional service that initiated the request\n            priority: Priority level for the request\n\n        Returns:\n            The created approval request\n\n        Raises:\n            ChainNotFoundError: If the specified chain doesn't exist\n        \"\"\"\n        chain = self.get_chain(chain_id)\n        if not chain:\n            raise ChainNotFoundError(f\"Approval chain not found: {chain_id}\")\n\n        request_id = str(uuid.uuid4())\n        now = datetime.now(timezone.utc)\n\n        request = ApprovalRequest(\n            request_id=request_id,\n            chain_id=chain_id,\n            current_level=1,\n            status=ApprovalStatus.PENDING,\n            priority=priority,\n            decision_type=decision_type,\n            decision_context=decision_context,\n            impact_level=impact_level,\n            requestor_id=requestor_id,\n            requestor_service=requestor_service,\n            created_at=now,\n            updated_at=now,\n            escalation_count=0,\n            escalation_history=[],\n        )\n\n        async with self._lock:\n            self._pending_requests[request_id] = request\n            self._decision_history[request_id] = []\n\n        logger.info(\n            f\"Created approval request {request_id} \"\n            f\"(chain={chain_id}, type={decision_type}, priority={priority.value})\"\n        )\n\n        # Record audit event\n        await self._record_audit_event(\n            request_id=request_id,\n            event_type=\"request_created\",\n            actor_id=requestor_id,\n            details={\n                \"chain_id\": chain_id,\n                \"decision_type\": decision_type,\n                \"impact_level\": impact_level,\n                \"priority\": priority.value,\n            },\n            new_state=ApprovalStatus.PENDING.value,\n        )\n\n        # Send notification to first-level approvers\n        await self._notify_approvers(request, chain)\n\n        return request\n\n    async def get_request(self, request_id: str) -> Optional[ApprovalRequest]:\n        \"\"\"\n        Get an approval request by ID.\n\n        Args:\n            request_id: The request identifier\n\n        Returns:\n            The approval request if found\n        \"\"\"\n        return self._pending_requests.get(request_id)\n\n    async def list_pending_requests(\n        self,\n        chain_id: Optional[str] = None,\n        priority: Optional[ApprovalPriority] = None,\n        status: Optional[ApprovalStatus] = None,\n    ) -> List[ApprovalRequest]:\n        \"\"\"\n        List pending approval requests with optional filters.\n\n        Args:\n            chain_id: Filter by chain ID\n            priority: Filter by priority level\n            status: Filter by status (defaults to PENDING if not specified)\n\n        Returns:\n            List of matching approval requests\n        \"\"\"\n        results = []\n        for request in self._pending_requests.values():\n            if chain_id and request.chain_id != chain_id:\n                continue\n            if priority and request.priority != priority:\n                continue\n            if status and request.status != status:\n                continue\n            results.append(request)\n\n        return sorted(results, key=lambda r: r.created_at)\n\n    # =========================================================================\n    # Approval Decision Processing\n    # =========================================================================\n\n    async def process_decision(\n        self,\n        request_id: str,\n        approver_id: str,\n        approver_role: str,\n        decision: ApprovalStatus,\n        rationale: Optional[str] = None,\n        conditions: Optional[str] = None,\n    ) -> ApprovalRequest:\n        \"\"\"\n        Process an approval or rejection decision.\n\n        Args:\n            request_id: The approval request ID\n            approver_id: ID of the user making the decision\n            approver_role: Role of the approver\n            decision: APPROVED or REJECTED\n            rationale: Reason for the decision\n            conditions: Any conditions attached to approval\n\n        Returns:\n            The updated approval request\n\n        Raises:\n            ApprovalNotFoundError: If request not found\n            ApprovalStateError: If request is not in a valid state for decisions\n        \"\"\"\n        async with self._lock:\n            request = self._pending_requests.get(request_id)\n            if not request:\n                raise ApprovalNotFoundError(f\"Approval request not found: {request_id}\")\n\n            if request.status not in (ApprovalStatus.PENDING, ApprovalStatus.ESCALATED):\n                raise ApprovalStateError(\n                    f\"Cannot process decision for request in state: {request.status.value}\"\n                )\n\n            # Validate approver has authority for current level\n            chain = self.get_chain(request.chain_id)\n            if not self._can_approve(chain, request.current_level, approver_role):\n                raise ApprovalStateError(\n                    f\"Approver with role '{approver_role}' cannot approve \"\n                    f\"at level {request.current_level}\"\n                )\n\n            previous_state = request.status.value\n            now = datetime.now(timezone.utc)\n\n            # Record the decision\n            approval_decision = ApprovalDecision(\n                request_id=request_id,\n                approver_id=approver_id,\n                approver_role=approver_role,\n                decision=decision,\n                rationale=rationale,\n                conditions=conditions,\n                decided_at=now,\n            )\n            self._decision_history[request_id].append(approval_decision)\n\n            # Handle based on decision type\n            if decision == ApprovalStatus.REJECTED:\n                request.status = ApprovalStatus.REJECTED\n                request.resolved_at = now\n                request.updated_at = now\n\n                logger.info(f\"Approval request {request_id} REJECTED by {approver_id}\")\n\n            elif decision == ApprovalStatus.APPROVED:\n                # Check if this is the final level\n                if chain and request.current_level >= len(chain.levels):\n                    # Final approval\n                    request.status = ApprovalStatus.APPROVED\n                    request.resolved_at = now\n                    logger.info(f\"Approval request {request_id} APPROVED (final) by {approver_id}\")\n                else:\n                    # Route to next level\n                    request.current_level += 1\n                    request.status = ApprovalStatus.PENDING\n                    prev_level = request.current_level - 1\n                    logger.info(\n                        f\"Approval request {request_id} approved at level {prev_level}, \"\n                        f\"routed to level {request.current_level}\"\n                    )\n                    # Notify next level approvers\n                    await self._notify_approvers(request, chain)\n\n                request.updated_at = now\n\n        # Record audit event\n        await self._record_audit_event(\n            request_id=request_id,\n            event_type=f\"decision_{decision.value}\",\n            actor_id=approver_id,\n            actor_role=approver_role,\n            details={\n                \"rationale\": rationale,\n                \"conditions\": conditions,\n                \"level\": request.current_level,\n            },\n            previous_state=previous_state,\n            new_state=request.status.value,\n        )\n\n        return request\n\n    # =========================================================================\n    # Escalation Handling\n    # =========================================================================\n\n    async def escalate_request(self, request_id: str, reason: str = \"timeout\") -> ApprovalRequest:\n        \"\"\"\n        Escalate a request to the next approval level.\n\n        Args:\n            request_id: The approval request ID\n            reason: Reason for escalation (default: timeout)\n\n        Returns:\n            The updated approval request\n\n        Raises:\n            ApprovalNotFoundError: If request not found\n            ApprovalStateError: If request cannot be escalated\n        \"\"\"\n        async with self._lock:\n            request = self._pending_requests.get(request_id)\n            if not request:\n                raise ApprovalNotFoundError(f\"Approval request not found: {request_id}\")\n\n            if request.status not in (ApprovalStatus.PENDING, ApprovalStatus.ESCALATED):\n                raise ApprovalStateError(\n                    f\"Cannot escalate request in state: {request.status.value}\"\n                )\n\n            chain = self.get_chain(request.chain_id)\n            policy = self.get_escalation_policy_for_priority(request.priority)\n\n            # Check escalation limits\n            max_escalations = policy.max_escalations if policy else 3\n            if request.escalation_count >= max_escalations:\n                # Use fallback approver if available\n                if chain and chain.fallback_approver:\n                    logger.warning(\n                        f\"Request {request_id} exceeded max escalations, \"\n                        f\"routing to fallback approver: {chain.fallback_approver}\"\n                    )\n                else:\n                    raise ApprovalStateError(\n                        f\"Request {request_id} has exceeded maximum escalations ({max_escalations})\"\n                    )\n\n            previous_state = request.status.value\n            now = datetime.now(timezone.utc)\n\n            # Move to next level if available\n            if chain and request.current_level < len(chain.levels):\n                request.current_level += 1\n\n            # Update request state\n            request.status = ApprovalStatus.ESCALATED\n            request.escalated_at = now\n            request.updated_at = now\n            request.escalation_count += 1\n            request.escalation_history.append(\n                {\n                    \"level\": request.current_level,\n                    \"reason\": reason,\n                    \"timestamp\": now.isoformat(),\n                    \"escalation_number\": request.escalation_count,\n                }\n            )\n\n            logger.warning(\n                f\"Approval request {request_id} ESCALATED to level {request.current_level} \"\n                f\"(reason: {reason}, count: {request.escalation_count})\"\n            )\n\n        # Record audit event\n        await self._record_audit_event(\n            request_id=request_id,\n            event_type=\"escalated\",\n            actor_id=\"system\",\n            details={\n                \"reason\": reason,\n                \"escalation_count\": request.escalation_count,\n                \"new_level\": request.current_level,\n            },\n            previous_state=previous_state,\n            new_state=request.status.value,\n        )\n\n        # Notify new level approvers\n        if chain:\n            await self._notify_approvers(request, chain, is_escalation=True)\n\n        return request\n\n    async def cancel_request(\n        self, request_id: str, cancelled_by: str, reason: Optional[str] = None\n    ) -> ApprovalRequest:\n        \"\"\"\n        Cancel a pending approval request.\n\n        Args:\n            request_id: The approval request ID\n            cancelled_by: ID of the user cancelling the request\n            reason: Optional reason for cancellation\n\n        Returns:\n            The updated approval request\n\n        Raises:\n            ApprovalNotFoundError: If request not found\n            ApprovalStateError: If request cannot be cancelled\n        \"\"\"\n        async with self._lock:\n            request = self._pending_requests.get(request_id)\n            if not request:\n                raise ApprovalNotFoundError(f\"Approval request not found: {request_id}\")\n\n            if request.status not in (ApprovalStatus.PENDING, ApprovalStatus.ESCALATED):\n                raise ApprovalStateError(f\"Cannot cancel request in state: {request.status.value}\")\n\n            previous_state = request.status.value\n            now = datetime.now(timezone.utc)\n\n            request.status = ApprovalStatus.CANCELLED\n            request.resolved_at = now\n            request.updated_at = now\n\n            logger.info(f\"Approval request {request_id} CANCELLED by {cancelled_by}\")\n\n        # Record audit event\n        await self._record_audit_event(\n            request_id=request_id,\n            event_type=\"cancelled\",\n            actor_id=cancelled_by,\n            details={\"reason\": reason},\n            previous_state=previous_state,\n            new_state=request.status.value,\n        )\n\n        return request\n\n    # =========================================================================\n    # Routing Logic\n    # =========================================================================\n\n    def _get_level_from_chain(\n        self, chain: ApprovalChain, level_number: int\n    ) -> Optional[ApprovalLevel]:\n        \"\"\"\n        Get a specific level from an approval chain.\n\n        Args:\n            chain: The approval chain\n            level_number: 1-based level number\n\n        Returns:\n            The approval level if found\n        \"\"\"\n        if not chain or level_number < 1 or level_number > len(chain.levels):\n            return None\n        return chain.levels[level_number - 1]\n\n    def _can_approve(\n        self,\n        chain: Optional[ApprovalChain],\n        level_number: int,\n        approver_role: str,\n    ) -> bool:\n        \"\"\"\n        Check if an approver with the given role can approve at the specified level.\n\n        Args:\n            chain: The approval chain\n            level_number: Current level number\n            approver_role: Role of the approver\n\n        Returns:\n            True if the approver can approve at this level\n        \"\"\"\n        if not chain:\n            return True  # No chain means any approver can approve\n\n        level = self._get_level_from_chain(chain, level_number)\n        if not level:\n            return False\n\n        return level.role == approver_role or approver_role == \"admin\"\n\n    def get_current_approvers(self, request: ApprovalRequest) -> List[str]:\n        \"\"\"\n        Get the list of approvers for the current level of a request.\n\n        Args:\n            request: The approval request\n\n        Returns:\n            List of approver IDs\n        \"\"\"\n        chain = self.get_chain(request.chain_id)\n        if not chain:\n            return []\n\n        level = self._get_level_from_chain(chain, request.current_level)\n        if not level:\n            # Check for fallback approver\n            if chain.fallback_approver:\n                return [chain.fallback_approver]\n            return []\n\n        return level.approvers\n\n    def get_required_role(self, request: ApprovalRequest) -> Optional[str]:\n        \"\"\"\n        Get the required role for the current level of a request.\n\n        Args:\n            request: The approval request\n\n        Returns:\n            The required role name, or None if not specified\n        \"\"\"\n        chain = self.get_chain(request.chain_id)\n        if not chain:\n            return None\n\n        level = self._get_level_from_chain(chain, request.current_level)\n        if not level:\n            return None\n\n        return level.role\n\n    # =========================================================================\n    # Notification Integration\n    # =========================================================================\n\n    async def _notify_approvers(\n        self,\n        request: ApprovalRequest,\n        chain: Optional[ApprovalChain],\n        is_escalation: bool = False,\n    ) -> None:\n        \"\"\"\n        Send notifications to approvers for a request.\n\n        Args:\n            request: The approval request\n            chain: The approval chain\n            is_escalation: Whether this is an escalation notification\n        \"\"\"\n        if not self._notification_callback:\n            logger.debug(f\"No notification callback configured for request {request.request_id}\")\n            return\n\n        approvers = self.get_current_approvers(request)\n        required_role = self.get_required_role(request)\n\n        # Build notification payload\n        title = \"Escalated Approval Required\" if is_escalation else \"Approval Required\"\n        message = (\n            f\"Decision type: {request.decision_type}\\n\"\n            f\"Impact level: {request.impact_level}\\n\"\n            f\"Priority: {request.priority.value}\\n\"\n            f\"Current level: {request.current_level}\"\n        )\n\n        if is_escalation:\n            message = f\"[ESCALATED - Level {request.current_level}]\\n{message}\"\n\n        payload = NotificationPayload(\n            request_id=request.request_id,\n            title=title,\n            message=message,\n            approval_url=f\"{settings.hitl_approvals_port}/approvals/{request.request_id}\",\n            priority=request.priority,\n            channels=[\"slack\", \"teams\"] if is_escalation else [\"slack\"],\n            recipients=approvers,\n            metadata={\n                \"chain_id\": request.chain_id,\n                \"chain_name\": chain.name if chain else None,\n                \"required_role\": required_role,\n                \"is_escalation\": is_escalation,\n                \"escalation_count\": request.escalation_count,\n            },\n        )\n\n        try:\n            await self._notification_callback(payload)\n            logger.info(\n                f\"Notification sent for request {request.request_id} \"\n                f\"to {len(approvers)} approvers\"\n            )\n        except Exception as e:\n            logger.error(f\"Failed to send notification for {request.request_id}: {e}\")\n\n    # =========================================================================\n    # Audit Integration\n    # =========================================================================\n\n    async def _record_audit_event(\n        self,\n        request_id: str,\n        event_type: str,\n        actor_id: str,\n        actor_role: Optional[str] = None,\n        details: Optional[ErrorDetails] = None,\n        previous_state: Optional[str] = None,\n        new_state: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Record an audit event for an approval action.\n\n        Args:\n            request_id: The approval request ID\n            event_type: Type of event\n            actor_id: ID of the actor\n            actor_role: Role of the actor\n            details: Additional event details\n            previous_state: State before the event\n            new_state: State after the event\n        \"\"\"\n        event = AuditEvent(\n            event_id=str(uuid.uuid4()),\n            event_type=event_type,\n            request_id=request_id,\n            actor_id=actor_id,\n            actor_role=actor_role,\n            timestamp=datetime.now(timezone.utc),\n            details=details or {},\n            previous_state=previous_state,\n            new_state=new_state,\n        )\n\n        if self._audit_callback:\n            try:\n                await self._audit_callback(event)\n            except Exception as e:\n                logger.error(f\"Failed to record audit event: {e}\")\n        else:\n            logger.debug(f\"Audit event recorded (no callback): {event.event_type}\")\n\n    # =========================================================================\n    # Statistics and Monitoring\n    # =========================================================================\n\n    def get_statistics(self) -> JSONDict:\n        \"\"\"\n        Get statistics about the approval engine.\n\n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        pending_count = sum(\n            1 for r in self._pending_requests.values() if r.status == ApprovalStatus.PENDING\n        )\n        escalated_count = sum(\n            1 for r in self._pending_requests.values() if r.status == ApprovalStatus.ESCALATED\n        )\n        approved_count = sum(\n            1 for r in self._pending_requests.values() if r.status == ApprovalStatus.APPROVED\n        )\n        rejected_count = sum(\n            1 for r in self._pending_requests.values() if r.status == ApprovalStatus.REJECTED\n        )\n\n        return {\n            \"total_requests\": len(self._pending_requests),\n            \"pending\": pending_count,\n            \"escalated\": escalated_count,\n            \"approved\": approved_count,\n            \"rejected\": rejected_count,\n            \"registered_chains\": len(self._approval_chains),\n            \"registered_policies\": len(self._escalation_policies),\n        }\n\n    def get_decision_history(self, request_id: str) -> List[ApprovalDecision]:\n        \"\"\"\n        Get the decision history for a request.\n\n        Args:\n            request_id: The approval request ID\n\n        Returns:\n            List of decisions made on the request\n        \"\"\"\n        return self._decision_history.get(request_id, [])\n\n\n# Global engine instance (singleton pattern)\n_approval_engine: Optional[ApprovalEngine] = None\n\n\ndef get_approval_engine() -> ApprovalEngine:\n    \"\"\"\n    Get the global ApprovalEngine instance.\n\n    Returns:\n        The singleton ApprovalEngine instance\n    \"\"\"\n    global _approval_engine\n    if _approval_engine is None:\n        _approval_engine = ApprovalEngine()\n    return _approval_engine\n\n\nasync def initialize_approval_engine(\n    wire_notifications: bool = True,\n) -> ApprovalEngine:\n    \"\"\"\n    Initialize and return the global ApprovalEngine with notification wiring.\n\n    This function sets up the approval engine with the notification manager\n    callback, enabling automatic notification dispatch when approvals are\n    created or escalated.\n\n    Args:\n        wire_notifications: Whether to wire the notification manager\n                           (default: True)\n\n    Returns:\n        The initialized ApprovalEngine instance\n\n    Example:\n        ```python\n        # In service startup\n        @app.on_event(\"startup\")\n        async def startup():\n            engine = await initialize_approval_engine()\n        ```\n    \"\"\"\n    global _approval_engine\n\n    # Initialize the notification manager first\n    notification_manager = get_notification_manager()\n    if wire_notifications and not notification_manager.is_initialized:\n        await notification_manager.initialize()\n\n    # Create the notification callback\n    async def notification_callback(payload: NotificationPayload) -> None:\n        \"\"\"Callback to send notifications via the NotificationManager.\"\"\"\n        results = await notification_manager.send_notification(payload)\n\n        # Log results summary\n        success_count = sum(1 for r in results.values() if r.is_success)\n        total_count = len(results)\n        logger.info(\n            f\"Notification sent for request {payload.request_id}: \"\n            f\"{success_count}/{total_count} channels succeeded\"\n        )\n\n    # Get or create the engine\n    if _approval_engine is None:\n        _approval_engine = ApprovalEngine(\n            notification_callback=notification_callback if wire_notifications else None\n        )\n    elif wire_notifications and _approval_engine._notification_callback is None:\n        # Update existing engine with notification callback\n        _approval_engine._notification_callback = notification_callback\n\n    logger.info(\n        f\"ApprovalEngine initialized \"\n        f\"(notifications={'wired' if wire_notifications else 'disabled'})\"\n    )\n\n    return _approval_engine\n\n\ndef reset_approval_engine() -> None:\n    \"\"\"\n    Reset the global ApprovalEngine instance.\n\n    Used primarily for test isolation.\n    \"\"\"\n    global _approval_engine\n    _approval_engine = None\n    reset_notification_manager()\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.282902",
  "last_updated": "2026-01-04T05:35:58.760260"
}