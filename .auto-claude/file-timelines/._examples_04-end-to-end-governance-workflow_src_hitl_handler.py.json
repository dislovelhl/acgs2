{
  "file_path": "./examples/04-end-to-end-governance-workflow/src/hitl_handler.py",
  "main_branch_history": [],
  "task_views": {
    "061-create-end-to-end-governance-workflow-examples-wit": {
      "task_id": "061-create-end-to-end-governance-workflow-examples-wit",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "#!/usr/bin/env python3\n\"\"\"\nHITL (Human-in-the-Loop) Handler Module for ACGS-2 Governance Workflow\n\nManages human approval workflow with simulated reviewers, timeouts, and escalation.\nThis module simulates the human review process for educational and demo purposes.\n\nUsage:\n    from src.hitl_handler import HITLHandler, HITLConfig\n\n    config = HITLConfig(\n        default_timeout=7200,\n        escalation_timeout=3600,\n        simulation_mode=True\n    )\n    handler = HITLHandler(config)\n\n    # Create approval request\n    request = handler.create_approval_request(\n        action_request={\"type\": \"deploy_model\", ...},\n        risk_score=0.85,\n        required_expertise=\"ml_safety_specialist\"\n    )\n\n    # Simulate review\n    decision = handler.simulate_review(request, \"reviewer-001\")\n\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport logging\nimport random\nimport time\nfrom dataclasses import dataclass\nfrom datetime import UTC, datetime, timedelta\nfrom uuid import UUID, uuid4\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\n# Custom exceptions for HITL handler errors\nclass HITLHandlerError(Exception):\n    \"\"\"Base exception for HITL handler errors\"\"\"\n\n    pass\n\n\nclass HITLTimeoutError(HITLHandlerError):\n    \"\"\"Raised when approval request times out\"\"\"\n\n    pass\n\n\nclass HITLRequestNotFoundError(HITLHandlerError):\n    \"\"\"Raised when approval request is not found\"\"\"\n\n    pass\n\n\n# Configuration dataclass\n@dataclass\nclass HITLConfig:\n    \"\"\"Configuration for HITL handler\"\"\"\n\n    default_timeout: int = 7200  # 2 hours in seconds\n    escalation_timeout: int = 3600  # 1 hour in seconds\n    simulation_mode: bool = True  # Use simulated reviewers\n    instant_demo_mode: bool = False  # Skip delays for demos\n\n\n# Approval request dataclass\n@dataclass\nclass ApprovalRequest:\n    \"\"\"Represents a human approval request\"\"\"\n\n    request_id: UUID\n    action_request: dict\n    risk_score: float\n    required_expertise: str\n    timeout_seconds: int\n    created_at: datetime\n    status: str = \"pending\"  # pending, approved, denied, timeout, escalated\n    escalation_to: str | None = None\n    priority: str = \"normal\"  # normal, medium, high, critical\n\n    def __post_init__(self):\n        \"\"\"Validate approval request fields\"\"\"\n        # Ensure created_at has timezone\n        if self.created_at.tzinfo is None:\n            self.created_at = self.created_at.replace(tzinfo=UTC)\n\n        # Validate status\n        valid_statuses = {\"pending\", \"approved\", \"denied\", \"timeout\", \"escalated\"}\n        if self.status not in valid_statuses:\n            raise ValueError(f\"Invalid status: {self.status}. Must be one of {valid_statuses}\")\n\n        # Validate risk score\n        if not 0.0 <= self.risk_score <= 1.0:\n            raise ValueError(f\"Invalid risk_score: {self.risk_score}. Must be between 0.0 and 1.0\")\n\n        # Validate timeout\n        if self.timeout_seconds <= 0:\n            raise ValueError(f\"Invalid timeout_seconds: {self.timeout_seconds}. Must be positive\")\n\n    def is_expired(self) -> bool:\n        \"\"\"Check if the approval request has expired\"\"\"\n        expiry_time = self.created_at + timedelta(seconds=self.timeout_seconds)\n        return datetime.now(UTC) > expiry_time\n\n    def time_remaining(self) -> int:\n        \"\"\"Get remaining time in seconds before timeout\"\"\"\n        expiry_time = self.created_at + timedelta(seconds=self.timeout_seconds)\n        remaining = (expiry_time - datetime.now(UTC)).total_seconds()\n        return max(0, int(remaining))\n\n\n# Reviewer decision dataclass\n@dataclass\nclass ReviewerDecision:\n    \"\"\"Represents a reviewer's decision on an approval request\"\"\"\n\n    approved: bool\n    reviewer_id: str\n    reviewer_role: str\n    decision_note: str\n    reviewed_at: datetime\n    review_duration_seconds: int\n    escalated: bool = False\n    escalated_to: str | None = None\n\n    def __post_init__(self):\n        \"\"\"Validate reviewer decision fields\"\"\"\n        # Ensure reviewed_at has timezone\n        if self.reviewed_at.tzinfo is None:\n            self.reviewed_at = self.reviewed_at.replace(tzinfo=UTC)\n\n        # Validate review duration\n        if self.review_duration_seconds < 0:\n            raise ValueError(\n                f\"Invalid review_duration_seconds: {self.review_duration_seconds}. Must be non-negative\"\n            )\n\n\n# Reviewer profile dataclass\n@dataclass\nclass ReviewerProfile:\n    \"\"\"Represents a reviewer's profile and expertise\"\"\"\n\n    reviewer_id: str\n    name: str\n    role: str\n    expertise: list[str]\n    approval_rate: float = 0.8  # Default 80% approval rate\n    avg_review_time: int = 30  # Default 30 seconds\n\n\n# HITL Handler class\nclass HITLHandler:\n    \"\"\"\n    Manages human-in-the-loop approval workflow with simulated reviewers.\n\n    This handler simulates the human review process for demonstration purposes.\n    In a production system, this would integrate with a real approval queue,\n    notification system, and human reviewer interface.\n\n    Features:\n    - Approval queue management\n    - Reviewer assignment based on expertise\n    - Simulated review with realistic timing and approval rates\n    - Timeout and escalation handling\n    - Request status tracking\n    \"\"\"\n\n    def __init__(self, config: HITLConfig):\n        \"\"\"\n        Initialize HITL handler with configuration.\n\n        Args:\n            config: HITLConfig configuration object\n        \"\"\"\n        self.config = config\n        self._approval_queue: dict[UUID, ApprovalRequest] = {}\n        self._reviewers = self._initialize_reviewers()\n        logger.info(\n            f\"HITLHandler initialized with {len(self._reviewers)} reviewers \"\n            f\"(simulation_mode={config.simulation_mode})\"\n        )\n\n    def _initialize_reviewers(self) -> dict[str, ReviewerProfile]:\n        \"\"\"\n        Initialize simulated reviewer profiles.\n\n        Returns:\n            Dictionary mapping reviewer roles to profiles\n        \"\"\"\n        reviewers = {\n            \"ml_safety_specialist\": ReviewerProfile(\n                reviewer_id=\"reviewer-ml-001\",\n                name=\"Dr. Sarah Chen\",\n                role=\"ml_safety_specialist\",\n                expertise=[\"deploy_model\", \"model_evaluation\", \"bias_testing\"],\n                approval_rate=0.75,\n                avg_review_time=45,\n            ),\n            \"data_protection_officer\": ReviewerProfile(\n                reviewer_id=\"reviewer-dpo-001\",\n                name=\"Michael Rodriguez\",\n                role=\"data_protection_officer\",\n                expertise=[\"access_pii\", \"data_privacy\", \"gdpr_compliance\"],\n                approval_rate=0.70,\n                avg_review_time=60,\n            ),\n            \"security_lead\": ReviewerProfile(\n                reviewer_id=\"reviewer-sec-001\",\n                name=\"Jennifer Wu\",\n                role=\"security_lead\",\n                expertise=[\"modify_config\", \"execute_code\", \"security_review\"],\n                approval_rate=0.65,\n                avg_review_time=50,\n            ),\n            \"senior_devops\": ReviewerProfile(\n                reviewer_id=\"reviewer-ops-001\",\n                name=\"David Kim\",\n                role=\"senior_devops\",\n                expertise=[\"delete_resource\", \"infrastructure\", \"deployment\"],\n                approval_rate=0.80,\n                avg_review_time=30,\n            ),\n        }\n        logger.debug(f\"Initialized {len(reviewers)} reviewer profiles\")\n        return reviewers\n\n    def create_approval_request(\n        self,\n        action_request: dict,\n        risk_score: float,\n        required_expertise: str,\n        timeout_seconds: int | None = None,\n        escalation_to: str | None = None,\n        priority: str = \"normal\",\n    ) -> ApprovalRequest:\n        \"\"\"\n        Create a new approval request and add it to the queue.\n\n        Args:\n            action_request: The action requiring approval\n            risk_score: Calculated risk score (0.0-1.0)\n            required_expertise: Required reviewer expertise\n            timeout_seconds: Timeout in seconds (default: from config)\n            escalation_to: Escalation target if timeout occurs\n            priority: Priority level (normal, medium, high, critical)\n\n        Returns:\n            ApprovalRequest object\n\n        Raises:\n            ValueError: If parameters are invalid\n        \"\"\"\n        if timeout_seconds is None:\n            timeout_seconds = self.config.default_timeout\n\n        request = ApprovalRequest(\n            request_id=uuid4(),\n            action_request=action_request,\n            risk_score=risk_score,\n            required_expertise=required_expertise,\n            timeout_seconds=timeout_seconds,\n            created_at=datetime.now(UTC),\n            status=\"pending\",\n            escalation_to=escalation_to,\n            priority=priority,\n        )\n\n        # Add to queue\n        self._approval_queue[request.request_id] = request\n\n        logger.info(\n            f\"Created approval request {request.request_id} \"\n            f\"(risk={risk_score:.2f}, expertise={required_expertise}, \"\n            f\"timeout={timeout_seconds}s, priority={priority})\"\n        )\n\n        return request\n\n    def assign_reviewer(self, request: ApprovalRequest) -> str:\n        \"\"\"\n        Assign a reviewer based on required expertise.\n\n        Args:\n            request: ApprovalRequest to assign\n\n        Returns:\n            Reviewer ID\n\n        Raises:\n            HITLHandlerError: If no suitable reviewer found\n        \"\"\"\n        # Find reviewer with matching expertise\n        reviewer = self._reviewers.get(request.required_expertise)\n\n        if not reviewer:\n            logger.warning(\n                f\"No reviewer found for expertise '{request.required_expertise}', \"\n                f\"assigning default senior_devops\"\n            )\n            reviewer = self._reviewers.get(\"senior_devops\")\n\n        if not reviewer:\n            raise HITLHandlerError(\n                f\"No reviewer available for expertise: {request.required_expertise}\"\n            )\n\n        logger.info(\n            f\"Assigned reviewer {reviewer.reviewer_id} ({reviewer.name}) \"\n            f\"to request {request.request_id}\"\n        )\n\n        return reviewer.reviewer_id\n\n    def simulate_review(\n        self, request: ApprovalRequest, assigned_reviewer_id: str\n    ) -> ReviewerDecision:\n        \"\"\"\n        Simulate human review process for demonstration purposes.\n\n        The simulation applies risk-based approval rates:\n        - Low risk (0.7-0.79): 90% approval, 15-30s review\n        - High risk (0.8-0.89): 70% approval, 30-60s review\n        - Critical risk (0.9+): 40% approval, 60-120s review\n\n        Args:\n            request: ApprovalRequest to review\n            assigned_reviewer_id: ID of assigned reviewer\n\n        Returns:\n            ReviewerDecision object\n\n        Raises:\n            HITLRequestNotFoundError: If reviewer not found\n        \"\"\"\n        start_time = datetime.now(UTC)\n\n        # Find reviewer profile\n        reviewer = None\n        for r in self._reviewers.values():\n            if r.reviewer_id == assigned_reviewer_id:\n                reviewer = r\n                break\n\n        if not reviewer:\n            raise HITLRequestNotFoundError(f\"Reviewer not found: {assigned_reviewer_id}\")\n\n        # Determine approval based on risk score\n        if request.risk_score >= 0.9:\n            # Critical risk: 40% approval, 60-120s review\n            approval_probability = 0.40\n            min_review_time = 60\n            max_review_time = 120\n            risk_level = \"critical\"\n        elif request.risk_score >= 0.8:\n            # High risk: 70% approval, 30-60s review\n            approval_probability = 0.70\n            min_review_time = 30\n            max_review_time = 60\n            risk_level = \"high\"\n        else:\n            # Medium-high risk (0.7-0.8): 90% approval, 15-30s review\n            approval_probability = 0.90\n            min_review_time = 15\n            max_review_time = 30\n            risk_level = \"medium-high\"\n\n        # Simulate approval decision\n        approved = random.random() < approval_probability\n\n        # Simulate review time\n        if self.config.instant_demo_mode:\n            review_time = 0\n        else:\n            review_time = random.randint(min_review_time, max_review_time)\n            time.sleep(min(review_time, 2))  # Cap actual delay at 2s for demos\n\n        # Generate decision note\n        action_type = request.action_request.get(\"type\", \"unknown\")\n        environment = request.action_request.get(\"context\", {}).get(\"environment\", \"unknown\")\n\n        if approved:\n            decision_note = (\n                f\"Approved {action_type} in {environment} environment. \"\n                f\"Risk level: {risk_level} ({request.risk_score:.2f}). \"\n                f\"Verified compliance requirements and risk mitigation measures.\"\n            )\n        else:\n            denial_reasons = [\n                f\"Risk score too high ({request.risk_score:.2f}) for {environment} environment\",\n                \"Insufficient justification provided\",\n                \"Missing required compliance documentation\",\n                \"Change window violation - not during approved maintenance window\",\n            ]\n            decision_note = (\n                f\"Denied {action_type} in {environment} environment. \"\n                f\"Risk level: {risk_level} ({request.risk_score:.2f}). \"\n                f\"Reason: {random.choice(denial_reasons)}\"\n            )\n\n        reviewed_at = datetime.now(UTC)\n        duration = int((reviewed_at - start_time).total_seconds())\n\n        decision = ReviewerDecision(\n            approved=approved,\n            reviewer_id=reviewer.reviewer_id,\n            reviewer_role=reviewer.role,\n            decision_note=decision_note,\n            reviewed_at=reviewed_at,\n            review_duration_seconds=duration,\n        )\n\n        # Update request status\n        request.status = \"approved\" if approved else \"denied\"\n\n        logger.info(\n            f\"Review completed for request {request.request_id}: \"\n            f\"{'APPROVED' if approved else 'DENIED'} by {reviewer.name} \"\n            f\"({duration}s review)\"\n        )\n\n        return decision\n\n    def wait_for_approval(\n        self, request_id: UUID, timeout_seconds: int | None = None  # noqa: ARG002\n    ) -> ReviewerDecision:\n        \"\"\"\n        Wait for approval with timeout handling.\n\n        In simulation mode, this immediately processes the approval.\n        In production, this would poll for reviewer decision.\n\n        Args:\n            request_id: UUID of approval request\n            timeout_seconds: Override timeout (default: use request timeout).\n                Note: Currently unused in simulation mode, reserved for production polling.\n\n        Returns:\n            ReviewerDecision object\n\n        Raises:\n            HITLRequestNotFoundError: If request not found\n            HITLTimeoutError: If request times out\n        \"\"\"\n        # Get request from queue\n        request = self._approval_queue.get(request_id)\n        if not request:\n            raise HITLRequestNotFoundError(f\"Approval request not found: {request_id}\")\n\n        # Check if already processed\n        if request.status in {\"approved\", \"denied\"}:\n            logger.warning(f\"Request {request_id} already processed: {request.status}\")\n            # Return a synthetic decision\n            return ReviewerDecision(\n                approved=(request.status == \"approved\"),\n                reviewer_id=\"system\",\n                reviewer_role=\"system\",\n                decision_note=f\"Request already {request.status}\",\n                reviewed_at=datetime.now(UTC),\n                review_duration_seconds=0,\n            )\n\n        # Check if expired\n        if request.is_expired():\n            return self.handle_timeout(request)\n\n        # In simulation mode, immediately process the request\n        if self.config.simulation_mode:\n            reviewer_id = self.assign_reviewer(request)\n            return self.simulate_review(request, reviewer_id)\n\n        # In production mode, this would poll for decision\n        # For now, raise NotImplementedError\n        raise NotImplementedError(\n            \"Production approval polling not implemented. Use simulation_mode=True.\"\n        )\n\n    def handle_timeout(self, request: ApprovalRequest) -> ReviewerDecision:\n        \"\"\"\n        Handle approval request timeout with escalation.\n\n        Args:\n            request: Timed-out ApprovalRequest\n\n        Returns:\n            ReviewerDecision indicating timeout and escalation\n        \"\"\"\n        logger.warning(\n            f\"Approval request {request.request_id} timed out \"\n            f\"(timeout={request.timeout_seconds}s, risk={request.risk_score:.2f})\"\n        )\n\n        # Update status\n        request.status = \"timeout\"\n\n        # Check if escalation is configured\n        if request.escalation_to:\n            logger.info(\n                f\"Escalating request {request.request_id} to {request.escalation_to}\"\n            )\n            escalation_note = (\n                f\"Request timed out after {request.timeout_seconds}s. \"\n                f\"Escalating to {request.escalation_to} for urgent review.\"\n            )\n            decision = ReviewerDecision(\n                approved=False,\n                reviewer_id=\"system\",\n                reviewer_role=\"system\",\n                decision_note=escalation_note,\n                reviewed_at=datetime.now(UTC),\n                review_duration_seconds=request.timeout_seconds,\n                escalated=True,\n                escalated_to=request.escalation_to,\n            )\n            request.status = \"escalated\"\n        else:\n            # No escalation configured - deny by default\n            logger.warning(\n                f\"No escalation configured for request {request.request_id}, denying\"\n            )\n            decision = ReviewerDecision(\n                approved=False,\n                reviewer_id=\"system\",\n                reviewer_role=\"system\",\n                decision_note=(\n                    f\"Request denied due to timeout ({request.timeout_seconds}s). \"\n                    f\"No escalation path configured.\"\n                ),\n                reviewed_at=datetime.now(UTC),\n                review_duration_seconds=request.timeout_seconds,\n            )\n\n        return decision\n\n    def get_request_status(self, request_id: UUID) -> str | None:\n        \"\"\"\n        Get current status of approval request.\n\n        Args:\n            request_id: UUID of approval request\n\n        Returns:\n            Status string or None if not found\n        \"\"\"\n        request = self._approval_queue.get(request_id)\n        if not request:\n            return None\n        return request.status\n\n    def get_queue_statistics(self) -> dict:\n        \"\"\"\n        Get approval queue statistics.\n\n        Returns:\n            Dictionary with queue statistics\n        \"\"\"\n        total_requests = len(self._approval_queue)\n        pending = sum(1 for r in self._approval_queue.values() if r.status == \"pending\")\n        approved = sum(1 for r in self._approval_queue.values() if r.status == \"approved\")\n        denied = sum(1 for r in self._approval_queue.values() if r.status == \"denied\")\n        timeout = sum(1 for r in self._approval_queue.values() if r.status == \"timeout\")\n        escalated = sum(1 for r in self._approval_queue.values() if r.status == \"escalated\")\n\n        return {\n            \"total_requests\": total_requests,\n            \"pending\": pending,\n            \"approved\": approved,\n            \"denied\": denied,\n            \"timeout\": timeout,\n            \"escalated\": escalated,\n            \"approval_rate\": approved / total_requests if total_requests > 0 else 0.0,\n        }\n\n    def clear_queue(self):\n        \"\"\"Clear all requests from the approval queue (for testing)\"\"\"\n        cleared = len(self._approval_queue)\n        self._approval_queue.clear()\n        logger.info(f\"Cleared {cleared} requests from approval queue\")\n\n    def __enter__(self):\n        \"\"\"Context manager entry\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit\"\"\"\n        # Log final statistics\n        stats = self.get_queue_statistics()\n        logger.info(f\"HITLHandler closing with queue stats: {stats}\")\n        return False\n",
        "timestamp": "2026-01-04T05:35:49.744738"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "061-create-end-to-end-governance-workflow-examples-wit",
        "description": "Create comprehensive examples demonstrating complete governance workflows from policy creation through enforcement to audit logging, targeting Enterprise DevOps/MLOps engineers deploying AI systems. The examples will show: defining constitutional policies, enforcing them on agent actions, handling HITL approvals, and auditing decisions.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:07.563023",
  "last_updated": "2026-01-04T05:35:49.810151"
}