{
  "file_path": "acgs2-core/enhanced_agent_bus/deliberation_layer/workflows/constitutional_saga.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Constitutional Saga Workflow\nConstitutional Hash: cdd01ef066bc6cf2\n\nImplements the Saga pattern for distributed transactions with compensation.\nUsed for constitutional operations that require all-or-nothing semantics.\n\nSaga Pattern:\n    For each step:\n        1. Register compensation BEFORE executing\n        2. Execute the step (via activity)\n        3. On failure, run all compensations in reverse order (LIFO)\n\nExample: Multi-Service Constitutional Validation\n    1. Reserve validation capacity (compensation: release capacity)\n    2. Validate constitutional hash (compensation: log validation failure)\n    3. Evaluate OPA policies (compensation: revert policy state)\n    4. Record to audit trail (compensation: mark audit as failed)\n    5. Deliver to target (compensation: recall message)\n\nReference: https://temporal.io/blog/saga-pattern-made-easy\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom dataclasses import asdict, dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Awaitable, Callable, Dict, Generic, List, Optional, TypeVar, Union\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar(\"T\")\n\n\nclass SagaStatus(Enum):\n    \"\"\"Status of the saga execution.\"\"\"\n\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    COMPENSATING = \"compensating\"\n    COMPENSATED = \"compensated\"\n    FAILED = \"failed\"\n    PARTIALLY_COMPENSATED = \"partially_compensated\"\n\n\nclass StepStatus(Enum):\n    \"\"\"Status of individual saga step.\"\"\"\n\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    COMPENSATING = \"compensating\"\n    COMPENSATED = \"compensated\"\n    COMPENSATION_FAILED = \"compensation_failed\"\n\n\n@dataclass\nclass SagaCompensation:\n    \"\"\"\n    Represents a compensation action for a saga step.\n\n    Compensations are idempotent operations that undo the effects of a step.\n    They must be safe to call multiple times.\n\n    Attributes:\n        name: Unique name for the compensation\n        execute: Async function that performs the compensation\n        description: Human-readable description\n        idempotency_key: Key for deduplication\n    \"\"\"\n\n    name: str\n    execute: Callable[[Dict[str, Any]], Awaitable[bool]]\n    description: str = \"\"\n    idempotency_key: Optional[str] = None\n    max_retries: int = 3\n    retry_delay_seconds: float = 1.0\n\n\n@dataclass\nclass SagaStep(Generic[T]):\n    \"\"\"\n    Represents a single step in a saga.\n\n    Each step has:\n    - An execution function (activity)\n    - A compensation function (for rollback)\n    - Configuration for retries and timeouts\n\n    IMPORTANT: Register compensation BEFORE executing the step.\n\n    Attributes:\n        name: Unique step name\n        execute: Async function that performs the step\n        compensation: Compensation to run if this or later steps fail\n        description: Human-readable description\n    \"\"\"\n\n    name: str\n    execute: Callable[[Dict[str, Any]], Awaitable[T]]\n    compensation: Optional[SagaCompensation] = None\n    description: str = \"\"\n    timeout_seconds: int = 30\n    max_retries: int = 3\n    retry_delay_seconds: float = 1.0\n    is_optional: bool = False\n    requires_previous: bool = True\n\n    # Runtime state\n    status: StepStatus = StepStatus.PENDING\n    result: Optional[T] = None\n    error: Optional[str] = None\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    execution_time_ms: float = 0.0\n\n\n@dataclass\nclass SagaContext:\n    \"\"\"\n    Context passed through saga execution.\n\n    Accumulates results from each step and provides shared state.\n    \"\"\"\n\n    saga_id: str\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    tenant_id: Optional[str] = None\n    correlation_id: Optional[str] = None\n    step_results: Dict[str, Any] = field(default_factory=dict)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    started_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    errors: List[str] = field(default_factory=list)\n\n    def get_step_result(self, step_name: str) -> Optional[Any]:\n        \"\"\"Get result from a previous step.\"\"\"\n        return self.step_results.get(step_name)\n\n    def set_step_result(self, step_name: str, result: Any):\n        \"\"\"Store result from a step.\"\"\"\n        self.step_results[step_name] = result\n\n\n@dataclass\nclass SagaResult:\n    \"\"\"Result of saga execution.\"\"\"\n\n    saga_id: str\n    status: SagaStatus\n    completed_steps: List[str]\n    failed_step: Optional[str]\n    compensated_steps: List[str]\n    failed_compensations: List[str]\n    total_execution_time_ms: float\n    context: SagaContext\n    version: str = \"1.0.0\"\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    errors: List[str] = field(default_factory=list)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"saga_id\": self.saga_id,\n            \"status\": self.status.value,\n            \"completed_steps\": self.completed_steps,\n            \"failed_step\": self.failed_step,\n            \"compensated_steps\": self.compensated_steps,\n            \"failed_compensations\": self.failed_compensations,\n            \"total_execution_time_ms\": self.total_execution_time_ms,\n            \"version\": self.version,\n            \"constitutional_hash\": self.constitutional_hash,\n            \"errors\": self.errors,\n            \"step_results\": self.context.step_results,\n        }\n\n\n@dataclass\nclass SagaState:\n    \"\"\"Serializable state of a saga for persistence.\"\"\"\n\n    saga_id: str\n    status: SagaStatus\n    completed_steps: List[str]\n    failed_step: Optional[str]\n    compensated_steps: List[str]\n    failed_compensations: List[str]\n    context: Dict[str, Any]\n    version: str = \"1.0.0\"\n    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    def to_json(self) -> str:\n        \"\"\"Serialize to JSON string.\"\"\"\n        data = asdict(self)\n        data[\"status\"] = self.status.value\n        data[\"updated_at\"] = self.updated_at.isoformat()\n        return json.dumps(data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -> \"SagaState\":\n        \"\"\"Deserialize from JSON string.\"\"\"\n        data = json.loads(json_str)\n        data[\"status\"] = SagaStatus(data[\"status\"])\n        data[\"updated_at\"] = datetime.fromisoformat(data[\"updated_at\"])\n        return cls(**data)\n\n\nclass SagaPersistenceProvider(ABC):\n    \"\"\"Abstract provider for saga state persistence.\"\"\"\n\n    @abstractmethod\n    async def save_state(self, state: SagaState) -> None:\n        \"\"\"Save saga state.\"\"\"\n        pass\n\n    @abstractmethod\n    async def load_state(self, saga_id: str) -> Optional[SagaState]:\n        \"\"\"Load saga state.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_state(self, saga_id: str) -> None:\n        \"\"\"Delete saga state.\"\"\"\n        pass\n\n\nclass FileSagaPersistenceProvider(SagaPersistenceProvider):\n    \"\"\"File-based persistence provider for saga state.\"\"\"\n\n    def __init__(self, base_path: Union[str, Path] = \"storage/workflow_states\"):\n        self.base_path = Path(base_path)\n        self.base_path.mkdir(parents=True, exist_ok=True)\n\n    def _get_path(self, saga_id: str) -> Path:\n        return self.base_path / f\"{saga_id}.json\"\n\n    async def save_state(self, state: SagaState) -> None:\n        path = self._get_path(state.saga_id)\n        with open(path, \"w\") as f:\n            f.write(state.to_json())\n\n    async def load_state(self, saga_id: str) -> Optional[SagaState]:\n        path = self._get_path(saga_id)\n        if not path.exists():\n            return None\n        with open(path, \"r\") as f:\n            return SagaState.from_json(f.read())\n\n    async def delete_state(self, saga_id: str) -> None:\n        path = self._get_path(saga_id)\n        if path.exists():\n            path.unlink()\n\n\nclass SagaActivities(ABC):\n    \"\"\"\n    Activity interface for saga operations.\n    All activities MUST be idempotent.\n    \"\"\"\n\n    @abstractmethod\n    async def reserve_capacity(\n        self, saga_id: str, resource_type: str, amount: int\n    ) -> Dict[str, Any]:\n        \"\"\"Reserve capacity for the operation.\"\"\"\n        pass\n\n    @abstractmethod\n    async def release_capacity(self, saga_id: str, reservation_id: str) -> bool:\n        \"\"\"Release previously reserved capacity (compensation).\"\"\"\n        pass\n\n    @abstractmethod\n    async def validate_constitutional_compliance(\n        self, saga_id: str, data: Dict[str, Any], constitutional_hash: str\n    ) -> Dict[str, Any]:\n        \"\"\"Validate data against constitutional requirements.\"\"\"\n        pass\n\n    @abstractmethod\n    async def log_validation_failure(self, saga_id: str, validation_id: str, reason: str) -> bool:\n        \"\"\"Log validation failure for audit (compensation).\"\"\"\n        pass\n\n    @abstractmethod\n    async def apply_policy_decision(\n        self, saga_id: str, policy_path: str, decision_data: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"Apply policy decision to system state.\"\"\"\n        pass\n\n    @abstractmethod\n    async def revert_policy_decision(self, saga_id: str, decision_id: str) -> bool:\n        \"\"\"Revert policy decision (compensation).\"\"\"\n        pass\n\n    @abstractmethod\n    async def record_audit_entry(\n        self, saga_id: str, entry_type: str, entry_data: Dict[str, Any]\n    ) -> str:\n        \"\"\"Record entry to audit trail.\"\"\"\n        pass\n\n    @abstractmethod\n    async def mark_audit_failed(self, saga_id: str, audit_id: str, reason: str) -> bool:\n        \"\"\"Mark audit entry as failed (compensation).\"\"\"\n        pass\n\n    @abstractmethod\n    async def deliver_to_target(\n        self, saga_id: str, target_id: str, payload: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"Deliver payload to target.\"\"\"\n        pass\n\n    @abstractmethod\n    async def recall_from_target(self, saga_id: str, delivery_id: str, target_id: str) -> bool:\n        \"\"\"Recall/revoke delivery from target (compensation).\"\"\"\n        pass\n\n    @abstractmethod\n    async def audit_llm_reasoning(\n        self, saga_id: str, reasoning: str, constitutional_hash: str\n    ) -> Dict[str, Any]:\n        \"\"\"Audit LLM thinking traces for constitutional compliance.\"\"\"\n        pass\n\n\nclass DefaultSagaActivities(SagaActivities):\n    \"\"\"Default implementation of saga activities.\"\"\"\n\n    async def reserve_capacity(\n        self, saga_id: str, resource_type: str, amount: int\n    ) -> Dict[str, Any]:\n        reservation_id = str(uuid.uuid4())\n        logger.info(\n            f\"Saga {saga_id}: Reserved {amount} {resource_type} (reservation: {reservation_id})\"\n        )\n        return {\n            \"reservation_id\": reservation_id,\n            \"resource_type\": resource_type,\n            \"amount\": amount,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n\n    async def release_capacity(self, saga_id: str, reservation_id: str) -> bool:\n        logger.info(f\"Saga {saga_id}: Released reservation {reservation_id}\")\n        return True\n\n    async def validate_constitutional_compliance(\n        self, saga_id: str, data: Dict[str, Any], constitutional_hash: str\n    ) -> Dict[str, Any]:\n        is_valid = data.get(\"constitutional_hash\") == constitutional_hash\n        validation_id = str(uuid.uuid4())\n        return {\n            \"validation_id\": validation_id,\n            \"is_valid\": is_valid,\n            \"errors\": [] if is_valid else [\"Constitutional hash mismatch\"],\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n\n    async def log_validation_failure(self, saga_id: str, validation_id: str, reason: str) -> bool:\n        logger.warning(f\"Saga {saga_id}: Validation {validation_id} failed - {reason}\")\n        return True\n\n    async def apply_policy_decision(\n        self, saga_id: str, policy_path: str, decision_data: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        decision_id = str(uuid.uuid4())\n        logger.info(f\"Saga {saga_id}: Applied policy {policy_path} (decision: {decision_id})\")\n        return {\n            \"decision_id\": decision_id,\n            \"policy_path\": policy_path,\n            \"applied\": True,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n\n    async def revert_policy_decision(self, saga_id: str, decision_id: str) -> bool:\n        logger.info(f\"Saga {saga_id}: Reverted policy decision {decision_id}\")\n        return True\n\n    async def record_audit_entry(\n        self, saga_id: str, entry_type: str, entry_data: Dict[str, Any]\n    ) -> str:\n        audit_id = str(uuid.uuid4())\n        logger.info(f\"Saga {saga_id}: Recorded audit entry {audit_id} ({entry_type})\")\n        return audit_id\n\n    async def mark_audit_failed(self, saga_id: str, audit_id: str, reason: str) -> bool:\n        logger.warning(f\"Saga {saga_id}: Marked audit {audit_id} as failed - {reason}\")\n        return True\n\n    async def deliver_to_target(\n        self, saga_id: str, target_id: str, payload: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        delivery_id = str(uuid.uuid4())\n        logger.info(f\"Saga {saga_id}: Delivered to {target_id} (delivery: {delivery_id})\")\n        return {\n            \"delivery_id\": delivery_id,\n            \"target_id\": target_id,\n            \"delivered\": True,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n\n    async def recall_from_target(self, saga_id: str, delivery_id: str, target_id: str) -> bool:\n        logger.warning(f\"Saga {saga_id}: Recalled delivery {delivery_id} from {target_id}\")\n        return True\n\n    async def audit_llm_reasoning(\n        self, saga_id: str, reasoning: str, constitutional_hash: str\n    ) -> Dict[str, Any]:\n        audit_id = str(uuid.uuid4())\n        # Simulated reasoning audit\n        is_safe = \"ignore previous instructions\" not in reasoning.lower()\n        logger.info(f\"Saga {saga_id}: Audited reasoning trace {audit_id} (Safe: {is_safe})\")\n        return {\n            \"audit_id\": audit_id,\n            \"is_safe\": is_safe,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        }\n\n\nclass ConstitutionalSagaWorkflow:\n    \"\"\"\n    Saga workflow for constitutional operations with compensation.\n\n    This workflow executes a series of steps with automatic compensation\n    on failure. It follows the saga pattern:\n\n    1. For each step:\n       a. Register compensation BEFORE execution\n       b. Execute the step\n       c. Store result in context\n\n    2. On failure at any step:\n       a. Stop forward execution\n       b. Execute compensations in REVERSE order (LIFO)\n       c. Report partial completion\n\n    Example Usage:\n        saga = ConstitutionalSagaWorkflow(\"saga-123\")\n\n        # Define steps with compensations\n        saga.add_step(SagaStep(\n            name=\"reserve_capacity\",\n            execute=activities.reserve_capacity,\n            compensation=SagaCompensation(\n                name=\"release_capacity\",\n                execute=activities.release_capacity\n            )\n        ))\n\n        # Execute saga\n        result = await saga.execute(context)\n    \"\"\"\n\n    def __init__(\n        self,\n        saga_id: str,\n        activities: Optional[SagaActivities] = None,\n        persistence_provider: Optional[SagaPersistenceProvider] = None,\n        version: str = \"1.0.0\",\n    ):\n        self.saga_id = saga_id\n        self.activities = activities or DefaultSagaActivities()\n        self.persistence_provider = persistence_provider\n        self.version = version\n\n        self._steps: List[SagaStep] = []\n        self._compensations: List[SagaCompensation] = []\n        self._status = SagaStatus.PENDING\n        self._completed_steps: List[str] = []\n        self._failed_step: Optional[str] = None\n        self._compensated_steps: List[str] = []\n        self._failed_compensations: List[str] = []\n        self._start_time: Optional[datetime] = None\n\n    def add_step(self, step: SagaStep) -> \"ConstitutionalSagaWorkflow\":\n        \"\"\"Add a step to the saga. Returns self for chaining.\"\"\"\n        self._steps.append(step)\n        return self\n\n    async def _save_current_state(self, context: SagaContext):\n        \"\"\"Save the current saga state if a persistence provider is configured.\"\"\"\n        if self.persistence_provider:\n            state = SagaState(\n                saga_id=self.saga_id,\n                status=self._status,\n                completed_steps=self._completed_steps.copy(),\n                failed_step=self._failed_step,\n                compensated_steps=self._compensated_steps.copy(),\n                failed_compensations=self._failed_compensations.copy(),\n                context=context.step_results.copy(),\n                version=self.version,\n            )\n            await self.persistence_provider.save_state(state)\n\n    async def execute(self, context: Optional[SagaContext] = None) -> SagaResult:\n        \"\"\"\n        Execute the saga with automatic compensation on failure.\n\n        Returns SagaResult with execution details.\n        \"\"\"\n        self._start_time = datetime.now(timezone.utc)\n        self._status = SagaStatus.EXECUTING\n\n        if context is None:\n            context = SagaContext(saga_id=self.saga_id)\n\n        # Save initial state\n        await self._save_current_state(context)\n\n        try:\n            # Execute steps in order\n            for step in self._steps:\n                success = await self._execute_step(step, context)\n\n                if not success and not step.is_optional:\n                    self._failed_step = step.name\n                    break\n\n            if self._failed_step:\n                # Failure occurred - run compensations\n                await self._run_compensations(context)\n                self._status = (\n                    SagaStatus.COMPENSATED\n                    if not self._failed_compensations\n                    else SagaStatus.PARTIALLY_COMPENSATED\n                )\n            else:\n                self._status = SagaStatus.COMPLETED\n\n            # Final state save\n            await self._save_current_state(context)\n\n        except Exception as e:\n            logger.error(f\"Saga {self.saga_id} failed with exception: {e}\")\n            context.errors.append(str(e))\n            self._status = SagaStatus.FAILED\n\n            # Attempt compensations even on exception\n            await self._run_compensations(context)\n\n        return self._build_result(context)\n\n    async def _execute_step(self, step: SagaStep, context: SagaContext) -> bool:\n        \"\"\"Execute a single saga step with retries.\"\"\"\n        step.status = StepStatus.EXECUTING\n        step.started_at = datetime.now(timezone.utc)\n\n        # CRITICAL: Register compensation BEFORE executing\n        if step.compensation:\n            self._compensations.append(step.compensation)\n\n        for attempt in range(step.max_retries):\n            try:\n                # Build step input from context\n                step_input = {\n                    \"saga_id\": self.saga_id,\n                    \"step_name\": step.name,\n                    \"attempt\": attempt + 1,\n                    \"context\": context.step_results.copy(),\n                    \"metadata\": context.metadata.copy(),\n                    \"constitutional_hash\": context.constitutional_hash,\n                }\n\n                # Execute with timeout\n                result = await asyncio.wait_for(\n                    step.execute(step_input), timeout=step.timeout_seconds\n                )\n\n                step.result = result\n                step.status = StepStatus.COMPLETED\n                step.completed_at = datetime.now(timezone.utc)\n                step.execution_time_ms = (\n                    step.completed_at - step.started_at\n                ).total_seconds() * 1000\n\n                # Store result in context\n                context.set_step_result(step.name, result)\n                self._completed_steps.append(step.name)\n\n                # Save state after each step\n                await self._save_current_state(context)\n\n                logger.info(\n                    f\"Saga {self.saga_id}: Step '{step.name}' completed \"\n                    f\"(attempt {attempt + 1}, {step.execution_time_ms:.2f}ms)\"\n                )\n\n                return True\n\n            except asyncio.TimeoutError:\n                step.error = f\"Timeout after {step.timeout_seconds}s\"\n                logger.warning(\n                    f\"Saga {self.saga_id}: Step '{step.name}' timed out (attempt {attempt + 1})\"\n                )\n\n            except Exception as e:\n                step.error = str(e)\n                logger.warning(\n                    f\"Saga {self.saga_id}: Step '{step.name}' failed (attempt {attempt + 1}): {e}\"\n                )\n\n            # Wait before retry\n            if attempt < step.max_retries - 1:\n                await asyncio.sleep(step.retry_delay_seconds)\n\n        # All retries exhausted\n        step.status = StepStatus.FAILED\n        context.errors.append(f\"Step '{step.name}' failed: {step.error}\")\n        return False\n\n    async def _run_compensations(self, context: SagaContext):\n        \"\"\"Run compensations in reverse order (LIFO).\"\"\"\n        self._status = SagaStatus.COMPENSATING\n\n        # Reverse order - most recent first\n        for compensation in reversed(self._compensations):\n            success = await self._execute_compensation(compensation, context)\n\n            if success:\n                self._compensated_steps.append(compensation.name)\n            else:\n                self._failed_compensations.append(compensation.name)\n\n            # Save state after each compensation\n            await self._save_current_state(context)\n\n    async def _execute_compensation(\n        self, compensation: SagaCompensation, context: SagaContext\n    ) -> bool:\n        \"\"\"Execute a single compensation with retries.\"\"\"\n        logger.info(f\"Saga {self.saga_id}: Running compensation '{compensation.name}'\")\n\n        for attempt in range(compensation.max_retries):\n            try:\n                # Build compensation input\n                comp_input = {\n                    \"saga_id\": self.saga_id,\n                    \"compensation_name\": compensation.name,\n                    \"attempt\": attempt + 1,\n                    \"context\": context.step_results.copy(),\n                    \"idempotency_key\": compensation.idempotency_key\n                    or f\"{self.saga_id}:{compensation.name}\",\n                }\n\n                result = await compensation.execute(comp_input)\n\n                if result:\n                    logger.info(\n                        f\"Saga {self.saga_id}: Compensation '{compensation.name}' \"\n                        f\"completed (attempt {attempt + 1})\"\n                    )\n                    return True\n\n            except Exception as e:\n                logger.warning(\n                    f\"Saga {self.saga_id}: Compensation '{compensation.name}' \"\n                    f\"failed (attempt {attempt + 1}): {e}\"\n                )\n\n            if attempt < compensation.max_retries - 1:\n                await asyncio.sleep(compensation.retry_delay_seconds)\n\n        logger.error(\n            f\"Saga {self.saga_id}: Compensation '{compensation.name}' \"\n            f\"failed after {compensation.max_retries} attempts\"\n        )\n        context.errors.append(f\"Compensation '{compensation.name}' failed\")\n        return False\n\n    def _build_result(self, context: SagaContext) -> SagaResult:\n        \"\"\"Build saga result from current state.\"\"\"\n        execution_time = 0.0\n        if self._start_time:\n            execution_time = (datetime.now(timezone.utc) - self._start_time).total_seconds() * 1000\n\n        return SagaResult(\n            saga_id=self.saga_id,\n            status=self._status,\n            completed_steps=self._completed_steps.copy(),\n            failed_step=self._failed_step,\n            compensated_steps=self._compensated_steps.copy(),\n            failed_compensations=self._failed_compensations.copy(),\n            total_execution_time_ms=execution_time,\n            context=context,\n            version=self.version,\n            constitutional_hash=context.constitutional_hash,\n            errors=context.errors.copy(),\n        )\n\n    @staticmethod\n    async def resume(\n        saga_id: str,\n        persistence_provider: SagaPersistenceProvider,\n        activities: Optional[SagaActivities] = None,\n    ) -> Optional[\"ConstitutionalSagaWorkflow\"]:\n        \"\"\"\n        Resume a saga from persistent storage.\n\n        This recreates the workflow instance and populates its state.\n        Caller must re-add all steps to the workflow before calling execute().\n        \"\"\"\n        state = await persistence_provider.load_state(saga_id)\n        if not state:\n            return None\n\n        saga = ConstitutionalSagaWorkflow(\n            saga_id=saga_id,\n            activities=activities,\n            persistence_provider=persistence_provider,\n            version=state.version,\n        )\n\n        saga._status = state.status\n        saga._completed_steps = state.completed_steps.copy()\n        saga._failed_step = state.failed_step\n        saga._compensated_steps = state.compensated_steps.copy()\n        saga._failed_compensations = state.failed_compensations.copy()\n\n        return saga\n\n    def get_status(self) -> SagaStatus:\n        \"\"\"Query current saga status.\"\"\"\n        return self._status\n\n\ndef create_constitutional_validation_saga(\n    saga_id: str, activities: Optional[SagaActivities] = None\n) -> ConstitutionalSagaWorkflow:\n    \"\"\"\n    Factory function to create a standard constitutional validation saga.\n\n    Steps:\n    1. Reserve validation capacity\n    2. Validate constitutional hash\n    3. Evaluate OPA policies\n    4. Record audit trail\n    5. Deliver to target\n\n    Each step has corresponding compensation.\n    \"\"\"\n    acts = activities or DefaultSagaActivities()\n    saga = ConstitutionalSagaWorkflow(saga_id, acts)\n\n    # Step 1: Reserve capacity\n    async def reserve_capacity(input: Dict[str, Any]) -> Dict[str, Any]:\n        return await acts.reserve_capacity(\n            saga_id=input[\"saga_id\"], resource_type=\"validation_slots\", amount=1\n        )\n\n    async def release_capacity(input: Dict[str, Any]) -> bool:\n        reservation = input[\"context\"].get(\"reserve_capacity\", {})\n        return await acts.release_capacity(\n            saga_id=input[\"saga_id\"], reservation_id=reservation.get(\"reservation_id\", \"unknown\")\n        )\n\n    saga.add_step(\n        SagaStep(\n            name=\"reserve_capacity\",\n            description=\"Reserve validation capacity\",\n            execute=reserve_capacity,\n            compensation=SagaCompensation(\n                name=\"release_capacity\",\n                description=\"Release reserved capacity\",\n                execute=release_capacity,\n            ),\n        )\n    )\n\n    # Step 2: Validate constitutional compliance\n    async def validate_compliance(input: Dict[str, Any]) -> Dict[str, Any]:\n        return await acts.validate_constitutional_compliance(\n            saga_id=input[\"saga_id\"],\n            data=input[\"context\"],\n            constitutional_hash=input[\"constitutional_hash\"],\n        )\n\n    async def log_validation_failure(input: Dict[str, Any]) -> bool:\n        validation = input[\"context\"].get(\"validate_compliance\", {})\n        return await acts.log_validation_failure(\n            saga_id=input[\"saga_id\"],\n            validation_id=validation.get(\"validation_id\", \"unknown\"),\n            reason=\"Saga compensated\",\n        )\n\n    saga.add_step(\n        SagaStep(\n            name=\"validate_compliance\",\n            description=\"Validate constitutional compliance\",\n            execute=validate_compliance,\n            compensation=SagaCompensation(\n                name=\"log_validation_failure\",\n                description=\"Log validation as failed\",\n                execute=log_validation_failure,\n            ),\n        )\n    )\n\n    # Step 2.5: Audit Reasoning Trace\n    async def audit_reasoning(input: Dict[str, Any]) -> Dict[str, Any]:\n        reasoning = input[\"context\"].get(\"llm_reasoning\", \"\")\n        if not reasoning:\n            return {\"audit_id\": \"none\", \"is_safe\": True, \"skipped\": True}\n\n        return await acts.audit_llm_reasoning(\n            saga_id=input[\"saga_id\"],\n            reasoning=reasoning,\n            constitutional_hash=input[\"constitutional_hash\"],\n        )\n\n    saga.add_step(\n        SagaStep(\n            name=\"audit_reasoning\",\n            description=\"Audit LLM thinking traces\",\n            execute=audit_reasoning,\n            is_optional=True,\n        )\n    )\n\n    # Step 3: Apply policy decision\n    async def apply_policy(input: Dict[str, Any]) -> Dict[str, Any]:\n        return await acts.apply_policy_decision(\n            saga_id=input[\"saga_id\"],\n            policy_path=\"acgs/constitutional/allow\",\n            decision_data=input[\"context\"],\n        )\n\n    async def revert_policy(input: Dict[str, Any]) -> bool:\n        decision = input[\"context\"].get(\"apply_policy\", {})\n        return await acts.revert_policy_decision(\n            saga_id=input[\"saga_id\"], decision_id=decision.get(\"decision_id\", \"unknown\")\n        )\n\n    saga.add_step(\n        SagaStep(\n            name=\"apply_policy\",\n            description=\"Apply policy decision\",\n            execute=apply_policy,\n            compensation=SagaCompensation(\n                name=\"revert_policy\", description=\"Revert policy decision\", execute=revert_policy\n            ),\n        )\n    )\n\n    # Step 4: Record audit entry\n    async def record_audit(input: Dict[str, Any]) -> str:\n        return await acts.record_audit_entry(\n            saga_id=input[\"saga_id\"],\n            entry_type=\"constitutional_validation\",\n            entry_data=input[\"context\"],\n        )\n\n    async def mark_audit_failed(input: Dict[str, Any]) -> bool:\n        audit_id = input[\"context\"].get(\"record_audit\", \"unknown\")\n        return await acts.mark_audit_failed(\n            saga_id=input[\"saga_id\"], audit_id=audit_id, reason=\"Saga compensated\"\n        )\n\n    saga.add_step(\n        SagaStep(\n            name=\"record_audit\",\n            description=\"Record to audit trail\",\n            execute=record_audit,\n            compensation=SagaCompensation(\n                name=\"mark_audit_failed\",\n                description=\"Mark audit as failed\",\n                execute=mark_audit_failed,\n            ),\n        )\n    )\n\n    return saga\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.122866",
  "last_updated": "2026-01-04T05:35:58.631364"
}