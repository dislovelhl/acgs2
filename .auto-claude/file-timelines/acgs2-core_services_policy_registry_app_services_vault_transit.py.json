{
  "file_path": "src/core/services/policy_registry/app/services/vault_transit.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Vault Crypto Service - Transit Engine Operations\nConstitutional Hash: cdd01ef066bc6cf2\n\nTransit secrets engine operations for signing, verification,\nencryption, and decryption using HashiCorp Vault.\n\"\"\"\n\nimport base64\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, Protocol\n\n# Add src/core/shared to path for type imports\nshared_path = Path(__file__).parent.parent.parent.parent.parent / \"shared\"\nif str(shared_path) not in sys.path:\n    sys.path.insert(0, str(shared_path))\n\nfrom types import JSONDict\n\nlogger = logging.getLogger(__name__)\n\n\nclass VaultHttpClient(Protocol):\n    \"\"\"Protocol for Vault HTTP client.\"\"\"\n\n    async def request(self, method: str, path: str, data: Optional[JSONDict] = None) -> JSONDict:\n        \"\"\"Make HTTP request to Vault API.\"\"\"\n        ...\n\n\nclass VaultTransitOperations:\n    \"\"\"\n    Vault Transit engine operations wrapper.\n\n    Provides high-level methods for cryptographic operations\n    using the Vault Transit secrets engine.\n    \"\"\"\n\n    def __init__(self, http_client: VaultHttpClient, transit_mount: str = \"transit\"):\n        \"\"\"\n        Initialize Transit operations.\n\n        Args:\n            http_client: VaultHttpClient instance for API calls\n            transit_mount: Mount path for Transit engine\n        \"\"\"\n        self._http_client = http_client\n        self._transit_mount = transit_mount\n\n    async def create_key(\n        self,\n        key_name: str,\n        key_type: str,\n        exportable: bool = False,\n        allow_plaintext_backup: bool = False,\n    ) -> None:\n        \"\"\"\n        Create a key in Transit engine.\n\n        Args:\n            key_name: Name for the key\n            key_type: Vault key type (ed25519, ecdsa-p256, etc.)\n            exportable: Whether key can be exported\n            allow_plaintext_backup: Allow plaintext backup\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/keys/{key_name}\"\n        data = {\n            \"type\": key_type,\n            \"exportable\": exportable,\n            \"allow_plaintext_backup\": allow_plaintext_backup,\n        }\n        await self._http_client.request(\"POST\", path, data=data)\n        logger.debug(f\"Created Transit key: {key_name} type={key_type}\")\n\n    async def sign(\n        self,\n        key_name: str,\n        data: bytes,\n        hash_algorithm: str = \"sha2-256\",\n        prehashed: bool = False,\n    ) -> str:\n        \"\"\"\n        Sign data using Transit engine.\n\n        Args:\n            key_name: Name of the signing key\n            data: Data to sign\n            hash_algorithm: Hash algorithm (sha2-256, sha2-384, sha2-512)\n            prehashed: Whether data is already hashed\n\n        Returns:\n            Base64-encoded signature\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/sign/{key_name}\"\n\n        payload = {\n            \"input\": base64.b64encode(data).decode(),\n            \"hash_algorithm\": hash_algorithm,\n            \"prehashed\": prehashed,\n        }\n\n        response = await self._http_client.request(\"POST\", path, data=payload)\n\n        # Vault returns signature as vault:v1:base64...\n        signature = response.get(\"data\", {}).get(\"signature\", \"\")\n\n        # Extract just the base64 part for compatibility\n        if signature.startswith(\"vault:\"):\n            parts = signature.split(\":\")\n            if len(parts) >= 3:\n                return parts[2]\n        return signature\n\n    async def verify(\n        self,\n        key_name: str,\n        data: bytes,\n        signature: str,\n        hash_algorithm: str = \"sha2-256\",\n        prehashed: bool = False,\n    ) -> bool:\n        \"\"\"\n        Verify signature using Transit engine.\n\n        Args:\n            key_name: Name of the signing key\n            data: Original data\n            signature: Signature to verify\n            hash_algorithm: Hash algorithm used for signing\n            prehashed: Whether data is already hashed\n\n        Returns:\n            True if signature is valid\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/verify/{key_name}\"\n\n        # Add vault prefix if not present\n        if not signature.startswith(\"vault:\"):\n            signature = f\"vault:v1:{signature}\"\n\n        payload = {\n            \"input\": base64.b64encode(data).decode(),\n            \"signature\": signature,\n            \"hash_algorithm\": hash_algorithm,\n            \"prehashed\": prehashed,\n        }\n\n        response = await self._http_client.request(\"POST\", path, data=payload)\n        return response.get(\"data\", {}).get(\"valid\", False)\n\n    async def encrypt(\n        self,\n        key_name: str,\n        plaintext: bytes,\n        context: Optional[bytes] = None,\n    ) -> str:\n        \"\"\"\n        Encrypt data using Transit engine.\n\n        Args:\n            key_name: Name of the encryption key\n            plaintext: Data to encrypt\n            context: Optional context for key derivation\n\n        Returns:\n            Vault ciphertext string (vault:v1:...)\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/encrypt/{key_name}\"\n\n        payload = {\"plaintext\": base64.b64encode(plaintext).decode()}\n        if context:\n            payload[\"context\"] = base64.b64encode(context).decode()\n\n        response = await self._http_client.request(\"POST\", path, data=payload)\n        return response.get(\"data\", {}).get(\"ciphertext\", \"\")\n\n    async def decrypt(\n        self,\n        key_name: str,\n        ciphertext: str,\n        context: Optional[bytes] = None,\n    ) -> bytes:\n        \"\"\"\n        Decrypt data using Transit engine.\n\n        Args:\n            key_name: Name of the encryption key\n            ciphertext: Vault ciphertext string\n            context: Optional context for key derivation\n\n        Returns:\n            Decrypted plaintext bytes\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/decrypt/{key_name}\"\n\n        payload = {\"ciphertext\": ciphertext}\n        if context:\n            payload[\"context\"] = base64.b64encode(context).decode()\n\n        response = await self._http_client.request(\"POST\", path, data=payload)\n        plaintext_b64 = response.get(\"data\", {}).get(\"plaintext\", \"\")\n        return base64.b64decode(plaintext_b64)\n\n    async def rotate_key(self, key_name: str) -> None:\n        \"\"\"\n        Rotate key in Transit engine.\n\n        Args:\n            key_name: Name of the key to rotate\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/keys/{key_name}/rotate\"\n        await self._http_client.request(\"POST\", path)\n        logger.info(f\"Rotated Transit key: {key_name}\")\n\n    async def get_public_key(self, key_name: str) -> str:\n        \"\"\"\n        Get public key from Transit engine.\n\n        Args:\n            key_name: Name of the key\n\n        Returns:\n            Base64-encoded public key\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/keys/{key_name}\"\n        response = await self._http_client.request(\"GET\", path)\n\n        keys = response.get(\"data\", {}).get(\"keys\", {})\n        latest_version = response.get(\"data\", {}).get(\"latest_version\", 1)\n        key_data = keys.get(str(latest_version), {})\n\n        # Return public key in base64 format\n        public_key = key_data.get(\"public_key\", \"\")\n        if public_key and not public_key.startswith(\"-----\"):\n            return public_key\n\n        # If PEM format, extract just the key\n        if public_key.startswith(\"-----BEGIN\"):\n            match = re.search(r\"-----BEGIN .+-----\\n(.+)\\n-----END\", public_key, re.DOTALL)\n            if match:\n                return match.group(1).replace(\"\\n\", \"\")\n\n        return public_key\n\n    async def get_key_info(self, key_name: str) -> JSONDict:\n        \"\"\"\n        Get key info from Transit engine.\n\n        Args:\n            key_name: Name of the key\n\n        Returns:\n            Key information dictionary\n        \"\"\"\n        path = f\"/v1/{self._transit_mount}/keys/{key_name}\"\n        response = await self._http_client.request(\"GET\", path)\n        return response.get(\"data\", {})\n\n\n__all__ = [\"VaultTransitOperations\"]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.134292",
  "last_updated": "2026-01-04T05:35:59.222607"
}