{
  "file_path": "integration-service/src/webhooks/models.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nPydantic models for webhook framework.\n\nDefines models for webhook subscriptions, events, deliveries, and results\nwith comprehensive validation, authentication support, and delivery tracking.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Dict, List, Literal, Optional\nfrom uuid import uuid4\n\nfrom pydantic import (\n    BaseModel,\n    ConfigDict,\n    Field,\n    SecretStr,\n    field_validator,\n    model_validator,\n)\n\nfrom ..types import JSONDict, ValidatorValue\n\n\nclass WebhookState(str, Enum):\n    \"\"\"State of a webhook subscription.\"\"\"\n\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n    SUSPENDED = \"suspended\"\n    PENDING_VERIFICATION = \"pending_verification\"\n    FAILED = \"failed\"\n\n\nclass WebhookAuthType(str, Enum):\n    \"\"\"Authentication types supported by webhooks.\"\"\"\n\n    NONE = \"none\"\n    API_KEY = \"api_key\"\n    BEARER = \"bearer\"\n    BASIC = \"basic\"\n    HMAC = \"hmac\"\n    OAUTH2 = \"oauth2\"\n\n\nclass WebhookDeliveryStatus(str, Enum):\n    \"\"\"Status of a webhook delivery attempt.\"\"\"\n\n    PENDING = \"pending\"\n    DELIVERED = \"delivered\"\n    FAILED = \"failed\"\n    RETRYING = \"retrying\"\n    DEAD_LETTERED = \"dead_lettered\"\n\n\nclass WebhookEventType(str, Enum):\n    \"\"\"Types of governance events that can trigger webhooks.\"\"\"\n\n    POLICY_VIOLATION = \"policy.violation\"\n    POLICY_CREATED = \"policy.created\"\n    POLICY_UPDATED = \"policy.updated\"\n    POLICY_DELETED = \"policy.deleted\"\n    ACCESS_REVIEW_STARTED = \"access_review.started\"\n    ACCESS_REVIEW_COMPLETED = \"access_review.completed\"\n    COMPLIANCE_CHECK_PASSED = \"compliance.check.passed\"\n    COMPLIANCE_CHECK_FAILED = \"compliance.check.failed\"\n    APPROVAL_REQUESTED = \"approval.requested\"\n    APPROVAL_GRANTED = \"approval.granted\"\n    APPROVAL_DENIED = \"approval.denied\"\n    INTEGRATION_ERROR = \"integration.error\"\n    SYSTEM_ALERT = \"system.alert\"\n\n\nclass WebhookSignatureAlgorithm(str, Enum):\n    \"\"\"HMAC signature algorithms for webhook verification.\"\"\"\n\n    SHA256 = \"sha256\"\n    SHA512 = \"sha512\"\n\n\nclass WebhookConfig(BaseModel):\n    \"\"\"Configuration for a webhook endpoint within a subscription.\"\"\"\n\n    # Endpoint settings\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    method: Literal[\"POST\", \"PUT\"] = Field(\n        default=\"POST\", description=\"HTTP method for webhook delivery\"\n    )\n\n    # Authentication\n    auth_type: WebhookAuthType = Field(\n        default=WebhookAuthType.NONE, description=\"Authentication type\"\n    )\n    auth_header: str = Field(default=\"Authorization\", description=\"Header name for authentication\")\n    auth_value: Optional[SecretStr] = Field(\n        None, description=\"Authentication value (token, API key, etc.)\"\n    )\n\n    # HMAC signature settings\n    hmac_secret: Optional[SecretStr] = Field(\n        None, description=\"HMAC secret for signature verification\"\n    )\n    hmac_header: str = Field(default=\"X-Webhook-Signature\", description=\"Header for HMAC signature\")\n    hmac_algorithm: WebhookSignatureAlgorithm = Field(\n        default=WebhookSignatureAlgorithm.SHA256, description=\"HMAC algorithm\"\n    )\n\n    # Request settings\n    content_type: str = Field(default=\"application/json\", description=\"Content-Type header value\")\n    custom_headers: Dict[str, str] = Field(\n        default_factory=dict, description=\"Additional headers to include\"\n    )\n    timeout_seconds: float = Field(\n        default=30.0, ge=1.0, le=120.0, description=\"Request timeout in seconds\"\n    )\n\n    # TLS settings\n    verify_ssl: bool = Field(default=True, description=\"Verify SSL certificates\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        validate_assignment=True,\n    )\n\n    @field_validator(\"url\", mode=\"before\")\n    @classmethod\n    def validate_url(cls, v: str) -> str:\n        \"\"\"Validate webhook URL format.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            raise ValueError(\"Webhook URL must start with http:// or https://\")\n        return v.rstrip(\"/\")\n\n    @model_validator(mode=\"after\")\n    def validate_auth_config(self) -> \"WebhookConfig\":\n        \"\"\"Validate authentication configuration consistency.\"\"\"\n        if self.auth_type in (WebhookAuthType.API_KEY, WebhookAuthType.BEARER):\n            if not self.auth_value:\n                raise ValueError(\n                    f\"auth_value is required for {self.auth_type.value} authentication\"\n                )\n        if self.auth_type == WebhookAuthType.HMAC:\n            if not self.hmac_secret:\n                raise ValueError(\"hmac_secret is required for HMAC authentication\")\n        return self\n\n\nclass WebhookSubscription(BaseModel):\n    \"\"\"\n    Webhook subscription model.\n\n    Represents a registered webhook endpoint that will receive\n    governance events based on configured filters.\n    \"\"\"\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        description=\"Unique identifier for this webhook subscription\",\n    )\n    name: str = Field(\n        ..., min_length=1, max_length=255, description=\"Display name for the subscription\"\n    )\n    description: Optional[str] = Field(\n        None, max_length=1000, description=\"Description of this webhook\"\n    )\n\n    # State and ownership\n    state: WebhookState = Field(\n        default=WebhookState.PENDING_VERIFICATION,\n        description=\"Current state of the subscription\",\n    )\n    owner_id: Optional[str] = Field(\n        None, description=\"User or service account that owns this subscription\"\n    )\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID for multi-tenant deployments\")\n\n    # Endpoint configuration\n    config: WebhookConfig = Field(..., description=\"Webhook endpoint configuration\")\n\n    # Event filtering\n    event_types: List[WebhookEventType] = Field(\n        default_factory=lambda: [WebhookEventType.POLICY_VIOLATION],\n        description=\"Event types to subscribe to\",\n    )\n    severity_filter: List[str] = Field(\n        default_factory=lambda: [\"critical\", \"high\", \"medium\", \"low\", \"info\"],\n        description=\"Filter events by severity levels\",\n    )\n    resource_filters: Dict[str, List[str]] = Field(\n        default_factory=dict,\n        description=\"Filter events by resource attributes (e.g., {'policy_id': ['POL-001']})\",\n    )\n    tag_filters: List[str] = Field(\n        default_factory=list,\n        description=\"Filter events by tags\",\n    )\n\n    # Retry settings\n    max_retries: int = Field(default=3, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(\n        default=1.0, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n    retry_exponential_base: float = Field(\n        default=2.0, ge=1.5, le=4.0, description=\"Exponential backoff multiplier\"\n    )\n    max_retry_delay_seconds: float = Field(\n        default=300.0, ge=1.0, le=3600, description=\"Maximum retry delay\"\n    )\n\n    # Rate limiting\n    rate_limit_per_minute: Optional[int] = Field(\n        None, ge=1, le=1000, description=\"Maximum deliveries per minute (None = unlimited)\"\n    )\n\n    # Metadata\n    tags: List[str] = Field(default_factory=list, description=\"Tags for categorization\")\n    created_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Subscription creation timestamp\",\n    )\n    updated_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Subscription last update timestamp\",\n    )\n    last_triggered_at: Optional[datetime] = Field(\n        None, description=\"Last time a delivery was attempted\"\n    )\n    verification_token: Optional[str] = Field(None, description=\"Token for endpoint verification\")\n    verified_at: Optional[datetime] = Field(None, description=\"When the endpoint was verified\")\n\n    # Statistics\n    total_deliveries: int = Field(default=0, ge=0, description=\"Total delivery attempts\")\n    successful_deliveries: int = Field(default=0, ge=0, description=\"Successful deliveries\")\n    failed_deliveries: int = Field(default=0, ge=0, description=\"Failed deliveries\")\n    consecutive_failures: int = Field(\n        default=0, ge=0, description=\"Consecutive failures (resets on success)\"\n    )\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        validate_assignment=True,\n    )\n\n    @field_validator(\"tags\", mode=\"before\")\n    @classmethod\n    def validate_tags(cls, v: ValidatorValue) -> List[str]:\n        \"\"\"Ensure tags is a list of strings.\"\"\"\n        if v is None:\n            return []\n        if isinstance(v, str):\n            return [v]\n        return list(v)\n\n    @field_validator(\"severity_filter\", mode=\"before\")\n    @classmethod\n    def validate_severity_filter(cls, v: ValidatorValue) -> List[str]:\n        \"\"\"Validate severity filter values.\"\"\"\n        if v is None:\n            return [\"critical\", \"high\", \"medium\", \"low\", \"info\"]\n\n        valid_severities = {\"critical\", \"high\", \"medium\", \"low\", \"info\"}\n        if isinstance(v, str):\n            v = [v]\n\n        invalid = set(v) - valid_severities\n        if invalid:\n            raise ValueError(f\"Invalid severity values: {invalid}\")\n        return list(v)\n\n    def should_deliver_event(self, event: \"WebhookEvent\") -> bool:\n        \"\"\"\n        Check if an event should be delivered to this subscription.\n\n        Args:\n            event: The webhook event to check\n\n        Returns:\n            True if the event matches subscription filters\n        \"\"\"\n        # Check state\n        if self.state != WebhookState.ACTIVE:\n            return False\n\n        # Check event type\n        if event.event_type not in self.event_types:\n            return False\n\n        # Check severity\n        if event.severity and event.severity not in self.severity_filter:\n            return False\n\n        # Check resource filters\n        for key, allowed_values in self.resource_filters.items():\n            event_value = event.resource_attributes.get(key)\n            if event_value and event_value not in allowed_values:\n                return False\n\n        # Check tag filters\n        if self.tag_filters:\n            if not any(tag in event.tags for tag in self.tag_filters):\n                return False\n\n        return True\n\n\nclass WebhookEvent(BaseModel):\n    \"\"\"\n    Webhook event payload model.\n\n    Represents a governance event that will be delivered to webhook endpoints.\n    \"\"\"\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        description=\"Unique event identifier\",\n    )\n    event_type: WebhookEventType = Field(..., description=\"Type of governance event\")\n    timestamp: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Event timestamp in UTC\",\n    )\n    severity: str = Field(\n        default=\"info\",\n        description=\"Event severity level\",\n    )\n    source: str = Field(default=\"acgs2\", description=\"Source system\")\n\n    # Event content\n    title: str = Field(..., description=\"Event title/summary\")\n    description: Optional[str] = Field(None, description=\"Detailed description\")\n    details: JSONDict = Field(default_factory=dict, description=\"Additional event details\")\n\n    # Resource context\n    policy_id: Optional[str] = Field(None, description=\"Related policy ID\")\n    resource_id: Optional[str] = Field(None, description=\"Affected resource ID\")\n    resource_type: Optional[str] = Field(None, description=\"Type of affected resource\")\n    resource_attributes: Dict[str, str] = Field(\n        default_factory=dict, description=\"Resource attributes for filtering\"\n    )\n\n    # User context\n    user_id: Optional[str] = Field(None, description=\"User who triggered the event\")\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID for multi-tenant deployments\")\n\n    # Tracing\n    correlation_id: Optional[str] = Field(None, description=\"Correlation ID for request tracing\")\n    tags: List[str] = Field(default_factory=list, description=\"Event tags\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    @field_validator(\"severity\", mode=\"before\")\n    @classmethod\n    def validate_severity(cls, v: str) -> str:\n        \"\"\"Validate and normalize severity.\"\"\"\n        v = v.lower().strip()\n        valid = {\"critical\", \"high\", \"medium\", \"low\", \"info\"}\n        if v not in valid:\n            raise ValueError(f\"Invalid severity '{v}', must be one of {valid}\")\n        return v\n\n    def to_payload(self) -> JSONDict:\n        \"\"\"\n        Convert event to webhook payload format.\n\n        Returns:\n            Dictionary suitable for JSON serialization and delivery\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"event_type\": self.event_type.value,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"severity\": self.severity,\n            \"source\": self.source,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"details\": self.details,\n            \"policy_id\": self.policy_id,\n            \"resource_id\": self.resource_id,\n            \"resource_type\": self.resource_type,\n            \"resource_attributes\": self.resource_attributes,\n            \"user_id\": self.user_id,\n            \"tenant_id\": self.tenant_id,\n            \"correlation_id\": self.correlation_id,\n            \"tags\": self.tags,\n        }\n\n\nclass WebhookDelivery(BaseModel):\n    \"\"\"\n    Webhook delivery attempt model.\n\n    Tracks individual delivery attempts for a webhook event\n    including retry state and delivery details.\n    \"\"\"\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        description=\"Unique delivery identifier\",\n    )\n    subscription_id: str = Field(..., description=\"ID of the webhook subscription\")\n    event_id: str = Field(..., description=\"ID of the event being delivered\")\n\n    # Status\n    status: WebhookDeliveryStatus = Field(\n        default=WebhookDeliveryStatus.PENDING,\n        description=\"Current delivery status\",\n    )\n\n    # Attempt tracking\n    attempt_number: int = Field(default=1, ge=1, description=\"Current attempt number\")\n    max_attempts: int = Field(default=3, ge=1, le=10, description=\"Maximum attempts allowed\")\n    next_retry_at: Optional[datetime] = Field(\n        None, description=\"When the next retry will be attempted\"\n    )\n\n    # Timing\n    created_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"When the delivery was created\",\n    )\n    started_at: Optional[datetime] = Field(None, description=\"When delivery attempt started\")\n    completed_at: Optional[datetime] = Field(None, description=\"When delivery attempt completed\")\n    duration_ms: Optional[int] = Field(None, ge=0, description=\"Delivery duration in milliseconds\")\n\n    # Request/Response details\n    request_url: Optional[str] = Field(None, description=\"Target URL\")\n    request_method: Optional[str] = Field(None, description=\"HTTP method used\")\n    request_headers: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Request headers (sensitive values redacted)\",\n    )\n    request_body_size: Optional[int] = Field(None, ge=0, description=\"Request body size in bytes\")\n\n    response_status_code: Optional[int] = Field(None, description=\"HTTP response status code\")\n    response_headers: Dict[str, str] = Field(default_factory=dict, description=\"Response headers\")\n    response_body: Optional[str] = Field(\n        None, max_length=10000, description=\"Response body (truncated)\"\n    )\n\n    # Error tracking\n    error_code: Optional[str] = Field(None, description=\"Error code if failed\")\n    error_message: Optional[str] = Field(\n        None, max_length=1000, description=\"Error message if failed\"\n    )\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        validate_assignment=True,\n    )\n\n    @property\n    def can_retry(self) -> bool:\n        \"\"\"Check if delivery can be retried.\"\"\"\n        return (\n            self.status in (WebhookDeliveryStatus.FAILED, WebhookDeliveryStatus.RETRYING)\n            and self.attempt_number < self.max_attempts\n        )\n\n    @property\n    def is_final(self) -> bool:\n        \"\"\"Check if delivery is in a final state.\"\"\"\n        return self.status in (\n            WebhookDeliveryStatus.DELIVERED,\n            WebhookDeliveryStatus.DEAD_LETTERED,\n        )\n\n\nclass WebhookDeliveryResult(BaseModel):\n    \"\"\"\n    Result of a webhook delivery operation.\n\n    Provides detailed information about the outcome of a delivery attempt.\n    \"\"\"\n\n    success: bool = Field(..., description=\"Whether delivery was successful\")\n    delivery_id: str = Field(..., description=\"ID of the delivery attempt\")\n    subscription_id: str = Field(..., description=\"ID of the subscription\")\n    event_id: str = Field(..., description=\"ID of the event\")\n\n    # Timing\n    timestamp: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Result timestamp\",\n    )\n    duration_ms: int = Field(default=0, ge=0, description=\"Delivery duration in milliseconds\")\n\n    # Status details\n    status_code: Optional[int] = Field(None, description=\"HTTP status code received\")\n    status: WebhookDeliveryStatus = Field(..., description=\"Final delivery status\")\n\n    # Retry information\n    attempt_number: int = Field(default=1, ge=1, description=\"Which attempt this was\")\n    should_retry: bool = Field(default=False, description=\"Whether delivery should be retried\")\n    retry_after_seconds: Optional[float] = Field(\n        None, ge=0, description=\"Seconds to wait before retry\"\n    )\n\n    # Error details\n    error_code: Optional[str] = Field(None, description=\"Error code if failed\")\n    error_message: Optional[str] = Field(\n        None, max_length=1000, description=\"Error message if failed\"\n    )\n    error_details: JSONDict = Field(\n        default_factory=dict, description=\"Additional error details\"\n    )\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    @classmethod\n    def success_result(\n        cls,\n        delivery_id: str,\n        subscription_id: str,\n        event_id: str,\n        status_code: int,\n        duration_ms: int,\n        attempt_number: int = 1,\n    ) -> \"WebhookDeliveryResult\":\n        \"\"\"Create a successful delivery result.\"\"\"\n        return cls(\n            success=True,\n            delivery_id=delivery_id,\n            subscription_id=subscription_id,\n            event_id=event_id,\n            status_code=status_code,\n            status=WebhookDeliveryStatus.DELIVERED,\n            duration_ms=duration_ms,\n            attempt_number=attempt_number,\n            should_retry=False,\n        )\n\n    @classmethod\n    def failure_result(\n        cls,\n        delivery_id: str,\n        subscription_id: str,\n        event_id: str,\n        error_code: str,\n        error_message: str,\n        status_code: Optional[int] = None,\n        duration_ms: int = 0,\n        attempt_number: int = 1,\n        should_retry: bool = True,\n        retry_after_seconds: Optional[float] = None,\n        max_attempts: int = 3,\n    ) -> \"WebhookDeliveryResult\":\n        \"\"\"Create a failed delivery result.\"\"\"\n        # Determine if we've exhausted retries\n        is_dead_lettered = not should_retry or attempt_number >= max_attempts\n\n        return cls(\n            success=False,\n            delivery_id=delivery_id,\n            subscription_id=subscription_id,\n            event_id=event_id,\n            status_code=status_code,\n            status=(\n                WebhookDeliveryStatus.DEAD_LETTERED\n                if is_dead_lettered\n                else WebhookDeliveryStatus.RETRYING\n            ),\n            duration_ms=duration_ms,\n            attempt_number=attempt_number,\n            should_retry=should_retry and attempt_number < max_attempts,\n            retry_after_seconds=retry_after_seconds,\n            error_code=error_code,\n            error_message=error_message,\n        )\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.206668",
  "last_updated": "2026-01-04T05:35:59.203351"
}