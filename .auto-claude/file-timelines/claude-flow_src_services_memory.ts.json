{
  "file_path": "claude-flow/src/services/memory.ts",
  "main_branch_history": [],
  "task_views": {
    "059-add-jsdoc-coverage-for-claude-flow-typescript-serv": {
      "task_id": "059-add-jsdoc-coverage-for-claude-flow-typescript-serv",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "import { createClient, RedisClientType } from 'redis';\nimport { MemoryConfig, MemoryEntry, MemorySearchResult } from '../types/memory';\nimport { logger } from '../utils/logger';\n\nexport class MemoryService {\n  private client: RedisClientType | null = null;\n  private readonly config: MemoryConfig;\n\n  constructor(config?: Partial<MemoryConfig>) {\n    this.config = {\n      url: process.env.REDIS_URL || 'redis://localhost:6379',\n      password: process.env.REDIS_PASSWORD,\n      defaultTtlSeconds: parseInt(process.env.MEMORY_DEFAULT_TTL_SECONDS || '86400', 10),\n      maxReconnectAttempts: parseInt(process.env.MEMORY_MAX_RECONNECT_ATTEMPTS || '10', 10),\n      ...config,\n    };\n  }\n\n  /**\n   * Initialize Redis connection\n   */\n  async initialize(): Promise<void> {\n    const isTLS = this.config.url.startsWith('rediss://');\n\n    this.client = createClient({\n      url: this.config.url,\n      password: this.config.password,\n      socket: {\n        reconnectStrategy: (retries) => {\n          if (retries > (this.config.maxReconnectAttempts || 10)) {\n            logger.error('Max Redis reconnection attempts reached');\n            return new Error('Max reconnection attempts reached');\n          }\n          const delay = Math.min(retries * 50, 500);\n          return delay;\n        },\n        ...(isTLS && {\n          tls: true,\n          rejectUnauthorized: false, // Allows self-signed certs\n        }),\n      },\n    });\n\n    this.client.on('error', (err) => logger.error('Redis Client Error', err));\n    this.client.on('connect', () => logger.info('Redis connected'));\n    this.client.on('reconnecting', () => logger.info('Redis reconnecting...'));\n    this.client.on('ready', () => logger.info('Redis client ready'));\n\n    try {\n      await this.client.connect();\n    } catch (err) {\n      logger.error('Failed to connect to Redis', err);\n      // Don't throw, allow degraded operation\n    }\n  }\n\n  /**\n   * Set a value in memory with optional TTL\n   */\n  async set(key: string, value: any, ttlSeconds?: number): Promise<void> {\n    if (!this.client || !this.client.isOpen) {\n      logger.warn('Redis client not connected, skipping set operation');\n      return;\n    }\n\n    try {\n      const serialized = JSON.stringify(value);\n      const ttl = ttlSeconds !== undefined ? ttlSeconds : this.config.defaultTtlSeconds;\n\n      if (ttl && ttl > 0) {\n        await this.client.set(key, serialized, { EX: ttl });\n      } else {\n        await this.client.set(key, serialized);\n      }\n    } catch (err) {\n      logger.error(`Error setting key ${key} in Redis`, err);\n    }\n  }\n\n  /**\n   * Get a value from memory\n   */\n  async get<T = any>(key: string): Promise<T | null> {\n    if (!this.client || !this.client.isOpen) {\n      logger.warn('Redis client not connected, skipping get operation');\n      return null;\n    }\n\n    try {\n      const value = await this.client.get(key);\n      if (!value) return null;\n\n      return JSON.parse(value) as T;\n    } catch (err) {\n      logger.error(`Error getting key ${key} from Redis`, err);\n      return null;\n    }\n  }\n\n  /**\n   * Delete a value from memory\n   */\n  async delete(key: string): Promise<void> {\n    if (!this.client || !this.client.isOpen) {\n      logger.warn('Redis client not connected, skipping delete operation');\n      return;\n    }\n\n    try {\n      await this.client.del(key);\n    } catch (err) {\n      logger.error(`Error deleting key ${key} from Redis`, err);\n    }\n  }\n\n  /**\n   * Cleanup keys matching a pattern\n   */\n  async cleanup(pattern: string = 'governance:*'): Promise<number> {\n    if (!this.client || !this.client.isOpen) {\n      logger.warn('Redis client not connected, skipping cleanup operation');\n      return 0;\n    }\n\n    let cursor = 0;\n    let deletedCount = 0;\n\n    try {\n      do {\n        const result = await this.client.scan(cursor, {\n          MATCH: pattern,\n          COUNT: 100,\n        });\n\n        cursor = result.cursor;\n        const keys = result.keys;\n\n        if (keys.length > 0) {\n          await this.client.del(keys);\n          deletedCount += keys.length;\n        }\n      } while (cursor !== 0);\n\n      logger.info(`Cleaned up ${deletedCount} keys matching pattern ${pattern}`);\n      return deletedCount;\n    } catch (err) {\n      logger.error(`Error during cleanup with pattern ${pattern}`, err);\n      return deletedCount;\n    }\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    if (this.client) {\n      try {\n        await this.client.quit();\n        logger.info('Redis client disconnected gracefully');\n      } catch (err) {\n        logger.error('Error during Redis disconnect', err);\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const memoryService = new MemoryService();\n",
        "timestamp": "2026-01-04T05:35:52.969195"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Add JSDoc coverage for claude-flow TypeScript service public exports",
        "description": "Add comprehensive JSDoc documentation to the 45 exported functions/classes across 17 TypeScript files in the claude-flow CLI tool to improve API documentation for enterprise users",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T05:35:53.008431",
  "last_updated": "2026-01-04T05:35:53.017315"
}