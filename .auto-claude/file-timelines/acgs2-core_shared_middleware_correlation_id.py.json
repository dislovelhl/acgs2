{
  "file_path": "src/core/shared/middleware/correlation_id.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Correlation ID Middleware\nConstitutional Hash: cdd01ef066bc6cf2\n\nFastAPI middleware for injecting and propagating correlation IDs across services.\nThis enables distributed tracing by ensuring every request has a unique identifier\nthat appears in all logs and is propagated via HTTP headers.\n\nFeatures:\n    - Extracts X-Request-ID from incoming requests or generates UUID if missing\n    - Integrates with OpenTelemetry trace IDs for observability correlation\n    - Binds correlation ID to structlog context (async-safe via contextvars)\n    - Propagates correlation ID in response headers for client-side tracing\n    - Clears context between requests to prevent leakage\n\nUsage:\n    from shared.middleware.correlation_id import correlation_id_middleware\n\n    # As decorator\n    @app.middleware(\"http\")\n    async def add_correlation_id(request, call_next):\n        return await correlation_id_middleware(request, call_next)\n\n    # Or use the class-based middleware\n    from shared.middleware.correlation_id import CorrelationIdMiddleware\n    app.add_middleware(CorrelationIdMiddleware, service_name=\"api_gateway\")\n\n    # Or use the convenience function\n    from shared.middleware.correlation_id import add_correlation_id_middleware\n    add_correlation_id_middleware(app, service_name=\"api_gateway\")\n\"\"\"\n\nimport uuid\nfrom typing import Any, Callable, Optional\n\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom shared.logging_config import (\n    bind_correlation_id,\n    clear_correlation_context,\n    get_current_trace_id,\n    get_logger,\n)\n\n# Header name for correlation ID (follows common conventions)\nCORRELATION_ID_HEADER = \"X-Request-ID\"\n\n# Alternative header names that may be used by different systems\nALTERNATIVE_HEADERS = [\n    \"X-Correlation-ID\",\n    \"X-Trace-ID\",\n    \"Request-Id\",\n]\n\n# Module-level logger\nlogger = get_logger(__name__)\n\n\ndef get_correlation_id(request: Request) -> str:\n    \"\"\"\n    Extract correlation ID from request headers or generate a new one.\n\n    Checks the primary X-Request-ID header first, then falls back to\n    alternative header names for compatibility with various tracing systems.\n\n    Args:\n        request: FastAPI/Starlette request object\n\n    Returns:\n        Correlation ID string (either extracted or newly generated UUID)\n    \"\"\"\n    # Try primary header first\n    correlation_id = request.headers.get(CORRELATION_ID_HEADER)\n\n    # Fall back to alternative headers\n    if not correlation_id:\n        for header in ALTERNATIVE_HEADERS:\n            correlation_id = request.headers.get(header)\n            if correlation_id:\n                break\n\n    # Generate new UUID if no header found\n    if not correlation_id:\n        correlation_id = str(uuid.uuid4())\n        logger.debug(\n            \"correlation_id_generated\",\n            correlation_id=correlation_id,\n            path=str(request.url.path),\n        )\n\n    return correlation_id\n\n\nasync def correlation_id_middleware(\n    request: Request,\n    call_next: Callable[[Request], Any],\n    service_name: Optional[str] = None,\n) -> Response:\n    \"\"\"\n    FastAPI middleware function for correlation ID injection and propagation.\n\n    This middleware should be registered EARLY in the middleware stack,\n    before any other middleware that performs logging.\n\n    Args:\n        request: FastAPI/Starlette request object\n        call_next: Next middleware or route handler\n        service_name: Optional service identifier for logs\n\n    Returns:\n        Response with X-Request-ID header set\n\n    Example:\n        @app.middleware(\"http\")\n        async def add_correlation_id(request, call_next):\n            return await correlation_id_middleware(request, call_next, \"api_gateway\")\n    \"\"\"\n    # Clear previous request context to prevent leakage\n    clear_correlation_context()\n\n    # Extract or generate correlation ID\n    correlation_id = get_correlation_id(request)\n\n    # Get OpenTelemetry trace ID if available\n    trace_id = get_current_trace_id()\n\n    # Build context for logging\n    log_context = {\"correlation_id\": correlation_id}\n    if trace_id:\n        log_context[\"trace_id\"] = trace_id\n    if service_name:\n        log_context[\"service\"] = service_name\n\n    # Bind to structlog context (async-safe via contextvars)\n    bind_correlation_id(correlation_id, trace_id=trace_id)\n\n    # Log request received (DEBUG level to avoid log spam)\n    logger.debug(\n        \"request_received\",\n        method=request.method,\n        path=str(request.url.path),\n        **log_context,\n    )\n\n    try:\n        # Process request\n        response = await call_next(request)\n\n        # Log request completed\n        logger.debug(\n            \"request_completed\",\n            method=request.method,\n            path=str(request.url.path),\n            status_code=response.status_code,\n            **log_context,\n        )\n\n    except Exception as exc:\n        # Log exception with correlation ID for tracing\n        logger.error(\n            \"request_failed\",\n            method=request.method,\n            path=str(request.url.path),\n            error_type=type(exc).__name__,\n            error_message=str(exc),\n            exc_info=True,\n            **log_context,\n        )\n        raise\n\n    # Propagate correlation ID in response headers\n    response.headers[CORRELATION_ID_HEADER] = correlation_id\n\n    return response\n\n\nclass CorrelationIdMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Class-based middleware for correlation ID injection and propagation.\n\n    This provides an alternative to the function-based middleware for\n    cases where class-based middleware is preferred.\n\n    Args:\n        app: FastAPI/Starlette application\n        service_name: Service identifier for logs\n\n    Usage:\n        app.add_middleware(CorrelationIdMiddleware, service_name=\"api_gateway\")\n    \"\"\"\n\n    def __init__(self, app: Any, service_name: Optional[str] = None):\n        \"\"\"\n        Initialize the correlation ID middleware.\n\n        Args:\n            app: FastAPI/Starlette application\n            service_name: Service identifier for logs\n        \"\"\"\n        super().__init__(app)\n        self.service_name = service_name\n\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        \"\"\"\n        Process the request with correlation ID handling.\n\n        Args:\n            request: FastAPI/Starlette request object\n            call_next: Next middleware or route handler\n\n        Returns:\n            Response with X-Request-ID header set\n        \"\"\"\n        return await correlation_id_middleware(\n            request,\n            call_next,\n            service_name=self.service_name,\n        )\n\n\ndef add_correlation_id_middleware(\n    app: Any,\n    service_name: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Convenience function to add correlation ID middleware to a FastAPI app.\n\n    This registers the middleware at the appropriate position in the\n    middleware stack (should be called early, before other middleware).\n\n    Args:\n        app: FastAPI application instance\n        service_name: Service identifier for logs\n\n    Example:\n        from fastapi import FastAPI\n        from shared.middleware.correlation_id import add_correlation_id_middleware\n\n        app = FastAPI()\n        add_correlation_id_middleware(app, service_name=\"api_gateway\")\n    \"\"\"\n    app.add_middleware(CorrelationIdMiddleware, service_name=service_name)\n    logger.info(\n        \"correlation_id_middleware_registered\",\n        service_name=service_name or \"unknown\",\n    )\n\n\n# Export public API\n__all__ = [\n    # Constants\n    \"CORRELATION_ID_HEADER\",\n    \"ALTERNATIVE_HEADERS\",\n    # Functions\n    \"get_correlation_id\",\n    \"correlation_id_middleware\",\n    \"add_correlation_id_middleware\",\n    # Classes\n    \"CorrelationIdMiddleware\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.266778",
  "last_updated": "2026-01-04T05:35:59.262747"
}