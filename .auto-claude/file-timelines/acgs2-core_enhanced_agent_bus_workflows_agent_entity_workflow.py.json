{
  "file_path": "src/core/enhanced_agent_bus/workflows/agent_entity_workflow.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Enhanced Agent Bus - Agent Entity Workflow\nConstitutional Hash: cdd01ef066bc6cf2\n\nLong-lived workflow representing a single agent instance lifecycle.\nImplements the Entity Workflow pattern (Actor Model) for agent management.\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nfrom .workflow_base import (\n    WorkflowContext,\n    WorkflowDefinition,\n    query,\n    signal,\n)\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentState(Enum):\n    \"\"\"Agent lifecycle states.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    INITIALIZING = \"initializing\"\n    IDLE = \"idle\"\n    PROCESSING = \"processing\"\n    SUSPENDED = \"suspended\"\n    RECOVERING = \"recovering\"\n    TERMINATING = \"terminating\"\n    TERMINATED = \"terminated\"\n    FAILED = \"failed\"\n\n\nclass TaskPriority(Enum):\n    \"\"\"Task priority levels.\"\"\"\n\n    LOW = 0\n    NORMAL = 1\n    HIGH = 2\n    CRITICAL = 3\n\n\n@dataclass\nclass AgentConfig:\n    \"\"\"Configuration for agent initialization.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    agent_id: str\n    agent_type: str\n    capabilities: List[str] = field(default_factory=list)\n    max_concurrent_tasks: int = 5\n    idle_timeout_seconds: float = 3600.0  # 1 hour\n    heartbeat_interval_seconds: float = 30.0\n    checkpoint_interval_seconds: float = 300.0  # 5 minutes\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"agent_id\": self.agent_id,\n            \"agent_type\": self.agent_type,\n            \"capabilities\": self.capabilities,\n            \"max_concurrent_tasks\": self.max_concurrent_tasks,\n            \"idle_timeout_seconds\": self.idle_timeout_seconds,\n            \"heartbeat_interval_seconds\": self.heartbeat_interval_seconds,\n            \"checkpoint_interval_seconds\": self.checkpoint_interval_seconds,\n            \"metadata\": self.metadata,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass Task:\n    \"\"\"Task to be executed by an agent.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    task_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    task_type: str = \"\"\n    payload: Dict[str, Any] = field(default_factory=dict)\n    priority: TaskPriority = TaskPriority.NORMAL\n    timeout_seconds: float = 300.0\n    retry_count: int = 0\n    max_retries: int = 3\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"task_id\": self.task_id,\n            \"task_type\": self.task_type,\n            \"payload\": self.payload,\n            \"priority\": self.priority.value,\n            \"timeout_seconds\": self.timeout_seconds,\n            \"retry_count\": self.retry_count,\n            \"max_retries\": self.max_retries,\n            \"created_at\": self.created_at.isoformat(),\n            \"metadata\": self.metadata,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass TaskResult:\n    \"\"\"Result of task execution.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    task_id: str\n    success: bool\n    result: Optional[Dict[str, Any]] = None\n    error: Optional[str] = None\n    duration_ms: float = 0.0\n    completed_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"task_id\": self.task_id,\n            \"success\": self.success,\n            \"result\": self.result,\n            \"error\": self.error,\n            \"duration_ms\": self.duration_ms,\n            \"completed_at\": self.completed_at.isoformat(),\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass AgentStatus:\n    \"\"\"Current status of an agent.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    agent_id: str\n    state: AgentState\n    current_task: Optional[str] = None\n    tasks_completed: int = 0\n    tasks_failed: int = 0\n    tasks_pending: int = 0\n    last_activity: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    uptime_seconds: float = 0.0\n    memory_usage_mb: float = 0.0\n    cpu_usage_percent: float = 0.0\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"agent_id\": self.agent_id,\n            \"state\": self.state.value,\n            \"current_task\": self.current_task,\n            \"tasks_completed\": self.tasks_completed,\n            \"tasks_failed\": self.tasks_failed,\n            \"tasks_pending\": self.tasks_pending,\n            \"last_activity\": self.last_activity.isoformat(),\n            \"uptime_seconds\": self.uptime_seconds,\n            \"memory_usage_mb\": self.memory_usage_mb,\n            \"cpu_usage_percent\": self.cpu_usage_percent,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass AgentResult:\n    \"\"\"Final result of agent lifecycle.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    agent_id: str\n    final_state: AgentState\n    total_tasks_completed: int = 0\n    total_tasks_failed: int = 0\n    total_runtime_seconds: float = 0.0\n    shutdown_reason: str = \"\"\n    checkpoints: List[Dict[str, Any]] = field(default_factory=list)\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"agent_id\": self.agent_id,\n            \"final_state\": self.final_state.value,\n            \"total_tasks_completed\": self.total_tasks_completed,\n            \"total_tasks_failed\": self.total_tasks_failed,\n            \"total_runtime_seconds\": self.total_runtime_seconds,\n            \"shutdown_reason\": self.shutdown_reason,\n            \"checkpoints\": self.checkpoints,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n@dataclass\nclass ShutdownRequest:\n    \"\"\"Request to shutdown an agent.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    agent_id: str\n    reason: str = \"requested\"\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"agent_id\": self.agent_id,\n            \"reason\": self.reason,\n            \"constitutional_hash\": self.constitutional_hash,\n        }\n\n\n# =============================================================================\n# Workflow Activities\n# =============================================================================\n\n\nclass WorkflowActivity:\n    \"\"\"Base class for workflow activities.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    activity_name: str = \"\"\n    activity_timeout_seconds: float = 60.0\n\n    @property\n    def name(self) -> str:\n        \"\"\"Activity name.\"\"\"\n        return self.activity_name or self.__class__.__name__\n\n    @property\n    def timeout_seconds(self) -> float:\n        \"\"\"Activity timeout.\"\"\"\n        return self.activity_timeout_seconds\n\n\nclass InitializeAgentActivity(WorkflowActivity):\n    \"\"\"Activity to initialize an agent.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    activity_name = \"initialize_agent\"\n    activity_timeout_seconds = 30.0\n\n    async def execute(self, config: AgentConfig, context: WorkflowContext) -> Dict[str, Any]:\n        \"\"\"Initialize the agent.\n\n        Args:\n            config: Agent configuration\n            context: Workflow context\n\n        Returns:\n            Initialization result\n        \"\"\"\n        logger.info(\n            f\"[{CONSTITUTIONAL_HASH}] Initializing agent {config.agent_id} \"\n            f\"of type {config.agent_type}\"\n        )\n\n        # Simulate initialization work\n        await asyncio.sleep(0.01)  # Small delay for realism\n\n        # Validate constitutional compliance\n        if config.constitutional_hash != CONSTITUTIONAL_HASH:\n            raise ValueError(\n                f\"Constitutional hash mismatch: expected {CONSTITUTIONAL_HASH}, \"\n                f\"got {config.constitutional_hash}\"\n            )\n\n        return {\n            \"status\": \"initialized\",\n            \"agent_id\": config.agent_id,\n            \"capabilities\": config.capabilities,\n            \"initialized_at\": datetime.now(timezone.utc).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n\nclass ExecuteTaskActivity(WorkflowActivity):\n    \"\"\"Activity to execute a task.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    activity_name = \"execute_task\"\n    activity_timeout_seconds = 300.0\n\n    async def execute(self, task: Task, context: WorkflowContext) -> TaskResult:\n        \"\"\"Execute a task.\n\n        Args:\n            task: Task to execute\n            context: Workflow context\n\n        Returns:\n            Task execution result\n        \"\"\"\n        start_time = datetime.now(timezone.utc)\n        logger.info(\n            f\"[{CONSTITUTIONAL_HASH}] Executing task {task.task_id} of type {task.task_type}\"\n        )\n\n        try:\n            # Validate constitutional compliance\n            if task.constitutional_hash != CONSTITUTIONAL_HASH:\n                raise ValueError(\"Constitutional hash mismatch\")\n\n            # Simulate task execution (would be replaced with actual logic)\n            await asyncio.sleep(0.01)\n\n            duration = (datetime.now(timezone.utc) - start_time).total_seconds() * 1000\n\n            return TaskResult(\n                task_id=task.task_id,\n                success=True,\n                result={\"processed\": True, \"task_type\": task.task_type},\n                duration_ms=duration,\n            )\n\n        except Exception as e:\n            duration = (datetime.now(timezone.utc) - start_time).total_seconds() * 1000\n            logger.error(f\"[{CONSTITUTIONAL_HASH}] Task {task.task_id} failed: {e}\")\n            return TaskResult(\n                task_id=task.task_id,\n                success=False,\n                error=str(e),\n                duration_ms=duration,\n            )\n\n\nclass CheckpointAgentActivity(WorkflowActivity):\n    \"\"\"Activity to checkpoint agent state.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    activity_name = \"checkpoint_agent\"\n    activity_timeout_seconds = 10.0\n\n    async def execute(self, status: AgentStatus, context: WorkflowContext) -> Dict[str, Any]:\n        \"\"\"Create a checkpoint of agent state.\n\n        Args:\n            status: Current agent status\n            context: Workflow context\n\n        Returns:\n            Checkpoint data\n        \"\"\"\n        logger.debug(f\"[{CONSTITUTIONAL_HASH}] Creating checkpoint for agent {status.agent_id}\")\n\n        checkpoint = {\n            \"checkpoint_id\": str(uuid.uuid4()),\n            \"agent_id\": status.agent_id,\n            \"state\": status.state.value,\n            \"tasks_completed\": status.tasks_completed,\n            \"tasks_failed\": status.tasks_failed,\n            \"checkpoint_time\": datetime.now(timezone.utc).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n        return checkpoint\n\n\nclass ShutdownAgentActivity(WorkflowActivity):\n    \"\"\"Activity to shutdown an agent.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    activity_name = \"shutdown_agent\"\n    activity_timeout_seconds = 30.0\n\n    async def execute(self, request: \"ShutdownRequest\", context: WorkflowContext) -> Dict[str, Any]:\n        \"\"\"Shutdown the agent.\n\n        Args:\n            request: Shutdown request containing agent_id and reason\n            context: Workflow context\n\n        Returns:\n            Shutdown result\n        \"\"\"\n        logger.info(\n            f\"[{CONSTITUTIONAL_HASH}] Shutting down agent {request.agent_id}: {request.reason}\"\n        )\n\n        # Simulate graceful shutdown\n        await asyncio.sleep(0.01)\n\n        return {\n            \"status\": \"shutdown\",\n            \"agent_id\": request.agent_id,\n            \"reason\": request.reason,\n            \"shutdown_at\": datetime.now(timezone.utc).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n\n# Activity instances for convenience\ninitialize_agent_activity = InitializeAgentActivity()\nexecute_task_activity = ExecuteTaskActivity()\ncheckpoint_agent_activity = CheckpointAgentActivity()\nshutdown_agent_activity = ShutdownAgentActivity()\n\n\n# =============================================================================\n# Agent Entity Workflow\n# =============================================================================\n\n\nclass AgentEntityWorkflow(WorkflowDefinition[AgentConfig, AgentResult]):\n    \"\"\"Long-lived workflow representing a single agent instance.\n\n    This workflow implements the Entity Workflow pattern (Actor Model):\n    - Receives tasks via signals\n    - Maintains agent state across tasks\n    - Supports queries for status inspection\n    - Handles graceful shutdown\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self._state: AgentState = AgentState.INITIALIZING\n        self._config: Optional[AgentConfig] = None\n        self._task_queue: asyncio.Queue[Task] = asyncio.Queue()\n        self._tasks_completed: int = 0\n        self._tasks_failed: int = 0\n        self._current_task: Optional[str] = None\n        self._shutdown_requested: bool = False\n        self._shutdown_reason: str = \"\"\n        self._suspend_requested: bool = False\n        self._checkpoints: List[Dict[str, Any]] = []\n        self._start_time: datetime = datetime.now(timezone.utc)\n        self._last_activity: datetime = datetime.now(timezone.utc)\n        self._task_results: List[TaskResult] = []\n\n    @property\n    def name(self) -> str:\n        \"\"\"Workflow name.\"\"\"\n        return \"AgentEntityWorkflow\"\n\n    @property\n    def state(self) -> AgentState:\n        \"\"\"Current agent state.\"\"\"\n        return self._state\n\n    @property\n    def config(self) -> Optional[AgentConfig]:\n        \"\"\"Agent configuration.\"\"\"\n        return self._config\n\n    async def run(self, config: AgentConfig) -> AgentResult:\n        \"\"\"Main workflow execution - agent lifecycle management.\n\n        Args:\n            config: Agent configuration\n\n        Returns:\n            Final agent result\n        \"\"\"\n        self._config = config\n        self._start_time = datetime.now(timezone.utc)\n\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Starting AgentEntityWorkflow for {config.agent_id}\")\n\n        try:\n            # Initialize agent\n            init_result = await self.execute_activity(\n                initialize_agent_activity,\n                config,\n            )\n            logger.debug(f\"Agent initialized: {init_result}\")\n            self._state = AgentState.IDLE\n            self._last_activity = datetime.now(timezone.utc)\n\n            # Main event loop - process tasks and signals\n            while self._state != AgentState.TERMINATED:\n                # Check for shutdown request\n                if self._shutdown_requested:\n                    await self._handle_shutdown()\n                    break\n\n                # Check for suspend request\n                if self._suspend_requested:\n                    self._state = AgentState.SUSPENDED\n                    await self._wait_for_resume()\n                    continue\n\n                # Process pending tasks\n                if not self._task_queue.empty():\n                    await self._process_next_task()\n                else:\n                    # Wait for new signals or timeout\n                    self._state = AgentState.IDLE\n                    try:\n                        # Wait for task with idle timeout\n                        await asyncio.wait_for(\n                            self._wait_for_task_or_signal(),\n                            timeout=config.idle_timeout_seconds,\n                        )\n                    except asyncio.TimeoutError:\n                        # Idle timeout - trigger shutdown\n                        logger.info(\n                            f\"[{CONSTITUTIONAL_HASH}] Agent {config.agent_id} idle timeout reached\"\n                        )\n                        self._shutdown_requested = True\n                        self._shutdown_reason = \"idle_timeout\"\n\n                # Periodic checkpoint\n                await self._maybe_checkpoint()\n\n        except asyncio.CancelledError:\n            logger.info(f\"[{CONSTITUTIONAL_HASH}] Agent {config.agent_id} cancelled\")\n            self._state = AgentState.TERMINATED\n            self._shutdown_reason = \"cancelled\"\n        except Exception as e:\n            logger.error(f\"[{CONSTITUTIONAL_HASH}] Agent {config.agent_id} failed: {e}\")\n            self._state = AgentState.FAILED\n            self._shutdown_reason = f\"error: {str(e)}\"\n\n        # Calculate final runtime\n        runtime = (datetime.now(timezone.utc) - self._start_time).total_seconds()\n\n        return AgentResult(\n            agent_id=config.agent_id,\n            final_state=self._state,\n            total_tasks_completed=self._tasks_completed,\n            total_tasks_failed=self._tasks_failed,\n            total_runtime_seconds=runtime,\n            shutdown_reason=self._shutdown_reason,\n            checkpoints=self._checkpoints,\n        )\n\n    async def _wait_for_task_or_signal(self) -> None:\n        \"\"\"Wait for a task to be queued or a signal to be received.\"\"\"\n        while (\n            self._task_queue.empty()\n            and not self._shutdown_requested\n            and not self._suspend_requested\n        ):\n            await asyncio.sleep(0.1)\n\n    async def _wait_for_resume(self) -> None:\n        \"\"\"Wait for resume signal when suspended.\"\"\"\n        while self._suspend_requested and not self._shutdown_requested:\n            await asyncio.sleep(0.1)\n        if not self._shutdown_requested:\n            self._state = AgentState.IDLE\n\n    async def _process_next_task(self) -> None:\n        \"\"\"Process the next task in the queue.\"\"\"\n        if self._task_queue.empty():\n            return\n\n        task = await self._task_queue.get()\n        self._state = AgentState.PROCESSING\n        self._current_task = task.task_id\n        self._last_activity = datetime.now(timezone.utc)\n\n        logger.debug(\n            f\"[{CONSTITUTIONAL_HASH}] Processing task {task.task_id} \"\n            f\"for agent {self._config.agent_id}\"\n        )\n\n        try:\n            result = await self.execute_activity(\n                execute_task_activity,\n                task,\n                timeout=task.timeout_seconds,\n            )\n\n            self._task_results.append(result)\n\n            if result.success:\n                self._tasks_completed += 1\n            else:\n                self._tasks_failed += 1\n                # Retry logic\n                if task.retry_count < task.max_retries:\n                    task.retry_count += 1\n                    await self._task_queue.put(task)\n                    logger.debug(\n                        f\"[{CONSTITUTIONAL_HASH}] Retrying task {task.task_id} \"\n                        f\"(attempt {task.retry_count})\"\n                    )\n\n        except Exception as e:\n            logger.error(f\"[{CONSTITUTIONAL_HASH}] Task processing error: {e}\")\n            self._tasks_failed += 1\n\n        finally:\n            self._current_task = None\n            self._state = AgentState.IDLE\n\n    async def _handle_shutdown(self) -> None:\n        \"\"\"Handle graceful shutdown.\"\"\"\n        self._state = AgentState.TERMINATING\n\n        # Shutdown activity\n        shutdown_request = ShutdownRequest(\n            agent_id=self._config.agent_id,\n            reason=self._shutdown_reason,\n        )\n        await self.execute_activity(\n            shutdown_agent_activity,\n            shutdown_request,\n        )\n\n        self._state = AgentState.TERMINATED\n\n    async def _maybe_checkpoint(self) -> None:\n        \"\"\"Create checkpoint if interval has passed.\"\"\"\n        if not self._config:\n            return\n\n        if not self._checkpoints:\n            # Create initial checkpoint\n            await self._create_checkpoint()\n            return\n\n        last_checkpoint_time = datetime.fromisoformat(\n            self._checkpoints[-1].get(\"checkpoint_time\", \"\")\n        )\n        elapsed = (datetime.now(timezone.utc) - last_checkpoint_time).total_seconds()\n\n        if elapsed >= self._config.checkpoint_interval_seconds:\n            await self._create_checkpoint()\n\n    async def _create_checkpoint(self) -> None:\n        \"\"\"Create a state checkpoint.\"\"\"\n        status = self._get_status()\n        checkpoint = await self.execute_activity(\n            checkpoint_agent_activity,\n            status,\n        )\n        self._checkpoints.append(checkpoint)\n\n    def _get_status(self) -> AgentStatus:\n        \"\"\"Get current agent status.\"\"\"\n        uptime = (datetime.now(timezone.utc) - self._start_time).total_seconds()\n        return AgentStatus(\n            agent_id=self._config.agent_id if self._config else \"\",\n            state=self._state,\n            current_task=self._current_task,\n            tasks_completed=self._tasks_completed,\n            tasks_failed=self._tasks_failed,\n            tasks_pending=self._task_queue.qsize(),\n            last_activity=self._last_activity,\n            uptime_seconds=uptime,\n        )\n\n    # =========================================================================\n    # Signals\n    # =========================================================================\n\n    @signal(\"assign_task\")\n    async def assign_task(self, task: Task) -> None:\n        \"\"\"Signal handler to assign a new task.\n\n        Args:\n            task: Task to assign\n        \"\"\"\n        logger.debug(f\"[{CONSTITUTIONAL_HASH}] Task {task.task_id} assigned to agent\")\n        await self._task_queue.put(task)\n        self._last_activity = datetime.now(timezone.utc)\n\n    @signal(\"suspend\")\n    async def suspend(self, reason: str = \"\") -> None:\n        \"\"\"Signal handler to suspend the agent.\n\n        Args:\n            reason: Suspension reason\n        \"\"\"\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Agent suspend requested: {reason}\")\n        self._suspend_requested = True\n\n    @signal(\"resume\")\n    async def resume(self, _data: Any = None) -> None:\n        \"\"\"Signal handler to resume a suspended agent.\"\"\"\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Agent resume requested\")\n        self._suspend_requested = False\n\n    @signal(\"shutdown\")\n    async def shutdown(self, reason: str = \"requested\") -> None:\n        \"\"\"Signal handler to initiate graceful shutdown.\n\n        Args:\n            reason: Shutdown reason\n        \"\"\"\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Agent shutdown requested: {reason}\")\n        self._shutdown_requested = True\n        self._shutdown_reason = reason\n\n    @signal(\"update_config\")\n    async def update_config(self, updates: Dict[str, Any]) -> None:\n        \"\"\"Signal handler to update agent configuration.\n\n        Args:\n            updates: Configuration updates\n        \"\"\"\n        if self._config:\n            for key, value in updates.items():\n                if hasattr(self._config, key):\n                    setattr(self._config, key, value)\n            logger.debug(f\"[{CONSTITUTIONAL_HASH}] Config updated: {updates}\")\n\n    # =========================================================================\n    # Queries\n    # =========================================================================\n\n    @query(\"get_status\")\n    def get_status(self) -> AgentStatus:\n        \"\"\"Query handler to get current agent status.\n\n        Returns:\n            Current agent status\n        \"\"\"\n        return self._get_status()\n\n    @query(\"get_state\")\n    def get_state(self) -> AgentState:\n        \"\"\"Query handler to get current agent state.\n\n        Returns:\n            Current agent state\n        \"\"\"\n        return self._state\n\n    @query(\"get_task_results\")\n    def get_task_results(self) -> List[TaskResult]:\n        \"\"\"Query handler to get task results.\n\n        Returns:\n            List of task results\n        \"\"\"\n        return self._task_results.copy()\n\n    @query(\"get_pending_tasks\")\n    def get_pending_tasks(self) -> int:\n        \"\"\"Query handler to get pending task count.\n\n        Returns:\n            Number of pending tasks\n        \"\"\"\n        return self._task_queue.qsize()\n\n    @query(\"get_checkpoints\")\n    def get_checkpoints(self) -> List[Dict[str, Any]]:\n        \"\"\"Query handler to get checkpoints.\n\n        Returns:\n            List of checkpoints\n        \"\"\"\n        return self._checkpoints.copy()\n\n\n__all__ = [\n    # Enums\n    \"AgentState\",\n    \"TaskPriority\",\n    # Data classes\n    \"AgentConfig\",\n    \"Task\",\n    \"TaskResult\",\n    \"AgentStatus\",\n    \"AgentResult\",\n    \"ShutdownRequest\",\n    # Activities\n    \"WorkflowActivity\",\n    \"InitializeAgentActivity\",\n    \"ExecuteTaskActivity\",\n    \"CheckpointAgentActivity\",\n    \"ShutdownAgentActivity\",\n    \"initialize_agent_activity\",\n    \"execute_task_activity\",\n    \"checkpoint_agent_activity\",\n    \"shutdown_agent_activity\",\n    # Workflow\n    \"AgentEntityWorkflow\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.172525",
  "last_updated": "2026-01-04T05:35:58.545450"
}