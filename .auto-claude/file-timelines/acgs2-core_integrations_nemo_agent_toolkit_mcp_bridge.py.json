{
  "file_path": "src/core/integrations/nemo_agent_toolkit/mcp_bridge.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 MCP Bridge for NeMo-Agent-Toolkit\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides Model Context Protocol (MCP) server and client implementations\nfor integrating ACGS-2 constitutional governance with NeMo agents.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport hashlib\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom datetime import UTC, datetime\nfrom enum import Enum\nfrom typing import TYPE_CHECKING, Any, Callable\n\nif TYPE_CHECKING:\n    pass\n\nCONSTITUTIONAL_HASH: str = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\n\nclass MCPToolType(str, Enum):\n    \"\"\"Types of MCP tools provided by ACGS-2.\"\"\"\n\n    VALIDATE_CONSTITUTIONAL = \"validate_constitutional\"\n    CHECK_COMPLIANCE = \"check_compliance\"\n    AUDIT_ACTION = \"audit_action\"\n    GET_POLICIES = \"get_policies\"\n    SUBMIT_APPROVAL = \"submit_approval\"\n    CHECK_GOVERNANCE = \"check_governance\"\n\n\n@dataclass\nclass MCPToolDefinition:\n    \"\"\"Definition of an MCP tool.\"\"\"\n\n    name: str\n    description: str\n    input_schema: dict[str, Any]\n    constitutional_required: bool = True\n\n\n@dataclass\nclass MCPToolResult:\n    \"\"\"Result from an MCP tool execution.\"\"\"\n\n    success: bool\n    data: Any\n    error: str | None = None\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"success\": self.success,\n            \"data\": self.data,\n            \"error\": self.error,\n            \"constitutional_hash\": self.constitutional_hash,\n            \"timestamp\": self.timestamp.isoformat(),\n        }\n\n\n@dataclass\nclass ConstitutionalMCPTool:\n    \"\"\"An MCP tool with constitutional validation.\"\"\"\n\n    definition: MCPToolDefinition\n    handler: Callable[..., Any]\n    requires_approval: bool = False\n    audit_enabled: bool = True\n\n\nclass ACGS2MCPServer:\n    \"\"\"\n    MCP Server exposing ACGS-2 constitutional governance tools.\n\n    Implements the Model Context Protocol to allow NeMo agents\n    to access ACGS-2's constitutional validation, compliance checking,\n    and governance features.\n    \"\"\"\n\n    def __init__(\n        self,\n        acgs2_client: Any | None = None,\n        enable_audit: bool = True,\n    ) -> None:\n        \"\"\"\n        Initialize the MCP server.\n\n        Args:\n            acgs2_client: ACGS-2 SDK client for backend operations\n            enable_audit: Enable audit logging for all tool calls\n        \"\"\"\n        self._client = acgs2_client\n        self._enable_audit = enable_audit\n        self._tools: dict[str, ConstitutionalMCPTool] = {}\n        self._audit_log: list[dict[str, Any]] = []\n\n        self._register_default_tools()\n\n    def _register_default_tools(self) -> None:\n        \"\"\"Register default ACGS-2 MCP tools.\"\"\"\n        # Validate Constitutional tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_validate_constitutional\",\n                    description=\"Validate an action against ACGS-2 constitutional principles\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"agent_id\": {\n                                \"type\": \"string\",\n                                \"description\": \"ID of the agent performing the action\",\n                            },\n                            \"action\": {\n                                \"type\": \"string\",\n                                \"description\": \"The action to validate\",\n                            },\n                            \"context\": {\n                                \"type\": \"object\",\n                                \"description\": \"Context for the validation\",\n                            },\n                        },\n                        \"required\": [\"agent_id\", \"action\"],\n                    },\n                ),\n                handler=self._handle_validate_constitutional,\n            )\n        )\n\n        # Check Compliance tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_check_compliance\",\n                    description=\"Check if an action complies with active policies\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"policy_id\": {\n                                \"type\": \"string\",\n                                \"description\": \"ID of the policy to check against\",\n                            },\n                            \"context\": {\n                                \"type\": \"object\",\n                                \"description\": \"Context for compliance check\",\n                            },\n                        },\n                        \"required\": [\"context\"],\n                    },\n                ),\n                handler=self._handle_check_compliance,\n            )\n        )\n\n        # Audit Action tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_audit_action\",\n                    description=\"Record an action in the ACGS-2 audit trail\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"action\": {\n                                \"type\": \"string\",\n                                \"description\": \"The action performed\",\n                            },\n                            \"actor\": {\n                                \"type\": \"string\",\n                                \"description\": \"Who performed the action\",\n                            },\n                            \"resource\": {\n                                \"type\": \"string\",\n                                \"description\": \"Resource affected\",\n                            },\n                            \"outcome\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"success\", \"failure\", \"pending\"],\n                                \"description\": \"Outcome of the action\",\n                            },\n                            \"details\": {\n                                \"type\": \"object\",\n                                \"description\": \"Additional details\",\n                            },\n                        },\n                        \"required\": [\"action\", \"actor\", \"resource\", \"outcome\"],\n                    },\n                ),\n                handler=self._handle_audit_action,\n            )\n        )\n\n        # Get Policies tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_get_policies\",\n                    description=\"Get active policies from ACGS-2\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"tags\": {\n                                \"type\": \"array\",\n                                \"items\": {\"type\": \"string\"},\n                                \"description\": \"Filter by tags\",\n                            },\n                            \"status\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"active\", \"inactive\", \"draft\"],\n                                \"description\": \"Filter by status\",\n                            },\n                        },\n                    },\n                ),\n                handler=self._handle_get_policies,\n            )\n        )\n\n        # Submit Approval tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_submit_approval\",\n                    description=\"Submit an approval request for governance review\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"request_type\": {\n                                \"type\": \"string\",\n                                \"description\": \"Type of approval request\",\n                            },\n                            \"payload\": {\n                                \"type\": \"object\",\n                                \"description\": \"Request payload\",\n                            },\n                            \"risk_score\": {\n                                \"type\": \"number\",\n                                \"minimum\": 0,\n                                \"maximum\": 100,\n                                \"description\": \"Risk score (0-100)\",\n                            },\n                        },\n                        \"required\": [\"request_type\", \"payload\"],\n                    },\n                ),\n                handler=self._handle_submit_approval,\n                requires_approval=True,\n            )\n        )\n\n        # Check Governance tool\n        self.register_tool(\n            ConstitutionalMCPTool(\n                definition=MCPToolDefinition(\n                    name=\"acgs2_check_governance\",\n                    description=\"Check governance status and metrics\",\n                    input_schema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"include_metrics\": {\n                                \"type\": \"boolean\",\n                                \"description\": \"Include governance metrics\",\n                            },\n                        },\n                    },\n                ),\n                handler=self._handle_check_governance,\n            )\n        )\n\n    def register_tool(self, tool: ConstitutionalMCPTool) -> None:\n        \"\"\"Register an MCP tool.\"\"\"\n        self._tools[tool.definition.name] = tool\n        logger.info(f\"Registered MCP tool: {tool.definition.name}\")\n\n    def get_tool_definitions(self) -> list[dict[str, Any]]:\n        \"\"\"Get all tool definitions for MCP protocol.\"\"\"\n        return [\n            {\n                \"name\": tool.definition.name,\n                \"description\": tool.definition.description,\n                \"inputSchema\": tool.definition.input_schema,\n            }\n            for tool in self._tools.values()\n        ]\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any],\n    ) -> MCPToolResult:\n        \"\"\"\n        Call an MCP tool.\n\n        Args:\n            name: Tool name\n            arguments: Tool arguments\n\n        Returns:\n            MCPToolResult with execution outcome\n        \"\"\"\n        if name not in self._tools:\n            return MCPToolResult(\n                success=False,\n                data=None,\n                error=f\"Unknown tool: {name}\",\n            )\n\n        tool = self._tools[name]\n        trace_id = hashlib.sha256(f\"{name}-{datetime.now(UTC).isoformat()}\".encode()).hexdigest()[\n            :16\n        ]\n\n        try:\n            # Validate constitutional hash in arguments if required\n            if tool.definition.constitutional_required:\n                provided_hash = arguments.pop(\"constitutional_hash\", None)\n                if provided_hash and provided_hash != CONSTITUTIONAL_HASH:\n                    return MCPToolResult(\n                        success=False,\n                        data=None,\n                        error=f\"Constitutional hash mismatch. Expected {CONSTITUTIONAL_HASH}\",\n                    )\n\n            # Execute tool handler\n            result = tool.handler(**arguments)\n            if asyncio.iscoroutine(result):\n                result = await result\n\n            # Audit if enabled\n            if self._enable_audit and tool.audit_enabled:\n                self._audit_tool_call(trace_id, name, arguments, result, None)\n\n            return MCPToolResult(\n                success=True,\n                data=result,\n            )\n\n        except Exception as e:\n            logger.error(f\"Tool {name} execution failed: {e}\")\n            if self._enable_audit:\n                self._audit_tool_call(trace_id, name, arguments, None, str(e))\n            return MCPToolResult(\n                success=False,\n                data=None,\n                error=str(e),\n            )\n\n    def _audit_tool_call(\n        self,\n        trace_id: str,\n        tool_name: str,\n        arguments: dict[str, Any],\n        result: Any,\n        error: str | None,\n    ) -> None:\n        \"\"\"Audit a tool call.\"\"\"\n        entry = {\n            \"trace_id\": trace_id,\n            \"tool_name\": tool_name,\n            \"arguments_hash\": hashlib.sha256(\n                json.dumps(arguments, sort_keys=True).encode()\n            ).hexdigest()[:16],\n            \"success\": error is None,\n            \"error\": error,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n        self._audit_log.append(entry)\n\n    async def _handle_validate_constitutional(\n        self,\n        agent_id: str,\n        action: str,\n        context: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Handle constitutional validation.\"\"\"\n        if self._client:\n            try:\n                from acgs2_sdk import GovernanceService\n\n                governance = GovernanceService(self._client)\n                result = await governance.validate_constitutional(\n                    agent_id=agent_id,\n                    action=action,\n                    context=context or {},\n                )\n                return result\n            except Exception as e:\n                logger.warning(f\"ACGS-2 validation failed: {e}\")\n\n        # Fallback to local validation\n        return {\n            \"valid\": True,\n            \"agent_id\": agent_id,\n            \"action\": action,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            \"validated_at\": datetime.now(UTC).isoformat(),\n        }\n\n    async def _handle_check_compliance(\n        self,\n        context: dict[str, Any],\n        policy_id: str | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Handle compliance check.\"\"\"\n        if self._client:\n            try:\n                from acgs2_sdk import ComplianceService\n\n                compliance = ComplianceService(self._client)\n\n                if policy_id:\n                    from acgs2_sdk import ValidateComplianceRequest\n\n                    result = await compliance.validate(\n                        ValidateComplianceRequest(\n                            policy_id=policy_id,\n                            context=context,\n                        )\n                    )\n                    return result.model_dump()\n                else:\n                    result = await compliance.validate_action(\n                        agent_id=context.get(\"agent_id\", \"nemo-agent\"),\n                        action=context.get(\"action\", \"unknown\"),\n                        context=context,\n                    )\n                    return result\n            except Exception as e:\n                logger.warning(f\"ACGS-2 compliance check failed: {e}\")\n\n        return {\n            \"compliant\": True,\n            \"policy_id\": policy_id,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            \"checked_at\": datetime.now(UTC).isoformat(),\n        }\n\n    async def _handle_audit_action(\n        self,\n        action: str,\n        actor: str,\n        resource: str,\n        outcome: str,\n        details: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Handle audit action recording.\"\"\"\n        if self._client:\n            try:\n                from acgs2_sdk import AuditService, EventCategory, EventSeverity\n\n                audit = AuditService(self._client)\n                event = await audit.record(\n                    category=EventCategory.AGENT,\n                    severity=EventSeverity.INFO,\n                    action=action,\n                    actor=actor,\n                    resource=resource,\n                    outcome=outcome,\n                    details=details,\n                )\n                return {\"event_id\": str(event.id), \"recorded\": True}\n            except Exception as e:\n                logger.warning(f\"ACGS-2 audit recording failed: {e}\")\n\n        return {\n            \"event_id\": hashlib.sha256(\n                f\"{action}-{actor}-{datetime.now(UTC).isoformat()}\".encode()\n            ).hexdigest()[:16],\n            \"recorded\": True,\n            \"local_only\": True,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n    async def _handle_get_policies(\n        self,\n        tags: list[str] | None = None,\n        status: str | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Handle getting policies.\"\"\"\n        if self._client:\n            try:\n                from acgs2_sdk import PolicyService\n\n                policies = PolicyService(self._client)\n                result = await policies.list(tags=tags, status=status)\n                return {\n                    \"policies\": [p.model_dump() for p in result.data],\n                    \"total\": result.total,\n                }\n            except Exception as e:\n                logger.warning(f\"ACGS-2 get policies failed: {e}\")\n\n        return {\n            \"policies\": [],\n            \"total\": 0,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n    async def _handle_submit_approval(\n        self,\n        request_type: str,\n        payload: dict[str, Any],\n        risk_score: float | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Handle approval submission.\"\"\"\n        if self._client:\n            try:\n                from acgs2_sdk import CreateApprovalRequest, GovernanceService\n\n                governance = GovernanceService(self._client)\n                approval = await governance.create_approval_request(\n                    CreateApprovalRequest(\n                        request_type=request_type,\n                        payload=payload,\n                        risk_score=risk_score or 50,\n                    )\n                )\n                return {\n                    \"approval_id\": str(approval.id),\n                    \"status\": approval.status.value,\n                    \"submitted\": True,\n                }\n            except Exception as e:\n                logger.warning(f\"ACGS-2 approval submission failed: {e}\")\n\n        return {\n            \"approval_id\": hashlib.sha256(\n                f\"{request_type}-{datetime.now(UTC).isoformat()}\".encode()\n            ).hexdigest()[:16],\n            \"status\": \"pending\",\n            \"submitted\": True,\n            \"local_only\": True,\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n    async def _handle_check_governance(\n        self,\n        include_metrics: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Handle governance status check.\"\"\"\n        result = {\n            \"status\": \"operational\",\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n        }\n\n        if self._client:\n            try:\n                from acgs2_sdk import GovernanceService\n\n                governance = GovernanceService(self._client)\n                if include_metrics:\n                    metrics = await governance.get_metrics()\n                    result[\"metrics\"] = metrics\n                dashboard = await governance.get_dashboard()\n                result[\"dashboard\"] = dashboard\n            except Exception as e:\n                logger.warning(f\"ACGS-2 governance check failed: {e}\")\n\n        if include_metrics and \"metrics\" not in result:\n            result[\"metrics\"] = {\n                \"total_decisions\": len(self._audit_log),\n                \"compliance_rate\": 1.0,\n            }\n\n        return result\n\n    def get_audit_log(self) -> list[dict[str, Any]]:\n        \"\"\"Get the audit log.\"\"\"\n        return self._audit_log.copy()\n\n\nclass ACGS2MCPClient:\n    \"\"\"\n    MCP Client for connecting to ACGS-2 MCP servers.\n\n    Allows NeMo agents to connect to remote ACGS-2 services\n    via the MCP protocol.\n    \"\"\"\n\n    def __init__(\n        self,\n        server_url: str,\n        api_key: str | None = None,\n    ) -> None:\n        \"\"\"\n        Initialize MCP client.\n\n        Args:\n            server_url: URL of the ACGS-2 MCP server\n            api_key: Optional API key for authentication\n        \"\"\"\n        self._server_url = server_url\n        self._api_key = api_key\n        self._connected = False\n        self._tools: list[dict[str, Any]] = []\n\n    async def connect(self) -> None:\n        \"\"\"Connect to the MCP server.\"\"\"\n        # Implementation would use WebSocket or HTTP\n        # For now, simulate connection\n        self._connected = True\n        logger.info(f\"Connected to ACGS-2 MCP server at {self._server_url}\")\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from the MCP server.\"\"\"\n        self._connected = False\n        logger.info(\"Disconnected from ACGS-2 MCP server\")\n\n    async def list_tools(self) -> list[dict[str, Any]]:\n        \"\"\"List available tools from the server.\"\"\"\n        if not self._connected:\n            raise RuntimeError(\"Not connected to MCP server\")\n        return self._tools\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any],\n    ) -> MCPToolResult:\n        \"\"\"\n        Call a tool on the MCP server.\n\n        Args:\n            name: Tool name\n            arguments: Tool arguments\n\n        Returns:\n            MCPToolResult with execution outcome\n        \"\"\"\n        if not self._connected:\n            raise RuntimeError(\"Not connected to MCP server\")\n\n        # Add constitutional hash to all requests\n        arguments[\"constitutional_hash\"] = CONSTITUTIONAL_HASH\n\n        # Implementation would make HTTP/WebSocket call\n        # For now, return placeholder\n        return MCPToolResult(\n            success=True,\n            data={\"tool\": name, \"arguments\": arguments},\n        )\n\n    async def validate_constitutional(\n        self,\n        agent_id: str,\n        action: str,\n        context: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Convenience method for constitutional validation.\"\"\"\n        result = await self.call_tool(\n            \"acgs2_validate_constitutional\",\n            {\n                \"agent_id\": agent_id,\n                \"action\": action,\n                \"context\": context or {},\n            },\n        )\n        return result.data if result.success else {\"valid\": False, \"error\": result.error}\n\n    async def check_compliance(\n        self,\n        context: dict[str, Any],\n        policy_id: str | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Convenience method for compliance checking.\"\"\"\n        result = await self.call_tool(\n            \"acgs2_check_compliance\",\n            {\n                \"context\": context,\n                \"policy_id\": policy_id,\n            },\n        )\n        return result.data if result.success else {\"compliant\": False, \"error\": result.error}\n\n    async def audit_action(\n        self,\n        action: str,\n        actor: str,\n        resource: str,\n        outcome: str,\n        details: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Convenience method for audit recording.\"\"\"\n        result = await self.call_tool(\n            \"acgs2_audit_action\",\n            {\n                \"action\": action,\n                \"actor\": actor,\n                \"resource\": resource,\n                \"outcome\": outcome,\n                \"details\": details,\n            },\n        )\n        return result.data if result.success else {\"recorded\": False, \"error\": result.error}\n\n    async def __aenter__(self) -> ACGS2MCPClient:\n        \"\"\"Async context manager entry.\"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.disconnect()\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.297506",
  "last_updated": "2026-01-04T05:35:58.483443"
}