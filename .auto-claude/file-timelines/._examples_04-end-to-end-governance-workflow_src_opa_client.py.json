{
  "file_path": "./examples/04-end-to-end-governance-workflow/src/opa_client.py",
  "main_branch_history": [],
  "task_views": {
    "061-create-end-to-end-governance-workflow-examples-wit": {
      "task_id": "061-create-end-to-end-governance-workflow-examples-wit",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "#!/usr/bin/env python3\n\"\"\"\nOPA Client Module for ACGS-2 Governance Workflow\n\nProvides a robust OPA client with connection handling, retry logic, caching,\nand batch evaluation capabilities. This module handles all OPA communication\nfor the governance workflow orchestrator.\n\nUsage:\n    from src.opa_client import OPAClient, OPAConfig\n\n    config = OPAConfig(\n        url=\"http://localhost:8181\",\n        timeout=5,\n        max_retries=3,\n        retry_delay=1.0\n    )\n    client = OPAClient(config)\n\n    # Health check\n    if not client.health_check():\n        print(\"OPA is not available\")\n\n    # Evaluate a policy\n    result = client.evaluate_policy(\n        policy_path=\"acgs2/constitutional/validate\",\n        input_data={\"action_type\": \"read_data\", ...}\n    )\n\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport logging\nimport time\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\nfrom typing import Any\n\nimport requests\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n\n# Custom exceptions for OPA client errors\nclass OPAConnectionError(Exception):\n    \"\"\"Raised when OPA service is unreachable\"\"\"\n\n    pass\n\n\nclass OPAPolicyError(Exception):\n    \"\"\"Raised when policy evaluation fails\"\"\"\n\n    pass\n\n\nclass OPATimeoutError(Exception):\n    \"\"\"Raised when OPA request times out\"\"\"\n\n    pass\n\n\n@dataclass\nclass OPAConfig:\n    \"\"\"Configuration for OPA client connection\"\"\"\n\n    url: str = \"http://localhost:8181\"\n    timeout: int = 5\n    max_retries: int = 3\n    retry_delay: float = 1.0\n\n\nclass OPAClient:\n    \"\"\"\n    Robust OPA client with health checks, retry logic, and response caching.\n\n    This client handles all communication with the OPA service, providing\n    robust error handling, exponential backoff retry logic, and optional\n    caching for improved performance.\n\n    Attributes:\n        base_url: Base URL for OPA service (e.g., http://localhost:8181)\n        timeout: Request timeout in seconds\n        max_retries: Maximum number of retry attempts\n        retry_delay: Initial delay between retries in seconds\n        session: Persistent HTTP session for connection pooling\n        _cache: Simple in-memory cache for policy evaluations\n    \"\"\"\n\n    def __init__(self, config: OPAConfig):\n        \"\"\"\n        Initialize OPA client with configuration.\n\n        Args:\n            config: OPAConfig instance with connection settings\n        \"\"\"\n        self.base_url = config.url.rstrip(\"/\")\n        self.timeout = config.timeout\n        self.max_retries = config.max_retries\n        self.retry_delay = config.retry_delay\n        self.session = requests.Session()\n        self.session.headers.update({\"Content-Type\": \"application/json\"})\n        self._cache: dict[str, dict] = {}\n\n        logger.info(f\"OPA client initialized for {self.base_url}\")\n\n    def health_check(self) -> bool:\n        \"\"\"\n        Check if OPA service is available and healthy.\n\n        Returns:\n            True if OPA is healthy and responding, False otherwise\n        \"\"\"\n        try:\n            response = self.session.get(\n                f\"{self.base_url}/health\", timeout=self.timeout\n            )\n            is_healthy = response.status_code == 200\n            if is_healthy:\n                logger.debug(\"OPA health check passed\")\n            else:\n                logger.warning(\n                    f\"OPA health check failed with status {response.status_code}\"\n                )\n            return is_healthy\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"OPA health check failed: {e}\")\n            return False\n\n    def evaluate_policy(\n        self, policy_path: str, input_data: dict, use_cache: bool = False\n    ) -> dict:\n        \"\"\"\n        Evaluate a policy with input data, with optional caching and retry logic.\n\n        Args:\n            policy_path: OPA policy path (e.g., \"acgs2/constitutional/validate\")\n            input_data: Dictionary containing the policy input\n            use_cache: If True, cache the result and return cached results for\n                      identical requests (default: False for governance decisions)\n\n        Returns:\n            Dictionary containing the policy evaluation result from OPA\n\n        Raises:\n            OPAConnectionError: If OPA service is unreachable\n            OPATimeoutError: If the request times out\n            OPAPolicyError: If policy evaluation returns an error\n\n        Example:\n            result = client.evaluate_policy(\n                policy_path=\"acgs2/agent_actions/evaluate\",\n                input_data={\n                    \"action_type\": \"read_data\",\n                    \"environment\": \"production\",\n                    \"resource\": \"customer_data\"\n                }\n            )\n            allowed = result.get(\"result\", {}).get(\"allowed\", False)\n        \"\"\"\n        # Check cache if enabled\n        cache_key = self._make_cache_key(policy_path, input_data)\n        if use_cache and cache_key in self._cache:\n            logger.debug(f\"Cache hit for policy {policy_path}\")\n            return self._cache[cache_key]\n\n        # Prepare the request\n        url = f\"{self.base_url}/v1/data/{policy_path}\"\n        payload = {\"input\": input_data}\n\n        # Execute with retry logic\n        def _query() -> dict:\n            try:\n                response = self.session.post(\n                    url, json=payload, timeout=self.timeout\n                )\n                response.raise_for_status()\n                result = response.json()\n\n                # Cache the result if caching is enabled\n                if use_cache:\n                    self._cache[cache_key] = result\n\n                return result\n\n            except requests.exceptions.ConnectionError as e:\n                logger.error(f\"Failed to connect to OPA at {self.base_url}: {e}\")\n                raise OPAConnectionError(\n                    f\"OPA service is unreachable at {self.base_url}. \"\n                    f\"Please ensure OPA is running.\"\n                ) from e\n\n            except requests.exceptions.Timeout as e:\n                logger.error(f\"OPA request timed out after {self.timeout}s: {e}\")\n                raise OPATimeoutError(\n                    f\"OPA request timed out after {self.timeout} seconds\"\n                ) from e\n\n            except requests.exceptions.HTTPError as e:\n                logger.error(\n                    f\"OPA policy evaluation failed for {policy_path}: \"\n                    f\"{e.response.status_code} - {e.response.text}\"\n                )\n                raise OPAPolicyError(\n                    f\"Policy evaluation failed: {e.response.status_code} - \"\n                    f\"{e.response.text}\"\n                ) from e\n\n            except requests.exceptions.RequestException as e:\n                logger.error(f\"OPA request failed: {e}\")\n                raise OPAPolicyError(f\"OPA request failed: {str(e)}\") from e\n\n        # Retry with exponential backoff\n        return self._retry_with_backoff(_query)\n\n    def evaluate_policies_batch(\n        self, evaluations: list[tuple[str, dict]]\n    ) -> list[dict]:\n        \"\"\"\n        Batch evaluate multiple policies in sequence.\n\n        This method evaluates multiple policies sequentially. For true parallel\n        evaluation, consider using asyncio or threading.\n\n        Args:\n            evaluations: List of (policy_path, input_data) tuples\n\n        Returns:\n            List of policy evaluation results in the same order as input\n\n        Raises:\n            OPAConnectionError: If OPA service is unreachable\n            OPATimeoutError: If any request times out\n            OPAPolicyError: If any policy evaluation fails\n\n        Example:\n            results = client.evaluate_policies_batch([\n                (\"acgs2/constitutional/validate\", action_request),\n                (\"acgs2/agent_actions/evaluate\", action_request),\n                (\"acgs2/hitl/determine\", action_request),\n            ])\n            constitutional_result, action_result, hitl_result = results\n        \"\"\"\n        logger.info(f\"Batch evaluating {len(evaluations)} policies\")\n        results = []\n\n        for i, (policy_path, input_data) in enumerate(evaluations, 1):\n            logger.debug(f\"Evaluating policy {i}/{len(evaluations)}: {policy_path}\")\n            result = self.evaluate_policy(policy_path, input_data, use_cache=False)\n            results.append(result)\n\n        logger.info(f\"Successfully evaluated {len(results)} policies\")\n        return results\n\n    def clear_cache(self) -> None:\n        \"\"\"\n        Clear the internal response cache.\n\n        This should be called when you want to ensure fresh policy evaluations,\n        such as after policy updates or at the start of a new governance workflow.\n        \"\"\"\n        cache_size = len(self._cache)\n        self._cache.clear()\n        logger.debug(f\"Cleared {cache_size} cached policy evaluations\")\n\n    def _retry_with_backoff(\n        self, func: Callable[[], Any], *args: Any, **kwargs: Any\n    ) -> Any:\n        \"\"\"\n        Retry a function with exponential backoff.\n\n        Args:\n            func: Function to retry\n            *args: Positional arguments for the function\n            **kwargs: Keyword arguments for the function\n\n        Returns:\n            Result from the function\n\n        Raises:\n            Exception: The last exception raised after all retries exhausted\n        \"\"\"\n        last_exception = None\n\n        for attempt in range(self.max_retries):\n            try:\n                return func(*args, **kwargs)\n            except (OPAConnectionError, OPATimeoutError) as e:\n                last_exception = e\n                if attempt < self.max_retries - 1:\n                    # Calculate exponential backoff delay\n                    delay = self.retry_delay * (2**attempt)\n                    logger.warning(\n                        f\"Attempt {attempt + 1}/{self.max_retries} failed: {e}. \"\n                        f\"Retrying in {delay:.1f}s...\"\n                    )\n                    time.sleep(delay)\n                else:\n                    logger.error(\n                        f\"All {self.max_retries} retry attempts exhausted for OPA request\"\n                    )\n\n        # If we get here, all retries failed\n        raise last_exception  # type: ignore\n\n    def _make_cache_key(self, policy_path: str, input_data: dict) -> str:\n        \"\"\"\n        Generate a cache key from policy path and input data.\n\n        Args:\n            policy_path: OPA policy path\n            input_data: Input data dictionary\n\n        Returns:\n            String cache key\n        \"\"\"\n        # Simple cache key - in production, use a proper hash function\n        # For now, convert input_data to sorted JSON string for consistent keys\n        import json\n\n        input_str = json.dumps(input_data, sort_keys=True)\n        return f\"{policy_path}:{input_str}\"\n\n    def close(self) -> None:\n        \"\"\"\n        Close the HTTP session and release resources.\n\n        Call this when you're done using the client to ensure proper cleanup.\n        \"\"\"\n        self.session.close()\n        logger.info(\"OPA client session closed\")\n\n    def __enter__(self) -> \"OPAClient\":\n        \"\"\"Support for context manager (with statement)\"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        \"\"\"Cleanup when exiting context manager\"\"\"\n        self.close()\n\n\n# Convenience function for quick one-off evaluations\ndef evaluate_policy(\n    policy_path: str, input_data: dict, opa_url: str = \"http://localhost:8181\"\n) -> dict:\n    \"\"\"\n    Convenience function for one-off policy evaluations.\n\n    This function creates a client, evaluates the policy, and cleans up.\n    For multiple evaluations, create an OPAClient instance directly.\n\n    Args:\n        policy_path: OPA policy path (e.g., \"acgs2/constitutional/validate\")\n        input_data: Dictionary containing the policy input\n        opa_url: OPA service URL (default: http://localhost:8181)\n\n    Returns:\n        Dictionary containing the policy evaluation result\n\n    Raises:\n        OPAConnectionError: If OPA service is unreachable\n        OPATimeoutError: If the request times out\n        OPAPolicyError: If policy evaluation fails\n\n    Example:\n        result = evaluate_policy(\n            policy_path=\"acgs2/constitutional/validate\",\n            input_data={\"action_type\": \"read_data\"}\n        )\n    \"\"\"\n    config = OPAConfig(url=opa_url)\n    with OPAClient(config) as client:\n        return client.evaluate_policy(policy_path, input_data)\n",
        "timestamp": "2026-01-04T05:35:49.744738"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "061-create-end-to-end-governance-workflow-examples-wit",
        "description": "Create comprehensive examples demonstrating complete governance workflows from policy creation through enforcement to audit logging, targeting Enterprise DevOps/MLOps engineers deploying AI systems. The examples will show: defining constitutional policies, enforcing them on agent actions, handling HITL approvals, and auditing decisions.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:07.530292",
  "last_updated": "2026-01-04T05:35:49.755517"
}