{
  "file_path": "claude-flow/src/utils/logging_config.ts",
  "main_branch_history": [],
  "task_views": {
    "059-add-jsdoc-coverage-for-claude-flow-typescript-serv": {
      "task_id": "059-add-jsdoc-coverage-for-claude-flow-typescript-serv",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * ACGS-2 Claude Flow Structured Logging Configuration\n *\n * Enterprise-grade structured logging with JSON formatting, correlation ID support,\n * and RFC 5424 severity levels for CLI operations.\n *\n * This module provides:\n *   - JSON-formatted log output for enterprise observability (Splunk, ELK, Datadog)\n *   - Correlation ID binding for request tracing\n *   - RFC 5424 severity levels (debug, info, warn, error)\n *   - Console-friendly output for local development\n *   - Convenience functions for structured logging\n *\n * Usage:\n *   import { getLogger, configureLogging, LogLevel } from './utils/logging_config';\n *\n *   // Configure logging at startup (optional - uses defaults)\n *   configureLogging({ serviceName: 'claude-flow', logLevel: 'info' });\n *\n *   // Get a logger instance\n *   const logger = getLogger('commands/agent');\n *   logger.info('agent_spawned', { agentId: 'abc123', type: 'coder' });\n *\n * Example output (JSON format):\n *   {\"timestamp\":\"2024-01-02T15:00:00.000Z\",\"level\":\"info\",\"service\":\"claude-flow\",\"logger\":\"commands/agent\",\"message\":\"agent_spawned\",\"agentId\":\"abc123\",\"type\":\"coder\"}\n */\n\nimport winston from 'winston';\n\n// ============================================================================\n// Types and Interfaces\n// ============================================================================\n\n/**\n * Log levels following RFC 5424 severity levels (subset commonly used in applications)\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Configuration options for logging setup\n */\nexport interface LoggingConfig {\n  /** Service name for log identification (default: 'claude-flow') */\n  serviceName?: string;\n  /** Minimum log level to output (default: 'info') */\n  logLevel?: LogLevel;\n  /** Whether to output JSON format (default: true for production, false for dev) */\n  jsonFormat?: boolean;\n  /** Whether to include timestamps (default: true) */\n  timestamps?: boolean;\n  /** Whether to colorize console output (default: true in dev) */\n  colorize?: boolean;\n}\n\n/**\n * Logger interface with typed methods\n */\nexport interface StructuredLogger {\n  debug(message: string, context?: Record<string, unknown>): void;\n  info(message: string, context?: Record<string, unknown>): void;\n  warn(message: string, context?: Record<string, unknown>): void;\n  error(message: string, context?: Record<string, unknown>): void;\n  child(context: Record<string, unknown>): StructuredLogger;\n}\n\n// ============================================================================\n// Module State\n// ============================================================================\n\nlet _configured = false;\nlet _serviceName = 'claude-flow';\nlet _baseLogger: winston.Logger | null = null;\nlet _correlationId: string | null = null;\n\n// Cache for logger instances\nconst _loggerCache = new Map<string, StructuredLogger>();\n\n// ============================================================================\n// Configuration Functions\n// ============================================================================\n\n/**\n * Configure logging for the application.\n *\n * This function should be called ONCE at application startup.\n * Subsequent calls will be ignored to prevent reconfiguration.\n *\n * @param config - Configuration options\n *\n * @example\n * // Configure with custom settings\n * configureLogging({\n *   serviceName: 'claude-flow',\n *   logLevel: 'debug',\n *   jsonFormat: true\n * });\n */\nexport function configureLogging(config: LoggingConfig = {}): void {\n  if (_configured && _baseLogger) {\n    return;\n  }\n\n  const {\n    serviceName = process.env.SERVICE_NAME || 'claude-flow',\n    logLevel = (process.env.LOG_LEVEL?.toLowerCase() as LogLevel) || 'info',\n    jsonFormat = process.env.LOG_FORMAT !== 'console',\n    timestamps = true,\n    colorize = !jsonFormat && process.env.NODE_ENV !== 'production',\n  } = config;\n\n  _serviceName = serviceName;\n\n  // Create format array\n  const formatters: winston.Logform.Format[] = [];\n\n  // Add timestamp\n  if (timestamps) {\n    formatters.push(winston.format.timestamp({ format: 'iso' }));\n  }\n\n  // Add error stack formatting\n  formatters.push(winston.format.errors({ stack: true }));\n\n  // Add metadata flattening for structured logging\n  formatters.push(\n    winston.format((info) => {\n      // Add service name to all logs\n      info.service = _serviceName;\n\n      // Add correlation ID if set\n      if (_correlationId) {\n        info.correlation_id = _correlationId;\n      }\n\n      return info;\n    })()\n  );\n\n  // Choose output format\n  if (jsonFormat) {\n    formatters.push(winston.format.json());\n  } else {\n    // Console-friendly format for development\n    formatters.push(\n      winston.format.printf(({ timestamp, level, message, service, logger: loggerName, ...meta }) => {\n        const metaStr = Object.keys(meta).length > 0 ? ` ${JSON.stringify(meta)}` : '';\n        return `${timestamp} [${service}] ${level.toUpperCase()} [${loggerName || 'root'}] ${message}${metaStr}`;\n      })\n    );\n    if (colorize) {\n      formatters.unshift(winston.format.colorize({ all: true }));\n    }\n  }\n\n  // Create winston logger\n  _baseLogger = winston.createLogger({\n    level: logLevel,\n    format: winston.format.combine(...formatters),\n    transports: [new winston.transports.Console()],\n    defaultMeta: {},\n  });\n\n  _configured = true;\n}\n\n// ============================================================================\n// Logger Factory\n// ============================================================================\n\n/**\n * Get a logger instance for the given module name.\n *\n * @param name - Logger name (typically module/file path)\n * @returns Configured logger instance\n *\n * @example\n * const logger = getLogger('commands/agent');\n * logger.info('agent_spawned', { agentId: 'abc123', type: 'coder' });\n */\nexport function getLogger(name: string): StructuredLogger {\n  // Auto-configure if not done yet\n  if (!_configured) {\n    configureLogging();\n  }\n\n  // Check cache\n  const cached = _loggerCache.get(name);\n  if (cached) {\n    return cached;\n  }\n\n  // Create wrapper around winston logger\n  const winstonLogger = _baseLogger!.child({ logger: name });\n\n  const logger: StructuredLogger = {\n    debug(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.debug(message, context);\n    },\n    info(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.info(message, context);\n    },\n    warn(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.warn(message, context);\n    },\n    error(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.error(message, context);\n    },\n    child(childContext: Record<string, unknown>): StructuredLogger {\n      const childWinston = winstonLogger.child(childContext);\n      return createLoggerWrapper(childWinston);\n    },\n  };\n\n  _loggerCache.set(name, logger);\n  return logger;\n}\n\n/**\n * Create a wrapper around a winston logger instance\n */\nfunction createLoggerWrapper(winstonLogger: winston.Logger): StructuredLogger {\n  return {\n    debug(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.debug(message, context);\n    },\n    info(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.info(message, context);\n    },\n    warn(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.warn(message, context);\n    },\n    error(message: string, context?: Record<string, unknown>): void {\n      winstonLogger.error(message, context);\n    },\n    child(childContext: Record<string, unknown>): StructuredLogger {\n      const childWinston = winstonLogger.child(childContext);\n      return createLoggerWrapper(childWinston);\n    },\n  };\n}\n\n// ============================================================================\n// Correlation ID Management\n// ============================================================================\n\n/**\n * Bind a correlation ID to the current context.\n *\n * For CLI operations, this can be used to track a specific command execution.\n *\n * @param correlationId - Unique identifier for the operation\n *\n * @example\n * bindCorrelationId(crypto.randomUUID());\n * logger.info('command_started', { command: 'agent spawn' });\n */\nexport function bindCorrelationId(correlationId: string): void {\n  _correlationId = correlationId;\n}\n\n/**\n * Get the current correlation ID.\n *\n * @returns Current correlation ID or null if not set\n */\nexport function getCorrelationId(): string | null {\n  return _correlationId;\n}\n\n/**\n * Clear the current correlation ID.\n */\nexport function clearCorrelationId(): void {\n  _correlationId = null;\n}\n\n// ============================================================================\n// Convenience Functions\n// ============================================================================\n\n/**\n * Log an error with optional exception information.\n *\n * @param logger - Logger instance\n * @param event - Event name describing the error\n * @param error - Optional error object\n * @param context - Additional context fields\n *\n * @example\n * try {\n *   await spawnAgent(options);\n * } catch (error) {\n *   logError(logger, 'agent_spawn_failed', error, { agentType: 'coder' });\n * }\n */\nexport function logError(\n  logger: StructuredLogger,\n  event: string,\n  error?: Error | unknown,\n  context?: Record<string, unknown>\n): void {\n  const errorContext: Record<string, unknown> = { ...context };\n\n  if (error instanceof Error) {\n    errorContext.error_type = error.name;\n    errorContext.error_message = error.message;\n    if (error.stack) {\n      errorContext.stack_trace = error.stack;\n    }\n  } else if (error) {\n    errorContext.error_message = String(error);\n  }\n\n  logger.error(event, errorContext);\n}\n\n/**\n * Log a successful operation with structured context.\n *\n * @param logger - Logger instance\n * @param event - Event name describing the success\n * @param context - Additional context fields\n *\n * @example\n * logSuccess(logger, 'agent_spawned', { agentId: 'abc123', type: 'coder' });\n */\nexport function logSuccess(logger: StructuredLogger, event: string, context?: Record<string, unknown>): void {\n  logger.info(event, { success: true, ...context });\n}\n\n/**\n * Log a warning with structured context.\n *\n * @param logger - Logger instance\n * @param event - Event name describing the warning\n * @param context - Additional context fields\n *\n * @example\n * logWarning(logger, 'rate_limit_approaching', { currentRate: 95, limit: 100 });\n */\nexport function logWarning(logger: StructuredLogger, event: string, context?: Record<string, unknown>): void {\n  logger.warn(event, context);\n}\n\n// ============================================================================\n// CLI-Specific Utilities\n// ============================================================================\n\n/**\n * Create a logger for CLI command execution.\n *\n * Automatically binds a correlation ID for the command session.\n *\n * @param commandName - Name of the CLI command being executed\n * @returns Logger configured for the command\n *\n * @example\n * const logger = createCommandLogger('agent spawn');\n * logger.info('command_started');\n * // ... execute command\n * logger.info('command_completed', { duration_ms: 150 });\n */\nexport function createCommandLogger(commandName: string): StructuredLogger {\n  // Generate correlation ID for this command execution\n  const correlationId = `cmd-${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;\n  bindCorrelationId(correlationId);\n\n  const logger = getLogger(`command/${commandName.replace(/\\s+/g, '-')}`);\n  return logger.child({ command: commandName, correlation_id: correlationId });\n}\n\n/**\n * Log the start of a CLI command.\n *\n * @param logger - Logger instance\n * @param args - Command arguments\n *\n * @example\n * logCommandStart(logger, { type: 'coder', name: 'my-agent' });\n */\nexport function logCommandStart(logger: StructuredLogger, args?: Record<string, unknown>): void {\n  logger.info('command_started', { args });\n}\n\n/**\n * Log the completion of a CLI command.\n *\n * @param logger - Logger instance\n * @param durationMs - Duration of command execution in milliseconds\n * @param result - Result context\n *\n * @example\n * logCommandComplete(logger, 150, { agentId: 'abc123' });\n */\nexport function logCommandComplete(\n  logger: StructuredLogger,\n  durationMs: number,\n  result?: Record<string, unknown>\n): void {\n  logger.info('command_completed', { duration_ms: durationMs, success: true, ...result });\n}\n\n/**\n * Log the failure of a CLI command.\n *\n * @param logger - Logger instance\n * @param durationMs - Duration of command execution in milliseconds\n * @param error - Error that caused the failure\n *\n * @example\n * logCommandFailure(logger, 50, new Error('Connection refused'));\n */\nexport function logCommandFailure(logger: StructuredLogger, durationMs: number, error?: Error | unknown): void {\n  const context: Record<string, unknown> = { duration_ms: durationMs, success: false };\n\n  if (error instanceof Error) {\n    context.error_type = error.name;\n    context.error_message = error.message;\n  } else if (error) {\n    context.error_message = String(error);\n  }\n\n  logger.error('command_failed', context);\n}\n\n// ============================================================================\n// CLI Output Utilities\n// ============================================================================\n\n/**\n * Write formatted output to stdout for CLI display.\n *\n * This function is used for user-facing CLI output (formatted messages,\n * results, help text) as opposed to structured logging events.\n *\n * @param message - The formatted message to display\n *\n * @example\n * cliOutput(chalk.blue('Results:'));\n * cliOutput(chalk.gray('  - Item 1'));\n */\nexport function cliOutput(message: string): void {\n  process.stdout.write(message + '\\n');\n}\n\n/**\n * Write raw output to stdout without newline (for special formatting).\n *\n * @param message - The message to display\n */\nexport function cliOutputRaw(message: string): void {\n  process.stdout.write(message);\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport default {\n  configureLogging,\n  getLogger,\n  bindCorrelationId,\n  getCorrelationId,\n  clearCorrelationId,\n  logError,\n  logSuccess,\n  logWarning,\n  createCommandLogger,\n  logCommandStart,\n  logCommandComplete,\n  logCommandFailure,\n  cliOutput,\n  cliOutputRaw,\n};\n",
        "timestamp": "2026-01-04T05:35:52.969195"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Add JSDoc coverage for claude-flow TypeScript service public exports",
        "description": "Add comprehensive JSDoc documentation to the 45 exported functions/classes across 17 TypeScript files in the claude-flow CLI tool to improve API documentation for enterprise users",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T05:35:53.050771",
  "last_updated": "2026-01-04T05:35:53.053217"
}