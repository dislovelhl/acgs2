{
  "file_path": "claude-flow/src/config/validator.ts",
  "main_branch_history": [],
  "task_views": {
    "059-add-jsdoc-coverage-for-claude-flow-typescript-serv": {
      "task_id": "059-add-jsdoc-coverage-for-claude-flow-typescript-serv",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * Configuration Validator Module\n *\n * This module provides comprehensive configuration validation with:\n * - Zod schema-based validation for all environment variables\n * - Security policy enforcement (e.g., blocking DEBUG mode in production)\n * - Clear error messages with remediation guidance\n * - Fail-fast behavior for invalid configurations\n *\n * @module validator\n */\n\nimport { z } from 'zod';\nimport { EnvSchema, ProductionSecuritySchema, EnvConfig } from './envSchema';\n\n/**\n * Configuration validation error with remediation guidance.\n * Extends Error with structured information about validation failures.\n */\nexport class ConfigValidationError extends Error {\n  public readonly errors: ValidationErrorDetail[];\n  public readonly isSecurityViolation: boolean;\n\n  constructor(\n    message: string,\n    errors: ValidationErrorDetail[],\n    isSecurityViolation = false\n  ) {\n    super(message);\n    this.name = 'ConfigValidationError';\n    this.errors = errors;\n    this.isSecurityViolation = isSecurityViolation;\n    Object.setPrototypeOf(this, ConfigValidationError.prototype);\n  }\n}\n\n/**\n * Detail structure for individual validation errors.\n */\nexport interface ValidationErrorDetail {\n  /** The configuration field that failed validation */\n  field: string;\n  /** The validation rule that was violated */\n  rule: string;\n  /** Human-readable description of the error */\n  message: string;\n  /** Actionable guidance on how to fix the error */\n  remediation: string;\n  /** The actual value that was provided (sanitized for sensitive fields) */\n  providedValue?: string;\n}\n\n/**\n * Result type for validation operations.\n */\nexport interface ValidationResult {\n  success: boolean;\n  config?: EnvConfig;\n  errors?: ValidationErrorDetail[];\n}\n\n/**\n * Security policy rules that must be enforced.\n */\ninterface SecurityPolicy {\n  name: string;\n  check: (config: EnvConfig) => boolean;\n  errorMessage: string;\n  remediation: string;\n}\n\n/**\n * List of sensitive field names that should not have their values exposed in error messages.\n */\nconst SENSITIVE_FIELDS = [\n  'REDIS_PASSWORD',\n  'KAFKA_PASSWORD',\n];\n\n/**\n * Security policies to enforce beyond basic schema validation.\n */\nconst SECURITY_POLICIES: SecurityPolicy[] = [\n  {\n    name: 'production-debug-mode',\n    check: (config) => config.ENVIRONMENT === 'production' && config.DEBUG === true,\n    errorMessage: 'DEBUG mode cannot be enabled in production environment',\n    remediation:\n      'Set DEBUG=false in your production .env file. Debug mode exposes sensitive information and should never be enabled in production.',\n  },\n  {\n    name: 'production-reload-mode',\n    check: (config) => config.ENVIRONMENT === 'production' && config.RELOAD === true,\n    errorMessage: 'RELOAD mode should not be enabled in production environment',\n    remediation:\n      'Set RELOAD=false in your production .env file. Hot-reload is intended for development only.',\n  },\n];\n\n/**\n * Formats a Zod error into a structured validation error detail.\n *\n * @param error - The Zod validation error issue\n * @returns A structured ValidationErrorDetail with remediation guidance\n */\nfunction formatZodError(error: z.ZodIssue): ValidationErrorDetail {\n  const field = error.path.join('.') || 'root';\n  const isSensitive = SENSITIVE_FIELDS.includes(field);\n\n  // Generate remediation based on error type\n  let remediation: string;\n  switch (error.code) {\n    case 'invalid_type':\n      remediation = `Check your .env file and ensure ${field} is set with the correct type. Expected: ${error.expected}, received: ${error.received}.`;\n      break;\n    case 'invalid_enum_value':\n      const options = (error as z.ZodInvalidEnumValueIssue).options?.join(', ') || 'valid values';\n      remediation = `Set ${field} to one of the valid options: ${options}.`;\n      break;\n    case 'too_small':\n      remediation = `The value for ${field} is too short or too small. Please provide a value that meets the minimum requirements.`;\n      break;\n    case 'too_big':\n      remediation = `The value for ${field} is too large. Please provide a value within the allowed range.`;\n      break;\n    case 'invalid_string':\n      if ((error as z.ZodInvalidStringIssue).validation === 'url') {\n        remediation = `Ensure ${field} contains a valid URL with the correct protocol (e.g., http://, https://, redis://).`;\n      } else {\n        remediation = `Check the format of ${field} and ensure it meets the required pattern.`;\n      }\n      break;\n    case 'custom':\n      remediation = `Review the value for ${field}. ${error.message}`;\n      break;\n    default:\n      remediation = `Check your .env file and ensure ${field} is configured correctly. Refer to the documentation for valid values.`;\n  }\n\n  return {\n    field,\n    rule: error.code,\n    message: error.message,\n    remediation,\n    providedValue: isSensitive ? '[REDACTED]' : undefined,\n  };\n}\n\n/**\n * Validates environment configuration against the schema and security policies.\n *\n * This function performs comprehensive validation:\n * 1. Schema validation using Zod\n * 2. Security policy checks (e.g., no DEBUG in production)\n * 3. Production-specific password strength requirements\n *\n * @param rawConfig - The raw environment configuration object (typically process.env)\n * @returns The validated and typed configuration object\n * @throws {ConfigValidationError} If validation fails, with detailed error information\n *\n * @example\n * ```typescript\n * try {\n *   const config = validateConfig(process.env);\n *   console.log('Configuration is valid');\n * } catch (error) {\n *   if (error instanceof ConfigValidationError) {\n *     console.error('Validation failed:', error.message);\n *     error.errors.forEach(e => console.error(`- ${e.field}: ${e.remediation}`));\n *   }\n *   process.exit(1);\n * }\n * ```\n */\nexport function validateConfig(rawConfig: Record<string, unknown>): EnvConfig {\n  const result = validateConfigSafe(rawConfig);\n\n  if (!result.success) {\n    const errorMessages = result.errors!.map(\n      (err) => `  - ${err.field}: ${err.message}\\n    Remediation: ${err.remediation}`\n    );\n\n    throw new ConfigValidationError(\n      `Configuration validation failed:\\n\\n${errorMessages.join('\\n\\n')}`,\n      result.errors!,\n      result.errors!.some((e) => e.rule === 'security_violation')\n    );\n  }\n\n  return result.config!;\n}\n\n/**\n * Validates environment configuration and returns a result object instead of throwing.\n *\n * Use this function when you want to handle validation errors programmatically\n * without exception handling.\n *\n * @param rawConfig - The raw environment configuration object\n * @returns A ValidationResult object with success status and either config or errors\n */\nexport function validateConfigSafe(rawConfig: Record<string, unknown>): ValidationResult {\n  const errors: ValidationErrorDetail[] = [];\n\n  // Step 1: Schema validation with Zod\n  const schemaResult = EnvSchema.safeParse(rawConfig);\n\n  if (!schemaResult.success) {\n    const zodErrors = schemaResult.error.errors.map(formatZodError);\n    errors.push(...zodErrors);\n    return { success: false, errors };\n  }\n\n  const config = schemaResult.data;\n\n  // Step 2: Security policy checks\n  for (const policy of SECURITY_POLICIES) {\n    if (policy.check(config)) {\n      errors.push({\n        field: policy.name,\n        rule: 'security_violation',\n        message: policy.errorMessage,\n        remediation: policy.remediation,\n      });\n    }\n  }\n\n  // Step 3: Production-specific password requirements\n  if (config.ENVIRONMENT === 'production') {\n    const prodSecurityResult = ProductionSecuritySchema.safeParse({\n      REDIS_PASSWORD: config.REDIS_PASSWORD,\n      KAFKA_PASSWORD: config.KAFKA_PASSWORD || undefined,\n    });\n\n    if (!prodSecurityResult.success) {\n      prodSecurityResult.error.errors.forEach((err) => {\n        const field = err.path.join('.') || 'unknown';\n        errors.push({\n          field,\n          rule: 'security_violation',\n          message: err.message,\n          remediation: `In production environments, ${field} must meet security requirements. Use a strong password with at least 8 characters.`,\n        });\n      });\n    }\n  }\n\n  if (errors.length > 0) {\n    return { success: false, errors };\n  }\n\n  return { success: true, config };\n}\n\n/**\n * Validates configuration and exits the process if validation fails.\n *\n * This is the recommended function to call at application startup for\n * fail-fast behavior. It will print formatted error messages and exit\n * with code 1 if validation fails.\n *\n * @param rawConfig - The raw environment configuration object\n * @returns The validated configuration if successful\n */\nexport function validateConfigOrExit(rawConfig: Record<string, unknown>): EnvConfig {\n  const result = validateConfigSafe(rawConfig);\n\n  if (!result.success) {\n    const isSecurityViolation = result.errors!.some((e) => e.rule === 'security_violation');\n\n    // Format error output for console\n    const header = isSecurityViolation\n      ? '\\n[SECURITY VIOLATION] Configuration validation failed:\\n'\n      : '\\n[ERROR] Configuration validation failed:\\n';\n\n    const errorMessages = result.errors!.map((err) => {\n      return [\n        `  Field: ${err.field}`,\n        `  Error: ${err.message}`,\n        `  Remediation: ${err.remediation}`,\n      ].join('\\n');\n    });\n\n    // Use process.stderr for error output\n    process.stderr.write(header);\n    process.stderr.write(errorMessages.join('\\n\\n'));\n    process.stderr.write('\\n\\nApplication cannot start with invalid configuration.\\n');\n\n    process.exit(1);\n  }\n\n  return result.config!;\n}\n\n/**\n * Creates a partial validator for a subset of configuration fields.\n *\n * Useful for validating specific sections of configuration without\n * requiring all fields to be present.\n *\n * @param fields - Array of field names to validate\n * @returns A validation function for the specified fields\n */\nexport function createPartialValidator(\n  fields: (keyof EnvConfig)[]\n): (config: Record<string, unknown>) => ValidationResult {\n  return (config: Record<string, unknown>) => {\n    const errors: ValidationErrorDetail[] = [];\n\n    // Create a partial schema with only the specified fields\n    const partialConfig: Record<string, unknown> = {};\n    for (const field of fields) {\n      if (field in config) {\n        partialConfig[field] = config[field];\n      }\n    }\n\n    // Validate using the full schema with partial data\n    const result = EnvSchema.partial().safeParse(partialConfig);\n\n    if (!result.success) {\n      errors.push(...result.error.errors.map(formatZodError));\n      return { success: false, errors };\n    }\n\n    return { success: true };\n  };\n}\n\n/**\n * Checks if a specific configuration value is valid without full validation.\n *\n * @param field - The field name to check\n * @param value - The value to validate\n * @returns True if the value is valid for the specified field\n */\nexport function isValidConfigValue(field: keyof EnvConfig, value: unknown): boolean {\n  const testConfig = { [field]: value };\n  const result = EnvSchema.partial().safeParse(testConfig);\n  return result.success;\n}\n\n/**\n * Re-export types for external use.\n */\nexport type { EnvConfig } from './envSchema';\n",
        "timestamp": "2026-01-04T05:35:52.969195"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Add JSDoc coverage for claude-flow TypeScript service public exports",
        "description": "Add comprehensive JSDoc documentation to the 45 exported functions/classes across 17 TypeScript files in the claude-flow CLI tool to improve API documentation for enterprise users",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T05:35:52.976668",
  "last_updated": "2026-01-04T05:35:52.986612"
}