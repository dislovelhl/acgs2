{
  "file_path": "src/core/services/policy_registry/advanced_rbac/policies/abac_engine.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Attribute-Based Access Control (ABAC) Engine\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport re\nimport sys\nimport time\nfrom collections import defaultdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Set, Tuple\n\n# Add src/core/shared to path for type imports\nshared_path = Path(__file__).parent.parent.parent.parent.parent / \"shared\"\nif str(shared_path) not in sys.path:\n    sys.path.insert(0, str(shared_path))\n\nfrom types import JSONDict, JSONValue\n\nfrom ..models.abac_models import (\n    ABACPolicy,\n    ABACRule,\n    AccessRequest,\n    Attribute,\n    AttributeCondition,\n    ComparisonOperator,\n    LogicalOperator,\n    PolicyDecision,\n)\n\n\nclass ABACPolicyEngine:\n    \"\"\"ABAC Policy Engine for evaluating access requests\"\"\"\n\n    def __init__(self):\n        self.policies: Dict[str, ABACPolicy] = {}\n        self.policy_index: Dict[str, Set[str]] = defaultdict(set)  # attribute -> policies\n        self.evaluation_cache: Dict[str, Tuple[PolicyDecision, float]] = {}\n        self.cache_ttl_seconds = 300  # 5 minutes\n\n    def register_policy(self, policy: ABACPolicy) -> None:\n        \"\"\"Register an ABAC policy\"\"\"\n        self.policies[policy.policy_id] = policy\n\n        # Update index for faster policy matching\n        for condition in policy.target_conditions:\n            self.policy_index[condition.attribute_name].add(policy.policy_id)\n\n        for rule in policy.rules:\n            for condition in rule.conditions:\n                self.policy_index[condition.attribute_name].add(policy.policy_id)\n\n    def unregister_policy(self, policy_id: str) -> None:\n        \"\"\"Unregister an ABAC policy\"\"\"\n        if policy_id in self.policies:\n            policy = self.policies[policy_id]\n\n            # Remove from index\n            for condition in policy.target_conditions:\n                self.policy_index[condition.attribute_name].discard(policy_id)\n\n            for rule in policy.rules:\n                for condition in rule.conditions:\n                    self.policy_index[condition.attribute_name].discard(policy_id)\n\n            del self.policies[policy_id]\n\n    def evaluate_access(self, request: AccessRequest) -> PolicyDecision:\n        \"\"\"Evaluate an access request against all policies\"\"\"\n        start_time = time.time()\n\n        # Check cache first\n        cache_key = self._generate_cache_key(request)\n        if cache_key in self.evaluation_cache:\n            cached_decision, cache_time = self.evaluation_cache[cache_key]\n            if time.time() - cache_time < self.cache_ttl_seconds:\n                return cached_decision\n\n        # Find applicable policies\n        applicable_policies = self._find_applicable_policies(request)\n\n        # Evaluate policies\n        decision = self._evaluate_policies(applicable_policies, request)\n\n        # Cache the result\n        evaluation_time = (time.time() - start_time) * 1000  # milliseconds\n        decision.evaluation_time_ms = evaluation_time\n        self.evaluation_cache[cache_key] = (decision, time.time())\n\n        return decision\n\n    def _find_applicable_policies(self, request: AccessRequest) -> List[ABACPolicy]:\n        \"\"\"Find policies that apply to the request\"\"\"\n        applicable_policies = []\n\n        # Get all attributes from the request\n        all_attributes = self._collect_request_attributes(request)\n\n        # Find candidate policies based on attribute index\n        candidate_policy_ids = set()\n        for attr_name in all_attributes.keys():\n            candidate_policy_ids.update(self.policy_index[attr_name])\n\n        # If no candidates from index, check all policies (fallback)\n        if not candidate_policy_ids:\n            candidate_policy_ids = set(self.policies.keys())\n\n        # Filter policies based on target conditions\n        for policy_id in candidate_policy_ids:\n            policy = self.policies.get(policy_id)\n            if policy and policy.enabled:\n                if self._matches_target_conditions(policy, request):\n                    applicable_policies.append(policy)\n\n        return applicable_policies\n\n    def _evaluate_policies(\n        self, policies: List[ABACPolicy], request: AccessRequest\n    ) -> PolicyDecision:\n        \"\"\"Evaluate policies using the specified combining algorithm\"\"\"\n        matched_rules = []\n        denied_rules = []\n        obligations = []\n        advice = []\n\n        # Sort policies by priority (higher priority first)\n        policies.sort(key=lambda p: getattr(p, \"priority\", 0), reverse=True)\n\n        for policy in policies:\n            decision = self._evaluate_single_policy(policy, request)\n\n            if decision.decision == \"allow\":\n                matched_rules.extend(decision.matched_rules)\n                obligations.extend(decision.obligations)\n                advice.extend(decision.advice)\n\n                if policy.combining_algorithm == \"first-applicable\":\n                    break\n\n            elif decision.decision == \"deny\":\n                denied_rules.extend(decision.denied_rules)\n\n                if policy.combining_algorithm == \"deny-overrides\":\n                    return PolicyDecision(\n                        decision=\"deny\",\n                        confidence_score=decision.confidence_score,\n                        matched_rules=matched_rules,\n                        denied_rules=denied_rules,\n                        obligations=obligations,\n                        advice=advice,\n                    )\n\n        # Determine final decision\n        if denied_rules and not matched_rules:\n            final_decision = \"deny\"\n            confidence = 0.8\n        elif matched_rules:\n            final_decision = \"allow\"\n            confidence = 0.9\n        else:\n            final_decision = \"not_applicable\"\n            confidence = 0.5\n\n        return PolicyDecision(\n            decision=final_decision,\n            confidence_score=confidence,\n            matched_rules=matched_rules,\n            denied_rules=denied_rules,\n            obligations=obligations,\n            advice=advice,\n        )\n\n    def _evaluate_single_policy(self, policy: ABACPolicy, request: AccessRequest) -> PolicyDecision:\n        \"\"\"Evaluate a single policy\"\"\"\n        matched_allow_rules = []\n        matched_deny_rules = []\n\n        # Evaluate deny rules first (deny-overrides within policy)\n        for rule in policy.deny_rules:\n            if rule.enabled and self._evaluate_rule(rule, request):\n                matched_deny_rules.append(rule.rule_id)\n\n        # Evaluate allow rules\n        for rule in policy.allow_rules:\n            if rule.enabled and self._evaluate_rule(rule, request):\n                matched_allow_rules.append(rule.rule_id)\n\n        # Determine policy decision\n        if matched_deny_rules:\n            return PolicyDecision(\n                decision=\"deny\",\n                confidence_score=0.9,\n                matched_rules=[],\n                denied_rules=matched_deny_rules,\n            )\n        elif matched_allow_rules:\n            return PolicyDecision(\n                decision=\"allow\",\n                confidence_score=0.9,\n                matched_rules=matched_allow_rules,\n                denied_rules=[],\n            )\n        else:\n            return PolicyDecision(\n                decision=\"not_applicable\", confidence_score=0.5, matched_rules=[], denied_rules=[]\n            )\n\n    def _evaluate_rule(self, rule: ABACRule, request: AccessRequest) -> bool:\n        \"\"\"Evaluate a single rule\"\"\"\n        conditions_results = []\n\n        for condition in rule.conditions:\n            result = self._evaluate_condition(condition, request)\n            conditions_results.append(result)\n\n        # Combine conditions based on logical operator\n        if rule.logical_operator == LogicalOperator.AND:\n            return all(conditions_results)\n        elif rule.logical_operator == LogicalOperator.OR:\n            return any(conditions_results)\n        else:  # NOT\n            return not all(conditions_results)\n\n    def _evaluate_condition(self, condition: AttributeCondition, request: AccessRequest) -> bool:\n        \"\"\"Evaluate a single condition\"\"\"\n        # Get attribute value from request\n        attribute_value = self._get_attribute_value(condition.attribute_name, request)\n\n        if attribute_value is None:\n            return False\n\n        # Apply the comparison operator\n        operator = condition.operator\n        expected = condition.expected_value\n\n        try:\n            if operator == ComparisonOperator.EQUALS:\n                return self._equals_comparison(attribute_value, expected, condition.case_sensitive)\n            elif operator == ComparisonOperator.NOT_EQUALS:\n                return not self._equals_comparison(\n                    attribute_value, expected, condition.case_sensitive\n                )\n            elif operator == ComparisonOperator.GREATER_THAN:\n                return float(attribute_value) > float(expected)\n            elif operator == ComparisonOperator.GREATER_THAN_EQUAL:\n                return float(attribute_value) >= float(expected)\n            elif operator == ComparisonOperator.LESS_THAN:\n                return float(attribute_value) < float(expected)\n            elif operator == ComparisonOperator.LESS_THAN_EQUAL:\n                return float(attribute_value) <= float(expected)\n            elif operator == ComparisonOperator.CONTAINS:\n                return self._contains_comparison(\n                    attribute_value, expected, condition.case_sensitive\n                )\n            elif operator == ComparisonOperator.NOT_CONTAINS:\n                return not self._contains_comparison(\n                    attribute_value, expected, condition.case_sensitive\n                )\n            elif operator == ComparisonOperator.IN:\n                return attribute_value in expected\n            elif operator == ComparisonOperator.NOT_IN:\n                return attribute_value not in expected\n            elif operator == ComparisonOperator.REGEX_MATCH:\n                return bool(re.match(expected, str(attribute_value)))\n            elif operator == ComparisonOperator.STARTS_WITH:\n                return str(attribute_value).startswith(str(expected))\n            elif operator == ComparisonOperator.ENDS_WITH:\n                return str(attribute_value).endswith(str(expected))\n            else:\n                return False\n\n        except (ValueError, TypeError):\n            return False\n\n    def _get_attribute_value(self, attribute_name: str, request: AccessRequest) -> JSONValue:\n        \"\"\"Get attribute value from request\"\"\"\n        # Check all attribute categories\n        all_attributes = {}\n\n        # Flatten all attribute categories\n        for category_name, category_attrs in [\n            (\"subject\", request.subject_attributes),\n            (\"resource\", request.resource_attributes),\n            (\"action\", request.action_attributes),\n            (\"environment\", request.environment_attributes),\n            (\"context\", request.context_attributes),\n        ]:\n            for attr_name, attr in category_attrs.items():\n                full_name = f\"{category_name}.{attr_name}\"\n                all_attributes[full_name] = attr.value\n                all_attributes[attr_name] = attr.value  # Also allow short names\n\n        return all_attributes.get(attribute_name)\n\n    def _collect_request_attributes(self, request: AccessRequest) -> Dict[str, Attribute]:\n        \"\"\"Collect all attributes from the request\"\"\"\n        all_attributes = {}\n\n        for category_attrs in [\n            request.subject_attributes,\n            request.resource_attributes,\n            request.action_attributes,\n            request.environment_attributes,\n            request.context_attributes,\n        ]:\n            all_attributes.update(category_attrs)\n\n        return all_attributes\n\n    def _matches_target_conditions(self, policy: ABACPolicy, request: AccessRequest) -> bool:\n        \"\"\"Check if policy target conditions match the request\"\"\"\n        for condition in policy.target_conditions:\n            if not self._evaluate_condition(condition, request):\n                return False\n        return True\n\n    def _equals_comparison(\n        self, actual: JSONValue, expected: JSONValue, case_sensitive: bool\n    ) -> bool:\n        \"\"\"Compare values for equality\"\"\"\n        if not case_sensitive and isinstance(actual, str) and isinstance(expected, str):\n            return actual.lower() == expected.lower()\n        return actual == expected\n\n    def _contains_comparison(\n        self, actual: JSONValue, expected: JSONValue, case_sensitive: bool\n    ) -> bool:\n        \"\"\"Check if actual contains expected\"\"\"\n        actual_str = str(actual)\n        expected_str = str(expected)\n\n        if not case_sensitive:\n            return expected_str.lower() in actual_str.lower()\n        return expected_str in actual_str\n\n    def _generate_cache_key(self, request: AccessRequest) -> str:\n        \"\"\"Generate a cache key for the request\"\"\"\n        # Create a deterministic key based on request attributes\n        key_parts = [\n            request.request_id,\n            str(sorted(request.subject_attributes.items())),\n            str(sorted(request.resource_attributes.items())),\n            str(sorted(request.action_attributes.items())),\n            str(sorted(request.environment_attributes.items())),\n            str(sorted(request.context_attributes.items())),\n        ]\n\n        return \"|\".join(key_parts)\n\n    def clear_cache(self) -> None:\n        \"\"\"Clear the evaluation cache\"\"\"\n        self.evaluation_cache.clear()\n\n    def get_cache_stats(self) -> JSONDict:\n        \"\"\"Get cache statistics\"\"\"\n        return {\n            \"cache_size\": len(self.evaluation_cache),\n            \"cache_ttl_seconds\": self.cache_ttl_seconds,\n        }\n\n    def get_policy_stats(self) -> JSONDict:\n        \"\"\"Get policy statistics\"\"\"\n        total_policies = len(self.policies)\n        enabled_policies = sum(1 for p in self.policies.values() if p.enabled)\n        total_rules = sum(len(p.rules) for p in self.policies.values())\n        enabled_rules = sum(len([r for r in p.rules if r.enabled]) for p in self.policies.values())\n\n        return {\n            \"total_policies\": total_policies,\n            \"enabled_policies\": enabled_policies,\n            \"disabled_policies\": total_policies - enabled_policies,\n            \"total_rules\": total_rules,\n            \"enabled_rules\": enabled_rules,\n            \"disabled_rules\": total_rules - enabled_rules,\n        }\n\n\nclass PolicyDecisionCache:\n    \"\"\"Cache for policy decisions with TTL\"\"\"\n\n    def __init__(self, ttl_seconds: int = 300):\n        self.cache: Dict[str, Tuple[PolicyDecision, float]] = {}\n        self.ttl_seconds = ttl_seconds\n\n    def get(self, key: str) -> Optional[PolicyDecision]:\n        \"\"\"Get cached decision if still valid\"\"\"\n        if key in self.cache:\n            decision, timestamp = self.cache[key]\n            if time.time() - timestamp < self.ttl_seconds:\n                return decision\n            else:\n                del self.cache[key]\n        return None\n\n    def put(self, key: str, decision: PolicyDecision) -> None:\n        \"\"\"Cache a decision\"\"\"\n        self.cache[key] = (decision, time.time())\n\n    def clear(self) -> None:\n        \"\"\"Clear all cached decisions\"\"\"\n        self.cache.clear()\n\n    def cleanup_expired(self) -> int:\n        \"\"\"Remove expired entries and return count removed\"\"\"\n        current_time = time.time()\n        expired_keys = [\n            key\n            for key, (_, timestamp) in self.cache.items()\n            if current_time - timestamp >= self.ttl_seconds\n        ]\n\n        for key in expired_keys:\n            del self.cache[key]\n\n        return len(expired_keys)\n\n    def size(self) -> int:\n        \"\"\"Get current cache size\"\"\"\n        return len(self.cache)\n\n\n# Global ABAC engine instance\nabac_engine = ABACPolicyEngine()\n\n\n# Convenience functions\ndef register_abac_policy(policy: ABACPolicy) -> None:\n    \"\"\"Register an ABAC policy\"\"\"\n    abac_engine.register_policy(policy)\n\n\ndef evaluate_access_request(request: AccessRequest) -> PolicyDecision:\n    \"\"\"Evaluate an access request\"\"\"\n    return abac_engine.evaluate_access(request)\n\n\ndef get_policy_stats() -> JSONDict:\n    \"\"\"Get policy engine statistics\"\"\"\n    return abac_engine.get_policy_stats()\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.182441",
  "last_updated": "2026-01-04T05:35:59.114810"
}