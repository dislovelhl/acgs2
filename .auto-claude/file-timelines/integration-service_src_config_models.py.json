{
  "file_path": "integration-service/src/config/models.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nPydantic configuration models for integration settings.\n\nDefines configuration schemas for all supported integrations with\nvalidation, sensible defaults, and secure credential handling.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Dict, List, Literal, Optional, Union\nfrom uuid import uuid4\n\nfrom pydantic import (\n    BaseModel,\n    ConfigDict,\n    Field,\n    SecretStr,\n    field_validator,\n    model_validator,\n)\n\nfrom ..types import ValidatorValue\n\n\nclass AuthType(str, Enum):\n    \"\"\"Authentication types supported by integrations.\"\"\"\n\n    API_KEY = \"api_key\"\n    API_TOKEN = \"api_token\"  # nosec B105 - Not a hardcoded password, just an enum value\n    BASIC = \"basic\"\n    OAUTH2 = \"oauth2\"\n    BEARER = \"bearer\"\n    HMAC = \"hmac\"\n    SERVICE_PRINCIPAL = \"service_principal\"\n\n\nclass IntegrationState(str, Enum):\n    \"\"\"State of an integration configuration.\"\"\"\n\n    ENABLED = \"enabled\"\n    DISABLED = \"disabled\"\n    PENDING = \"pending\"\n    ERROR = \"error\"\n\n\nclass RetryConfig(BaseModel):\n    \"\"\"Configuration for retry behavior.\"\"\"\n\n    max_attempts: int = Field(default=3, ge=1, le=10, description=\"Maximum retry attempts\")\n    initial_delay_seconds: float = Field(\n        default=1.0, ge=0.1, le=60, description=\"Initial delay between retries\"\n    )\n    max_delay_seconds: float = Field(\n        default=60.0, ge=1, le=600, description=\"Maximum delay between retries\"\n    )\n    exponential_base: float = Field(\n        default=2.0, ge=1.5, le=4.0, description=\"Exponential backoff multiplier\"\n    )\n    retry_on_status_codes: List[int] = Field(\n        default=[429, 500, 502, 503, 504],\n        description=\"HTTP status codes to retry on\",\n    )\n\n    model_config = ConfigDict(frozen=True)\n\n\nclass BaseIntegrationConfig(BaseModel):\n    \"\"\"Base configuration model for all integrations.\"\"\"\n\n    id: str = Field(\n        default_factory=lambda: str(uuid4()),\n        description=\"Unique identifier for this integration configuration\",\n    )\n    name: str = Field(\n        ..., min_length=1, max_length=255, description=\"Display name for the integration\"\n    )\n    enabled: bool = Field(default=False, description=\"Whether the integration is enabled\")\n    state: IntegrationState = Field(\n        default=IntegrationState.DISABLED, description=\"Current state of the integration\"\n    )\n\n    # Common settings\n    timeout_seconds: float = Field(\n        default=30.0, ge=1.0, le=300.0, description=\"Request timeout in seconds\"\n    )\n    retry_config: RetryConfig = Field(\n        default_factory=RetryConfig, description=\"Retry configuration\"\n    )\n\n    # Metadata\n    description: Optional[str] = Field(\n        None, max_length=1000, description=\"Description of this integration instance\"\n    )\n    tags: List[str] = Field(default_factory=list, description=\"Tags for categorization\")\n    created_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Configuration creation timestamp\",\n    )\n    updated_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Configuration last update timestamp\",\n    )\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        validate_assignment=True,\n    )\n\n    @field_validator(\"tags\", mode=\"before\")\n    @classmethod\n    def validate_tags(cls, v: ValidatorValue) -> List[str]:\n        \"\"\"Ensure tags is a list of strings.\"\"\"\n        if v is None:\n            return []\n        if isinstance(v, str):\n            return [v]\n        return list(v)\n\n\n# SIEM Configurations\n\n\nclass SIEMIntegrationConfig(BaseIntegrationConfig):\n    \"\"\"Base configuration for SIEM integrations.\"\"\"\n\n    integration_type: Literal[\"siem\"] = \"siem\"\n    batch_size: int = Field(default=100, ge=1, le=1000, description=\"Maximum events per batch\")\n    batch_timeout_seconds: float = Field(\n        default=5.0, ge=1.0, le=60.0, description=\"Timeout to wait before sending batch\"\n    )\n    source_type: str = Field(\n        default=\"governance:event\", description=\"Source type for SIEM categorization\"\n    )\n\n\nclass SplunkConfig(SIEMIntegrationConfig):\n    \"\"\"Configuration for Splunk HEC integration.\"\"\"\n\n    provider: Literal[\"splunk\"] = \"splunk\"\n\n    # Connection settings\n    host: str = Field(..., description=\"Splunk host (without protocol)\")\n    port: int = Field(default=8088, ge=1, le=65535, description=\"HEC port (default 8088)\")\n    use_ssl: bool = Field(default=True, description=\"Use HTTPS for HEC connection\")\n    verify_ssl: bool = Field(\n        default=True, description=\"Verify SSL certificates (set False for self-signed)\"\n    )\n\n    # Authentication\n    hec_token: SecretStr = Field(..., description=\"HTTP Event Collector token\")\n\n    # Event settings\n    index: str = Field(default=\"main\", description=\"Target Splunk index (must exist)\")\n    source: str = Field(default=\"acgs2\", description=\"Event source identifier\")\n    host_field: str = Field(default=\"integration-service\", description=\"Host field value in events\")\n\n    # Cloud vs On-Premise\n    is_cloud: bool = Field(default=False, description=\"Whether this is Splunk Cloud (affects auth)\")\n\n    @property\n    def hec_url(self) -> str:\n        \"\"\"Construct the HEC endpoint URL.\"\"\"\n        protocol = \"https\" if self.use_ssl else \"http\"\n        return f\"{protocol}://{self.host}:{self.port}/services/collector/event\"\n\n    @field_validator(\"host\", mode=\"before\")\n    @classmethod\n    def strip_protocol(cls, v: str) -> str:\n        \"\"\"Remove protocol prefix if present.\"\"\"\n        if v.startswith(\"https://\"):\n            return v[8:]\n        if v.startswith(\"http://\"):\n            return v[7:]\n        return v\n\n\nclass SentinelConfig(SIEMIntegrationConfig):\n    \"\"\"Configuration for Microsoft Sentinel/Azure Monitor integration.\"\"\"\n\n    provider: Literal[\"sentinel\"] = \"sentinel\"\n\n    # Azure identity\n    tenant_id: str = Field(..., description=\"Azure AD tenant ID\")\n    client_id: str = Field(..., description=\"Service principal client ID\")\n    client_secret: SecretStr = Field(..., description=\"Service principal secret\")\n\n    # Data Collection settings\n    dce_endpoint: str = Field(\n        ...,\n        description=\"Data Collection Endpoint URL (https://<name>.<region>.ingest.monitor.azure.com)\",\n    )\n    dcr_immutable_id: str = Field(..., description=\"Data Collection Rule immutable ID\")\n    stream_name: str = Field(\n        default=\"Custom-GovernanceEvents_CL\",\n        description=\"Log Analytics stream name (must match DCR schema)\",\n    )\n\n    # Azure Cloud settings\n    azure_cloud: Literal[\"public\", \"china\", \"germany\", \"government\"] = Field(\n        default=\"public\", description=\"Azure cloud environment\"\n    )\n\n    @field_validator(\"dce_endpoint\", mode=\"before\")\n    @classmethod\n    def validate_dce_endpoint(cls, v: str) -> str:\n        \"\"\"Validate DCE endpoint format.\"\"\"\n        if not v.startswith(\"https://\"):\n            raise ValueError(\"DCE endpoint must use HTTPS\")\n        if not v.endswith(\".ingest.monitor.azure.com\"):\n            raise ValueError(\"DCE endpoint must end with .ingest.monitor.azure.com\")\n        return v\n\n\n# Ticketing Configurations\n\n\nclass TicketingIntegrationConfig(BaseIntegrationConfig):\n    \"\"\"Base configuration for ticketing integrations.\"\"\"\n\n    integration_type: Literal[\"ticketing\"] = \"ticketing\"\n    default_priority: str = Field(default=\"medium\", description=\"Default ticket priority\")\n    auto_create_tickets: bool = Field(\n        default=True, description=\"Automatically create tickets for events\"\n    )\n    severity_priority_mapping: Dict[str, str] = Field(\n        default_factory=lambda: {\n            \"critical\": \"highest\",\n            \"high\": \"high\",\n            \"medium\": \"medium\",\n            \"low\": \"low\",\n            \"info\": \"lowest\",\n        },\n        description=\"Map event severity to ticket priority\",\n    )\n\n\nclass JiraConfig(TicketingIntegrationConfig):\n    \"\"\"Configuration for Jira integration.\"\"\"\n\n    provider: Literal[\"jira\"] = \"jira\"\n\n    # Connection\n    base_url: str = Field(\n        ..., description=\"Jira base URL (e.g., https://your-domain.atlassian.net)\"\n    )\n\n    # Authentication - Cloud uses API token, Server uses different methods\n    auth_type: Literal[\"api_token\", \"oauth2\", \"personal_access_token\"] = Field(\n        default=\"api_token\", description=\"Authentication method\"\n    )\n    user_email: Optional[str] = Field(\n        None, description=\"User email for API token auth (Jira Cloud)\"\n    )\n    api_token: Optional[SecretStr] = Field(None, description=\"API token for authentication\")\n    personal_access_token: Optional[SecretStr] = Field(\n        None, description=\"Personal Access Token (Jira Server/Data Center)\"\n    )\n\n    # Project settings\n    project_key: str = Field(..., description=\"Default Jira project key\")\n    issue_type: str = Field(default=\"Bug\", description=\"Default issue type\")\n    labels: List[str] = Field(\n        default_factory=lambda: [\"governance\", \"acgs2\"],\n        description=\"Labels to add to created issues\",\n    )\n\n    # Field mappings\n    custom_fields: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Custom field mappings (field_id -> value or template)\",\n    )\n\n    # Cloud vs Server\n    is_cloud: bool = Field(\n        default=True, description=\"Whether this is Jira Cloud (affects auth and API)\"\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_auth_config(self) -> \"JiraConfig\":\n        \"\"\"Validate authentication configuration.\"\"\"\n        if self.auth_type == \"api_token\":\n            if not self.user_email or not self.api_token:\n                raise ValueError(\"user_email and api_token required for api_token auth\")\n        elif self.auth_type == \"personal_access_token\":\n            if not self.personal_access_token:\n                raise ValueError(\"personal_access_token required for PAT auth\")\n        return self\n\n    @field_validator(\"base_url\", mode=\"before\")\n    @classmethod\n    def validate_base_url(cls, v: str) -> str:\n        \"\"\"Validate and normalize base URL.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            v = f\"https://{v}\"\n        return v.rstrip(\"/\")\n\n\nclass ServiceNowConfig(TicketingIntegrationConfig):\n    \"\"\"Configuration for ServiceNow integration.\"\"\"\n\n    provider: Literal[\"servicenow\"] = \"servicenow\"\n\n    # Connection\n    instance: str = Field(\n        ..., description=\"ServiceNow instance URL (e.g., https://your-instance.service-now.com)\"\n    )\n\n    # Authentication\n    auth_type: Literal[\"basic\", \"oauth2\"] = Field(\n        default=\"basic\", description=\"Authentication method\"\n    )\n    username: Optional[str] = Field(None, description=\"Username for basic auth\")\n    password: Optional[SecretStr] = Field(None, description=\"Password for basic auth\")\n    client_id: Optional[str] = Field(None, description=\"OAuth2 client ID\")\n    client_secret: Optional[SecretStr] = Field(None, description=\"OAuth2 client secret\")\n\n    # Incident settings\n    table_name: str = Field(default=\"incident\", description=\"Target table for tickets\")\n    category: str = Field(default=\"Governance\", description=\"Default category\")\n    subcategory: str = Field(default=\"Policy Violation\", description=\"Default subcategory\")\n    impact: str = Field(default=\"2\", description=\"Default impact level (1-3)\")\n    urgency: str = Field(default=\"2\", description=\"Default urgency level (1-3)\")\n\n    # Field mappings\n    additional_fields: Dict[str, str] = Field(\n        default_factory=dict, description=\"Additional fields to set on incidents\"\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_auth_config(self) -> \"ServiceNowConfig\":\n        \"\"\"Validate authentication configuration.\"\"\"\n        if self.auth_type == \"basic\":\n            if not self.username or not self.password:\n                raise ValueError(\"username and password required for basic auth\")\n        elif self.auth_type == \"oauth2\":\n            if not self.client_id or not self.client_secret:\n                raise ValueError(\"client_id and client_secret required for OAuth2\")\n        return self\n\n    @field_validator(\"instance\", mode=\"before\")\n    @classmethod\n    def validate_instance(cls, v: str) -> str:\n        \"\"\"Validate and normalize instance URL.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            v = f\"https://{v}\"\n        return v.rstrip(\"/\")\n\n\n# CI/CD Configurations\n\n\nclass CICDIntegrationConfig(BaseIntegrationConfig):\n    \"\"\"Base configuration for CI/CD integrations.\"\"\"\n\n    integration_type: Literal[\"cicd\"] = \"cicd\"\n    fail_on_violation: bool = Field(default=True, description=\"Fail pipeline on policy violation\")\n    severity_threshold: str = Field(\n        default=\"medium\",\n        description=\"Minimum severity to fail pipeline (critical, high, medium, low)\",\n    )\n    include_annotations: bool = Field(\n        default=True, description=\"Include violation details as annotations/comments\"\n    )\n\n\nclass GitHubActionsConfig(CICDIntegrationConfig):\n    \"\"\"Configuration for GitHub Actions integration.\"\"\"\n\n    provider: Literal[\"github\"] = \"github\"\n\n    # Authentication\n    token: SecretStr = Field(..., description=\"GitHub Personal Access Token or App token\")\n    app_id: Optional[str] = Field(None, description=\"GitHub App ID (if using app authentication)\")\n    app_private_key: Optional[SecretStr] = Field(None, description=\"GitHub App private key\")\n\n    # Repository settings\n    owner: Optional[str] = Field(None, description=\"Repository owner/organization\")\n    repo: Optional[str] = Field(None, description=\"Repository name\")\n\n    # API settings\n    api_url: str = Field(\n        default=\"https://api.github.com\",\n        description=\"GitHub API URL (change for Enterprise)\",\n    )\n\n    # Action settings\n    check_name: str = Field(default=\"ACGS2 Policy Check\", description=\"Name of the check to create\")\n    status_context: str = Field(\n        default=\"acgs2/policy-validation\", description=\"Status context for commits\"\n    )\n\n\nclass GitLabCIConfig(CICDIntegrationConfig):\n    \"\"\"Configuration for GitLab CI integration.\"\"\"\n\n    provider: Literal[\"gitlab\"] = \"gitlab\"\n\n    # Authentication\n    token: SecretStr = Field(..., description=\"GitLab access token\")\n    token_type: Literal[\"personal\", \"project\", \"group\"] = Field(\n        default=\"personal\", description=\"Type of access token\"\n    )\n\n    # GitLab settings\n    api_url: str = Field(\n        default=\"https://gitlab.com\",\n        description=\"GitLab API URL (change for self-hosted)\",\n    )\n    project_id: Optional[str] = Field(\n        None, description=\"GitLab project ID or path (e.g., 'group/project')\"\n    )\n\n    # Pipeline settings\n    job_name: str = Field(default=\"acgs2-policy-check\", description=\"Name of the policy check job\")\n    allow_failure: bool = Field(\n        default=False, description=\"Allow job failure without blocking pipeline\"\n    )\n\n\n# Webhook Configuration\n\n\nclass WebhookConfig(BaseIntegrationConfig):\n    \"\"\"Configuration for custom webhook integrations.\"\"\"\n\n    integration_type: Literal[\"webhook\"] = \"webhook\"\n    provider: Literal[\"webhook\"] = \"webhook\"\n\n    # Endpoint settings\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    method: Literal[\"POST\", \"PUT\"] = Field(\n        default=\"POST\", description=\"HTTP method for webhook delivery\"\n    )\n\n    # Authentication\n    auth_type: AuthType = Field(default=AuthType.API_KEY, description=\"Authentication type\")\n    auth_header: str = Field(default=\"Authorization\", description=\"Header name for authentication\")\n    auth_value: Optional[SecretStr] = Field(\n        None, description=\"Authentication value (token, API key, etc.)\"\n    )\n    hmac_secret: Optional[SecretStr] = Field(\n        None, description=\"HMAC secret for signature verification\"\n    )\n    hmac_header: str = Field(default=\"X-Webhook-Signature\", description=\"Header for HMAC signature\")\n    hmac_algorithm: Literal[\"sha256\", \"sha512\"] = Field(\n        default=\"sha256\", description=\"HMAC algorithm\"\n    )\n\n    # Payload settings\n    content_type: str = Field(default=\"application/json\", description=\"Content-Type header value\")\n    include_headers: Dict[str, str] = Field(\n        default_factory=dict, description=\"Additional headers to include\"\n    )\n\n    # Delivery settings\n    max_retries: int = Field(default=3, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(\n        default=1.0, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n\n    @field_validator(\"url\", mode=\"before\")\n    @classmethod\n    def validate_url(cls, v: str) -> str:\n        \"\"\"Validate webhook URL.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            raise ValueError(\"Webhook URL must start with http:// or https://\")\n        return v\n\n\n# Union type for all integration configs\nIntegrationConfig = Union[\n    SplunkConfig,\n    SentinelConfig,\n    JiraConfig,\n    ServiceNowConfig,\n    GitHubActionsConfig,\n    GitLabCIConfig,\n    WebhookConfig,\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.313618",
  "last_updated": "2026-01-04T05:35:58.771874"
}