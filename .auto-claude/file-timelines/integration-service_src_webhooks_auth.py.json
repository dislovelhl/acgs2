{
  "file_path": "integration-service/src/webhooks/auth.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhook authentication handlers for ACGS-2 Integration Service.\n\nProvides authentication handlers for webhook endpoints including:\n- API key validation\n- HMAC signature verification\n- OAuth 2.0 bearer token validation\n\nSupports both incoming webhook verification (validating requests to our endpoints)\nand outgoing webhook authentication (authenticating requests we send).\n\"\"\"\n\nimport abc\nimport hashlib\nimport hmac\nimport logging\nimport re\nimport secrets\nimport warnings\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport httpx\nfrom pydantic import BaseModel, ConfigDict, Field, SecretStr\n\nfrom exceptions.auth import (\n    AuthenticationError,\n    InvalidApiKeyError,\n    InvalidBearerTokenError,\n    InvalidSignatureError,\n    MissingAuthHeaderError,\n    SignatureTimestampError,\n    TokenExpiredError,\n)\n\nfrom .models import WebhookAuthType\n\nlogger = logging.getLogger(__name__)\n\n\n# Backward compatibility aliases\n# These maintain API compatibility for existing code that imports from webhooks.auth\nclass WebhookAuthError(AuthenticationError):\n    \"\"\"\n    Deprecated: Use AuthenticationError from exceptions.auth instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookAuthError is deprecated. \"\n            \"Use AuthenticationError from exceptions.auth instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n# Public API exports - make exceptions available for import from this module\n__all__ = [\n    \"WebhookAuthError\",\n    \"AuthenticationError\",\n    \"InvalidSignatureError\",\n    \"InvalidApiKeyError\",\n    \"InvalidBearerTokenError\",\n    \"TokenExpiredError\",\n    \"SignatureTimestampError\",\n    \"MissingAuthHeaderError\",\n    \"AuthResult\",\n    \"OAuthToken\",\n    \"WebhookAuthHandler\",\n    \"ApiKeyAuthHandler\",\n    \"HmacAuthHandler\",\n    \"OAuthBearerAuthHandler\",\n    \"WebhookAuthRegistry\",\n]\n\n\n# ============================================================================\n# Authentication Result Models\n# ============================================================================\n\n\nclass AuthResult(BaseModel):\n    \"\"\"Result of an authentication attempt.\"\"\"\n\n    authenticated: bool = Field(..., description=\"Whether authentication succeeded\")\n    auth_type: WebhookAuthType = Field(..., description=\"Type of authentication used\")\n    principal: Optional[str] = Field(\n        None, description=\"Authenticated principal (user, key ID, etc.)\"\n    )\n    scopes: List[str] = Field(default_factory=list, description=\"Granted scopes/permissions\")\n    metadata: Dict[str, Any] = Field(default_factory=dict, description=\"Additional auth metadata\")\n\n    # Error details (if not authenticated)\n    error_code: Optional[str] = Field(None, description=\"Error code if authentication failed\")\n    error_message: Optional[str] = Field(None, description=\"Error message if authentication failed\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    @classmethod\n    def success(\n        cls,\n        auth_type: WebhookAuthType,\n        principal: Optional[str] = None,\n        scopes: Optional[List[str]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"AuthResult\":\n        \"\"\"Create a successful authentication result.\"\"\"\n        return cls(\n            authenticated=True,\n            auth_type=auth_type,\n            principal=principal,\n            scopes=scopes or [],\n            metadata=metadata or {},\n        )\n\n    @classmethod\n    def failure(\n        cls,\n        auth_type: WebhookAuthType,\n        error_code: str,\n        error_message: str,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"AuthResult\":\n        \"\"\"Create a failed authentication result.\"\"\"\n        return cls(\n            authenticated=False,\n            auth_type=auth_type,\n            error_code=error_code,\n            error_message=error_message,\n            metadata=metadata or {},\n        )\n\n\nclass OAuthToken(BaseModel):\n    \"\"\"OAuth 2.0 token model.\"\"\"\n\n    access_token: SecretStr = Field(..., description=\"The access token\")\n    token_type: str = Field(default=\"Bearer\", description=\"Token type (usually Bearer)\")\n    expires_in: Optional[int] = Field(None, description=\"Token lifetime in seconds\")\n    refresh_token: Optional[SecretStr] = Field(None, description=\"Refresh token if available\")\n    scope: Optional[str] = Field(None, description=\"Granted scopes (space-separated)\")\n\n    # Computed fields\n    issued_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"When the token was issued\",\n    )\n    expires_at: Optional[datetime] = Field(None, description=\"When the token expires\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    def model_post_init(self, _: Any) -> None:\n        \"\"\"Calculate expiration time if not set.\"\"\"\n        if self.expires_at is None and self.expires_in is not None:\n            self.expires_at = self.issued_at + timedelta(seconds=self.expires_in)\n\n    @property\n    def is_expired(self) -> bool:\n        \"\"\"Check if token is expired.\"\"\"\n        if self.expires_at is None:\n            return False\n        # Add 30 second buffer for clock skew\n        return datetime.now(timezone.utc) >= (self.expires_at - timedelta(seconds=30))\n\n    @property\n    def scopes(self) -> List[str]:\n        \"\"\"Get scopes as a list.\"\"\"\n        if self.scope is None:\n            return []\n        return self.scope.split()\n\n\n# ============================================================================\n# Abstract Base Handler\n# ============================================================================\n\n\nclass WebhookAuthHandler(abc.ABC):\n    \"\"\"\n    Abstract base class for webhook authentication handlers.\n\n    Handlers can be used to:\n    - Verify incoming webhook requests (requests received by our service)\n    - Prepare authentication for outgoing webhook requests (requests we send)\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def auth_type(self) -> WebhookAuthType:\n        \"\"\"Get the authentication type this handler supports.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"\n        Verify an incoming webhook request.\n\n        Args:\n            headers: Request headers (case-insensitive lookup)\n            body: Raw request body bytes\n            method: HTTP method\n            url: Request URL (optional)\n\n        Returns:\n            AuthResult indicating if the request is authenticated\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"\n        Prepare authentication headers for an outgoing request.\n\n        Args:\n            headers: Existing headers to augment\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL (optional)\n\n        Returns:\n            Headers dict with authentication headers added\n        \"\"\"\n        pass\n\n\n# ============================================================================\n# API Key Authentication Handler\n# ============================================================================\n\n\nclass ApiKeyAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    API Key authentication handler.\n\n    Validates API keys passed in request headers against a set of known valid keys.\n    Supports multiple header formats (X-API-Key, Authorization with API-Key prefix).\n    \"\"\"\n\n    def __init__(\n        self,\n        valid_keys: Optional[Dict[str, str]] = None,\n        header_name: str = \"X-API-Key\",\n        key_prefix: Optional[str] = None,\n        api_key: Optional[SecretStr] = None,\n    ):\n        \"\"\"\n        Initialize API key handler.\n\n        Args:\n            valid_keys: Dict mapping API key values to their identifiers/principals\n            header_name: Header name to look for API key\n            key_prefix: Optional prefix to strip (e.g., \"API-Key \" or \"Bearer \")\n            api_key: API key for outgoing requests (SecretStr for security)\n        \"\"\"\n        self._valid_keys: Dict[str, str] = valid_keys or {}\n        self._header_name = header_name\n        self._key_prefix = key_prefix\n        self._api_key = api_key\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.API_KEY\n\n    def add_valid_key(self, key: str, principal: str) -> None:\n        \"\"\"Add a valid API key.\"\"\"\n        self._valid_keys[key] = principal\n\n    def remove_valid_key(self, key: str) -> bool:\n        \"\"\"Remove a valid API key. Returns True if key was present.\"\"\"\n        if key in self._valid_keys:\n            del self._valid_keys[key]\n            return True\n        return False\n\n    def _get_header_value(self, headers: Dict[str, str]) -> Optional[str]:\n        \"\"\"Get the API key from headers (case-insensitive lookup).\"\"\"\n        # Normalize header names to lowercase for lookup\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n        header_name_lower = self._header_name.lower()\n\n        value = normalized_headers.get(header_name_lower)\n        if value is None:\n            # Try Authorization header as fallback\n            auth_header = normalized_headers.get(\"authorization\")\n            if auth_header and auth_header.lower().startswith(\"api-key \"):\n                value = auth_header[8:]  # len(\"API-Key \") = 8\n\n        if value and self._key_prefix:\n            if value.startswith(self._key_prefix):\n                value = value[len(self._key_prefix) :]\n            else:\n                # Prefix expected but not found\n                return None\n\n        return value.strip() if value else None\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify API key in request headers.\"\"\"\n        api_key = self._get_header_value(headers)\n\n        if api_key is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_API_KEY\",\n                error_message=f\"API key not found in {self._header_name} header\",\n            )\n\n        # Use constant-time comparison to prevent timing attacks\n        for valid_key, principal in self._valid_keys.items():\n            if secrets.compare_digest(api_key, valid_key):\n                logger.debug(f\"API key authenticated for principal: {principal}\")\n                return AuthResult.success(\n                    auth_type=self.auth_type,\n                    principal=principal,\n                    metadata={\"header\": self._header_name},\n                )\n\n        logger.warning(\"Invalid API key provided\")\n        return AuthResult.failure(\n            auth_type=self.auth_type,\n            error_code=\"INVALID_API_KEY\",\n            error_message=\"Invalid API key\",\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add API key to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        if self._api_key:\n            key_value = self._api_key.get_secret_value()\n            if self._key_prefix:\n                key_value = f\"{self._key_prefix}{key_value}\"\n            result[self._header_name] = key_value\n\n        return result\n\n\n# ============================================================================\n# HMAC Signature Authentication Handler\n# ============================================================================\n\n\nclass HmacAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    HMAC signature authentication handler.\n\n    Verifies webhook requests using HMAC signatures for payload integrity\n    and authenticity. Supports SHA-256 and SHA-512 algorithms.\n\n    Security features:\n    - Constant-time signature comparison to prevent timing attacks\n    - Timestamp validation for replay protection\n    - Multiple signature formats (sha256=xxx, t=xxx,v1=xxx)\n    \"\"\"\n\n    # Supported algorithms\n    ALGORITHMS = {\n        \"sha256\": hashlib.sha256,\n        \"sha512\": hashlib.sha512,\n    }\n\n    def __init__(\n        self,\n        secret: SecretStr,\n        signature_header: str = \"X-Webhook-Signature\",\n        timestamp_header: str = \"X-Webhook-Timestamp\",\n        algorithm: str = \"sha256\",\n        timestamp_tolerance_seconds: int = 300,\n        require_timestamp: bool = True,\n    ):\n        \"\"\"\n        Initialize HMAC handler.\n\n        Args:\n            secret: HMAC secret key\n            signature_header: Header name for signature\n            timestamp_header: Header name for timestamp\n            algorithm: Hash algorithm (sha256 or sha512)\n            timestamp_tolerance_seconds: Maximum age of request in seconds\n            require_timestamp: Whether to require and validate timestamp\n        \"\"\"\n        self._secret = secret\n        self._signature_header = signature_header\n        self._timestamp_header = timestamp_header\n        self._timestamp_tolerance = timestamp_tolerance_seconds\n        self._require_timestamp = require_timestamp\n\n        algorithm = algorithm.lower()\n        if algorithm not in self.ALGORITHMS:\n            raise ValueError(f\"Unsupported algorithm: {algorithm}. Use 'sha256' or 'sha512'\")\n        self._algorithm = algorithm\n        self._hash_func = self.ALGORITHMS[algorithm]\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.HMAC\n\n    def _compute_signature(self, payload: bytes, timestamp: Optional[str] = None) -> str:\n        \"\"\"\n        Compute HMAC signature for payload.\n\n        Args:\n            payload: Request body bytes\n            timestamp: Optional timestamp to include in signed data\n\n        Returns:\n            Hex-encoded signature\n        \"\"\"\n        secret = self._secret.get_secret_value().encode(\"utf-8\")\n\n        # If timestamp provided, prepend it to the payload (Stripe-style)\n        if timestamp:\n            signed_payload = f\"{timestamp}.\".encode(\"utf-8\") + payload\n        else:\n            signed_payload = payload\n\n        signature = hmac.new(secret, signed_payload, self._hash_func).hexdigest()\n        return signature\n\n    def _parse_signature_header(self, header_value: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"\n        Parse signature header value.\n\n        Supports multiple formats:\n        - \"sha256=abcd1234...\"  (simple format)\n        - \"t=1234567890,v1=abcd1234...\"  (Stripe-style with timestamp)\n\n        Args:\n            header_value: Raw header value\n\n        Returns:\n            Tuple of (signature, timestamp) - timestamp may be None\n        \"\"\"\n        header_value = header_value.strip()\n\n        # Try Stripe-style format: t=timestamp,v1=signature\n        if \",\" in header_value and \"=\" in header_value:\n            parts = {}\n            for part in header_value.split(\",\"):\n                if \"=\" in part:\n                    key, value = part.split(\"=\", 1)\n                    parts[key.strip()] = value.strip()\n\n            timestamp = parts.get(\"t\")\n            signature = parts.get(\"v1\") or parts.get(\"v2\")\n            if signature:\n                return signature, timestamp\n\n        # Try simple format: algorithm=signature\n        if \"=\" in header_value:\n            prefix, signature = header_value.split(\"=\", 1)\n            prefix_lower = prefix.lower().strip()\n            if prefix_lower in (\"sha256\", \"sha512\"):\n                return signature.strip(), None\n            # If prefix doesn't match known algorithm, treat whole value as signature\n            return header_value, None\n\n        # Plain signature\n        return header_value, None\n\n    def _validate_timestamp(self, timestamp_str: str) -> bool:\n        \"\"\"\n        Validate timestamp is within acceptable range.\n\n        Args:\n            timestamp_str: Timestamp as string (epoch seconds or ISO format)\n\n        Returns:\n            True if timestamp is valid\n        \"\"\"\n        try:\n            # Try parsing as epoch seconds\n            if timestamp_str.isdigit():\n                timestamp = int(timestamp_str)\n                request_time = datetime.fromtimestamp(timestamp, tz=timezone.utc)\n            else:\n                # Try ISO format\n                request_time = datetime.fromisoformat(timestamp_str.replace(\"Z\", \"+00:00\"))\n\n            now = datetime.now(timezone.utc)\n            age = abs((now - request_time).total_seconds())\n\n            return age <= self._timestamp_tolerance\n\n        except (ValueError, OverflowError):\n            return False\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify HMAC signature on request.\"\"\"\n        # Normalize headers\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n\n        # Get signature header\n        sig_header_lower = self._signature_header.lower()\n        signature_value = normalized_headers.get(sig_header_lower)\n\n        if signature_value is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_SIGNATURE\",\n                error_message=f\"Missing {self._signature_header} header\",\n            )\n\n        # Parse signature header\n        provided_signature, header_timestamp = self._parse_signature_header(signature_value)\n\n        if provided_signature is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"INVALID_SIGNATURE_FORMAT\",\n                error_message=\"Could not parse signature from header\",\n            )\n\n        # Get timestamp from header or dedicated timestamp header\n        timestamp = header_timestamp\n        if timestamp is None:\n            ts_header_lower = self._timestamp_header.lower()\n            timestamp = normalized_headers.get(ts_header_lower)\n\n        # Validate timestamp if required\n        if self._require_timestamp:\n            if timestamp is None:\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"MISSING_TIMESTAMP\",\n                    error_message=f\"Missing {self._timestamp_header} header\",\n                )\n\n            if not self._validate_timestamp(timestamp):\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"TIMESTAMP_EXPIRED\",\n                    error_message=(\n                        f\"Request timestamp is outside acceptable window \"\n                        f\"({self._timestamp_tolerance}s)\"\n                    ),\n                )\n\n        # Compute expected signature\n        expected_signature = self._compute_signature(body, timestamp if timestamp else None)\n\n        # Constant-time comparison to prevent timing attacks\n        if not secrets.compare_digest(provided_signature.lower(), expected_signature.lower()):\n            logger.warning(\"HMAC signature verification failed\")\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"INVALID_SIGNATURE\",\n                error_message=\"Signature verification failed\",\n            )\n\n        logger.debug(\"HMAC signature verified successfully\")\n        return AuthResult.success(\n            auth_type=self.auth_type,\n            principal=\"hmac_verified\",\n            metadata={\n                \"algorithm\": self._algorithm,\n                \"timestamp\": timestamp,\n            },\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add HMAC signature to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        # Generate timestamp\n        timestamp = str(int(datetime.now(timezone.utc).timestamp()))\n        result[self._timestamp_header] = timestamp\n\n        # Compute signature\n        signature = self._compute_signature(body, timestamp)\n        result[self._signature_header] = f\"{self._algorithm}={signature}\"\n\n        return result\n\n\n# ============================================================================\n# OAuth Bearer Token Authentication Handler\n# ============================================================================\n\n\nclass OAuthBearerAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    OAuth 2.0 Bearer token authentication handler.\n\n    Supports:\n    - Token validation against token info endpoint\n    - Local token validation with optional JWKS\n    - Token refresh using refresh tokens\n    - Scope verification\n    \"\"\"\n\n    def __init__(\n        self,\n        token_info_url: Optional[str] = None,\n        required_scopes: Optional[List[str]] = None,\n        access_token: Optional[SecretStr] = None,\n        refresh_token: Optional[SecretStr] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[SecretStr] = None,\n        token_url: Optional[str] = None,\n        valid_tokens: Optional[Dict[str, OAuthToken]] = None,\n    ):\n        \"\"\"\n        Initialize OAuth bearer handler.\n\n        Args:\n            token_info_url: URL to validate tokens (e.g., /oauth/token_info)\n            required_scopes: Required scopes for authorization\n            access_token: Access token for outgoing requests\n            refresh_token: Refresh token for token refresh\n            client_id: OAuth client ID for token refresh\n            client_secret: OAuth client secret for token refresh\n            token_url: Token endpoint URL for refresh\n            valid_tokens: Dict of valid tokens (for local validation)\n        \"\"\"\n        self._token_info_url = token_info_url\n        self._required_scopes = set(required_scopes or [])\n        self._access_token = access_token\n        self._refresh_token = refresh_token\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._token_url = token_url\n        self._valid_tokens: Dict[str, OAuthToken] = valid_tokens or {}\n        self._http_client: Optional[httpx.AsyncClient] = None\n        self._current_token: Optional[OAuthToken] = None\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.OAUTH2\n\n    async def _get_http_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._http_client is None or self._http_client.is_closed:\n            self._http_client = httpx.AsyncClient(timeout=30.0)\n        return self._http_client\n\n    async def close(self) -> None:\n        \"\"\"Close HTTP client.\"\"\"\n        if self._http_client is not None:\n            await self._http_client.aclose()\n            self._http_client = None\n\n    def add_valid_token(self, token_value: str, token: OAuthToken) -> None:\n        \"\"\"Add a valid token for local validation.\"\"\"\n        self._valid_tokens[token_value] = token\n\n    def remove_valid_token(self, token_value: str) -> bool:\n        \"\"\"Remove a valid token. Returns True if token was present.\"\"\"\n        if token_value in self._valid_tokens:\n            del self._valid_tokens[token_value]\n            return True\n        return False\n\n    def _extract_bearer_token(self, headers: Dict[str, str]) -> Optional[str]:\n        \"\"\"Extract bearer token from Authorization header.\"\"\"\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n        auth_header = normalized_headers.get(\"authorization\")\n\n        if auth_header is None:\n            return None\n\n        # Bearer token format: \"Bearer <token>\"\n        match = re.match(r\"^Bearer\\s+(.+)$\", auth_header, re.IGNORECASE)\n        if match:\n            return match.group(1).strip()\n\n        return None\n\n    async def _validate_token_local(self, token_value: str) -> Tuple[bool, Optional[OAuthToken]]:\n        \"\"\"Validate token against local store.\"\"\"\n        token = self._valid_tokens.get(token_value)\n        if token is None:\n            return False, None\n\n        if token.is_expired:\n            return False, token\n\n        return True, token\n\n    async def _validate_token_remote(\n        self, token_value: str\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"Validate token against remote token info endpoint.\"\"\"\n        if self._token_info_url is None:\n            return False, None\n\n        try:\n            client = await self._get_http_client()\n            response = await client.post(\n                self._token_info_url,\n                data={\"token\": token_value},\n            )\n\n            if response.status_code != 200:\n                return False, None\n\n            token_info = response.json()\n\n            # Check if token is active\n            if not token_info.get(\"active\", False):\n                return False, token_info\n\n            return True, token_info\n\n        except Exception as e:\n            logger.error(f\"Token validation request failed: {e}\")\n            return False, None\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify bearer token in request.\"\"\"\n        token_value = self._extract_bearer_token(headers)\n\n        if token_value is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_BEARER_TOKEN\",\n                error_message=\"Missing or invalid Authorization header\",\n            )\n\n        # Try local validation first\n        is_valid, token = await self._validate_token_local(token_value)\n\n        if is_valid and token is not None:\n            # Check scopes\n            token_scopes = set(token.scopes)\n            if self._required_scopes and not self._required_scopes.issubset(token_scopes):\n                missing = self._required_scopes - token_scopes\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"INSUFFICIENT_SCOPE\",\n                    error_message=f\"Missing required scopes: {', '.join(missing)}\",\n                )\n\n            return AuthResult.success(\n                auth_type=self.auth_type,\n                principal=\"oauth_user\",\n                scopes=list(token_scopes),\n                metadata={\"expires_at\": token.expires_at.isoformat() if token.expires_at else None},\n            )\n\n        if token is not None and token.is_expired:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"TOKEN_EXPIRED\",\n                error_message=\"Bearer token has expired\",\n            )\n\n        # Try remote validation\n        if self._token_info_url:\n            is_valid, token_info = await self._validate_token_remote(token_value)\n\n            if is_valid and token_info:\n                # Check scopes from token info\n                scope_str = token_info.get(\"scope\", \"\")\n                token_scopes = set(scope_str.split()) if scope_str else set()\n\n                if self._required_scopes and not self._required_scopes.issubset(token_scopes):\n                    missing = self._required_scopes - token_scopes\n                    return AuthResult.failure(\n                        auth_type=self.auth_type,\n                        error_code=\"INSUFFICIENT_SCOPE\",\n                        error_message=f\"Missing required scopes: {', '.join(missing)}\",\n                    )\n\n                return AuthResult.success(\n                    auth_type=self.auth_type,\n                    principal=token_info.get(\"sub\") or token_info.get(\"username\") or \"oauth_user\",\n                    scopes=list(token_scopes),\n                    metadata={\"token_info\": token_info},\n                )\n\n        return AuthResult.failure(\n            auth_type=self.auth_type,\n            error_code=\"INVALID_TOKEN\",\n            error_message=\"Bearer token validation failed\",\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add bearer token to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        # Check if we need to refresh the token\n        await self._ensure_valid_token()\n\n        if self._current_token and not self._current_token.is_expired:\n            token_value = self._current_token.access_token.get_secret_value()\n            result[\"Authorization\"] = f\"Bearer {token_value}\"\n        elif self._access_token:\n            result[\"Authorization\"] = f\"Bearer {self._access_token.get_secret_value()}\"\n\n        return result\n\n    async def _ensure_valid_token(self) -> None:\n        \"\"\"Ensure we have a valid access token, refreshing if necessary.\"\"\"\n        if self._current_token is None and self._access_token:\n            # Initialize current token from access_token\n            self._current_token = OAuthToken(\n                access_token=self._access_token,\n                refresh_token=self._refresh_token,\n            )\n            return\n\n        if self._current_token is None:\n            return\n\n        if not self._current_token.is_expired:\n            return\n\n        # Try to refresh\n        if self._current_token.refresh_token and self._token_url:\n            try:\n                new_token = await self._refresh_access_token()\n                if new_token:\n                    self._current_token = new_token\n            except Exception as e:\n                logger.error(f\"Token refresh failed: {e}\")\n\n    async def _refresh_access_token(self) -> Optional[OAuthToken]:\n        \"\"\"Refresh the access token using refresh token.\"\"\"\n        if not self._token_url or not self._current_token or not self._current_token.refresh_token:\n            return None\n\n        try:\n            client = await self._get_http_client()\n\n            data = {\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self._current_token.refresh_token.get_secret_value(),\n            }\n\n            if self._client_id:\n                data[\"client_id\"] = self._client_id\n            if self._client_secret:\n                data[\"client_secret\"] = self._client_secret.get_secret_value()\n\n            response = await client.post(self._token_url, data=data)\n\n            if response.status_code != 200:\n                logger.error(f\"Token refresh failed with status {response.status_code}\")\n                return None\n\n            token_data = response.json()\n            return OAuthToken(\n                access_token=SecretStr(token_data[\"access_token\"]),\n                token_type=token_data.get(\"token_type\", \"Bearer\"),\n                expires_in=token_data.get(\"expires_in\"),\n                refresh_token=(\n                    SecretStr(token_data[\"refresh_token\"])\n                    if \"refresh_token\" in token_data\n                    else self._current_token.refresh_token\n                ),\n                scope=token_data.get(\"scope\"),\n            )\n\n        except Exception as e:\n            logger.error(f\"Token refresh request failed: {e}\")\n            return None\n\n    async def refresh_token(self) -> Optional[OAuthToken]:\n        \"\"\"\n        Public method to refresh the access token.\n\n        Returns:\n            New OAuthToken if refresh succeeded, None otherwise\n        \"\"\"\n        return await self._refresh_access_token()\n\n\n# ============================================================================\n# Authentication Handler Registry\n# ============================================================================\n\n\nclass WebhookAuthRegistry:\n    \"\"\"\n    Registry for webhook authentication handlers.\n\n    Provides a centralized way to manage and lookup authentication handlers\n    by type for both incoming and outgoing webhook authentication.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the registry.\"\"\"\n        self._handlers: Dict[WebhookAuthType, WebhookAuthHandler] = {}\n\n    def register(self, handler: WebhookAuthHandler) -> None:\n        \"\"\"Register an authentication handler.\"\"\"\n        self._handlers[handler.auth_type] = handler\n        logger.debug(f\"Registered auth handler for {handler.auth_type.value}\")\n\n    def unregister(self, auth_type: WebhookAuthType) -> Optional[WebhookAuthHandler]:\n        \"\"\"Unregister and return an authentication handler.\"\"\"\n        return self._handlers.pop(auth_type, None)\n\n    def get(self, auth_type: WebhookAuthType) -> Optional[WebhookAuthHandler]:\n        \"\"\"Get an authentication handler by type.\"\"\"\n        return self._handlers.get(auth_type)\n\n    def get_all(self) -> Dict[WebhookAuthType, WebhookAuthHandler]:\n        \"\"\"Get all registered handlers.\"\"\"\n        return dict(self._handlers)\n\n    async def verify_request(\n        self,\n        auth_type: WebhookAuthType,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"\n        Verify a request using the appropriate handler.\n\n        Args:\n            auth_type: Type of authentication to use\n            headers: Request headers\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL\n\n        Returns:\n            AuthResult from the handler\n        \"\"\"\n        if auth_type == WebhookAuthType.NONE:\n            return AuthResult.success(auth_type=auth_type)\n\n        handler = self._handlers.get(auth_type)\n        if handler is None:\n            return AuthResult.failure(\n                auth_type=auth_type,\n                error_code=\"NO_HANDLER\",\n                error_message=f\"No handler registered for {auth_type.value}\",\n            )\n\n        return await handler.verify_request(headers, body, method, url)\n\n    async def prepare_headers(\n        self,\n        auth_type: WebhookAuthType,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"\n        Prepare authentication headers using the appropriate handler.\n\n        Args:\n            auth_type: Type of authentication to use\n            headers: Existing headers\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL\n\n        Returns:\n            Headers dict with authentication added\n        \"\"\"\n        if auth_type == WebhookAuthType.NONE:\n            return dict(headers)\n\n        handler = self._handlers.get(auth_type)\n        if handler is None:\n            logger.warning(f\"No handler for {auth_type.value}, returning headers unchanged\")\n            return dict(headers)\n\n        return await handler.prepare_headers(headers, body, method, url)\n\n\n# ============================================================================\n# Factory Functions\n# ============================================================================\n\n\ndef create_api_key_handler(\n    valid_keys: Optional[Dict[str, str]] = None,\n    header_name: str = \"X-API-Key\",\n    api_key: Optional[SecretStr] = None,\n) -> ApiKeyAuthHandler:\n    \"\"\"\n    Create an API key authentication handler.\n\n    Args:\n        valid_keys: Dict mapping API key values to principals\n        header_name: Header name for API key\n        api_key: API key for outgoing requests\n\n    Returns:\n        Configured ApiKeyAuthHandler\n    \"\"\"\n    return ApiKeyAuthHandler(\n        valid_keys=valid_keys,\n        header_name=header_name,\n        api_key=api_key,\n    )\n\n\ndef create_hmac_handler(\n    secret: SecretStr,\n    signature_header: str = \"X-Webhook-Signature\",\n    timestamp_header: str = \"X-Webhook-Timestamp\",\n    algorithm: str = \"sha256\",\n    timestamp_tolerance_seconds: int = 300,\n) -> HmacAuthHandler:\n    \"\"\"\n    Create an HMAC signature authentication handler.\n\n    Args:\n        secret: HMAC secret key\n        signature_header: Header name for signature\n        timestamp_header: Header name for timestamp\n        algorithm: Hash algorithm (sha256 or sha512)\n        timestamp_tolerance_seconds: Maximum request age\n\n    Returns:\n        Configured HmacAuthHandler\n    \"\"\"\n    return HmacAuthHandler(\n        secret=secret,\n        signature_header=signature_header,\n        timestamp_header=timestamp_header,\n        algorithm=algorithm,\n        timestamp_tolerance_seconds=timestamp_tolerance_seconds,\n    )\n\n\ndef create_oauth_handler(\n    token_info_url: Optional[str] = None,\n    required_scopes: Optional[List[str]] = None,\n    access_token: Optional[SecretStr] = None,\n    refresh_token: Optional[SecretStr] = None,\n    client_id: Optional[str] = None,\n    client_secret: Optional[SecretStr] = None,\n    token_url: Optional[str] = None,\n) -> OAuthBearerAuthHandler:\n    \"\"\"\n    Create an OAuth bearer token authentication handler.\n\n    Args:\n        token_info_url: URL to validate tokens\n        required_scopes: Required scopes for authorization\n        access_token: Access token for outgoing requests\n        refresh_token: Refresh token for refresh flow\n        client_id: OAuth client ID\n        client_secret: OAuth client secret\n        token_url: Token endpoint URL\n\n    Returns:\n        Configured OAuthBearerAuthHandler\n    \"\"\"\n    return OAuthBearerAuthHandler(\n        token_info_url=token_info_url,\n        required_scopes=required_scopes,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        client_id=client_id,\n        client_secret=client_secret,\n        token_url=token_url,\n    )\n\n\ndef create_default_registry() -> WebhookAuthRegistry:\n    \"\"\"\n    Create a registry with default handlers.\n\n    Returns:\n        WebhookAuthRegistry with common handlers registered\n    \"\"\"\n    registry = WebhookAuthRegistry()\n    # Note: Handlers need to be configured with secrets before use\n    # This just provides the registry structure\n    return registry\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhook authentication handlers for ACGS-2 Integration Service.\n\nProvides authentication handlers for webhook endpoints including:\n- API key validation\n- HMAC signature verification\n- OAuth 2.0 bearer token validation\n\nSupports both incoming webhook verification (validating requests to our endpoints)\nand outgoing webhook authentication (authenticating requests we send).\n\"\"\"\n\nimport abc\nimport hashlib\nimport hmac\nimport logging\nimport re\nimport secrets\nimport warnings\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport httpx\nfrom pydantic import BaseModel, ConfigDict, Field, SecretStr\n\nfrom exceptions.auth import (\n    AuthenticationError,\n    InvalidApiKeyError,\n    InvalidBearerTokenError,\n    InvalidSignatureError,\n    MissingAuthHeaderError,\n    SignatureTimestampError,\n    TokenExpiredError,\n)\n\nfrom .models import WebhookAuthType\n\nlogger = logging.getLogger(__name__)\n\n\n# Backward compatibility aliases\n# These maintain API compatibility for existing code that imports from webhooks.auth\nclass WebhookAuthError(AuthenticationError):\n    \"\"\"\n    Deprecated: Use AuthenticationError from exceptions.auth instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookAuthError is deprecated. \"\n            \"Use AuthenticationError from exceptions.auth instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n# Public API exports - make exceptions available for import from this module\n__all__ = [\n    \"WebhookAuthError\",\n    \"AuthenticationError\",\n    \"InvalidSignatureError\",\n    \"InvalidApiKeyError\",\n    \"InvalidBearerTokenError\",\n    \"TokenExpiredError\",\n    \"SignatureTimestampError\",\n    \"MissingAuthHeaderError\",\n    \"AuthResult\",\n    \"OAuthToken\",\n    \"WebhookAuthHandler\",\n    \"ApiKeyAuthHandler\",\n    \"HmacAuthHandler\",\n    \"OAuthBearerAuthHandler\",\n    \"WebhookAuthRegistry\",\n]\n\n\n# ============================================================================\n# Authentication Result Models\n# ============================================================================\n\n\nclass AuthResult(BaseModel):\n    \"\"\"Result of an authentication attempt.\"\"\"\n\n    authenticated: bool = Field(..., description=\"Whether authentication succeeded\")\n    auth_type: WebhookAuthType = Field(..., description=\"Type of authentication used\")\n    principal: Optional[str] = Field(\n        None, description=\"Authenticated principal (user, key ID, etc.)\"\n    )\n    scopes: List[str] = Field(default_factory=list, description=\"Granted scopes/permissions\")\n    metadata: Dict[str, Any] = Field(default_factory=dict, description=\"Additional auth metadata\")\n\n    # Error details (if not authenticated)\n    error_code: Optional[str] = Field(None, description=\"Error code if authentication failed\")\n    error_message: Optional[str] = Field(None, description=\"Error message if authentication failed\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    @classmethod\n    def success(\n        cls,\n        auth_type: WebhookAuthType,\n        principal: Optional[str] = None,\n        scopes: Optional[List[str]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"AuthResult\":\n        \"\"\"Create a successful authentication result.\"\"\"\n        return cls(\n            authenticated=True,\n            auth_type=auth_type,\n            principal=principal,\n            scopes=scopes or [],\n            metadata=metadata or {},\n        )\n\n    @classmethod\n    def failure(\n        cls,\n        auth_type: WebhookAuthType,\n        error_code: str,\n        error_message: str,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> \"AuthResult\":\n        \"\"\"Create a failed authentication result.\"\"\"\n        return cls(\n            authenticated=False,\n            auth_type=auth_type,\n            error_code=error_code,\n            error_message=error_message,\n            metadata=metadata or {},\n        )\n\n\nclass OAuthToken(BaseModel):\n    \"\"\"OAuth 2.0 token model.\"\"\"\n\n    access_token: SecretStr = Field(..., description=\"The access token\")\n    token_type: str = Field(default=\"Bearer\", description=\"Token type (usually Bearer)\")\n    expires_in: Optional[int] = Field(None, description=\"Token lifetime in seconds\")\n    refresh_token: Optional[SecretStr] = Field(None, description=\"Refresh token if available\")\n    scope: Optional[str] = Field(None, description=\"Granted scopes (space-separated)\")\n\n    # Computed fields\n    issued_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"When the token was issued\",\n    )\n    expires_at: Optional[datetime] = Field(None, description=\"When the token expires\")\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        str_strip_whitespace=True,\n    )\n\n    def model_post_init(self, _: Any) -> None:\n        \"\"\"Calculate expiration time if not set.\"\"\"\n        if self.expires_at is None and self.expires_in is not None:\n            self.expires_at = self.issued_at + timedelta(seconds=self.expires_in)\n\n    @property\n    def is_expired(self) -> bool:\n        \"\"\"Check if token is expired.\"\"\"\n        if self.expires_at is None:\n            return False\n        # Add 30 second buffer for clock skew\n        return datetime.now(timezone.utc) >= (self.expires_at - timedelta(seconds=30))\n\n    @property\n    def scopes(self) -> List[str]:\n        \"\"\"Get scopes as a list.\"\"\"\n        if self.scope is None:\n            return []\n        return self.scope.split()\n\n\n# ============================================================================\n# Abstract Base Handler\n# ============================================================================\n\n\nclass WebhookAuthHandler(abc.ABC):\n    \"\"\"\n    Abstract base class for webhook authentication handlers.\n\n    Handlers can be used to:\n    - Verify incoming webhook requests (requests received by our service)\n    - Prepare authentication for outgoing webhook requests (requests we send)\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def auth_type(self) -> WebhookAuthType:\n        \"\"\"Get the authentication type this handler supports.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"\n        Verify an incoming webhook request.\n\n        Args:\n            headers: Request headers (case-insensitive lookup)\n            body: Raw request body bytes\n            method: HTTP method\n            url: Request URL (optional)\n\n        Returns:\n            AuthResult indicating if the request is authenticated\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"\n        Prepare authentication headers for an outgoing request.\n\n        Args:\n            headers: Existing headers to augment\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL (optional)\n\n        Returns:\n            Headers dict with authentication headers added\n        \"\"\"\n        pass\n\n\n# ============================================================================\n# API Key Authentication Handler\n# ============================================================================\n\n\nclass ApiKeyAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    API Key authentication handler.\n\n    Validates API keys passed in request headers against a set of known valid keys.\n    Supports multiple header formats (X-API-Key, Authorization with API-Key prefix).\n    \"\"\"\n\n    def __init__(\n        self,\n        valid_keys: Optional[Dict[str, str]] = None,\n        header_name: str = \"X-API-Key\",\n        key_prefix: Optional[str] = None,\n        api_key: Optional[SecretStr] = None,\n    ):\n        \"\"\"\n        Initialize API key handler.\n\n        Args:\n            valid_keys: Dict mapping API key values to their identifiers/principals\n            header_name: Header name to look for API key\n            key_prefix: Optional prefix to strip (e.g., \"API-Key \" or \"Bearer \")\n            api_key: API key for outgoing requests (SecretStr for security)\n        \"\"\"\n        self._valid_keys: Dict[str, str] = valid_keys or {}\n        self._header_name = header_name\n        self._key_prefix = key_prefix\n        self._api_key = api_key\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.API_KEY\n\n    def add_valid_key(self, key: str, principal: str) -> None:\n        \"\"\"Add a valid API key.\"\"\"\n        self._valid_keys[key] = principal\n\n    def remove_valid_key(self, key: str) -> bool:\n        \"\"\"Remove a valid API key. Returns True if key was present.\"\"\"\n        if key in self._valid_keys:\n            del self._valid_keys[key]\n            return True\n        return False\n\n    def _get_header_value(self, headers: Dict[str, str]) -> Optional[str]:\n        \"\"\"Get the API key from headers (case-insensitive lookup).\"\"\"\n        # Normalize header names to lowercase for lookup\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n        header_name_lower = self._header_name.lower()\n\n        value = normalized_headers.get(header_name_lower)\n        if value is None:\n            # Try Authorization header as fallback\n            auth_header = normalized_headers.get(\"authorization\")\n            if auth_header and auth_header.lower().startswith(\"api-key \"):\n                value = auth_header[8:]  # len(\"API-Key \") = 8\n\n        if value and self._key_prefix:\n            if value.startswith(self._key_prefix):\n                value = value[len(self._key_prefix) :]\n            else:\n                # Prefix expected but not found\n                return None\n\n        return value.strip() if value else None\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify API key in request headers.\"\"\"\n        api_key = self._get_header_value(headers)\n\n        if api_key is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_API_KEY\",\n                error_message=f\"API key not found in {self._header_name} header\",\n            )\n\n        # Use constant-time comparison to prevent timing attacks\n        for valid_key, principal in self._valid_keys.items():\n            if secrets.compare_digest(api_key, valid_key):\n                logger.debug(f\"API key authenticated for principal: {principal}\")\n                return AuthResult.success(\n                    auth_type=self.auth_type,\n                    principal=principal,\n                    metadata={\"header\": self._header_name},\n                )\n\n        logger.warning(\"Invalid API key provided\")\n        return AuthResult.failure(\n            auth_type=self.auth_type,\n            error_code=\"INVALID_API_KEY\",\n            error_message=\"Invalid API key\",\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add API key to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        if self._api_key:\n            key_value = self._api_key.get_secret_value()\n            if self._key_prefix:\n                key_value = f\"{self._key_prefix}{key_value}\"\n            result[self._header_name] = key_value\n\n        return result\n\n\n# ============================================================================\n# HMAC Signature Authentication Handler\n# ============================================================================\n\n\nclass HmacAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    HMAC signature authentication handler.\n\n    Verifies webhook requests using HMAC signatures for payload integrity\n    and authenticity. Supports SHA-256 and SHA-512 algorithms.\n\n    Security features:\n    - Constant-time signature comparison to prevent timing attacks\n    - Timestamp validation for replay protection\n    - Multiple signature formats (sha256=xxx, t=xxx,v1=xxx)\n    \"\"\"\n\n    # Supported algorithms\n    ALGORITHMS = {\n        \"sha256\": hashlib.sha256,\n        \"sha512\": hashlib.sha512,\n    }\n\n    def __init__(\n        self,\n        secret: SecretStr,\n        signature_header: str = \"X-Webhook-Signature\",\n        timestamp_header: str = \"X-Webhook-Timestamp\",\n        algorithm: str = \"sha256\",\n        timestamp_tolerance_seconds: int = 300,\n        require_timestamp: bool = True,\n    ):\n        \"\"\"\n        Initialize HMAC handler.\n\n        Args:\n            secret: HMAC secret key\n            signature_header: Header name for signature\n            timestamp_header: Header name for timestamp\n            algorithm: Hash algorithm (sha256 or sha512)\n            timestamp_tolerance_seconds: Maximum age of request in seconds\n            require_timestamp: Whether to require and validate timestamp\n        \"\"\"\n        self._secret = secret\n        self._signature_header = signature_header\n        self._timestamp_header = timestamp_header\n        self._timestamp_tolerance = timestamp_tolerance_seconds\n        self._require_timestamp = require_timestamp\n\n        algorithm = algorithm.lower()\n        if algorithm not in self.ALGORITHMS:\n            raise ValueError(f\"Unsupported algorithm: {algorithm}. Use 'sha256' or 'sha512'\")\n        self._algorithm = algorithm\n        self._hash_func = self.ALGORITHMS[algorithm]\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.HMAC\n\n    def _compute_signature(self, payload: bytes, timestamp: Optional[str] = None) -> str:\n        \"\"\"\n        Compute HMAC signature for payload.\n\n        Args:\n            payload: Request body bytes\n            timestamp: Optional timestamp to include in signed data\n\n        Returns:\n            Hex-encoded signature\n        \"\"\"\n        secret = self._secret.get_secret_value().encode(\"utf-8\")\n\n        # If timestamp provided, prepend it to the payload (Stripe-style)\n        if timestamp:\n            signed_payload = f\"{timestamp}.\".encode(\"utf-8\") + payload\n        else:\n            signed_payload = payload\n\n        signature = hmac.new(secret, signed_payload, self._hash_func).hexdigest()\n        return signature\n\n    def _parse_signature_header(self, header_value: str) -> Tuple[Optional[str], Optional[str]]:\n        \"\"\"\n        Parse signature header value.\n\n        Supports multiple formats:\n        - \"sha256=abcd1234...\"  (simple format)\n        - \"t=1234567890,v1=abcd1234...\"  (Stripe-style with timestamp)\n\n        Args:\n            header_value: Raw header value\n\n        Returns:\n            Tuple of (signature, timestamp) - timestamp may be None\n        \"\"\"\n        header_value = header_value.strip()\n\n        # Try Stripe-style format: t=timestamp,v1=signature\n        if \",\" in header_value and \"=\" in header_value:\n            parts = {}\n            for part in header_value.split(\",\"):\n                if \"=\" in part:\n                    key, value = part.split(\"=\", 1)\n                    parts[key.strip()] = value.strip()\n\n            timestamp = parts.get(\"t\")\n            signature = parts.get(\"v1\") or parts.get(\"v2\")\n            if signature:\n                return signature, timestamp\n\n        # Try simple format: algorithm=signature\n        if \"=\" in header_value:\n            prefix, signature = header_value.split(\"=\", 1)\n            prefix_lower = prefix.lower().strip()\n            if prefix_lower in (\"sha256\", \"sha512\"):\n                return signature.strip(), None\n            # If prefix doesn't match known algorithm, treat whole value as signature\n            return header_value, None\n\n        # Plain signature\n        return header_value, None\n\n    def _validate_timestamp(self, timestamp_str: str) -> bool:\n        \"\"\"\n        Validate timestamp is within acceptable range.\n\n        Args:\n            timestamp_str: Timestamp as string (epoch seconds or ISO format)\n\n        Returns:\n            True if timestamp is valid\n        \"\"\"\n        try:\n            # Try parsing as epoch seconds\n            if timestamp_str.isdigit():\n                timestamp = int(timestamp_str)\n                request_time = datetime.fromtimestamp(timestamp, tz=timezone.utc)\n            else:\n                # Try ISO format\n                request_time = datetime.fromisoformat(timestamp_str.replace(\"Z\", \"+00:00\"))\n\n            now = datetime.now(timezone.utc)\n            age = abs((now - request_time).total_seconds())\n\n            return age <= self._timestamp_tolerance\n\n        except (ValueError, OverflowError):\n            return False\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify HMAC signature on request.\"\"\"\n        # Normalize headers\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n\n        # Get signature header\n        sig_header_lower = self._signature_header.lower()\n        signature_value = normalized_headers.get(sig_header_lower)\n\n        if signature_value is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_SIGNATURE\",\n                error_message=f\"Missing {self._signature_header} header\",\n            )\n\n        # Parse signature header\n        provided_signature, header_timestamp = self._parse_signature_header(signature_value)\n\n        if provided_signature is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"INVALID_SIGNATURE_FORMAT\",\n                error_message=\"Could not parse signature from header\",\n            )\n\n        # Get timestamp from header or dedicated timestamp header\n        timestamp = header_timestamp\n        if timestamp is None:\n            ts_header_lower = self._timestamp_header.lower()\n            timestamp = normalized_headers.get(ts_header_lower)\n\n        # Validate timestamp if required\n        if self._require_timestamp:\n            if timestamp is None:\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"MISSING_TIMESTAMP\",\n                    error_message=f\"Missing {self._timestamp_header} header\",\n                )\n\n            if not self._validate_timestamp(timestamp):\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"TIMESTAMP_EXPIRED\",\n                    error_message=(\n                        f\"Request timestamp is outside acceptable window \"\n                        f\"({self._timestamp_tolerance}s)\"\n                    ),\n                )\n\n        # Compute expected signature\n        expected_signature = self._compute_signature(body, timestamp if timestamp else None)\n\n        # Constant-time comparison to prevent timing attacks\n        if not secrets.compare_digest(provided_signature.lower(), expected_signature.lower()):\n            logger.warning(\"HMAC signature verification failed\")\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"INVALID_SIGNATURE\",\n                error_message=\"Signature verification failed\",\n            )\n\n        logger.debug(\"HMAC signature verified successfully\")\n        return AuthResult.success(\n            auth_type=self.auth_type,\n            principal=\"hmac_verified\",\n            metadata={\n                \"algorithm\": self._algorithm,\n                \"timestamp\": timestamp,\n            },\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add HMAC signature to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        # Generate timestamp\n        timestamp = str(int(datetime.now(timezone.utc).timestamp()))\n        result[self._timestamp_header] = timestamp\n\n        # Compute signature\n        signature = self._compute_signature(body, timestamp)\n        result[self._signature_header] = f\"{self._algorithm}={signature}\"\n\n        return result\n\n\n# ============================================================================\n# OAuth Bearer Token Authentication Handler\n# ============================================================================\n\n\nclass OAuthBearerAuthHandler(WebhookAuthHandler):\n    \"\"\"\n    OAuth 2.0 Bearer token authentication handler.\n\n    Supports:\n    - Token validation against token info endpoint\n    - Local token validation with optional JWKS\n    - Token refresh using refresh tokens\n    - Scope verification\n    \"\"\"\n\n    def __init__(\n        self,\n        token_info_url: Optional[str] = None,\n        required_scopes: Optional[List[str]] = None,\n        access_token: Optional[SecretStr] = None,\n        refresh_token: Optional[SecretStr] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[SecretStr] = None,\n        token_url: Optional[str] = None,\n        valid_tokens: Optional[Dict[str, OAuthToken]] = None,\n    ):\n        \"\"\"\n        Initialize OAuth bearer handler.\n\n        Args:\n            token_info_url: URL to validate tokens (e.g., /oauth/token_info)\n            required_scopes: Required scopes for authorization\n            access_token: Access token for outgoing requests\n            refresh_token: Refresh token for token refresh\n            client_id: OAuth client ID for token refresh\n            client_secret: OAuth client secret for token refresh\n            token_url: Token endpoint URL for refresh\n            valid_tokens: Dict of valid tokens (for local validation)\n        \"\"\"\n        self._token_info_url = token_info_url\n        self._required_scopes = set(required_scopes or [])\n        self._access_token = access_token\n        self._refresh_token = refresh_token\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._token_url = token_url\n        self._valid_tokens: Dict[str, OAuthToken] = valid_tokens or {}\n        self._http_client: Optional[httpx.AsyncClient] = None\n        self._current_token: Optional[OAuthToken] = None\n\n    @property\n    def auth_type(self) -> WebhookAuthType:\n        return WebhookAuthType.OAUTH2\n\n    async def _get_http_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._http_client is None or self._http_client.is_closed:\n            self._http_client = httpx.AsyncClient(timeout=30.0)\n        return self._http_client\n\n    async def close(self) -> None:\n        \"\"\"Close HTTP client.\"\"\"\n        if self._http_client is not None:\n            await self._http_client.aclose()\n            self._http_client = None\n\n    def add_valid_token(self, token_value: str, token: OAuthToken) -> None:\n        \"\"\"Add a valid token for local validation.\"\"\"\n        self._valid_tokens[token_value] = token\n\n    def remove_valid_token(self, token_value: str) -> bool:\n        \"\"\"Remove a valid token. Returns True if token was present.\"\"\"\n        if token_value in self._valid_tokens:\n            del self._valid_tokens[token_value]\n            return True\n        return False\n\n    def _extract_bearer_token(self, headers: Dict[str, str]) -> Optional[str]:\n        \"\"\"Extract bearer token from Authorization header.\"\"\"\n        normalized_headers = {k.lower(): v for k, v in headers.items()}\n        auth_header = normalized_headers.get(\"authorization\")\n\n        if auth_header is None:\n            return None\n\n        # Bearer token format: \"Bearer <token>\"\n        match = re.match(r\"^Bearer\\s+(.+)$\", auth_header, re.IGNORECASE)\n        if match:\n            return match.group(1).strip()\n\n        return None\n\n    async def _validate_token_local(self, token_value: str) -> Tuple[bool, Optional[OAuthToken]]:\n        \"\"\"Validate token against local store.\"\"\"\n        token = self._valid_tokens.get(token_value)\n        if token is None:\n            return False, None\n\n        if token.is_expired:\n            return False, token\n\n        return True, token\n\n    async def _validate_token_remote(\n        self, token_value: str\n    ) -> Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"Validate token against remote token info endpoint.\"\"\"\n        if self._token_info_url is None:\n            return False, None\n\n        try:\n            client = await self._get_http_client()\n            response = await client.post(\n                self._token_info_url,\n                data={\"token\": token_value},\n            )\n\n            if response.status_code != 200:\n                return False, None\n\n            token_info = response.json()\n\n            # Check if token is active\n            if not token_info.get(\"active\", False):\n                return False, token_info\n\n            return True, token_info\n\n        except Exception as e:\n            logger.error(f\"Token validation request failed: {e}\")\n            return False, None\n\n    async def verify_request(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"Verify bearer token in request.\"\"\"\n        token_value = self._extract_bearer_token(headers)\n\n        if token_value is None:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"MISSING_BEARER_TOKEN\",\n                error_message=\"Missing or invalid Authorization header\",\n            )\n\n        # Try local validation first\n        is_valid, token = await self._validate_token_local(token_value)\n\n        if is_valid and token is not None:\n            # Check scopes\n            token_scopes = set(token.scopes)\n            if self._required_scopes and not self._required_scopes.issubset(token_scopes):\n                missing = self._required_scopes - token_scopes\n                return AuthResult.failure(\n                    auth_type=self.auth_type,\n                    error_code=\"INSUFFICIENT_SCOPE\",\n                    error_message=f\"Missing required scopes: {', '.join(missing)}\",\n                )\n\n            return AuthResult.success(\n                auth_type=self.auth_type,\n                principal=\"oauth_user\",\n                scopes=list(token_scopes),\n                metadata={\"expires_at\": token.expires_at.isoformat() if token.expires_at else None},\n            )\n\n        if token is not None and token.is_expired:\n            return AuthResult.failure(\n                auth_type=self.auth_type,\n                error_code=\"TOKEN_EXPIRED\",\n                error_message=\"Bearer token has expired\",\n            )\n\n        # Try remote validation\n        if self._token_info_url:\n            is_valid, token_info = await self._validate_token_remote(token_value)\n\n            if is_valid and token_info:\n                # Check scopes from token info\n                scope_str = token_info.get(\"scope\", \"\")\n                token_scopes = set(scope_str.split()) if scope_str else set()\n\n                if self._required_scopes and not self._required_scopes.issubset(token_scopes):\n                    missing = self._required_scopes - token_scopes\n                    return AuthResult.failure(\n                        auth_type=self.auth_type,\n                        error_code=\"INSUFFICIENT_SCOPE\",\n                        error_message=f\"Missing required scopes: {', '.join(missing)}\",\n                    )\n\n                return AuthResult.success(\n                    auth_type=self.auth_type,\n                    principal=token_info.get(\"sub\") or token_info.get(\"username\") or \"oauth_user\",\n                    scopes=list(token_scopes),\n                    metadata={\"token_info\": token_info},\n                )\n\n        return AuthResult.failure(\n            auth_type=self.auth_type,\n            error_code=\"INVALID_TOKEN\",\n            error_message=\"Bearer token validation failed\",\n        )\n\n    async def prepare_headers(\n        self,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"Add bearer token to outgoing request headers.\"\"\"\n        result = dict(headers)\n\n        # Check if we need to refresh the token\n        await self._ensure_valid_token()\n\n        if self._current_token and not self._current_token.is_expired:\n            token_value = self._current_token.access_token.get_secret_value()\n            result[\"Authorization\"] = f\"Bearer {token_value}\"\n        elif self._access_token:\n            result[\"Authorization\"] = f\"Bearer {self._access_token.get_secret_value()}\"\n\n        return result\n\n    async def _ensure_valid_token(self) -> None:\n        \"\"\"Ensure we have a valid access token, refreshing if necessary.\"\"\"\n        if self._current_token is None and self._access_token:\n            # Initialize current token from access_token\n            self._current_token = OAuthToken(\n                access_token=self._access_token,\n                refresh_token=self._refresh_token,\n            )\n            return\n\n        if self._current_token is None:\n            return\n\n        if not self._current_token.is_expired:\n            return\n\n        # Try to refresh\n        if self._current_token.refresh_token and self._token_url:\n            try:\n                new_token = await self._refresh_access_token()\n                if new_token:\n                    self._current_token = new_token\n            except Exception as e:\n                logger.error(f\"Token refresh failed: {e}\")\n\n    async def _refresh_access_token(self) -> Optional[OAuthToken]:\n        \"\"\"Refresh the access token using refresh token.\"\"\"\n        if not self._token_url or not self._current_token or not self._current_token.refresh_token:\n            return None\n\n        try:\n            client = await self._get_http_client()\n\n            data = {\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self._current_token.refresh_token.get_secret_value(),\n            }\n\n            if self._client_id:\n                data[\"client_id\"] = self._client_id\n            if self._client_secret:\n                data[\"client_secret\"] = self._client_secret.get_secret_value()\n\n            response = await client.post(self._token_url, data=data)\n\n            if response.status_code != 200:\n                logger.error(f\"Token refresh failed with status {response.status_code}\")\n                return None\n\n            token_data = response.json()\n            return OAuthToken(\n                access_token=SecretStr(token_data[\"access_token\"]),\n                token_type=token_data.get(\"token_type\", \"Bearer\"),\n                expires_in=token_data.get(\"expires_in\"),\n                refresh_token=(\n                    SecretStr(token_data[\"refresh_token\"])\n                    if \"refresh_token\" in token_data\n                    else self._current_token.refresh_token\n                ),\n                scope=token_data.get(\"scope\"),\n            )\n\n        except Exception as e:\n            logger.error(f\"Token refresh request failed: {e}\")\n            return None\n\n    async def refresh_token(self) -> Optional[OAuthToken]:\n        \"\"\"\n        Public method to refresh the access token.\n\n        Returns:\n            New OAuthToken if refresh succeeded, None otherwise\n        \"\"\"\n        return await self._refresh_access_token()\n\n\n# ============================================================================\n# Authentication Handler Registry\n# ============================================================================\n\n\nclass WebhookAuthRegistry:\n    \"\"\"\n    Registry for webhook authentication handlers.\n\n    Provides a centralized way to manage and lookup authentication handlers\n    by type for both incoming and outgoing webhook authentication.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the registry.\"\"\"\n        self._handlers: Dict[WebhookAuthType, WebhookAuthHandler] = {}\n\n    def register(self, handler: WebhookAuthHandler) -> None:\n        \"\"\"Register an authentication handler.\"\"\"\n        self._handlers[handler.auth_type] = handler\n        logger.debug(f\"Registered auth handler for {handler.auth_type.value}\")\n\n    def unregister(self, auth_type: WebhookAuthType) -> Optional[WebhookAuthHandler]:\n        \"\"\"Unregister and return an authentication handler.\"\"\"\n        return self._handlers.pop(auth_type, None)\n\n    def get(self, auth_type: WebhookAuthType) -> Optional[WebhookAuthHandler]:\n        \"\"\"Get an authentication handler by type.\"\"\"\n        return self._handlers.get(auth_type)\n\n    def get_all(self) -> Dict[WebhookAuthType, WebhookAuthHandler]:\n        \"\"\"Get all registered handlers.\"\"\"\n        return dict(self._handlers)\n\n    async def verify_request(\n        self,\n        auth_type: WebhookAuthType,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> AuthResult:\n        \"\"\"\n        Verify a request using the appropriate handler.\n\n        Args:\n            auth_type: Type of authentication to use\n            headers: Request headers\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL\n\n        Returns:\n            AuthResult from the handler\n        \"\"\"\n        if auth_type == WebhookAuthType.NONE:\n            return AuthResult.success(auth_type=auth_type)\n\n        handler = self._handlers.get(auth_type)\n        if handler is None:\n            return AuthResult.failure(\n                auth_type=auth_type,\n                error_code=\"NO_HANDLER\",\n                error_message=f\"No handler registered for {auth_type.value}\",\n            )\n\n        return await handler.verify_request(headers, body, method, url)\n\n    async def prepare_headers(\n        self,\n        auth_type: WebhookAuthType,\n        headers: Dict[str, str],\n        body: bytes,\n        method: str = \"POST\",\n        url: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"\n        Prepare authentication headers using the appropriate handler.\n\n        Args:\n            auth_type: Type of authentication to use\n            headers: Existing headers\n            body: Request body bytes\n            method: HTTP method\n            url: Request URL\n\n        Returns:\n            Headers dict with authentication added\n        \"\"\"\n        if auth_type == WebhookAuthType.NONE:\n            return dict(headers)\n\n        handler = self._handlers.get(auth_type)\n        if handler is None:\n            logger.warning(f\"No handler for {auth_type.value}, returning headers unchanged\")\n            return dict(headers)\n\n        return await handler.prepare_headers(headers, body, method, url)\n\n\n# ============================================================================\n# Factory Functions\n# ============================================================================\n\n\ndef create_api_key_handler(\n    valid_keys: Optional[Dict[str, str]] = None,\n    header_name: str = \"X-API-Key\",\n    api_key: Optional[SecretStr] = None,\n) -> ApiKeyAuthHandler:\n    \"\"\"\n    Create an API key authentication handler.\n\n    Args:\n        valid_keys: Dict mapping API key values to principals\n        header_name: Header name for API key\n        api_key: API key for outgoing requests\n\n    Returns:\n        Configured ApiKeyAuthHandler\n    \"\"\"\n    return ApiKeyAuthHandler(\n        valid_keys=valid_keys,\n        header_name=header_name,\n        api_key=api_key,\n    )\n\n\ndef create_hmac_handler(\n    secret: SecretStr,\n    signature_header: str = \"X-Webhook-Signature\",\n    timestamp_header: str = \"X-Webhook-Timestamp\",\n    algorithm: str = \"sha256\",\n    timestamp_tolerance_seconds: int = 300,\n) -> HmacAuthHandler:\n    \"\"\"\n    Create an HMAC signature authentication handler.\n\n    Args:\n        secret: HMAC secret key\n        signature_header: Header name for signature\n        timestamp_header: Header name for timestamp\n        algorithm: Hash algorithm (sha256 or sha512)\n        timestamp_tolerance_seconds: Maximum request age\n\n    Returns:\n        Configured HmacAuthHandler\n    \"\"\"\n    return HmacAuthHandler(\n        secret=secret,\n        signature_header=signature_header,\n        timestamp_header=timestamp_header,\n        algorithm=algorithm,\n        timestamp_tolerance_seconds=timestamp_tolerance_seconds,\n    )\n\n\ndef create_oauth_handler(\n    token_info_url: Optional[str] = None,\n    required_scopes: Optional[List[str]] = None,\n    access_token: Optional[SecretStr] = None,\n    refresh_token: Optional[SecretStr] = None,\n    client_id: Optional[str] = None,\n    client_secret: Optional[SecretStr] = None,\n    token_url: Optional[str] = None,\n) -> OAuthBearerAuthHandler:\n    \"\"\"\n    Create an OAuth bearer token authentication handler.\n\n    Args:\n        token_info_url: URL to validate tokens\n        required_scopes: Required scopes for authorization\n        access_token: Access token for outgoing requests\n        refresh_token: Refresh token for refresh flow\n        client_id: OAuth client ID\n        client_secret: OAuth client secret\n        token_url: Token endpoint URL\n\n    Returns:\n        Configured OAuthBearerAuthHandler\n    \"\"\"\n    return OAuthBearerAuthHandler(\n        token_info_url=token_info_url,\n        required_scopes=required_scopes,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        client_id=client_id,\n        client_secret=client_secret,\n        token_url=token_url,\n    )\n\n\ndef create_default_registry() -> WebhookAuthRegistry:\n    \"\"\"\n    Create a registry with default handlers.\n\n    Returns:\n        WebhookAuthRegistry with common handlers registered\n    \"\"\"\n    registry = WebhookAuthRegistry()\n    # Note: Handlers need to be configured with secrets before use\n    # This just provides the registry structure\n    return registry\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.595175",
  "last_updated": "2026-01-04T05:35:59.166186"
}