{
  "file_path": "integration-service/tests/integrations/test_sentinel.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nTests for Microsoft Sentinel integration adapter with Azure Monitor Ingestion.\n\nTests cover:\n- SentinelCredentials validation\n- Azure AD authentication and token refresh\n- Event formatting and submission\n- Batch event submission\n- Error handling (rate limits, auth failures, DCR errors)\n- Connection testing\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom datetime import datetime, timedelta, timezone\nfrom typing import TYPE_CHECKING\nfrom unittest.mock import MagicMock, patch\n\nimport httpx\nimport pytest\nfrom pydantic import SecretStr\n\nfrom src.exceptions.auth import AuthenticationError\nfrom src.exceptions.delivery import DeliveryError\nfrom src.exceptions.integration import RateLimitError\nfrom src.integrations.base import (\n    EventSeverity,\n    IntegrationEvent,\n    IntegrationStatus,\n    IntegrationType,\n)\nfrom src.integrations.sentinel_adapter import (\n    AzureCloud,\n    SentinelAdapter,\n    SentinelCredentials,\n)\n\nif TYPE_CHECKING:\n    pass\n\n\n# ============================================================================\n# Fixtures\n# ============================================================================\n\n\n@pytest.fixture\ndef sample_credentials() -> SentinelCredentials:\n    \"\"\"Create sample Sentinel credentials for testing.\"\"\"\n    return SentinelCredentials(\n        integration_name=\"Test Sentinel\",\n        tenant_id=\"12345678-1234-1234-1234-123456789012\",\n        client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n        client_secret=SecretStr(\"test-client-secret-12345\"),\n        dce_endpoint=\"https://test-dce.eastus.ingest.monitor.azure.com\",\n        dcr_immutable_id=\"dcr-abc123def456\",\n        stream_name=\"Custom-GovernanceEvents_CL\",\n        azure_cloud=AzureCloud.PUBLIC,\n    )\n\n\n@pytest.fixture\ndef sample_event() -> IntegrationEvent:\n    \"\"\"Create a sample governance event for testing.\"\"\"\n    return IntegrationEvent(\n        event_id=\"evt-test-001\",\n        event_type=\"policy_violation\",\n        severity=EventSeverity.HIGH,\n        source=\"acgs2\",\n        policy_id=\"POL-001\",\n        resource_id=\"res-123\",\n        resource_type=\"compute\",\n        action=\"create\",\n        outcome=\"blocked\",\n        title=\"Policy Violation Detected\",\n        description=\"Resource creation blocked due to policy violation\",\n        details={\"region\": \"eastus\", \"cost_estimate\": 150.00},\n        user_id=\"user-456\",\n        tenant_id=\"tenant-789\",\n        correlation_id=\"corr-123\",\n        tags=[\"security\", \"compliance\"],\n    )\n\n\n@pytest.fixture\ndef sentinel_adapter(sample_credentials: SentinelCredentials) -> SentinelAdapter:\n    \"\"\"Create a Sentinel adapter for testing.\"\"\"\n    return SentinelAdapter(sample_credentials)\n\n\n@pytest.fixture\ndef mock_token_response() -> dict:\n    \"\"\"Create a mock Azure AD token response.\"\"\"\n    return {\n        \"access_token\": \"mock-access-token-12345\",\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600,\n    }\n\n\n# ============================================================================\n# Credentials Tests\n# ============================================================================\n\n\nclass TestSentinelCredentials:\n    \"\"\"Tests for SentinelCredentials validation.\"\"\"\n\n    def test_valid_credentials(self, sample_credentials: SentinelCredentials):\n        \"\"\"Test creating valid credentials.\"\"\"\n        assert sample_credentials.integration_type == IntegrationType.SIEM\n        assert sample_credentials.tenant_id == \"12345678-1234-1234-1234-123456789012\"\n        assert sample_credentials.client_id == \"abcdefab-abcd-abcd-abcd-abcdefabcdef\"\n        assert sample_credentials.stream_name == \"Custom-GovernanceEvents_CL\"\n        assert sample_credentials.azure_cloud == AzureCloud.PUBLIC\n\n    def test_tenant_id_guid_format(self):\n        \"\"\"Test that tenant_id must be a valid GUID.\"\"\"\n        with pytest.raises(ValueError, match=\"Invalid GUID format\"):\n            SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"invalid-guid\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n            )\n\n    def test_tenant_id_accepts_no_dashes(self):\n        \"\"\"Test that tenant_id accepts GUID without dashes.\"\"\"\n        creds = SentinelCredentials(\n            integration_name=\"Test\",\n            tenant_id=\"12345678123412341234123456789012\",\n            client_id=\"abcdefababcdabcdabcdabcdefabcdef\",\n            client_secret=SecretStr(\"secret\"),\n            dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n            dcr_immutable_id=\"dcr-abc123\",\n        )\n        # Should be normalized to dashed format\n        assert creds.tenant_id == \"12345678-1234-1234-1234-123456789012\"\n\n    def test_dce_endpoint_requires_https(self):\n        \"\"\"Test that DCE endpoint must use HTTPS.\"\"\"\n        with pytest.raises(ValueError, match=\"must use HTTPS\"):\n            SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"12345678-1234-1234-1234-123456789012\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"http://test.eastus.ingest.monitor.azure.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n            )\n\n    def test_dce_endpoint_requires_azure_monitor_domain(self):\n        \"\"\"Test that DCE endpoint must be Azure Monitor domain.\"\"\"\n        with pytest.raises(ValueError, match=\"Azure Monitor\"):\n            SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"12345678-1234-1234-1234-123456789012\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"https://example.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n            )\n\n    def test_dce_endpoint_trailing_slash_removed(self):\n        \"\"\"Test that trailing slash is removed from DCE endpoint.\"\"\"\n        creds = SentinelCredentials(\n            integration_name=\"Test\",\n            tenant_id=\"12345678-1234-1234-1234-123456789012\",\n            client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n            client_secret=SecretStr(\"secret\"),\n            dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com/\",\n            dcr_immutable_id=\"dcr-abc123\",\n        )\n        assert creds.dce_endpoint == \"https://test.eastus.ingest.monitor.azure.com\"\n\n    def test_batch_size_limits(self):\n        \"\"\"Test batch size validation.\"\"\"\n        # Valid range (max 500 for Azure)\n        creds = SentinelCredentials(\n            integration_name=\"Test\",\n            tenant_id=\"12345678-1234-1234-1234-123456789012\",\n            client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n            client_secret=SecretStr(\"secret\"),\n            dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n            dcr_immutable_id=\"dcr-abc123\",\n            batch_size=100,\n        )\n        assert creds.batch_size == 100\n\n        # Too small\n        with pytest.raises(ValueError):\n            SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"12345678-1234-1234-1234-123456789012\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n                batch_size=0,\n            )\n\n        # Too large (Azure limit is 500)\n        with pytest.raises(ValueError):\n            SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"12345678-1234-1234-1234-123456789012\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n                batch_size=1000,\n            )\n\n    def test_secret_is_secret(self, sample_credentials: SentinelCredentials):\n        \"\"\"Test that client secret is properly secured.\"\"\"\n        assert isinstance(sample_credentials.client_secret, SecretStr)\n        # Secret should not appear in string representation\n        creds_str = str(sample_credentials.model_dump())\n        assert \"test-client-secret-12345\" not in creds_str\n\n    def test_azure_cloud_options(self):\n        \"\"\"Test different Azure cloud configurations.\"\"\"\n        for cloud in AzureCloud:\n            creds = SentinelCredentials(\n                integration_name=\"Test\",\n                tenant_id=\"12345678-1234-1234-1234-123456789012\",\n                client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n                client_secret=SecretStr(\"secret\"),\n                dce_endpoint=\"https://test.eastus.ingest.monitor.azure.com\",\n                dcr_immutable_id=\"dcr-abc123\",\n                azure_cloud=cloud,\n            )\n            assert creds.azure_cloud == cloud\n\n\n# ============================================================================\n# Adapter Initialization Tests\n# ============================================================================\n\n\nclass TestSentinelAdapterInit:\n    \"\"\"Tests for SentinelAdapter initialization.\"\"\"\n\n    def test_initialization(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test adapter initializes correctly.\"\"\"\n        assert sentinel_adapter.name == \"Test Sentinel\"\n        assert sentinel_adapter.integration_type == IntegrationType.SIEM\n        assert sentinel_adapter.status == IntegrationStatus.INACTIVE\n        assert sentinel_adapter.is_authenticated is False\n\n    def test_custom_timeout_and_retries(self, sample_credentials: SentinelCredentials):\n        \"\"\"Test adapter accepts custom timeout and retry settings.\"\"\"\n        adapter = SentinelAdapter(\n            sample_credentials,\n            max_retries=5,\n            timeout=60.0,\n        )\n        assert adapter.max_retries == 5\n        assert adapter.timeout == 60.0\n\n    def test_sentinel_credentials_property(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test sentinel_credentials property returns typed credentials.\"\"\"\n        creds = sentinel_adapter.sentinel_credentials\n        assert isinstance(creds, SentinelCredentials)\n        assert creds.dcr_immutable_id == \"dcr-abc123def456\"\n\n\n# ============================================================================\n# Authentication Tests\n# ============================================================================\n\n\nclass TestSentinelAuthentication:\n    \"\"\"Tests for Sentinel Azure AD authentication.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_authentication(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test successful Azure AD authentication.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = mock_token_response\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.authenticate()\n\n        assert result.success is True\n        assert sentinel_adapter.is_authenticated is True\n        assert sentinel_adapter.status == IntegrationStatus.ACTIVE\n\n    @pytest.mark.asyncio\n    async def test_authentication_invalid_credentials(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test authentication with invalid credentials.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 401\n        mock_response.json.return_value = {\n            \"error\": \"invalid_client\",\n            \"error_description\": \"Invalid client credentials\",\n        }\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.authenticate()\n\n        assert result.success is False\n        assert result.error_code == \"AUTH_FAILED\"\n        assert sentinel_adapter.is_authenticated is False\n\n    @pytest.mark.asyncio\n    async def test_authentication_bad_request(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test authentication with malformed request.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 400\n        mock_response.json.return_value = {\n            \"error\": \"invalid_request\",\n            \"error_description\": \"Missing required parameter\",\n        }\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.authenticate()\n\n        assert result.success is False\n        assert result.error_code == \"AUTH_FAILED\"\n\n    @pytest.mark.asyncio\n    async def test_authentication_timeout(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test authentication handles timeout.\"\"\"\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                raise httpx.TimeoutException(\"Connection timed out\")\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(AuthenticationError, match=\"timed out\"):\n                await sentinel_adapter.authenticate()\n\n    @pytest.mark.asyncio\n    async def test_authentication_network_error(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test authentication handles network errors.\"\"\"\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                raise httpx.NetworkError(\"Connection refused\")\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(AuthenticationError, match=\"Network error\"):\n                await sentinel_adapter.authenticate()\n\n    @pytest.mark.asyncio\n    async def test_token_caching(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test that access tokens are cached and reused.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = mock_token_response\n\n        call_count = 0\n\n        async def async_post(*args, **kwargs):\n            nonlocal call_count\n            call_count += 1\n            return mock_response\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n            mock_client.return_value.post = async_post\n\n            # First call should acquire token\n            await sentinel_adapter._get_access_token()\n            assert call_count == 1\n\n            # Second call should use cached token\n            await sentinel_adapter._get_access_token()\n            assert call_count == 1  # Still 1, no new request\n\n    @pytest.mark.asyncio\n    async def test_token_refresh_on_expiry(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test that expired tokens are refreshed.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = mock_token_response\n\n        call_count = 0\n\n        async def async_post(*args, **kwargs):\n            nonlocal call_count\n            call_count += 1\n            return mock_response\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n            mock_client.return_value.post = async_post\n\n            # First call\n            await sentinel_adapter._get_access_token()\n            assert call_count == 1\n\n            # Simulate token expiration\n            sentinel_adapter._token_expires_at = datetime.now(timezone.utc) - timedelta(minutes=1)\n\n            # Next call should refresh\n            await sentinel_adapter._get_access_token()\n            assert call_count == 2\n\n\n# ============================================================================\n# Validation Tests\n# ============================================================================\n\n\nclass TestSentinelValidation:\n    \"\"\"Tests for Sentinel configuration validation.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_validation(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test successful configuration validation.\"\"\"\n        token_response = MagicMock(spec=httpx.Response)\n        token_response.status_code = 200\n        token_response.json.return_value = mock_token_response\n\n        ingestion_response = MagicMock(spec=httpx.Response)\n        ingestion_response.status_code = 204  # Success with no content\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                # Check if it's token request or ingestion request\n                if \"oauth2\" in args[0]:\n                    return token_response\n                return ingestion_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.validate()\n\n        assert result.success is True\n\n    @pytest.mark.asyncio\n    async def test_validation_dcr_not_found(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test validation when DCR doesn't exist.\"\"\"\n        token_response = MagicMock(spec=httpx.Response)\n        token_response.status_code = 200\n        token_response.json.return_value = mock_token_response\n\n        ingestion_response = MagicMock(spec=httpx.Response)\n        ingestion_response.status_code = 404\n        ingestion_response.json.return_value = {\"error\": {\"message\": \"DCR not found\"}}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                if \"oauth2\" in args[0]:\n                    return token_response\n                return ingestion_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.validate()\n\n        assert result.success is False\n        assert \"not found\" in result.error_message.lower()\n\n    @pytest.mark.asyncio\n    async def test_validation_permission_denied(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test validation when token lacks permissions.\"\"\"\n        token_response = MagicMock(spec=httpx.Response)\n        token_response.status_code = 200\n        token_response.json.return_value = mock_token_response\n\n        ingestion_response = MagicMock(spec=httpx.Response)\n        ingestion_response.status_code = 403\n        ingestion_response.json.return_value = {}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                if \"oauth2\" in args[0]:\n                    return token_response\n                return ingestion_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.validate()\n\n        assert result.success is False\n        assert (\n            \"denied\" in result.error_message.lower() or \"permission\" in result.error_message.lower()\n        )\n\n\n# ============================================================================\n# Event Submission Tests\n# ============================================================================\n\n\nclass TestSentinelEventSubmission:\n    \"\"\"Tests for Sentinel event submission.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_event_submission(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n        mock_token_response: dict,\n    ):\n        \"\"\"Test successful single event submission.\"\"\"\n        # Mark as authenticated\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 204\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await sentinel_adapter.send_event(sample_event)\n\n        assert result.success is True\n        assert result.external_id == sample_event.event_id\n        assert sentinel_adapter._events_sent == 1\n\n    @pytest.mark.asyncio\n    async def test_event_submission_requires_auth(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that event submission requires authentication.\"\"\"\n        with pytest.raises(AuthenticationError, match=\"not authenticated\"):\n            await sentinel_adapter.send_event(sample_event)\n\n    @pytest.mark.asyncio\n    async def test_event_submission_rate_limited(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test rate limit handling during event submission.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"60\"}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(RateLimitError) as exc_info:\n                await sentinel_adapter.send_event(sample_event)\n\n            assert exc_info.value.retry_after == 60\n\n    @pytest.mark.asyncio\n    async def test_event_submission_dcr_error(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test handling of DCR not found error.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 404\n        mock_response.json.return_value = {\"error\": {\"message\": \"DCR not found\"}}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"not found\"):\n                await sentinel_adapter.send_event(sample_event)\n\n    @pytest.mark.asyncio\n    async def test_event_submission_server_unavailable(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test handling of server unavailable (503).\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 503\n        mock_response.json.return_value = {}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"unavailable\"):\n                await sentinel_adapter.send_event(sample_event)\n\n\n# ============================================================================\n# Event Formatting Tests\n# ============================================================================\n\n\nclass TestSentinelEventFormatting:\n    \"\"\"Tests for Sentinel event formatting.\"\"\"\n\n    def test_event_formatting(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that events are properly formatted for Azure Monitor.\"\"\"\n        formatted = sentinel_adapter._format_event_for_sentinel(sample_event)\n\n        # Check required fields\n        assert \"TimeGenerated\" in formatted\n        assert \"EventId\" in formatted\n        assert \"EventType\" in formatted\n        assert \"Severity\" in formatted\n        assert \"SeverityLevel\" in formatted\n        assert \"Source\" in formatted\n        assert \"Title\" in formatted\n\n        # Check event content\n        assert formatted[\"EventId\"] == \"evt-test-001\"\n        assert formatted[\"EventType\"] == \"policy_violation\"\n        assert formatted[\"Severity\"] == \"High\"\n        assert formatted[\"SeverityLevel\"] == 2  # Mapped severity\n        assert formatted[\"Title\"] == \"Policy Violation Detected\"\n        assert formatted[\"PolicyId\"] == \"POL-001\"\n        assert formatted[\"ResourceId\"] == \"res-123\"\n\n        # Check TimeGenerated format (ISO 8601)\n        assert \"T\" in formatted[\"TimeGenerated\"]\n        assert formatted[\"TimeGenerated\"].endswith(\"Z\")\n\n    def test_event_formatting_empty_optionals(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test that empty optional fields are formatted correctly.\"\"\"\n        event = IntegrationEvent(\n            event_type=\"test\",\n            title=\"Test Event\",\n            # Leave optional fields as None\n        )\n\n        formatted = sentinel_adapter._format_event_for_sentinel(event)\n\n        # Optional fields should be empty strings, not None\n        assert formatted[\"PolicyId\"] == \"\"\n        assert formatted[\"ResourceId\"] == \"\"\n        assert formatted[\"UserId\"] == \"\"\n        assert formatted[\"Description\"] == \"\"\n\n    def test_severity_mapping(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test severity mapping to Sentinel levels.\"\"\"\n        test_cases = [\n            (EventSeverity.CRITICAL, \"Critical\", 1),\n            (EventSeverity.HIGH, \"High\", 2),\n            (EventSeverity.MEDIUM, \"Medium\", 3),\n            (EventSeverity.LOW, \"Low\", 4),\n            (EventSeverity.INFO, \"Informational\", 5),\n        ]\n\n        for severity, expected_name, expected_level in test_cases:\n            event = IntegrationEvent(\n                event_type=\"test\",\n                title=\"Test\",\n                severity=severity,\n            )\n            formatted = sentinel_adapter._format_event_for_sentinel(event)\n            assert formatted[\"Severity\"] == expected_name\n            assert formatted[\"SeverityLevel\"] == expected_level\n\n    def test_details_serialized_as_json(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that details dict is serialized as JSON string.\"\"\"\n        formatted = sentinel_adapter._format_event_for_sentinel(sample_event)\n\n        # Details should be a JSON string\n        assert isinstance(formatted[\"Details\"], str)\n        details = json.loads(formatted[\"Details\"])\n        assert details[\"region\"] == \"eastus\"\n        assert details[\"cost_estimate\"] == 150.00\n\n    def test_tags_serialized_as_json(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that tags list is serialized as JSON string.\"\"\"\n        formatted = sentinel_adapter._format_event_for_sentinel(sample_event)\n\n        # Tags should be a JSON string\n        assert isinstance(formatted[\"Tags\"], str)\n        tags = json.loads(formatted[\"Tags\"])\n        assert \"security\" in tags\n        assert \"compliance\" in tags\n\n\n# ============================================================================\n# Batch Submission Tests\n# ============================================================================\n\n\nclass TestSentinelBatchSubmission:\n    \"\"\"Tests for batch event submission.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_batch_submission(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test successful batch event submission.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        events = [sample_event for _ in range(5)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 204\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await sentinel_adapter.send_events_batch(events)\n\n        assert len(results) == 5\n        assert all(r.success for r in results)\n        # Verify event metrics\n        assert sentinel_adapter._events_sent == 5\n        # Verify batch-specific metrics\n        assert sentinel_adapter._batches_sent == 1\n        assert sentinel_adapter._batch_events_total == 5\n        assert sentinel_adapter._batches_failed == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_requires_auth(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that batch submission requires authentication.\"\"\"\n        with pytest.raises(AuthenticationError, match=\"not authenticated\"):\n            await sentinel_adapter.send_events_batch([sample_event])\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_empty_list(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test batch submission with empty list returns empty results.\"\"\"\n        sentinel_adapter._authenticated = True\n\n        results = await sentinel_adapter.send_events_batch([])\n\n        assert results == []\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_failure(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission failure returns failures for all events.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        events = [sample_event for _ in range(3)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 500\n        mock_response.json.return_value = {\"error\": {\"message\": \"Internal error\"}}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await sentinel_adapter.send_events_batch(events)\n\n        assert len(results) == 3\n        assert all(not r.success for r in results)\n        # Verify event metrics\n        assert sentinel_adapter._events_failed == 3\n        # Verify batch-specific metrics\n        assert sentinel_adapter._batches_failed == 1\n        assert sentinel_adapter._batches_sent == 0\n        assert sentinel_adapter._batch_events_total == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_rate_limited(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission handles rate limiting.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        events = [sample_event for _ in range(3)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"60\"}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(RateLimitError) as exc_info:\n                await sentinel_adapter.send_events_batch(events)\n\n            assert exc_info.value.retry_after == 60\n\n    @pytest.mark.asyncio\n    async def test_batch_metrics_accumulation(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that batch metrics accumulate across multiple batches.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 204\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            # Send first batch of 3 events\n            await sentinel_adapter.send_events_batch([sample_event for _ in range(3)])\n\n            # Send second batch of 5 events\n            await sentinel_adapter.send_events_batch([sample_event for _ in range(5)])\n\n        # Verify accumulated metrics\n        assert sentinel_adapter._batches_sent == 2\n        assert sentinel_adapter._events_sent == 8\n        assert sentinel_adapter._batch_events_total == 8\n        assert sentinel_adapter._batches_failed == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_dcr_error(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission handles DCR not found error.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        events = [sample_event for _ in range(2)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 404\n        mock_response.json.return_value = {\"error\": {\"message\": \"DCR not found\"}}\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"not found\"):\n                await sentinel_adapter.send_events_batch(events)\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_network_error_retry(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission retries on network errors.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        events = [sample_event for _ in range(2)]\n\n        # First two calls fail with network error, third succeeds\n        call_count = 0\n\n        async def async_post_with_retry(*args, **kwargs):\n            nonlocal call_count\n            call_count += 1\n            if call_count < 3:\n                raise httpx.NetworkError(\"Connection failed\")\n            mock_response = MagicMock(spec=httpx.Response)\n            mock_response.status_code = 204\n            return mock_response\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n            mock_client.return_value.post = async_post_with_retry\n\n            results = await sentinel_adapter.send_events_batch(events)\n\n        assert len(results) == 2\n        assert all(r.success for r in results)\n        assert call_count == 3  # Verify retry happened\n        assert sentinel_adapter._batches_sent == 1\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_external_id(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test batch submission result ordering and external ID mapping.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        # Create events with different IDs\n        events = [\n            IntegrationEvent(\n                event_id=f\"evt-{i}\",\n                event_type=\"test\",\n                title=f\"Event {i}\",\n            )\n            for i in range(3)\n        ]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 204\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await sentinel_adapter.send_events_batch(events)\n\n        # Verify result count and ordering\n        assert len(results) == 3\n        assert results[0].external_id == \"evt-0\"\n        assert results[1].external_id == \"evt-1\"\n        assert results[2].external_id == \"evt-2\"\n        assert all(r.success for r in results)\n\n\n# ============================================================================\n# Connection Testing Tests\n# ============================================================================\n\n\nclass TestSentinelConnectionTest:\n    \"\"\"Tests for connection testing.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_success(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test successful connection test.\"\"\"\n        ad_response = MagicMock(spec=httpx.Response)\n        ad_response.status_code = 200\n\n        dce_response = MagicMock(spec=httpx.Response)\n        dce_response.status_code = 400  # Even 4xx indicates reachable\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return ad_response\n\n            async def async_head(*args, **kwargs):\n                return dce_response\n\n            mock_client.return_value.get = async_get\n            mock_client.return_value.head = async_head\n\n            result = await sentinel_adapter.test_connection()\n\n        assert result.success is True\n        assert result.operation == \"test_connection\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_azure_ad_unreachable(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test connection test when Azure AD is unreachable.\"\"\"\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.NetworkError(\"Connection refused\")\n\n            mock_client.return_value.get = async_get\n\n            result = await sentinel_adapter.test_connection()\n\n        assert result.success is False\n        assert \"AZURE_AD\" in result.error_code\n\n    @pytest.mark.asyncio\n    async def test_connection_test_dce_server_error(\n        self,\n        sentinel_adapter: SentinelAdapter,\n    ):\n        \"\"\"Test connection test with DCE server error.\"\"\"\n        ad_response = MagicMock(spec=httpx.Response)\n        ad_response.status_code = 200\n\n        dce_response = MagicMock(spec=httpx.Response)\n        dce_response.status_code = 500\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return ad_response\n\n            async def async_head(*args, **kwargs):\n                return dce_response\n\n            mock_client.return_value.get = async_get\n            mock_client.return_value.head = async_head\n\n            result = await sentinel_adapter.test_connection()\n\n        assert result.success is False\n        assert result.error_code == \"HTTP_500\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_timeout(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test connection test handles timeout.\"\"\"\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.TimeoutException(\"Timed out\")\n\n            mock_client.return_value.get = async_get\n\n            result = await sentinel_adapter.test_connection()\n\n        assert result.success is False\n        assert result.error_code == \"TIMEOUT\"\n\n\n# ============================================================================\n# Azure Cloud Configuration Tests\n# ============================================================================\n\n\nclass TestAzureCloudConfiguration:\n    \"\"\"Tests for Azure cloud environment configuration.\"\"\"\n\n    def test_public_cloud_endpoints(self, sample_credentials: SentinelCredentials):\n        \"\"\"Test public cloud Azure AD endpoints.\"\"\"\n        adapter = SentinelAdapter(sample_credentials)\n        assert \"login.microsoftonline.com\" in adapter._get_azure_ad_endpoint()\n        assert \"monitor.azure.com\" in adapter._get_monitor_scope()\n\n    def test_government_cloud_endpoints(self):\n        \"\"\"Test government cloud Azure AD endpoints.\"\"\"\n        creds = SentinelCredentials(\n            integration_name=\"Test\",\n            tenant_id=\"12345678-1234-1234-1234-123456789012\",\n            client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n            client_secret=SecretStr(\"secret\"),\n            dce_endpoint=\"https://test.usgovvirginia.ingest.monitor.azure.us\",\n            dcr_immutable_id=\"dcr-abc123\",\n            azure_cloud=AzureCloud.GOVERNMENT,\n        )\n        adapter = SentinelAdapter(creds)\n        assert \"microsoftonline.us\" in adapter._get_azure_ad_endpoint()\n        assert \"monitor.azure.us\" in adapter._get_monitor_scope()\n\n    def test_china_cloud_endpoints(self):\n        \"\"\"Test China cloud Azure AD endpoints.\"\"\"\n        creds = SentinelCredentials(\n            integration_name=\"Test\",\n            tenant_id=\"12345678-1234-1234-1234-123456789012\",\n            client_id=\"abcdefab-abcd-abcd-abcd-abcdefabcdef\",\n            client_secret=SecretStr(\"secret\"),\n            dce_endpoint=\"https://test.chinaeast2.ingest.monitor.azure.cn\",\n            dcr_immutable_id=\"dcr-abc123\",\n            azure_cloud=AzureCloud.CHINA,\n        )\n        adapter = SentinelAdapter(creds)\n        assert \"chinacloudapi.cn\" in adapter._get_azure_ad_endpoint()\n        assert \"monitor.azure.cn\" in adapter._get_monitor_scope()\n\n\n# ============================================================================\n# Metrics Tests\n# ============================================================================\n\n\nclass TestSentinelMetrics:\n    \"\"\"Tests for metrics tracking.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_metrics_tracking(\n        self,\n        sentinel_adapter: SentinelAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that metrics are properly tracked.\"\"\"\n        sentinel_adapter._authenticated = True\n        sentinel_adapter._status = IntegrationStatus.ACTIVE\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc) + timedelta(hours=1)\n\n        # Successful submission\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 204\n\n        with patch.object(sentinel_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            await sentinel_adapter.send_event(sample_event)\n\n        metrics = sentinel_adapter.metrics\n        assert metrics[\"events_sent\"] == 1\n        assert metrics[\"events_failed\"] == 0\n        assert metrics[\"last_success\"] is not None\n        assert metrics[\"status\"] == \"active\"\n\n\n# ============================================================================\n# Cleanup Tests\n# ============================================================================\n\n\nclass TestSentinelCleanup:\n    \"\"\"Tests for adapter cleanup.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_close_cleans_up_resources(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test that close() properly cleans up resources.\"\"\"\n        # Set up some state\n        sentinel_adapter._access_token = \"test-token\"\n        sentinel_adapter._token_expires_at = datetime.now(timezone.utc)\n\n        # Create a mock client\n        mock_client = MagicMock()\n        mock_client.is_closed = False\n        sentinel_adapter._http_client = mock_client\n\n        async def mock_aclose():\n            mock_client.is_closed = True\n\n        mock_client.aclose = mock_aclose\n\n        await sentinel_adapter.close()\n\n        assert sentinel_adapter._access_token is None\n        assert sentinel_adapter._token_expires_at is None\n        assert sentinel_adapter._http_client is None\n        assert sentinel_adapter.is_authenticated is False\n        assert sentinel_adapter.status == IntegrationStatus.INACTIVE\n\n\n# ============================================================================\n# Ingestion URL Tests\n# ============================================================================\n\n\nclass TestIngestionURL:\n    \"\"\"Tests for ingestion URL generation.\"\"\"\n\n    def test_ingestion_url_format(self, sentinel_adapter: SentinelAdapter):\n        \"\"\"Test that ingestion URL is properly formatted.\"\"\"\n        url = sentinel_adapter._get_ingestion_url()\n\n        assert sentinel_adapter.sentinel_credentials.dce_endpoint in url\n        assert sentinel_adapter.sentinel_credentials.dcr_immutable_id in url\n        assert sentinel_adapter.sentinel_credentials.stream_name in url\n        assert \"api-version=\" in url\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.736470",
  "last_updated": "2026-01-04T00:39:57.741008"
}