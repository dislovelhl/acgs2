{
  "file_path": "acgs2-core/enhanced_agent_bus/mcp_server/adapters/agent_bus.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nEnhancedAgentBus Adapter for MCP Integration.\n\nBridges MCP tools/resources with the Enhanced Agent Bus.\n\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport logging\nfrom typing import Any, Dict, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentBusAdapter:\n    \"\"\"\n    Adapter for integrating MCP with EnhancedAgentBus.\n\n    Provides a clean interface for MCP tools to interact with\n    the agent bus governance system.\n    \"\"\"\n\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n    def __init__(\n        self,\n        agent_bus: Optional[Any] = None,\n        mcp_agent_id: str = \"mcp-server\",\n    ):\n        \"\"\"\n        Initialize the agent bus adapter.\n\n        Args:\n            agent_bus: Reference to EnhancedAgentBus instance\n            mcp_agent_id: Agent ID for the MCP server\n        \"\"\"\n        self.agent_bus = agent_bus\n        self.mcp_agent_id = mcp_agent_id\n        self._request_count = 0\n        self._connected = False\n\n    async def connect(self) -> bool:\n        \"\"\"\n        Establish connection to the agent bus.\n\n        Returns:\n            True if connection successful\n        \"\"\"\n        if self.agent_bus is None:\n            logger.warning(\"No agent bus instance provided, running in standalone mode\")\n            return False\n\n        try:\n            # Register MCP server as an agent using the agent bus API\n            result = await self.agent_bus.register_agent(\n                agent_id=self.mcp_agent_id,\n                agent_type=\"mcp_server\",\n                capabilities=[\"governance\", \"validation\", \"audit\"],\n            )\n\n            if result:\n                self._connected = True\n                logger.info(f\"MCP adapter connected to agent bus as {self.mcp_agent_id}\")\n                return True\n            else:\n                logger.warning(f\"Agent registration failed for {self.mcp_agent_id}\")\n                return False\n\n        except Exception as e:\n            logger.error(f\"Failed to connect to agent bus: {e}\")\n            return False\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from the agent bus.\"\"\"\n        if self.agent_bus and self._connected:\n            try:\n                await self.agent_bus.deregister_agent(self.mcp_agent_id)\n                self._connected = False\n                logger.info(\"MCP adapter disconnected from agent bus\")\n            except Exception as e:\n                logger.error(f\"Error during disconnect: {e}\")\n\n    async def validate_action(\n        self,\n        action: str,\n        context: Dict[str, Any],\n        strict_mode: bool = True,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate an action through the agent bus.\n\n        Args:\n            action: The action to validate\n            context: Action context\n            strict_mode: Whether to use strict validation\n\n        Returns:\n            Validation result dictionary\n        \"\"\"\n        self._request_count += 1\n\n        if not self._connected or self.agent_bus is None:\n            # Return simulated validation for standalone mode\n            return await self._validate_standalone(action, context, strict_mode)\n\n        try:\n            from ...models import AgentMessage, MessageType, Priority\n\n            # Create governance request message\n            message = AgentMessage(\n                from_agent=self.mcp_agent_id,\n                to_agent=\"constitutional_validator\",\n                message_type=MessageType.GOVERNANCE_REQUEST,\n                content={\n                    \"action\": action,\n                    \"context\": context,\n                    \"strict_mode\": strict_mode,\n                    \"constitutional_hash\": self.CONSTITUTIONAL_HASH,\n                },\n                priority=Priority.HIGH if strict_mode else Priority.MEDIUM,\n            )\n\n            # Send through agent bus\n            response = await self.agent_bus.send_message(message)\n\n            return self._parse_validation_response(response)\n\n        except Exception as e:\n            logger.error(f\"Agent bus validation error: {e}\")\n\n            if strict_mode:\n                # Fail closed\n                return {\n                    \"compliant\": False,\n                    \"confidence\": 0.0,\n                    \"violations\": [\n                        {\n                            \"principle\": \"system\",\n                            \"severity\": \"high\",\n                            \"description\": f\"Validation system error: {e}\",\n                        }\n                    ],\n                    \"recommendations\": [\"Retry validation when system recovers\"],\n                    \"fail_closed\": True,\n                }\n            raise\n\n    async def _validate_standalone(\n        self,\n        action: str,\n        context: Dict[str, Any],\n        strict_mode: bool,\n    ) -> Dict[str, Any]:\n        \"\"\"Perform standalone validation without agent bus.\"\"\"\n        violations = []\n        confidence = 1.0\n\n        # Basic validation rules\n        if context.get(\"data_sensitivity\") in [\"confidential\", \"restricted\"]:\n            if not context.get(\"consent_obtained\"):\n                violations.append(\n                    {\n                        \"principle\": \"privacy\",\n                        \"severity\": \"high\",\n                        \"description\": \"Sensitive data access requires consent\",\n                    }\n                )\n                confidence -= 0.3\n\n        high_risk_patterns = [\"delete\", \"drop\", \"admin\", \"root\", \"exec\"]\n        if any(p in action.lower() for p in high_risk_patterns):\n            if not context.get(\"authorization_verified\"):\n                violations.append(\n                    {\n                        \"principle\": \"safety\",\n                        \"severity\": \"high\",\n                        \"description\": \"High-risk action requires authorization\",\n                    }\n                )\n                confidence -= 0.3\n\n        return {\n            \"compliant\": len(violations) == 0,\n            \"confidence\": max(0.0, confidence),\n            \"violations\": violations,\n            \"recommendations\": [v[\"description\"] for v in violations] if violations else [],\n            \"standalone_mode\": True,\n        }\n\n    def _parse_validation_response(self, response: Any) -> Dict[str, Any]:\n        \"\"\"Parse the agent bus response into validation result.\"\"\"\n        if hasattr(response, \"content\"):\n            return response.content\n        if isinstance(response, dict):\n            return response\n        return {\n            \"compliant\": False,\n            \"confidence\": 0.0,\n            \"violations\": [\n                {\n                    \"principle\": \"system\",\n                    \"severity\": \"medium\",\n                    \"description\": \"Unable to parse validation response\",\n                }\n            ],\n            \"recommendations\": [],\n        }\n\n    async def submit_governance_request(\n        self,\n        action: str,\n        context: Dict[str, Any],\n        priority: str,\n        requester_id: str,\n        wait_for_approval: bool = True,\n        timeout_seconds: int = 30,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Submit a governance request through the agent bus.\n\n        Args:\n            action: The action requiring governance\n            context: Action context\n            priority: Request priority\n            requester_id: ID of the requester\n            wait_for_approval: Whether to wait for approval\n            timeout_seconds: Timeout for waiting\n\n        Returns:\n            Governance decision result\n        \"\"\"\n        self._request_count += 1\n\n        if not self._connected or self.agent_bus is None:\n            # Simulate governance in standalone mode\n            validation = await self._validate_standalone(action, context, True)\n            return {\n                \"status\": \"approved\" if validation[\"compliant\"] else \"denied\",\n                \"validation_result\": validation,\n                \"conditions\": [],\n                \"standalone_mode\": True,\n            }\n\n        try:\n            from ...models import AgentMessage, MessageType, Priority\n\n            priority_map = {\n                \"low\": Priority.LOW,\n                \"medium\": Priority.MEDIUM,\n                \"high\": Priority.HIGH,\n                \"critical\": Priority.CRITICAL,\n            }\n\n            message = AgentMessage(\n                from_agent=self.mcp_agent_id,\n                to_agent=\"governance_coordinator\",\n                message_type=MessageType.GOVERNANCE_REQUEST,\n                content={\n                    \"action\": action,\n                    \"context\": context,\n                    \"requester_id\": requester_id,\n                    \"wait_for_approval\": wait_for_approval,\n                    \"timeout_seconds\": timeout_seconds,\n                    \"constitutional_hash\": self.CONSTITUTIONAL_HASH,\n                },\n                priority=priority_map.get(priority, Priority.MEDIUM),\n            )\n\n            response = await self.agent_bus.send_message(message)\n\n            if hasattr(response, \"content\"):\n                return response.content\n            return response\n\n        except Exception as e:\n            logger.error(f\"Governance request error: {e}\")\n            return {\n                \"status\": \"error\",\n                \"error\": str(e),\n                \"validation_result\": None,\n                \"conditions\": [],\n            }\n\n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get adapter metrics.\"\"\"\n        return {\n            \"request_count\": self._request_count,\n            \"connected\": self._connected,\n            \"agent_id\": self.mcp_agent_id,\n            \"constitutional_hash\": self.CONSTITUTIONAL_HASH,\n        }\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.292919",
  "last_updated": "2026-01-04T05:35:58.475763"
}