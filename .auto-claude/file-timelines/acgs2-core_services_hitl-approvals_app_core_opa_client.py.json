{
  "file_path": "src/core/services/hitl-approvals/app/core/opa_client.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nHITL Approvals OPA Client\n\nProvides integration with Open Policy Agent for role-based routing policy evaluation.\nSupports querying OPA to determine approval chain routing based on decision type,\nimpact level, and user roles.\n\nPattern from: src/core/enhanced_agent_bus/opa_client.py\n\"\"\"\n\nimport hashlib\nimport json\nimport logging\nimport re\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional, Union\n\nimport httpx\nfrom acgs2_core.shared.types import JSONDict, JSONValue, KwargsType, PolicyData\n\nfrom app.config import settings\n\nlogger = logging.getLogger(__name__)\n\n\nclass OPAClientError(Exception):\n    \"\"\"Base exception for OPA client errors.\"\"\"\n\n    pass\n\n\nclass OPAConnectionError(OPAClientError):\n    \"\"\"Raised when unable to connect to OPA.\"\"\"\n\n    pass\n\n\nclass OPANotInitializedError(OPAClientError):\n    \"\"\"Raised when OPA client is not initialized.\"\"\"\n\n    pass\n\n\nclass PolicyEvaluationError(OPAClientError):\n    \"\"\"Raised when policy evaluation fails.\"\"\"\n\n    pass\n\n\nclass OPAClient:\n    \"\"\"\n    Client for OPA (Open Policy Agent) policy evaluation.\n\n    Provides role-based routing policy evaluation for the HITL approvals service.\n    Implements fail-closed architecture for security.\n\n    Features:\n    - HTTP API mode for remote OPA server\n    - Memory caching for performance\n    - Fail-closed behavior when OPA unavailable\n    - Input validation to prevent injection attacks\n    \"\"\"\n\n    # Default policy paths for HITL routing\n    ROUTING_POLICY = \"data.hitl.routing\"\n    AUTHORIZATION_POLICY = \"data.hitl.authorization\"\n    ESCALATION_POLICY = \"data.hitl.escalation\"\n\n    def __init__(\n        self,\n        opa_url: Optional[str] = None,\n        timeout: float = 5.0,\n        cache_ttl: int = 300,  # 5 minutes\n        enable_cache: bool = True,\n        fail_closed: bool = True,\n    ):\n        \"\"\"\n        Initialize OPA client.\n\n        Args:\n            opa_url: OPA server URL (defaults to settings.opa_url)\n            timeout: Request timeout in seconds\n            cache_ttl: Cache time-to-live in seconds\n            enable_cache: Enable memory caching\n            fail_closed: Deny requests when OPA unavailable (security default)\n        \"\"\"\n        self.opa_url = (opa_url or settings.opa_url).rstrip(\"/\")\n        self.timeout = timeout\n        self.cache_ttl = cache_ttl\n        self.enable_cache = enable_cache\n        self.fail_closed = fail_closed\n\n        self._http_client: Optional[httpx.AsyncClient] = None\n        self._memory_cache: Dict[str, JSONDict] = {}\n        self._initialized = False\n\n        logger.info(f\"OPAClient configured with URL: {self._sanitize_url(self.opa_url)}\")\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.initialize()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n    async def initialize(self) -> None:\n        \"\"\"Initialize HTTP client.\"\"\"\n        if self._initialized:\n            return\n\n        self._http_client = httpx.AsyncClient(\n            timeout=self.timeout,\n            limits=httpx.Limits(max_keepalive_connections=10, max_connections=20),\n        )\n        self._initialized = True\n        logger.info(\"OPAClient initialized\")\n\n    async def close(self) -> None:\n        \"\"\"Close HTTP client and clear cache.\"\"\"\n        if self._http_client:\n            await self._http_client.aclose()\n            self._http_client = None\n\n        self._memory_cache.clear()\n        self._initialized = False\n        logger.info(\"OPAClient closed\")\n\n    def _sanitize_url(self, url: str) -> str:\n        \"\"\"Sanitize URL for logging (mask sensitive parts).\"\"\"\n        if not url:\n            return \"<not configured>\"\n        # Only show host:port for logging\n        match = re.match(r\"(https?://[^/]+)\", url)\n        if match:\n            return match.group(1)\n        return \"<url>\"\n\n    def _generate_cache_key(self, policy_path: str, input_data: JSONDict) -> str:\n        \"\"\"Generate cache key from policy path and input data.\"\"\"\n        input_str = json.dumps(input_data, sort_keys=True)\n        input_hash = hashlib.sha256(input_str.encode()).hexdigest()[:16]\n        return f\"opa:{policy_path}:{input_hash}\"\n\n    def _get_from_cache(self, cache_key: str) -> Optional[JSONDict]:\n        \"\"\"Get result from memory cache.\"\"\"\n        if not self.enable_cache:\n            return None\n\n        if cache_key in self._memory_cache:\n            cached = self._memory_cache[cache_key]\n            now = datetime.now(timezone.utc).timestamp()\n            if now - cached[\"timestamp\"] < self.cache_ttl:\n                return cached[\"result\"]\n            else:\n                del self._memory_cache[cache_key]\n\n        return None\n\n    def _set_to_cache(self, cache_key: str, result: JSONDict) -> None:\n        \"\"\"Set result in memory cache.\"\"\"\n        if not self.enable_cache:\n            return\n\n        self._memory_cache[cache_key] = {\n            \"result\": result,\n            \"timestamp\": datetime.now(timezone.utc).timestamp(),\n        }\n\n    def _validate_policy_path(self, policy_path: str) -> None:\n        \"\"\"\n        Validate OPA policy path to prevent injection attacks.\n\n        Args:\n            policy_path: The policy path to validate\n\n        Raises:\n            ValueError: If policy path contains invalid characters\n        \"\"\"\n        if not re.match(r\"^[a-zA-Z0-9_.]+$\", policy_path):\n            raise ValueError(f\"Invalid policy path characters: {policy_path}\")\n        if \"..\" in policy_path:\n            raise ValueError(f\"Path traversal detected in policy path: {policy_path}\")\n\n    def _validate_input_data(self, input_data: JSONDict) -> None:\n        \"\"\"\n        Validate input data size and structure.\n\n        Args:\n            input_data: The input data to validate\n\n        Raises:\n            ValueError: If input data exceeds size limits\n        \"\"\"\n        serialized = json.dumps(input_data)\n        if len(serialized) > 512 * 1024:  # 512KB limit\n            raise ValueError(\"Input data exceeds maximum allowed size (512KB)\")\n\n    def _sanitize_error(self, error: Exception) -> str:\n        \"\"\"Strip sensitive metadata from error messages.\"\"\"\n        error_msg = str(error)\n        # Remove potential API keys, URLs with tokens\n        error_msg = re.sub(r\"key=[^&\\s]+\", \"key=REDACTED\", error_msg)\n        error_msg = re.sub(r\"token=[^&\\s]+\", \"token=REDACTED\", error_msg)\n        error_msg = re.sub(r\"https?://[^:\\s]+:[^@\\s]+@\", \"http://REDACTED@\", error_msg)\n        return error_msg\n\n    async def evaluate_policy(\n        self, input_data: JSONDict, policy_path: str = \"data.hitl.routing.allow\"\n    ) -> PolicyData:\n        \"\"\"\n        Evaluate a policy against input data.\n\n        Args:\n            input_data: Input data for policy evaluation\n            policy_path: OPA policy path (default: data.hitl.routing.allow)\n\n        Returns:\n            Dictionary containing:\n            - result: The raw policy result\n            - allowed: Boolean indicating if action is allowed\n            - reason: Human-readable reason\n            - metadata: Additional context\n\n        Raises:\n            PolicyEvaluationError: If evaluation fails and fail_closed is True\n        \"\"\"\n        # Check cache first\n        cache_key = self._generate_cache_key(policy_path, input_data)\n        cached_result = self._get_from_cache(cache_key)\n        if cached_result:\n            logger.debug(f\"Cache hit for policy: {policy_path}\")\n            return cached_result\n\n        try:\n            # Validate inputs\n            self._validate_policy_path(policy_path)\n            self._validate_input_data(input_data)\n\n            # Ensure client is initialized\n            if not self._http_client:\n                await self.initialize()\n\n            # Convert policy path to URL path\n            # \"data.hitl.routing\" -> \"hitl/routing\"\n            path_parts = policy_path.replace(\"data.\", \"\").replace(\".\", \"/\")\n            url = f\"{self.opa_url}/v1/data/{path_parts}\"\n\n            response = await self._http_client.post(url, json={\"input\": input_data})\n            response.raise_for_status()\n\n            data = response.json()\n            opa_result = data.get(\"result\")\n\n            result = self._process_opa_result(opa_result, policy_path)\n            self._set_to_cache(cache_key, result)\n\n            logger.debug(\n                f\"Policy evaluation completed: {policy_path} -> allowed={result['allowed']}\"\n            )\n            return result\n\n        except httpx.ConnectError as e:\n            sanitized_error = self._sanitize_error(e)\n            logger.error(f\"OPA connection error: {sanitized_error}\")\n            return self._handle_unavailable(policy_path, sanitized_error)\n\n        except httpx.HTTPStatusError as e:\n            sanitized_error = self._sanitize_error(e)\n            logger.error(f\"OPA HTTP error: {sanitized_error}\")\n            return self._handle_unavailable(policy_path, sanitized_error)\n\n        except Exception as e:\n            sanitized_error = self._sanitize_error(e)\n            logger.error(f\"Policy evaluation error: {sanitized_error}\")\n            return self._handle_unavailable(policy_path, sanitized_error)\n\n    def _process_opa_result(\n        self, opa_result: Union[bool, JSONDict, JSONValue, None], policy_path: str\n    ) -> PolicyData:\n        \"\"\"Process OPA result into standard format.\"\"\"\n        if opa_result is None:\n            return {\n                \"result\": None,\n                \"allowed\": False,\n                \"reason\": \"Policy not found or returned undefined\",\n                \"metadata\": {\"policy_path\": policy_path},\n            }\n\n        if isinstance(opa_result, bool):\n            return {\n                \"result\": opa_result,\n                \"allowed\": opa_result,\n                \"reason\": \"Policy evaluated successfully\",\n                \"metadata\": {\"policy_path\": policy_path},\n            }\n\n        if isinstance(opa_result, dict):\n            return {\n                \"result\": opa_result,\n                \"allowed\": opa_result.get(\"allow\", False),\n                \"reason\": opa_result.get(\"reason\", \"Policy evaluated successfully\"),\n                \"metadata\": {\n                    \"policy_path\": policy_path,\n                    **opa_result.get(\"metadata\", {}),\n                },\n            }\n\n        # Unexpected result type\n        return {\n            \"result\": opa_result,\n            \"allowed\": False,\n            \"reason\": f\"Unexpected result type: {type(opa_result).__name__}\",\n            \"metadata\": {\"policy_path\": policy_path},\n        }\n\n    def _handle_unavailable(self, policy_path: str, error: str) -> PolicyData:\n        \"\"\"\n        Handle OPA unavailability with fail-closed behavior.\n\n        When OPA is unavailable, deny all requests for security.\n        \"\"\"\n        if self.fail_closed:\n            logger.warning(f\"OPA unavailable - denying request (fail-closed): {error}\")\n            return {\n                \"result\": False,\n                \"allowed\": False,\n                \"reason\": f\"OPA unavailable - denied (fail-closed): {error}\",\n                \"metadata\": {\n                    \"policy_path\": policy_path,\n                    \"security\": \"fail-closed\",\n                    \"error\": error,\n                },\n            }\n        else:\n            # This should not happen in production - fail_closed should always be True\n            logger.error(\"OPA unavailable and fail_closed=False - this is a security risk!\")\n            return {\n                \"result\": False,\n                \"allowed\": False,\n                \"reason\": \"OPA unavailable - denied\",\n                \"metadata\": {\n                    \"policy_path\": policy_path,\n                    \"error\": error,\n                },\n            }\n\n    # =========================================================================\n    # HITL-Specific Policy Evaluation Methods\n    # =========================================================================\n\n    async def evaluate_routing(\n        self,\n        decision_type: str,\n        user_role: str,\n        impact_level: str = \"medium\",\n        context: Optional[JSONDict] = None,\n    ) -> PolicyData:\n        \"\"\"\n        Evaluate routing policy to determine approval chain.\n\n        Args:\n            decision_type: Type of decision (e.g., \"high_risk\", \"standard\")\n            user_role: Role of the user (e.g., \"engineer\", \"manager\")\n            impact_level: Impact level (low, medium, high, critical)\n            context: Additional context for policy evaluation\n\n        Returns:\n            Dictionary containing routing decision:\n            - allowed: Whether the request can proceed\n            - chain_id: Recommended approval chain ID\n            - reason: Explanation of routing decision\n        \"\"\"\n        input_data = {\n            \"decision_type\": decision_type,\n            \"user_role\": user_role,\n            \"impact_level\": impact_level,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            **(context or {}),\n        }\n\n        result = await self.evaluate_policy(input_data, self.ROUTING_POLICY)\n\n        # Extract chain_id from result if available\n        if result.get(\"result\") and isinstance(result[\"result\"], dict):\n            chain_id = result[\"result\"].get(\"chain_id\")\n            if chain_id:\n                result[\"chain_id\"] = chain_id\n\n        return result\n\n    async def evaluate_authorization(\n        self,\n        user_id: str,\n        user_role: str,\n        action: str,\n        resource: str,\n        context: Optional[JSONDict] = None,\n    ) -> bool:\n        \"\"\"\n        Check if user is authorized to perform action on resource.\n\n        Args:\n            user_id: User identifier\n            user_role: User's role\n            action: Action to perform (e.g., \"approve\", \"reject\", \"escalate\")\n            resource: Resource identifier (e.g., request_id)\n            context: Additional authorization context\n\n        Returns:\n            True if authorized, False otherwise\n        \"\"\"\n        input_data = {\n            \"user_id\": user_id,\n            \"user_role\": user_role,\n            \"action\": action,\n            \"resource\": resource,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            **(context or {}),\n        }\n\n        result = await self.evaluate_policy(input_data, self.AUTHORIZATION_POLICY)\n        return result.get(\"allowed\", False)\n\n    async def evaluate_escalation(\n        self,\n        request_id: str,\n        current_level: int,\n        escalation_count: int,\n        priority: str,\n        context: Optional[JSONDict] = None,\n    ) -> PolicyData:\n        \"\"\"\n        Evaluate escalation policy for a request.\n\n        Args:\n            request_id: Approval request identifier\n            current_level: Current approval level\n            escalation_count: Number of times escalated\n            priority: Request priority (low, medium, high, critical)\n            context: Additional context\n\n        Returns:\n            Dictionary containing:\n            - allowed: Whether escalation is allowed\n            - next_level: Next approval level (if allowed)\n            - reason: Explanation\n        \"\"\"\n        input_data = {\n            \"request_id\": request_id,\n            \"current_level\": current_level,\n            \"escalation_count\": escalation_count,\n            \"priority\": priority,\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            **(context or {}),\n        }\n\n        result = await self.evaluate_policy(input_data, self.ESCALATION_POLICY)\n\n        # Extract next_level from result if available\n        if result.get(\"result\") and isinstance(result[\"result\"], dict):\n            next_level = result[\"result\"].get(\"next_level\")\n            if next_level is not None:\n                result[\"next_level\"] = next_level\n\n        return result\n\n    async def get_required_approvers(\n        self,\n        decision_type: str,\n        impact_level: str,\n        current_level: int,\n    ) -> List[str]:\n        \"\"\"\n        Get list of required approver roles for a given decision type and level.\n\n        Args:\n            decision_type: Type of decision\n            impact_level: Impact level\n            current_level: Current approval level\n\n        Returns:\n            List of required approver roles\n        \"\"\"\n        input_data = {\n            \"decision_type\": decision_type,\n            \"impact_level\": impact_level,\n            \"current_level\": current_level,\n        }\n\n        result = await self.evaluate_policy(input_data, \"data.hitl.routing.required_approvers\")\n\n        if result.get(\"result\") and isinstance(result[\"result\"], list):\n            return result[\"result\"]\n\n        # Default approver roles based on level\n        default_roles = {\n            1: [\"engineer\", \"analyst\"],\n            2: [\"manager\", \"lead\"],\n            3: [\"director\", \"vp\"],\n            4: [\"executive\", \"ciso\"],\n        }\n        return default_roles.get(current_level, [\"admin\"])\n\n    # =========================================================================\n    # Health Check and Status\n    # =========================================================================\n\n    async def health_check(self) -> JSONDict:\n        \"\"\"\n        Check OPA service health.\n\n        Returns:\n            Dictionary containing health status\n        \"\"\"\n        try:\n            if not self._http_client:\n                await self.initialize()\n\n            response = await self._http_client.get(f\"{self.opa_url}/health\", timeout=2.0)\n            response.raise_for_status()\n\n            return {\n                \"status\": \"healthy\",\n                \"opa_url\": self._sanitize_url(self.opa_url),\n                \"cache_enabled\": self.enable_cache,\n                \"cache_size\": len(self._memory_cache),\n                \"fail_closed\": self.fail_closed,\n            }\n\n        except Exception as e:\n            sanitized_error = self._sanitize_error(e)\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": sanitized_error,\n                \"opa_url\": self._sanitize_url(self.opa_url),\n                \"fail_closed\": self.fail_closed,\n            }\n\n    def get_stats(self) -> JSONDict:\n        \"\"\"Get client statistics.\"\"\"\n        return {\n            \"opa_url\": self._sanitize_url(self.opa_url),\n            \"initialized\": self._initialized,\n            \"cache_enabled\": self.enable_cache,\n            \"cache_size\": len(self._memory_cache),\n            \"fail_closed\": self.fail_closed,\n        }\n\n\n# Global client instance (singleton pattern)\n_opa_client: Optional[OPAClient] = None\n\n\ndef get_opa_client() -> OPAClient:\n    \"\"\"\n    Get the global OPAClient instance.\n\n    Returns:\n        The singleton OPAClient instance\n    \"\"\"\n    global _opa_client\n    if _opa_client is None:\n        _opa_client = OPAClient()\n    return _opa_client\n\n\nasync def initialize_opa_client(\n    opa_url: Optional[str] = None,\n    timeout: float = 5.0,\n    **kwargs: KwargsType,\n) -> OPAClient:\n    \"\"\"\n    Initialize the global OPA client.\n\n    Args:\n        opa_url: OPA server URL\n        timeout: Request timeout\n        **kwargs: Additional OPAClient arguments\n\n    Returns:\n        Initialized OPAClient instance\n    \"\"\"\n    global _opa_client\n    _opa_client = OPAClient(opa_url=opa_url, timeout=timeout, **kwargs)\n    await _opa_client.initialize()\n    return _opa_client\n\n\nasync def close_opa_client() -> None:\n    \"\"\"Close the global OPA client.\"\"\"\n    global _opa_client\n    if _opa_client:\n        await _opa_client.close()\n        _opa_client = None\n\n\ndef reset_opa_client() -> None:\n    \"\"\"\n    Reset the global OPAClient instance.\n\n    Used primarily for test isolation.\n    \"\"\"\n    global _opa_client\n    _opa_client = None\n\n\n__all__ = [\n    \"OPAClient\",\n    \"OPAClientError\",\n    \"OPAConnectionError\",\n    \"OPANotInitializedError\",\n    \"PolicyEvaluationError\",\n    \"get_opa_client\",\n    \"initialize_opa_client\",\n    \"close_opa_client\",\n    \"reset_opa_client\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.254932",
  "last_updated": "2026-01-04T05:35:58.783733"
}