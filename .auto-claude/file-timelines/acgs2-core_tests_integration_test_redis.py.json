{
  "file_path": "acgs2-core/tests/integration/test_redis.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Integration Tests - Redis Service\nConstitutional Hash: cdd01ef066bc6cf2\n\nTests integration with the Redis caching service.\nThese tests verify:\n- Connection and ping functionality\n- SET/GET operations\n- Key expiration (TTL) handling\n- Connection pooling\n- Error handling for unavailable service\n- Fail-closed architecture enforcement\n\nUsage:\n    # Run with mock (offline mode - default)\n    pytest acgs2-core/tests/integration/test_redis.py -v\n\n    # Run against live Redis service (requires Redis on localhost:6379)\n    SKIP_LIVE_TESTS=false REDIS_URL=redis://localhost:6379/0 pytest -v -m integration\n\"\"\"\n\nimport os\nimport sys\nfrom typing import Any, Dict, List, Optional\n\nimport pytest\n\n# Add parent directories to path for local imports\n_tests_dir = os.path.dirname(os.path.abspath(__file__))\n_acgs2_core_dir = os.path.dirname(os.path.dirname(_tests_dir))\nif _acgs2_core_dir not in sys.path:\n    sys.path.insert(0, _acgs2_core_dir)\n\n# Try to import redis, fall back to mock if not available\ntry:\n    import redis.asyncio as aioredis\n\n    REDIS_AVAILABLE = True\nexcept ImportError:\n    REDIS_AVAILABLE = False\n\n\n# Constants\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\nDEFAULT_REDIS_URL = os.environ.get(\"REDIS_URL\", \"redis://localhost:6379/0\")\nDEFAULT_TIMEOUT = 5.0\n\n\n# Test Fixtures\n@pytest.fixture\ndef redis_url() -> str:\n    \"\"\"Get the Redis URL from environment or use default.\"\"\"\n    return os.environ.get(\"REDIS_URL\", DEFAULT_REDIS_URL)\n\n\n@pytest.fixture\ndef test_key_prefix() -> str:\n    \"\"\"Prefix for test keys to avoid conflicts.\"\"\"\n    return \"acgs2:test:integration:\"\n\n\n@pytest.fixture\ndef sample_cache_data() -> Dict[str, Any]:\n    \"\"\"Sample data for caching tests.\"\"\"\n    return {\n        \"user_id\": \"test-user-001\",\n        \"session_id\": \"test-session-abc\",\n        \"permissions\": [\"read\", \"write\"],\n        \"constitutional_hash\": CONSTITUTIONAL_HASH,\n    }\n\n\n@pytest.fixture\ndef sample_policy_cache() -> Dict[str, Any]:\n    \"\"\"Sample policy data for caching tests.\"\"\"\n    return {\n        \"policy_name\": \"acgs.test.policy\",\n        \"version\": \"1.0.0\",\n        \"rules\": [\n            {\"action\": \"allow\", \"resource\": \"config\"},\n            {\"action\": \"deny\", \"resource\": \"admin\"},\n        ],\n        \"ttl\": 3600,\n    }\n\n\n# Mock Redis Client Fixture\n@pytest.fixture\ndef mock_redis_client(sample_cache_data, sample_policy_cache, test_key_prefix):\n    \"\"\"Create a mock Redis client for offline testing.\"\"\"\n\n    class MockRedisClient:\n        def __init__(self):\n            self._storage: Dict[str, Any] = {}\n            self._ttls: Dict[str, int] = {}\n            self._connected = True\n            self._fail_next = False\n\n        async def __aenter__(self):\n            return self\n\n        async def __aexit__(self, exc_type, exc_val, exc_tb):\n            pass\n\n        def set_fail_next(self, fail: bool = True):\n            \"\"\"Configure mock to fail the next operation.\"\"\"\n            self._fail_next = fail\n\n        def set_connected(self, connected: bool = True):\n            \"\"\"Configure mock connection state.\"\"\"\n            self._connected = connected\n\n        async def ping(self) -> bool:\n            \"\"\"Test Redis connection.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if not self._connected:\n                raise Exception(\"Connection refused\")\n            return True\n\n        async def get(self, key: str) -> Optional[bytes]:\n            \"\"\"Get a value from Redis.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if not self._connected:\n                raise Exception(\"Connection refused\")\n            value = self._storage.get(key)\n            if value is None:\n                return None\n            return value.encode(\"utf-8\") if isinstance(value, str) else value\n\n        async def set(\n            self,\n            key: str,\n            value: Any,\n            ex: Optional[int] = None,\n            px: Optional[int] = None,\n            nx: bool = False,\n            xx: bool = False,\n        ) -> bool:\n            \"\"\"Set a value in Redis.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if not self._connected:\n                raise Exception(\"Connection refused\")\n\n            # Handle NX (only set if not exists)\n            if nx and key in self._storage:\n                return False\n\n            # Handle XX (only set if exists)\n            if xx and key not in self._storage:\n                return False\n\n            self._storage[key] = value\n            if ex:\n                self._ttls[key] = ex\n            return True\n\n        async def delete(self, *keys: str) -> int:\n            \"\"\"Delete keys from Redis.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            deleted = 0\n            for key in keys:\n                if key in self._storage:\n                    del self._storage[key]\n                    if key in self._ttls:\n                        del self._ttls[key]\n                    deleted += 1\n            return deleted\n\n        async def exists(self, *keys: str) -> int:\n            \"\"\"Check if keys exist.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            count = 0\n            for key in keys:\n                if key in self._storage:\n                    count += 1\n            return count\n\n        async def ttl(self, key: str) -> int:\n            \"\"\"Get TTL for a key.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if key not in self._storage:\n                return -2  # Key does not exist\n            if key not in self._ttls:\n                return -1  # Key exists but no TTL\n            return self._ttls[key]\n\n        async def expire(self, key: str, seconds: int) -> bool:\n            \"\"\"Set expiration on a key.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if key not in self._storage:\n                return False\n            self._ttls[key] = seconds\n            return True\n\n        async def keys(self, pattern: str = \"*\") -> List[bytes]:\n            \"\"\"Get keys matching pattern.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            # Simple pattern matching (just prefix)\n            prefix = pattern.rstrip(\"*\")\n            matching = [k for k in self._storage.keys() if k.startswith(prefix)]\n            return [k.encode(\"utf-8\") for k in matching]\n\n        async def mget(self, *keys: str) -> List[Optional[bytes]]:\n            \"\"\"Get multiple values.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            results = []\n            for key in keys:\n                value = self._storage.get(key)\n                if value is None:\n                    results.append(None)\n                else:\n                    results.append(value.encode(\"utf-8\") if isinstance(value, str) else value)\n            return results\n\n        async def mset(self, mapping: Dict[str, Any]) -> bool:\n            \"\"\"Set multiple values.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            for key, value in mapping.items():\n                self._storage[key] = value\n            return True\n\n        async def incr(self, key: str) -> int:\n            \"\"\"Increment a value.\"\"\"\n            if self._fail_next:\n                self._fail_next = False\n                raise Exception(\"Connection refused\")\n            if key not in self._storage:\n                self._storage[key] = \"0\"\n            current = int(self._storage[key])\n            self._storage[key] = str(current + 1)\n            return current + 1\n\n        async def close(self):\n            \"\"\"Close the connection.\"\"\"\n            self._connected = False\n\n    return MockRedisClient()\n\n\n# ============================================================================\n# Connection Tests\n# ============================================================================\nclass TestRedisConnection:\n    \"\"\"Tests for Redis connection functionality.\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_ping_returns_true(self, mock_redis_client):\n        \"\"\"\n        Integration test: Verify Redis ping returns True.\n\n        Tests basic connectivity to the Redis service.\n        \"\"\"\n        async with mock_redis_client as client:\n            result = await client.ping()\n\n            assert result is True\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_connection_state_tracking(self, mock_redis_client):\n        \"\"\"\n        Integration test: Verify connection state is tracked correctly.\n        \"\"\"\n        async with mock_redis_client as client:\n            # Initially connected\n            result = await client.ping()\n            assert result is True\n\n            # After closing\n            await client.close()\n            with pytest.raises(Exception) as excinfo:\n                await client.ping()\n            assert \"Connection refused\" in str(excinfo.value)\n\n\n# ============================================================================\n# Basic Operations Tests\n# ============================================================================\nclass TestRedisBasicOperations:\n    \"\"\"Tests for Redis basic SET/GET operations.\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_set_returns_true(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify SET operation returns True.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}test_key\"\n            result = await client.set(key, \"test_value\")\n\n            assert result is True\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_get_returns_value(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify GET operation returns stored value.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}test_key\"\n            await client.set(key, \"test_value\")\n\n            result = await client.get(key)\n\n            assert result == b\"test_value\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_get_nonexistent_returns_none(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify GET on nonexistent key returns None.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}nonexistent_key\"\n\n            result = await client.get(key)\n\n            assert result is None\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_delete_removes_key(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify DELETE removes key.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}delete_test\"\n            await client.set(key, \"to_be_deleted\")\n\n            deleted = await client.delete(key)\n\n            assert deleted == 1\n            assert await client.get(key) is None\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_exists_returns_count(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify EXISTS returns correct count.\n        \"\"\"\n        async with mock_redis_client as client:\n            key1 = f\"{test_key_prefix}exists_test_1\"\n            key2 = f\"{test_key_prefix}exists_test_2\"\n            await client.set(key1, \"value1\")\n            await client.set(key2, \"value2\")\n\n            count = await client.exists(key1, key2, f\"{test_key_prefix}nonexistent\")\n\n            assert count == 2\n\n\n# ============================================================================\n# TTL and Expiration Tests\n# ============================================================================\nclass TestRedisTTLOperations:\n    \"\"\"Tests for Redis TTL and expiration functionality.\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_set_with_ttl(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify SET with expiration.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}ttl_test\"\n            await client.set(key, \"expiring_value\", ex=3600)\n\n            ttl = await client.ttl(key)\n\n            assert ttl == 3600\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_ttl_nonexistent_key(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify TTL on nonexistent key returns -2.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}nonexistent_ttl\"\n\n            ttl = await client.ttl(key)\n\n            assert ttl == -2\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_ttl_no_expiration(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify TTL on key without expiration returns -1.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}no_ttl\"\n            await client.set(key, \"persistent_value\")\n\n            ttl = await client.ttl(key)\n\n            assert ttl == -1\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_expire_sets_ttl(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify EXPIRE sets TTL on existing key.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}expire_test\"\n            await client.set(key, \"value\")\n\n            result = await client.expire(key, 1800)\n\n            assert result is True\n            assert await client.ttl(key) == 1800\n\n\n# ============================================================================\n# Batch Operations Tests\n# ============================================================================\nclass TestRedisBatchOperations:\n    \"\"\"Tests for Redis batch operations (MGET, MSET).\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_mset_sets_multiple_keys(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify MSET sets multiple keys.\n        \"\"\"\n        async with mock_redis_client as client:\n            mapping = {\n                f\"{test_key_prefix}batch_1\": \"value1\",\n                f\"{test_key_prefix}batch_2\": \"value2\",\n                f\"{test_key_prefix}batch_3\": \"value3\",\n            }\n\n            result = await client.mset(mapping)\n\n            assert result is True\n            for key in mapping:\n                assert await client.get(key) is not None\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_mget_returns_multiple_values(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify MGET returns multiple values.\n        \"\"\"\n        async with mock_redis_client as client:\n            keys = [\n                f\"{test_key_prefix}mget_1\",\n                f\"{test_key_prefix}mget_2\",\n                f\"{test_key_prefix}mget_3\",\n            ]\n            for i, key in enumerate(keys):\n                await client.set(key, f\"value{i}\")\n\n            results = await client.mget(*keys)\n\n            assert len(results) == 3\n            assert all(r is not None for r in results)\n\n\n# ============================================================================\n# Conditional Operations Tests\n# ============================================================================\nclass TestRedisConditionalOperations:\n    \"\"\"Tests for Redis conditional SET operations (NX, XX).\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_set_nx_only_if_not_exists(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify SET NX only sets if key doesn't exist.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}nx_test\"\n\n            # First set should succeed\n            result1 = await client.set(key, \"first\", nx=True)\n            assert result1 is True\n\n            # Second set should fail\n            result2 = await client.set(key, \"second\", nx=True)\n            assert result2 is False\n\n            # Value should be first\n            value = await client.get(key)\n            assert value == b\"first\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_set_xx_only_if_exists(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify SET XX only sets if key exists.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}xx_test\"\n\n            # Set on nonexistent key should fail\n            result1 = await client.set(key, \"value\", xx=True)\n            assert result1 is False\n\n            # Create the key\n            await client.set(key, \"initial\")\n\n            # Set on existing key should succeed\n            result2 = await client.set(key, \"updated\", xx=True)\n            assert result2 is True\n\n            # Value should be updated\n            value = await client.get(key)\n            assert value == b\"updated\"\n\n\n# ============================================================================\n# Counter Operations Tests\n# ============================================================================\nclass TestRedisCounterOperations:\n    \"\"\"Tests for Redis counter operations (INCR).\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_incr_increments_value(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify INCR increments numeric value.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}counter\"\n            await client.set(key, \"0\")\n\n            result = await client.incr(key)\n\n            assert result == 1\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_incr_creates_if_not_exists(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify INCR creates key if not exists.\n        \"\"\"\n        async with mock_redis_client as client:\n            key = f\"{test_key_prefix}new_counter\"\n\n            result = await client.incr(key)\n\n            assert result == 1\n\n\n# ============================================================================\n# Error Handling Tests\n# ============================================================================\nclass TestRedisErrorHandling:\n    \"\"\"Tests for Redis error handling and resilience.\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_connection_error_handling(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify connection errors are handled gracefully.\n        \"\"\"\n        async with mock_redis_client as client:\n            client.set_fail_next(True)\n\n            with pytest.raises(Exception) as excinfo:\n                await client.get(f\"{test_key_prefix}any_key\")\n\n            assert \"Connection refused\" in str(excinfo.value)\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_disconnected_state_raises_error(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Integration test: Verify operations fail on disconnected client.\n        \"\"\"\n        async with mock_redis_client as client:\n            client.set_connected(False)\n\n            with pytest.raises(Exception) as excinfo:\n                await client.get(f\"{test_key_prefix}any_key\")\n\n            assert \"Connection refused\" in str(excinfo.value)\n\n\n# ============================================================================\n# Fail-Closed Architecture Tests\n# ============================================================================\nclass TestRedisFailClosedArchitecture:\n    \"\"\"Tests verifying fail-closed security architecture for Redis.\"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.constitutional\n    def test_fail_closed_on_connection_error(self):\n        \"\"\"\n        Constitutional test: Verify fail-closed behavior on Redis unavailability.\n\n        When Redis is unreachable, the system should fail operations\n        rather than silently returning defaults.\n        \"\"\"\n        fail_closed = True  # ACGS-2 security architecture requirement\n        assert fail_closed is True\n\n    @pytest.mark.integration\n    @pytest.mark.constitutional\n    def test_cache_miss_returns_none(self, mock_redis_client, test_key_prefix):\n        \"\"\"\n        Constitutional test: Verify cache miss returns None, not cached default.\n\n        This ensures the application checks the authoritative source\n        rather than assuming a default value.\n        \"\"\"\n        # Cache miss should explicitly return None\n        # Application should then query the authoritative source\n        assert True\n\n\n# ============================================================================\n# Constitutional Compliance Tests\n# ============================================================================\nclass TestConstitutionalCompliance:\n    \"\"\"Tests verifying constitutional compliance of the integration tests.\"\"\"\n\n    def test_constitutional_hash_present(self):\n        \"\"\"Verify constitutional hash is correctly set.\"\"\"\n        assert CONSTITUTIONAL_HASH == \"cdd01ef066bc6cf2\"\n\n    @pytest.mark.constitutional\n    def test_tests_are_marked_for_integration(self):\n        \"\"\"Verify tests are properly marked with integration marker.\"\"\"\n        import inspect\n\n        # Get all test classes in this module\n        test_classes = [\n            TestRedisConnection,\n            TestRedisBasicOperations,\n            TestRedisTTLOperations,\n            TestRedisBatchOperations,\n            TestRedisConditionalOperations,\n            TestRedisCounterOperations,\n            TestRedisErrorHandling,\n            TestRedisFailClosedArchitecture,\n        ]\n\n        for test_class in test_classes:\n            methods = inspect.getmembers(test_class, predicate=inspect.isfunction)\n            test_methods = [m for m in methods if m[0].startswith(\"test_\")]\n\n            # Verify we have test methods\n            assert len(test_methods) > 0, f\"{test_class.__name__} has no test methods\"\n\n\n# ============================================================================\n# Live Service Tests (only run when service is available)\n# ============================================================================\n@pytest.mark.skipif(\n    not REDIS_AVAILABLE or os.environ.get(\"SKIP_LIVE_TESTS\", \"true\").lower() == \"true\",\n    reason=\"Live tests skipped - set SKIP_LIVE_TESTS=false and ensure redis is installed\",\n)\nclass TestRedisLiveService:\n    \"\"\"\n    Live integration tests that run against an actual Redis service.\n\n    These tests are skipped by default. To run them:\n    1. Start Redis service on localhost:6379\n    2. Set SKIP_LIVE_TESTS=false\n    3. Run: pytest acgs2-core/tests/integration/test_redis.py -v -k \"Live\"\n    \"\"\"\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_ping(self, redis_url, test_key_prefix):\n        \"\"\"Live test: Ping Redis service.\"\"\"\n        if not REDIS_AVAILABLE:\n            pytest.skip(\"redis not available\")\n\n        try:\n            client = aioredis.from_url(redis_url, socket_timeout=DEFAULT_TIMEOUT)\n            try:\n                result = await client.ping()\n                assert result is True\n            finally:\n                await client.close()\n        except Exception as e:\n            pytest.skip(f\"Redis not reachable: {e}\")\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_set_get(self, redis_url, test_key_prefix):\n        \"\"\"Live test: SET and GET operations.\"\"\"\n        if not REDIS_AVAILABLE:\n            pytest.skip(\"redis not available\")\n\n        try:\n            client = aioredis.from_url(redis_url, socket_timeout=DEFAULT_TIMEOUT)\n            try:\n                key = f\"{test_key_prefix}live_test\"\n                await client.set(key, \"live_value\")\n                result = await client.get(key)\n                assert result == b\"live_value\"\n\n                # Cleanup\n                await client.delete(key)\n            finally:\n                await client.close()\n        except Exception as e:\n            pytest.skip(f\"Redis not reachable: {e}\")\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_connection_pool(self, redis_url, test_key_prefix):\n        \"\"\"Live test: Connection pooling behavior.\"\"\"\n        if not REDIS_AVAILABLE:\n            pytest.skip(\"redis not available\")\n\n        try:\n            # Create multiple clients to test pooling\n            client1 = aioredis.from_url(redis_url, socket_timeout=DEFAULT_TIMEOUT)\n            client2 = aioredis.from_url(redis_url, socket_timeout=DEFAULT_TIMEOUT)\n\n            try:\n                key = f\"{test_key_prefix}pool_test\"\n\n                # Both clients should be able to access Redis\n                await client1.set(key, \"pooled_value\")\n                result = await client2.get(key)\n                assert result == b\"pooled_value\"\n\n                # Cleanup\n                await client1.delete(key)\n            finally:\n                await client1.close()\n                await client2.close()\n        except Exception as e:\n            pytest.skip(f\"Redis not reachable: {e}\")\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-m\", \"integration\"])\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.204311",
  "last_updated": "2026-01-04T05:35:59.217493"
}