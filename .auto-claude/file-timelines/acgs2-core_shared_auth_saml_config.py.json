{
  "file_path": "src/core/shared/auth/saml_config.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 SAML 2.0 Configuration Module\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides configuration dataclasses for SAML 2.0 Service Provider (SP) setup\nwith PySAML2. Supports multiple Identity Providers (IdPs) including Okta,\nAzure AD, and custom SAML IdPs.\n\nFeatures:\n    - SP configuration with entity ID and endpoints\n    - IdP metadata handling (URL or inline XML)\n    - Certificate and key management\n    - Signature and encryption settings\n    - Clock skew tolerance configuration\n\nUsage:\n    from shared.auth.saml_config import SAMLSPConfig, SAMLIdPConfig\n\n    # Create SP configuration\n    sp_config = SAMLSPConfig(\n        entity_id=\"https://acgs2.example.com/saml/metadata\",\n        acs_url=\"https://acgs2.example.com/saml/acs\",\n        sls_url=\"https://acgs2.example.com/saml/sls\",\n        cert_file=\"/path/to/sp.crt\",\n        key_file=\"/path/to/sp.key\",\n    )\n\n    # Create IdP configuration\n    idp_config = SAMLIdPConfig(\n        name=\"okta\",\n        entity_id=\"http://www.okta.com/exk123\",\n        metadata_url=\"https://dev-123.okta.com/app/exk123/sso/saml/metadata\",\n    )\n\"\"\"\n\nimport logging\nimport os\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Optional\n\nlogger = logging.getLogger(__name__)\n\n# Constitutional hash constant\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n# Default paths relative to this module\nDEFAULT_CERT_DIR = Path(__file__).parent / \"certs\"\nDEFAULT_SP_CERT = DEFAULT_CERT_DIR / \"sp.crt\"\nDEFAULT_SP_KEY = DEFAULT_CERT_DIR / \"sp.key\"\n\n# Default clock skew tolerance (in seconds)\nDEFAULT_CLOCK_SKEW_TOLERANCE = 120\n\n\nclass SAMLConfigurationError(Exception):\n    \"\"\"Configuration error for SAML provider.\"\"\"\n\n    pass\n\n\n@dataclass\nclass SAMLSPConfig:\n    \"\"\"Service Provider (SP) configuration for SAML 2.0.\n\n    Configures the SAML 2.0 Service Provider endpoints and security settings.\n    The SP is the relying party that receives SAML assertions from IdPs.\n\n    Attributes:\n        entity_id: Unique identifier for this SP (typically the metadata URL)\n        acs_url: Assertion Consumer Service URL for POST binding\n        sls_url: Single Logout Service URL for redirect binding\n        metadata_url: URL where SP metadata is served\n        cert_file: Path to SP certificate file (PEM format)\n        key_file: Path to SP private key file (PEM format)\n        cert_content: SP certificate content (alternative to file)\n        key_content: SP private key content (alternative to file)\n        sign_authn_requests: Whether to sign AuthnRequests\n        want_assertions_signed: Whether to require signed assertions\n        want_assertions_encrypted: Whether to require encrypted assertions\n        allow_unsolicited: Whether to accept IdP-initiated SSO\n        clock_skew_tolerance: Allowed clock skew in seconds\n        name: Human-readable name for this SP\n        description: Description of this SP\n        org_name: Organization name\n        org_display_name: Organization display name\n        org_url: Organization URL\n        contact_name: Technical contact name\n        contact_email: Technical contact email\n        xmlsec_binary: Path to xmlsec1 binary (auto-detected if not set)\n    \"\"\"\n\n    # Required fields\n    entity_id: str\n    acs_url: str\n\n    # Optional endpoint URLs\n    sls_url: Optional[str] = None\n    metadata_url: Optional[str] = None\n\n    # Certificate configuration (file paths or content)\n    cert_file: Optional[str] = None\n    key_file: Optional[str] = None\n    cert_content: Optional[str] = None\n    key_content: Optional[str] = None\n\n    # Security settings\n    sign_authn_requests: bool = True\n    want_assertions_signed: bool = True\n    want_assertions_encrypted: bool = False\n    allow_unsolicited: bool = True\n\n    # Timing settings\n    clock_skew_tolerance: int = DEFAULT_CLOCK_SKEW_TOLERANCE\n\n    # SP identity\n    name: str = \"ACGS-2 SAML SP\"\n    description: str = \"ACGS-2 Constitutional AI Governance System\"\n    org_name: str = \"ACGS-2\"\n    org_display_name: str = \"ACGS-2 Platform\"\n    org_url: str = \"https://acgs2.example.com\"\n\n    # Contact information\n    contact_name: str = \"ACGS-2 Admin\"\n    contact_email: str = \"admin@example.com\"\n\n    # xmlsec1 binary path (auto-detected if None)\n    xmlsec_binary: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        if not self.entity_id:\n            raise SAMLConfigurationError(\"SP entity ID is required\")\n        if not self.acs_url:\n            raise SAMLConfigurationError(\"ACS URL is required\")\n\n        # Auto-detect xmlsec1 if not specified\n        if not self.xmlsec_binary:\n            self.xmlsec_binary = self._find_xmlsec_binary()\n\n        # Use default certificate paths if not specified and no content provided\n        if not self.cert_file and not self.cert_content:\n            if DEFAULT_SP_CERT.exists():\n                self.cert_file = str(DEFAULT_SP_CERT)\n        if not self.key_file and not self.key_content:\n            if DEFAULT_SP_KEY.exists():\n                self.key_file = str(DEFAULT_SP_KEY)\n\n    def _find_xmlsec_binary(self) -> str:\n        \"\"\"Find xmlsec1 binary in common locations.\n\n        Returns:\n            Path to xmlsec1 binary.\n\n        Raises:\n            SAMLConfigurationError: If xmlsec1 is not found.\n        \"\"\"\n        # Check environment variable first\n        env_path = os.environ.get(\"SAML_XMLSEC_BINARY\")\n        if env_path and os.path.isfile(env_path):\n            return env_path\n\n        # Common locations\n        common_paths = [\n            \"/usr/bin/xmlsec1\",\n            \"/usr/local/bin/xmlsec1\",\n            \"/opt/homebrew/bin/xmlsec1\",  # macOS Homebrew ARM\n            \"/opt/local/bin/xmlsec1\",  # macOS MacPorts\n        ]\n\n        for path in common_paths:\n            if os.path.isfile(path):\n                return path\n\n        # Check PATH\n        import shutil\n\n        path = shutil.which(\"xmlsec1\")\n        if path:\n            return path\n\n        logger.warning(\n            \"xmlsec1 binary not found. SAML signature validation will fail. \"\n            \"Install with: apt-get install xmlsec1 (Debian/Ubuntu) or \"\n            \"brew install libxmlsec1 (macOS)\"\n        )\n        return \"/usr/bin/xmlsec1\"  # Return default, will fail at runtime\n\n    def get_cert_content(self) -> Optional[str]:\n        \"\"\"Get SP certificate content.\n\n        Returns:\n            Certificate content string, or None if not configured.\n        \"\"\"\n        if self.cert_content:\n            return self.cert_content\n        if self.cert_file and os.path.isfile(self.cert_file):\n            with open(self.cert_file) as f:\n                return f.read()\n        return None\n\n    def get_key_content(self) -> Optional[str]:\n        \"\"\"Get SP private key content.\n\n        Returns:\n            Private key content string, or None if not configured.\n        \"\"\"\n        if self.key_content:\n            return self.key_content\n        if self.key_file and os.path.isfile(self.key_file):\n            with open(self.key_file) as f:\n                return f.read()\n        return None\n\n    def has_signing_credentials(self) -> bool:\n        \"\"\"Check if signing credentials are available.\n\n        Returns:\n            True if both certificate and key are available.\n        \"\"\"\n        cert = self.get_cert_content()\n        key = self.get_key_content()\n        return bool(cert and key)\n\n    def validate(self) -> list[str]:\n        \"\"\"Validate SP configuration.\n\n        Returns:\n            List of validation errors, empty if valid.\n        \"\"\"\n        errors = []\n\n        if not self.entity_id:\n            errors.append(\"SP entity ID is required\")\n        if not self.acs_url:\n            errors.append(\"ACS URL is required\")\n\n        if self.sign_authn_requests:\n            if not self.has_signing_credentials():\n                errors.append(\n                    \"SP certificate and key are required when sign_authn_requests is enabled\"\n                )\n\n        if self.xmlsec_binary and not os.path.isfile(self.xmlsec_binary):\n            errors.append(f\"xmlsec1 binary not found at {self.xmlsec_binary}\")\n\n        return errors\n\n\n@dataclass\nclass SAMLIdPConfig:\n    \"\"\"Identity Provider (IdP) configuration for SAML 2.0.\n\n    Configures a SAML 2.0 Identity Provider for SSO authentication.\n    Supports metadata URL, inline XML, or manual endpoint configuration.\n\n    Attributes:\n        name: Unique name for this IdP (e.g., 'okta', 'azure')\n        entity_id: IdP entity ID (from metadata or manually configured)\n        metadata_url: URL to fetch IdP metadata XML\n        metadata_xml: Inline IdP metadata XML content\n        sso_url: IdP SSO endpoint URL (if not using metadata)\n        sso_binding: SSO binding type (redirect or post)\n        slo_url: IdP SLO endpoint URL\n        slo_binding: SLO binding type (redirect or post)\n        certificate: IdP signing certificate (PEM format)\n        want_response_signed: Whether to require signed SAML responses\n        want_assertions_signed: Whether to require signed assertions\n        enabled: Whether this IdP is enabled\n    \"\"\"\n\n    # Required fields\n    name: str\n\n    # IdP identity (one of entity_id or metadata_url/xml required)\n    entity_id: Optional[str] = None\n    metadata_url: Optional[str] = None\n    metadata_xml: Optional[str] = None\n\n    # Manual endpoint configuration (used if no metadata)\n    sso_url: Optional[str] = None\n    sso_binding: str = \"redirect\"  # redirect or post\n    slo_url: Optional[str] = None\n    slo_binding: str = \"redirect\"  # redirect or post\n\n    # IdP certificate for signature validation\n    certificate: Optional[str] = None\n\n    # Security requirements\n    want_response_signed: bool = True\n    want_assertions_signed: bool = True\n\n    # Status\n    enabled: bool = True\n\n    def __post_init__(self) -> None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        if not self.name:\n            raise SAMLConfigurationError(\"IdP name is required\")\n\n        # Normalize binding types\n        self.sso_binding = self.sso_binding.lower()\n        self.slo_binding = self.slo_binding.lower()\n\n        if self.sso_binding not in (\"redirect\", \"post\"):\n            raise SAMLConfigurationError(\n                f\"Invalid SSO binding '{self.sso_binding}'. Must be 'redirect' or 'post'\"\n            )\n        if self.slo_binding not in (\"redirect\", \"post\"):\n            raise SAMLConfigurationError(\n                f\"Invalid SLO binding '{self.slo_binding}'. Must be 'redirect' or 'post'\"\n            )\n\n    def has_metadata(self) -> bool:\n        \"\"\"Check if IdP metadata is available.\n\n        Returns:\n            True if metadata URL or XML is configured.\n        \"\"\"\n        return bool(self.metadata_url or self.metadata_xml)\n\n    def has_manual_config(self) -> bool:\n        \"\"\"Check if manual endpoint configuration is available.\n\n        Returns:\n            True if SSO URL and certificate are configured.\n        \"\"\"\n        return bool(self.sso_url and self.certificate)\n\n    def is_configured(self) -> bool:\n        \"\"\"Check if IdP is properly configured.\n\n        Returns:\n            True if IdP can be used for authentication.\n        \"\"\"\n        return self.has_metadata() or self.has_manual_config()\n\n    def validate(self) -> list[str]:\n        \"\"\"Validate IdP configuration.\n\n        Returns:\n            List of validation errors, empty if valid.\n        \"\"\"\n        errors = []\n\n        if not self.name:\n            errors.append(\"IdP name is required\")\n\n        if not self.has_metadata() and not self.has_manual_config():\n            errors.append(\n                \"Either metadata (URL or XML) or manual configuration \"\n                \"(SSO URL + certificate) is required\"\n            )\n\n        if not self.has_metadata() and self.has_manual_config():\n            if not self.entity_id:\n                errors.append(\"IdP entity ID is required when using manual configuration\")\n\n        return errors\n\n\n@dataclass\nclass SAMLConfig:\n    \"\"\"Complete SAML configuration combining SP and IdP settings.\n\n    Provides a unified configuration object for the SAML handler,\n    combining SP settings with multiple IdP configurations.\n\n    Attributes:\n        sp: Service Provider configuration\n        idps: Dictionary of IdP configurations keyed by name\n        debug: Enable debug logging\n        strict: Enable strict mode (reject invalid responses)\n        metadata_cache_duration: How long to cache IdP metadata (seconds)\n    \"\"\"\n\n    sp: SAMLSPConfig\n    idps: dict[str, SAMLIdPConfig] = field(default_factory=dict)\n    debug: bool = False\n    strict: bool = True\n    metadata_cache_duration: int = 86400  # 24 hours\n\n    def add_idp(self, idp: SAMLIdPConfig) -> None:\n        \"\"\"Add an IdP configuration.\n\n        Args:\n            idp: IdP configuration to add.\n        \"\"\"\n        self.idps[idp.name] = idp\n        logger.info(\n            \"SAML IdP added\",\n            extra={\n                \"idp_name\": idp.name,\n                \"has_metadata\": idp.has_metadata(),\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n    def get_idp(self, name: str) -> Optional[SAMLIdPConfig]:\n        \"\"\"Get an IdP configuration by name.\n\n        Args:\n            name: IdP name.\n\n        Returns:\n            IdP configuration or None if not found.\n        \"\"\"\n        return self.idps.get(name)\n\n    def list_enabled_idps(self) -> list[str]:\n        \"\"\"List names of all enabled IdPs.\n\n        Returns:\n            List of enabled IdP names.\n        \"\"\"\n        return [name for name, idp in self.idps.items() if idp.enabled]\n\n    def validate(self) -> list[str]:\n        \"\"\"Validate complete SAML configuration.\n\n        Returns:\n            List of validation errors, empty if valid.\n        \"\"\"\n        errors = self.sp.validate()\n\n        for name, idp in self.idps.items():\n            idp_errors = idp.validate()\n            for error in idp_errors:\n                errors.append(f\"IdP '{name}': {error}\")\n\n        return errors\n\n    @classmethod\n    def from_settings(cls, settings: Any) -> \"SAMLConfig\":\n        \"\"\"Create SAMLConfig from application settings.\n\n        Args:\n            settings: Application settings object with sso attribute.\n\n        Returns:\n            SAMLConfig instance.\n        \"\"\"\n        sso = getattr(settings, \"sso\", None)\n        if not sso:\n            raise SAMLConfigurationError(\"SSO settings not found\")\n\n        sp_config = SAMLSPConfig(\n            entity_id=getattr(sso, \"saml_entity_id\", \"urn:acgs2:sp\"),\n            acs_url=\"/sso/saml/acs\",  # Default relative URL\n            sls_url=\"/sso/saml/sls\",\n            metadata_url=\"/sso/saml/metadata\",\n            sign_authn_requests=getattr(sso, \"saml_sign_requests\", True),\n            want_assertions_signed=getattr(sso, \"saml_want_assertions_signed\", True),\n            want_assertions_encrypted=getattr(sso, \"saml_want_assertions_encrypted\", False),\n        )\n\n        # Handle SP certificate\n        sp_cert = getattr(sso, \"saml_sp_certificate\", None)\n        if sp_cert:\n            sp_config.cert_content = sp_cert\n\n        sp_key = getattr(sso, \"saml_sp_private_key\", None)\n        if sp_key:\n            if hasattr(sp_key, \"get_secret_value\"):\n                sp_config.key_content = sp_key.get_secret_value()\n            else:\n                sp_config.key_content = str(sp_key)\n\n        config = cls(sp=sp_config)\n\n        # Add IdP from settings if configured\n        idp_metadata_url = getattr(sso, \"saml_idp_metadata_url\", None)\n        if idp_metadata_url:\n            idp_config = SAMLIdPConfig(\n                name=\"default\",\n                metadata_url=idp_metadata_url,\n                entity_id=getattr(sso, \"saml_entity_id\", None),\n                sso_url=getattr(sso, \"saml_idp_sso_url\", None),\n                slo_url=getattr(sso, \"saml_idp_slo_url\", None),\n                certificate=getattr(sso, \"saml_idp_certificate\", None),\n            )\n            config.add_idp(idp_config)\n\n        return config\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.167995",
  "last_updated": "2026-01-04T05:35:58.425926"
}