{
  "file_path": "acgs2-core/services/hitl_approvals/app/services/approval_chain_engine.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nApproval Chain Engine Service\nManages routing of approvals through configured chains and steps.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import selectinload\n\nfrom ..models.approval_chain import ApprovalChain\nfrom ..models.approval_request import ApprovalAuditLog, ApprovalDecision, ApprovalRequest\nfrom .notification_orchestrator import NotificationOrchestrator\n\nlogger = logging.getLogger(__name__)\n\n\nimport redis.asyncio as redis\n\nfrom ..config.settings import settings\n\n\nclass ApprovalChainEngine:\n    \"\"\"\n    Core engine for processing approval requests through chains.\n    \"\"\"\n\n    def __init__(self, db: AsyncSession, redis_client: Optional[redis.Redis] = None):\n        self.db = db\n        self.notifications = NotificationOrchestrator()\n        self.redis = redis_client\n\n    async def _get_redis(self) -> redis.Redis:\n        if self.redis:\n            return self.redis\n        self.redis = await redis.from_url(settings.redis_url, decode_responses=True)\n        return self.redis\n\n    async def _set_escalation_timer(self, request_id: UUID, timeout_minutes: int):\n        r = await self._get_redis()\n        key = f\"hitl:escalation:pending:{request_id}\"\n        await r.setex(key, timeout_minutes * 60, str(request_id))\n        logger.debug(f\"Set escalation timer for {request_id} ({timeout_minutes}m)\")\n\n    async def create_request(\n        self,\n        chain_id: UUID,\n        decision_id: str,\n        tenant_id: str,\n        requested_by: str,\n        title: str,\n        priority: str,\n        context: Dict[str, Any],\n        description: Optional[str] = None,\n    ) -> ApprovalRequest:\n        \"\"\"Create a new approval request and start the chain\"\"\"\n        # Fetch chain and its steps\n        query = (\n            select(ApprovalChain)\n            .where(ApprovalChain.id == chain_id)\n            .options(selectinload(ApprovalChain.steps))\n        )\n        result = await self.db.execute(query)\n        chain = result.scalar_one_or_none()\n\n        if not chain:\n            raise ValueError(f\"Approval chain {chain_id} not found\")\n\n        if not chain.steps:\n            raise ValueError(f\"Approval chain {chain_id} has no steps defined\")\n\n        # Initial step\n        first_step = chain.steps[0]\n        expires_at = datetime.utcnow() + timedelta(minutes=first_step.timeout_minutes)\n\n        request = ApprovalRequest(\n            chain_id=chain_id,\n            decision_id=decision_id,\n            tenant_id=tenant_id,\n            requested_by=requested_by,\n            title=title,\n            description=description,\n            priority=priority,\n            context=context,\n            status=\"pending\",\n            current_step_index=0,\n            expires_at=expires_at,\n        )\n\n        self.db.add(request)\n        await self.db.flush()\n\n        # Set escalation timer\n        await self._set_escalation_timer(request.id, first_step.timeout_minutes)\n\n        # Log creation\n        audit_log = ApprovalAuditLog(\n            request_id=request.id,\n            action=\"created\",\n            actor_id=requested_by,\n            context={\"chain_id\": str(chain_id), \"priority\": priority},\n        )\n        self.db.add(audit_log)\n\n        # Notify initial approvers\n        await self.notifications.send_approval_request_notification(request)\n\n        return request\n\n    async def submit_decision(\n        self,\n        request_id: UUID,\n        approver_id: str,\n        decision: str,  # approved, rejected\n        rationale: Optional[str] = None,\n        ip_address: Optional[str] = None,\n    ) -> ApprovalRequest:\n        \"\"\"Process an approval or rejection decision\"\"\"\n        # Fetch request with chain and steps\n        query = (\n            select(ApprovalRequest)\n            .where(ApprovalRequest.id == request_id)\n            .options(\n                selectinload(ApprovalRequest.chain).selectinload(ApprovalChain.steps),\n                selectinload(ApprovalRequest.approvals),\n            )\n        )\n        result = await self.db.execute(query)\n        request = result.scalar_one_or_none()\n\n        if not request:\n            raise ValueError(f\"Approval request {request_id} not found\")\n\n        if request.status != \"pending\":\n            raise ValueError(\n                f\"Approval request {request_id} is in status '{request.status}', cannot submit decision\"\n            )\n\n        chain = request.chain\n        current_step = chain.steps[request.current_step_index]\n\n        # Check if decision already submitted by this approver for this step\n        # (Simplified: assumes only one approver per role for now, or multiple if required_approvals > 1)\n        # TODO: Add role verification via OPA\n\n        # Record decision\n        new_decision = ApprovalDecision(\n            request_id=request_id,\n            step_id=current_step.id,\n            approver_id=approver_id,\n            decision=decision,\n            rationale=rationale,\n        )\n        self.db.add(new_decision)\n\n        # Log action\n        audit_log = ApprovalAuditLog(\n            request_id=request_id,\n            action=decision,\n            actor_id=approver_id,\n            context={\"step_id\": str(current_step.id), \"rationale\": rationale},\n            ip_address=ip_address,\n        )\n        self.db.add(audit_log)\n\n        if decision == \"rejected\":\n            request.status = \"rejected\"\n            request.updated_at = datetime.utcnow()\n            # Notify requester of rejection?\n        else:\n            # Check if step requirements met\n            step_approvals = [\n                d\n                for d in request.approvals\n                if d.step_id == current_step.id and d.decision == \"approved\"\n            ]\n            step_approvals.append(new_decision)  # Include current one\n\n            if len(step_approvals) >= current_step.required_approvals:\n                # Move to next step\n                if request.current_step_index < len(chain.steps) - 1:\n                    request.current_step_index += 1\n                    next_step = chain.steps[request.current_step_index]\n                    request.expires_at = datetime.utcnow() + timedelta(\n                        minutes=next_step.timeout_minutes\n                    )\n                    request.updated_at = datetime.utcnow()\n\n                    # Set new escalation timer\n                    await self._set_escalation_timer(request.id, next_step.timeout_minutes)\n\n                    # Notify next step approvers\n                    await self.notifications.send_approval_request_notification(request)\n                else:\n                    # Final step complete\n                    request.status = \"approved\"\n                    request.updated_at = datetime.utcnow()\n                    request.expires_at = None\n\n                    # Remove timer\n                    r = await self._get_redis()\n                    await r.delete(f\"hitl:escalation:pending:{request.id}\")\n\n                    # Notify requester of success?\n\n        return request\n\n    async def escalate_request(self, request_id: UUID, reason: str = \"timeout\") -> ApprovalRequest:\n        \"\"\"Escalate a request to the next step or fallback\"\"\"\n        query = (\n            select(ApprovalRequest)\n            .where(ApprovalRequest.id == request_id)\n            .options(selectinload(ApprovalRequest.chain).selectinload(ApprovalChain.steps))\n        )\n        result = await self.db.execute(query)\n        request = result.scalar_one_or_none()\n\n        if not request or request.status != \"pending\":\n            return request\n\n        chain = request.chain\n\n        # Log escalation\n        audit_log = ApprovalAuditLog(\n            request_id=request_id,\n            action=\"escalated\",\n            context={\"reason\": reason, \"previous_step\": request.current_step_index},\n        )\n        self.db.add(audit_log)\n\n        if request.current_step_index < len(chain.steps) - 1:\n            request.current_step_index += 1\n            request.status = \"escalated\"  # Temporarily marked as escalated\n            next_step = chain.steps[request.current_step_index]\n            request.expires_at = datetime.utcnow() + timedelta(minutes=next_step.timeout_minutes)\n            request.updated_at = datetime.utcnow()\n\n            # Back to pending for the new step\n            request.status = \"pending\"\n\n            # Set new escalation timer\n            await self._set_escalation_timer(request.id, next_step.timeout_minutes)\n\n            # Send escalation notifications\n            await self.notifications.send_escalation_notification(\n                request, request.current_step_index\n            )\n        else:\n            # Max escalation reached\n            request.status = \"timed_out\"\n            request.updated_at = datetime.utcnow()\n            request.expires_at = None\n\n            # Remove timer\n            r = await self._get_redis()\n            await r.delete(f\"hitl:escalation:pending:{request.id}\")\n\n            # Critical alert\n            await self.notifications.send_escalation_notification(request, 999)  # 999 = max level\n\n        return request\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.573896",
  "last_updated": "2026-01-04T05:35:51.234673"
}