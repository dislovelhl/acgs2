{
  "file_path": "src/core/services/policy_registry/advanced_rbac/models/abac_models.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Advanced RBAC Models\nAttribute-Based Access Control (ABAC) Implementation\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\n# Import type aliases from shared types\nimport sys\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nfrom pydantic import BaseModel, Field, validator\n\n# Add src/core/shared to path for type imports\nshared_path = Path(__file__).parent.parent.parent.parent.parent / \"shared\"\nif str(shared_path) not in sys.path:\n    sys.path.insert(0, str(shared_path))\n\nfrom types import (\n    AttributeMap,\n    ConfigDict,\n    JSONDict,\n    JSONValue,\n    MetadataDict,\n)\n\n\nclass AttributeCategory(Enum):\n    \"\"\"Categories of attributes for ABAC\"\"\"\n\n    SUBJECT = \"subject\"\n    RESOURCE = \"resource\"\n    ACTION = \"action\"\n    ENVIRONMENT = \"environment\"\n    CONTEXT = \"context\"\n\n\nclass AttributeType(Enum):\n    \"\"\"Types of attributes\"\"\"\n\n    STRING = \"string\"\n    INTEGER = \"integer\"\n    FLOAT = \"float\"\n    BOOLEAN = \"boolean\"\n    DATETIME = \"datetime\"\n    LIST = \"list\"\n    JSON = \"json\"\n\n\nclass ComparisonOperator(Enum):\n    \"\"\"Comparison operators for ABAC policies\"\"\"\n\n    EQUALS = \"eq\"\n    NOT_EQUALS = \"ne\"\n    GREATER_THAN = \"gt\"\n    GREATER_THAN_EQUAL = \"gte\"\n    LESS_THAN = \"lt\"\n    LESS_THAN_EQUAL = \"lte\"\n    CONTAINS = \"contains\"\n    NOT_CONTAINS = \"not_contains\"\n    IN = \"in\"\n    NOT_IN = \"not_in\"\n    REGEX_MATCH = \"regex\"\n    STARTS_WITH = \"starts_with\"\n    ENDS_WITH = \"ends_with\"\n\n\nclass LogicalOperator(Enum):\n    \"\"\"Logical operators for combining conditions\"\"\"\n\n    AND = \"and\"\n    OR = \"or\"\n    NOT = \"not\"\n\n\nclass DelegationScope(Enum):\n    \"\"\"Delegation scope levels\"\"\"\n\n    LIMITED = \"limited\"\n    BROAD = \"broad\"\n    FULL = \"full\"\n\n\nclass DelegationType(Enum):\n    \"\"\"Types of delegation\"\"\"\n\n    TEMPORARY = \"temporary\"\n    CONDITIONAL = \"conditional\"\n    REVOCABLE = \"revocable\"\n    CASCADE = \"cascade\"\n\n\n@dataclass\nclass Attribute:\n    \"\"\"An attribute for ABAC\"\"\"\n\n    name: str\n    value: JSONValue\n    attr_type: AttributeType\n    category: AttributeCategory\n    metadata: MetadataDict = field(default_factory=dict)\n    confidence: float = 1.0  # Confidence score for attribute value\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass AttributeCondition:\n    \"\"\"A condition for attribute matching\"\"\"\n\n    attribute_name: str\n    operator: ComparisonOperator\n    expected_value: JSONValue\n    case_sensitive: bool = True\n    weight: float = 1.0  # Weight for scoring\n\n\n@dataclass\nclass ABACRule:\n    \"\"\"An ABAC rule\"\"\"\n\n    rule_id: str\n    name: str\n    description: str\n    effect: str  # \"allow\" or \"deny\"\n    conditions: List[AttributeCondition]\n    logical_operator: LogicalOperator = LogicalOperator.AND\n    priority: int = 0\n    enabled: bool = True\n    metadata: MetadataDict = field(default_factory=dict)\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    updated_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass ABACPolicy:\n    \"\"\"An ABAC policy containing multiple rules\"\"\"\n\n    policy_id: str\n    name: str\n    description: str\n    rules: List[ABACRule]\n    combining_algorithm: str = (\n        \"first-applicable\"  # first-applicable, deny-overrides, permit-overrides\n    )\n    target_conditions: List[AttributeCondition] = field(default_factory=list)\n    enabled: bool = True\n    metadata: MetadataDict = field(default_factory=dict)\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    updated_at: datetime = field(default_factory=datetime.utcnow)\n\n    @property\n    def allow_rules(self) -> List[ABACRule]:\n        \"\"\"Get all allow rules\"\"\"\n        return [rule for rule in self.rules if rule.effect == \"allow\"]\n\n    @property\n    def deny_rules(self) -> List[ABACRule]:\n        \"\"\"Get all deny rules\"\"\"\n        return [rule for rule in self.rules if rule.effect == \"deny\"]\n\n\n@dataclass\nclass AccessRequest:\n    \"\"\"An access request for ABAC evaluation\"\"\"\n\n    request_id: str\n    subject_attributes: Dict[str, Attribute]\n    resource_attributes: Dict[str, Attribute]\n    action_attributes: Dict[str, Attribute]\n    environment_attributes: Dict[str, Attribute]\n    context_attributes: Dict[str, Attribute] = field(default_factory=dict)\n    requested_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass PolicyDecision:\n    \"\"\"ABAC policy decision\"\"\"\n\n    decision: str  # \"allow\", \"deny\", \"indeterminate\", \"not_applicable\"\n    confidence_score: float\n    matched_rules: List[str]\n    denied_rules: List[str]\n    obligations: List[JSONDict] = field(default_factory=list)\n    advice: List[str] = field(default_factory=list)\n    evaluated_at: datetime = field(default_factory=datetime.utcnow)\n    evaluation_time_ms: float = 0.0\n\n\n@dataclass\nclass DelegationGrant:\n    \"\"\"A delegation grant\"\"\"\n\n    grant_id: str\n    delegator_id: str\n    delegatee_id: str\n    delegation_type: DelegationType\n    scope: DelegationScope\n    permissions: List[str]\n    conditions: List[AttributeCondition] = field(default_factory=list)\n    constraints: JSONDict = field(default_factory=dict)\n    expires_at: Optional[datetime] = None\n    revocable: bool = True\n    cascade_allowed: bool = False\n    metadata: MetadataDict = field(default_factory=dict)\n    granted_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass DelegationChain:\n    \"\"\"A chain of delegations\"\"\"\n\n    chain_id: str\n    root_delegator: str\n    current_delegatee: str\n    grants: List[DelegationGrant]\n    depth: int\n    max_depth: int = 3\n    active: bool = True\n    created_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass AttributeSource:\n    \"\"\"Source for attribute values\"\"\"\n\n    source_id: str\n    name: str\n    source_type: str  # ldap, database, api, computed, etc.\n    attributes: List[str]\n    refresh_interval_seconds: int = 300\n    cache_ttl_seconds: int = 300\n    enabled: bool = True\n    config: ConfigDict = field(default_factory=dict)\n    last_updated: Optional[datetime] = None\n\n\n@dataclass\nclass AttributeResolutionContext:\n    \"\"\"Context for attribute resolution\"\"\"\n\n    request_id: str\n    subject_id: str\n    resource_id: str\n    action: str\n    resolved_attributes: Dict[str, Attribute] = field(default_factory=dict)\n    failed_sources: List[str] = field(default_factory=list)\n    resolution_time_ms: float = 0.0\n    cache_hits: int = 0\n    cache_misses: int = 0\n\n\n@dataclass\nclass ABACAuditEvent:\n    \"\"\"Audit event for ABAC decisions\"\"\"\n\n    event_id: str\n    request_id: str\n    subject_id: str\n    resource_id: str\n    action: str\n    decision: str\n    confidence_score: float\n    matched_policies: List[str]\n    matched_rules: List[str]\n    attributes_used: AttributeMap\n    delegation_chain: Optional[str] = None\n    evaluation_time_ms: float\n    ip_address: Optional[str] = None\n    user_agent: Optional[str] = None\n    session_id: Optional[str] = None\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n\n\n# Pydantic models for API\nclass AttributeModel(BaseModel):\n    name: str\n    value: JSONValue\n    attr_type: AttributeType\n    category: AttributeCategory\n    metadata: MetadataDict = Field(default_factory=dict)\n    confidence: float = Field(default=1.0, ge=0.0, le=1.0)\n\n    class Config:\n        use_enum_values = True\n\n\nclass AttributeConditionModel(BaseModel):\n    attribute_name: str\n    operator: ComparisonOperator\n    expected_value: JSONValue\n    case_sensitive: bool = True\n    weight: float = Field(default=1.0, gt=0.0)\n\n    class Config:\n        use_enum_values = True\n\n\nclass ABACRuleModel(BaseModel):\n    rule_id: str\n    name: str\n    description: str\n    effect: str = Field(regex=\"^(allow|deny)$\")\n    conditions: List[AttributeConditionModel]\n    logical_operator: LogicalOperator = LogicalOperator.AND\n    priority: int = 0\n    enabled: bool = True\n    metadata: MetadataDict = Field(default_factory=dict)\n\n    @validator(\"conditions\")\n    def validate_conditions(cls, v):\n        if not v:\n            raise ValueError(\"At least one condition is required\")\n        return v\n\n    class Config:\n        use_enum_values = True\n\n\nclass ABACPolicyModel(BaseModel):\n    policy_id: str\n    name: str\n    description: str\n    rules: List[ABACRuleModel]\n    combining_algorithm: str = \"first-applicable\"\n    target_conditions: List[AttributeConditionModel] = Field(default_factory=list)\n    enabled: bool = True\n    metadata: MetadataDict = Field(default_factory=dict)\n\n    class Config:\n        use_enum_values = True\n\n\nclass AccessRequestModel(BaseModel):\n    request_id: str\n    subject_attributes: Dict[str, AttributeModel]\n    resource_attributes: Dict[str, AttributeModel]\n    action_attributes: Dict[str, AttributeModel]\n    environment_attributes: Dict[str, AttributeModel]\n    context_attributes: Dict[str, AttributeModel] = Field(default_factory=dict)\n\n    class Config:\n        use_enum_values = True\n\n\nclass DelegationGrantModel(BaseModel):\n    grant_id: str\n    delegator_id: str\n    delegatee_id: str\n    delegation_type: DelegationType\n    scope: DelegationScope\n    permissions: List[str]\n    conditions: List[AttributeConditionModel] = Field(default_factory=list)\n    constraints: JSONDict = Field(default_factory=dict)\n    expires_at: Optional[datetime] = None\n    revocable: bool = True\n    cascade_allowed: bool = False\n    metadata: MetadataDict = Field(default_factory=dict)\n\n    class Config:\n        use_enum_values = True\n\n\nclass AttributeSourceModel(BaseModel):\n    source_id: str\n    name: str\n    source_type: str\n    attributes: List[str]\n    refresh_interval_seconds: int = Field(default=300, gt=0)\n    cache_ttl_seconds: int = Field(default=300, gt=0)\n    enabled: bool = True\n    config: ConfigDict = Field(default_factory=dict)\n\n    class Config:\n        use_enum_values = True\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.136616",
  "last_updated": "2026-01-04T05:35:59.181778"
}