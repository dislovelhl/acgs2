{
  "file_path": "acgs2-core/enhanced_agent_bus/observability/telemetry.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 OpenTelemetry Core Configuration\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides unified telemetry configuration for distributed tracing,\nmetrics collection, and constitutional compliance tracking.\n\"\"\"\n\nimport logging\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, Optional, Tuple\n\ntry:\n    from shared.config import settings\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    settings = None  # type: ignore\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\n# Check OpenTelemetry availability\nOTEL_AVAILABLE = False\ntracer_type = None\nmeter_type = None\n\ntry:\n    from opentelemetry import metrics, trace\n    from opentelemetry.propagate import set_global_textmap\n    from opentelemetry.sdk.metrics import MeterProvider\n    from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader\n    from opentelemetry.sdk.resources import Resource\n    from opentelemetry.sdk.trace import TracerProvider\n    from opentelemetry.sdk.trace.export import BatchSpanProcessor, SimpleSpanProcessor\n    from opentelemetry.trace import Span, Status, StatusCode\n\n    OTEL_AVAILABLE = True\n    tracer_type = trace.Tracer\n    meter_type = metrics.Meter\n    logger.info(f\"[{CONSTITUTIONAL_HASH}] OpenTelemetry SDK available\")\nexcept ImportError:\n    logger.warning(\n        f\"[{CONSTITUTIONAL_HASH}] OpenTelemetry not available, using no-op implementations\"\n    )\n\n\ndef _get_env_default() -> str:\n    \"\"\"Get environment from centralized config or fallback.\"\"\"\n    if settings is not None:\n        return settings.env\n    import os\n\n    return os.getenv(\"ENVIRONMENT\", \"development\")\n\n\ndef _get_otlp_endpoint() -> str:\n    \"\"\"Get OTLP endpoint from centralized config or fallback.\"\"\"\n    if settings is not None:\n        return settings.telemetry.otlp_endpoint\n    import os\n\n    return os.getenv(\"OTEL_EXPORTER_OTLP_ENDPOINT\", \"http://localhost:4317\")\n\n\ndef _get_export_traces() -> bool:\n    \"\"\"Get export_traces from centralized config or default.\"\"\"\n    if settings is not None:\n        return settings.telemetry.export_traces\n    return True\n\n\ndef _get_export_metrics() -> bool:\n    \"\"\"Get export_metrics from centralized config or default.\"\"\"\n    if settings is not None:\n        return settings.telemetry.export_metrics\n    return True\n\n\ndef _get_trace_sample_rate() -> float:\n    \"\"\"Get trace sample rate from centralized config or default.\"\"\"\n    if settings is not None:\n        return settings.telemetry.trace_sample_rate\n    return 1.0\n\n\n@dataclass\nclass TelemetryConfig:\n    \"\"\"Configuration for OpenTelemetry setup.\"\"\"\n\n    service_name: str = \"acgs2-agent-bus\"\n    service_version: str = \"2.0.0\"\n    environment: str = field(default_factory=_get_env_default)\n\n    # Collector endpoints\n    otlp_endpoint: str = field(default_factory=_get_otlp_endpoint)\n\n    # Export settings\n    export_traces: bool = field(default_factory=_get_export_traces)\n    export_metrics: bool = field(default_factory=_get_export_metrics)\n    batch_span_processor: bool = True  # False = SimpleSpanProcessor for debugging\n\n    # Constitutional compliance\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n    # Sampling\n    trace_sample_rate: float = field(default_factory=_get_trace_sample_rate)\n\n\nclass NoOpSpan:\n    \"\"\"No-op span for when OpenTelemetry is not available.\"\"\"\n\n    def set_attribute(self, key: str, value: Any) -> None:\n        pass\n\n    def add_event(self, name: str, attributes: Optional[Dict] = None) -> None:\n        pass\n\n    def record_exception(self, exception: Exception) -> None:\n        pass\n\n    def set_status(self, status: Any) -> None:\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        return False\n\n\nclass NoOpTracer:\n    \"\"\"No-op tracer for when OpenTelemetry is not available.\"\"\"\n\n    @contextmanager\n    def start_as_current_span(self, name: str, **kwargs):\n        yield NoOpSpan()\n\n    def start_span(self, name: str, **kwargs) -> NoOpSpan:\n        return NoOpSpan()\n\n\nclass NoOpCounter:\n    \"\"\"No-op counter for when OpenTelemetry is not available.\"\"\"\n\n    def add(self, amount: int, attributes: Optional[Dict] = None) -> None:\n        pass\n\n\nclass NoOpHistogram:\n    \"\"\"No-op histogram for when OpenTelemetry is not available.\"\"\"\n\n    def record(self, value: float, attributes: Optional[Dict] = None) -> None:\n        pass\n\n\nclass NoOpUpDownCounter:\n    \"\"\"No-op up-down counter for when OpenTelemetry is not available.\"\"\"\n\n    def add(self, amount: int, attributes: Optional[Dict] = None) -> None:\n        pass\n\n\nclass NoOpMeter:\n    \"\"\"No-op meter for when OpenTelemetry is not available.\"\"\"\n\n    def create_counter(self, name: str, **kwargs) -> NoOpCounter:\n        return NoOpCounter()\n\n    def create_histogram(self, name: str, **kwargs) -> NoOpHistogram:\n        return NoOpHistogram()\n\n    def create_up_down_counter(self, name: str, **kwargs) -> NoOpUpDownCounter:\n        return NoOpUpDownCounter()\n\n    def create_observable_gauge(self, name: str, callbacks=None, **kwargs):\n        return None\n\n\n# Global registries\n_tracers: Dict[str, Any] = {}\n_meters: Dict[str, Any] = {}\n_configured = False\n\n\ndef configure_telemetry(config: Optional[TelemetryConfig] = None) -> Tuple[Any, Any]:\n    \"\"\"\n    Configure OpenTelemetry for a service.\n\n    Args:\n        config: Telemetry configuration\n\n    Returns:\n        Tuple of (tracer, meter) for the service\n    \"\"\"\n    global _configured\n\n    if config is None:\n        config = TelemetryConfig()\n\n    if not OTEL_AVAILABLE:\n        logger.warning(\n            f\"[{CONSTITUTIONAL_HASH}] OpenTelemetry not available, returning no-op implementations\"\n        )\n        return NoOpTracer(), NoOpMeter()\n\n    if not _configured:\n        # Create resource with constitutional hash\n        resource = Resource.create(\n            {\n                \"service.name\": config.service_name,\n                \"service.version\": config.service_version,\n                \"deployment.environment\": config.environment,\n                \"constitutional.hash\": config.constitutional_hash,\n            }\n        )\n\n        # Configure trace provider\n        trace_provider = TracerProvider(resource=resource)\n\n        if config.export_traces:\n            try:\n                from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter\n\n                exporter = OTLPSpanExporter(endpoint=config.otlp_endpoint)\n\n                if config.batch_span_processor:\n                    processor = BatchSpanProcessor(exporter)\n                else:\n                    processor = SimpleSpanProcessor(exporter)\n\n                trace_provider.add_span_processor(processor)\n                logger.info(\n                    f\"[{CONSTITUTIONAL_HASH}] Configured OTLP trace export to \"\n                    f\"{config.otlp_endpoint}\"\n                )\n            except ImportError:\n                logger.warning(\n                    f\"[{CONSTITUTIONAL_HASH}] OTLP exporter not available, \"\n                    \"traces will not be exported\"\n                )\n\n        trace.set_tracer_provider(trace_provider)\n\n        # Configure meter provider\n        meter_provider = MeterProvider(resource=resource)\n\n        if config.export_metrics:\n            try:\n                from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import (\n                    OTLPMetricExporter,\n                )\n\n                metric_exporter = OTLPMetricExporter(endpoint=config.otlp_endpoint)\n                reader = PeriodicExportingMetricReader(metric_exporter)\n                meter_provider = MeterProvider(resource=resource, metric_readers=[reader])\n                logger.info(\n                    f\"[{CONSTITUTIONAL_HASH}] Configured OTLP metric export to \"\n                    f\"{config.otlp_endpoint}\"\n                )\n            except ImportError:\n                logger.warning(\n                    f\"[{CONSTITUTIONAL_HASH}] OTLP metric exporter not available, \"\n                    \"metrics will not be exported\"\n                )\n\n        metrics.set_meter_provider(meter_provider)\n\n        # Configure propagation (B3 for distributed tracing)\n        try:\n            from opentelemetry.propagators.b3 import B3MultiFormat\n\n            set_global_textmap(B3MultiFormat())\n            logger.info(f\"[{CONSTITUTIONAL_HASH}] Configured B3 trace propagation\")\n        except ImportError:\n            logger.warning(f\"[{CONSTITUTIONAL_HASH}] B3 propagator not available\")\n\n        _configured = True\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] OpenTelemetry configured for {config.service_name}\")\n\n    # Get or create tracer and meter\n    tracer = trace.get_tracer(config.service_name, config.service_version)\n    meter = metrics.get_meter(config.service_name, config.service_version)\n\n    _tracers[config.service_name] = tracer\n    _meters[config.service_name] = meter\n\n    return tracer, meter\n\n\ndef get_tracer(service_name: Optional[str] = None) -> Any:\n    \"\"\"\n    Get a tracer for the specified service.\n\n    Args:\n        service_name: Service name (defaults to acgs2-agent-bus)\n\n    Returns:\n        Tracer instance (or NoOpTracer if OTEL unavailable)\n    \"\"\"\n    if service_name and service_name in _tracers:\n        return _tracers[service_name]\n\n    if not OTEL_AVAILABLE:\n        return NoOpTracer()\n\n    # Auto-configure if not done\n    if not _configured:\n        configure_telemetry()\n\n    name = service_name or \"acgs2-agent-bus\"\n    if name not in _tracers:\n        from opentelemetry import trace\n\n        _tracers[name] = trace.get_tracer(name)\n\n    return _tracers[name]\n\n\ndef get_meter(service_name: Optional[str] = None) -> Any:\n    \"\"\"\n    Get a meter for the specified service.\n\n    Args:\n        service_name: Service name (defaults to acgs2-agent-bus)\n\n    Returns:\n        Meter instance (or NoOpMeter if OTEL unavailable)\n    \"\"\"\n    if service_name and service_name in _meters:\n        return _meters[service_name]\n\n    if not OTEL_AVAILABLE:\n        return NoOpMeter()\n\n    # Auto-configure if not done\n    if not _configured:\n        configure_telemetry()\n\n    name = service_name or \"acgs2-agent-bus\"\n    if name not in _meters:\n        from opentelemetry import metrics\n\n        _meters[name] = metrics.get_meter(name)\n\n    return _meters[name]\n\n\nclass TracingContext:\n    \"\"\"\n    Context manager for creating spans with constitutional hash.\n\n    Example:\n        with TracingContext(\"process_message\") as span:\n            span.set_attribute(\"message.id\", msg_id)\n            # ... processing\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        service_name: Optional[str] = None,\n        attributes: Optional[Dict[str, Any]] = None,\n    ):\n        self.name = name\n        self.tracer = get_tracer(service_name)\n        self.attributes = attributes or {}\n        self._span = None\n        self._context = None\n\n    def __enter__(self) -> Any:\n        self._context = self.tracer.start_as_current_span(self.name)\n        self._span = self._context.__enter__()\n\n        # Always add constitutional hash\n        self._span.set_attribute(\"constitutional.hash\", CONSTITUTIONAL_HASH)\n        self._span.set_attribute(\"timestamp\", datetime.now(timezone.utc).isoformat())\n\n        # Add custom attributes\n        for key, value in self.attributes.items():\n            self._span.set_attribute(key, value)\n\n        return self._span\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None and self._span:\n            self._span.record_exception(exc_val)\n            if OTEL_AVAILABLE:\n                from opentelemetry.trace import Status, StatusCode\n\n                self._span.set_status(Status(StatusCode.ERROR, str(exc_val)))\n\n        if self._context:\n            return self._context.__exit__(exc_type, exc_val, exc_tb)\n        return False\n\n\nclass MetricsRegistry:\n    \"\"\"\n    Registry for commonly used metrics with constitutional hash tagging.\n\n    Example:\n        registry = MetricsRegistry(\"agent_bus\")\n        registry.record_latency(\"message_processing\", 5.2)\n        registry.increment_counter(\"messages_processed\")\n    \"\"\"\n\n    def __init__(self, service_name: str = \"acgs2-agent-bus\"):\n        self.service_name = service_name\n        self.meter = get_meter(service_name)\n        self._counters: Dict[str, Any] = {}\n        self._histograms: Dict[str, Any] = {}\n        self._gauges: Dict[str, Any] = {}\n\n    def get_counter(self, name: str, description: str = \"\") -> Any:\n        \"\"\"Get or create a counter metric.\"\"\"\n        if name not in self._counters:\n            full_name = f\"acgs2.{self.service_name}.{name}\"\n            self._counters[name] = self.meter.create_counter(\n                name=full_name,\n                description=description,\n            )\n        return self._counters[name]\n\n    def get_histogram(self, name: str, unit: str = \"ms\", description: str = \"\") -> Any:\n        \"\"\"Get or create a histogram metric.\"\"\"\n        if name not in self._histograms:\n            full_name = f\"acgs2.{self.service_name}.{name}\"\n            self._histograms[name] = self.meter.create_histogram(\n                name=full_name,\n                unit=unit,\n                description=description,\n            )\n        return self._histograms[name]\n\n    def get_gauge(self, name: str, description: str = \"\") -> Any:\n        \"\"\"Get or create an up-down counter (gauge-like behavior).\"\"\"\n        if name not in self._gauges:\n            full_name = f\"acgs2.{self.service_name}.{name}\"\n            self._gauges[name] = self.meter.create_up_down_counter(\n                name=full_name,\n                description=description,\n            )\n        return self._gauges[name]\n\n    def increment_counter(\n        self,\n        name: str,\n        amount: int = 1,\n        attributes: Optional[Dict[str, str]] = None,\n    ) -> None:\n        \"\"\"Increment a counter with constitutional hash attribute.\"\"\"\n        counter = self.get_counter(name)\n        attrs = {\"constitutional_hash\": CONSTITUTIONAL_HASH}\n        if attributes:\n            attrs.update(attributes)\n        counter.add(amount, attrs)\n\n    def record_latency(\n        self,\n        name: str,\n        value_ms: float,\n        attributes: Optional[Dict[str, str]] = None,\n    ) -> None:\n        \"\"\"Record a latency value in milliseconds.\"\"\"\n        histogram = self.get_histogram(name, unit=\"ms\")\n        attrs = {\"constitutional_hash\": CONSTITUTIONAL_HASH}\n        if attributes:\n            attrs.update(attributes)\n        histogram.record(value_ms, attrs)\n\n    def set_gauge(\n        self,\n        name: str,\n        delta: int,\n        attributes: Optional[Dict[str, str]] = None,\n    ) -> None:\n        \"\"\"Adjust a gauge value.\"\"\"\n        gauge = self.get_gauge(name)\n        attrs = {\"constitutional_hash\": CONSTITUTIONAL_HASH}\n        if attributes:\n            attrs.update(attributes)\n        gauge.add(delta, attrs)\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.153383",
  "last_updated": "2026-01-04T05:35:58.522867"
}