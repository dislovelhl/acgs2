{
  "file_path": "acgs2-core/services/hitl-approvals/app/notifications/retry.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nNotification Retry Logic with Exponential Backoff\n\nProvides retry functionality for notification providers with configurable\nexponential backoff, jitter, and failed notification persistence.\n\"\"\"\n\nimport asyncio\nimport logging\nimport random\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Awaitable, Callable, Dict, List, Optional, TypeVar\n\nfrom acgs2_core.shared.types import ArgsType, JSONDict, KwargsType\n\nfrom app.models import NotificationPayload\nfrom app.notifications.base import NotificationResult, NotificationStatus\n\n# Avoid circular import by using TYPE_CHECKING\nif TYPE_CHECKING:\n    from app.notifications.base import NotificationProvider\n\nlogger = logging.getLogger(__name__)\n\n# Default retry configuration (as per spec: 3 attempts)\nDEFAULT_MAX_RETRIES = 3\nDEFAULT_BASE_DELAY_SECONDS = 1.0\nDEFAULT_MAX_DELAY_SECONDS = 60.0\nDEFAULT_EXPONENTIAL_BASE = 2.0\nDEFAULT_JITTER_FACTOR = 0.1  # 10% jitter\n\n\n@dataclass\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior.\"\"\"\n\n    max_retries: int = DEFAULT_MAX_RETRIES\n    base_delay_seconds: float = DEFAULT_BASE_DELAY_SECONDS\n    max_delay_seconds: float = DEFAULT_MAX_DELAY_SECONDS\n    exponential_base: float = DEFAULT_EXPONENTIAL_BASE\n    jitter_factor: float = DEFAULT_JITTER_FACTOR\n    respect_retry_after: bool = True  # Use provider's retry_after hint\n\n\n@dataclass\nclass FailedNotification:\n    \"\"\"Record of a failed notification for manual review.\"\"\"\n\n    payload: NotificationPayload\n    provider: str\n    attempts: int\n    last_error: str\n    first_attempt_at: datetime\n    last_attempt_at: datetime\n    results: List[NotificationResult] = field(default_factory=list)\n\n    def to_dict(self) -> JSONDict:\n        \"\"\"Convert to dictionary for persistence.\"\"\"\n        return {\n            \"payload\": self.payload.model_dump(),\n            \"provider\": self.provider,\n            \"attempts\": self.attempts,\n            \"last_error\": self.last_error,\n            \"first_attempt_at\": self.first_attempt_at.isoformat(),\n            \"last_attempt_at\": self.last_attempt_at.isoformat(),\n            \"results\": [\n                {\n                    \"status\": r.status.value,\n                    \"error\": r.error,\n                    \"timestamp\": r.timestamp.isoformat(),\n                }\n                for r in self.results\n            ],\n        }\n\n\nclass FailedNotificationStore:\n    \"\"\"\n    In-memory store for failed notifications awaiting manual review.\n\n    In production, this should be backed by a persistent database.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the failed notification store.\"\"\"\n        self._failed: Dict[str, FailedNotification] = {}\n        self._lock = asyncio.Lock()\n\n    async def add(self, notification: FailedNotification) -> None:\n        \"\"\"\n        Add a failed notification to the store.\n\n        Args:\n            notification: The failed notification record\n        \"\"\"\n        async with self._lock:\n            key = f\"{notification.provider}:{notification.payload.request_id}\"\n            self._failed[key] = notification\n            logger.warning(\n                f\"Failed notification persisted for manual review: \"\n                f\"provider={notification.provider}, \"\n                f\"request_id={notification.payload.request_id}, \"\n                f\"attempts={notification.attempts}\"\n            )\n\n    async def get(self, provider: str, request_id: str) -> Optional[FailedNotification]:\n        \"\"\"\n        Retrieve a failed notification.\n\n        Args:\n            provider: The notification provider name\n            request_id: The approval request ID\n\n        Returns:\n            The failed notification record if found\n        \"\"\"\n        async with self._lock:\n            key = f\"{provider}:{request_id}\"\n            return self._failed.get(key)\n\n    async def remove(self, provider: str, request_id: str) -> bool:\n        \"\"\"\n        Remove a failed notification (e.g., after manual resolution).\n\n        Args:\n            provider: The notification provider name\n            request_id: The approval request ID\n\n        Returns:\n            True if notification was removed, False if not found\n        \"\"\"\n        async with self._lock:\n            key = f\"{provider}:{request_id}\"\n            if key in self._failed:\n                del self._failed[key]\n                logger.info(\n                    f\"Failed notification removed: provider={provider}, request_id={request_id}\"\n                )\n                return True\n            return False\n\n    async def list_all(self) -> List[FailedNotification]:\n        \"\"\"\n        List all failed notifications.\n\n        Returns:\n            List of all failed notifications\n        \"\"\"\n        async with self._lock:\n            return list(self._failed.values())\n\n    async def count(self) -> int:\n        \"\"\"\n        Get count of failed notifications.\n\n        Returns:\n            Number of failed notifications\n        \"\"\"\n        async with self._lock:\n            return len(self._failed)\n\n\n# Global store for failed notifications\n_failed_notification_store = FailedNotificationStore()\n\n\ndef get_failed_notification_store() -> FailedNotificationStore:\n    \"\"\"Get the global failed notification store.\"\"\"\n    return _failed_notification_store\n\n\ndef calculate_backoff_delay(\n    attempt: int,\n    config: RetryConfig,\n    retry_after: Optional[int] = None,\n) -> float:\n    \"\"\"\n    Calculate the delay before the next retry attempt.\n\n    Uses exponential backoff with optional jitter and respects\n    the provider's retry_after hint if available.\n\n    Args:\n        attempt: Current attempt number (1-indexed)\n        config: Retry configuration\n        retry_after: Optional provider-specified delay in seconds\n\n    Returns:\n        Delay in seconds before next retry\n    \"\"\"\n    # If provider specifies retry_after and we should respect it, use that\n    if retry_after is not None and config.respect_retry_after:\n        # Still apply jitter to prevent thundering herd\n        jitter = retry_after * config.jitter_factor * random.random()\n        return min(retry_after + jitter, config.max_delay_seconds)\n\n    # Calculate exponential backoff: base_delay * (exponential_base ^ attempt)\n    delay = config.base_delay_seconds * (config.exponential_base ** (attempt - 1))\n\n    # Apply jitter (random factor to prevent thundering herd)\n    jitter = delay * config.jitter_factor * random.random()\n    delay = delay + jitter\n\n    # Cap at max delay\n    return min(delay, config.max_delay_seconds)\n\n\n# Type variable for the send function return type\nT = TypeVar(\"T\", bound=NotificationResult)\n\n\nasync def retry_with_backoff(\n    send_func: Callable[[NotificationPayload], Awaitable[NotificationResult]],\n    payload: NotificationPayload,\n    provider_name: str,\n    config: Optional[RetryConfig] = None,\n    persist_failures: bool = True,\n) -> NotificationResult:\n    \"\"\"\n    Execute a notification send with exponential backoff retry.\n\n    Implements retry logic as per research recommendations:\n    - 3 attempts with exponential backoff\n    - Respects provider rate limit hints\n    - Persists failed notifications for manual review\n\n    Args:\n        send_func: Async function to send the notification\n        payload: The notification payload to send\n        provider_name: Name of the provider for logging\n        config: Optional retry configuration (uses defaults if not provided)\n        persist_failures: Whether to persist failed notifications\n\n    Returns:\n        NotificationResult from the final attempt\n\n    Example:\n        result = await retry_with_backoff(\n            provider.send_notification,\n            payload,\n            provider.name,\n        )\n    \"\"\"\n    if config is None:\n        config = RetryConfig()\n\n    first_attempt_at = datetime.utcnow()\n    attempt_results: List[NotificationResult] = []\n    last_result: Optional[NotificationResult] = None\n\n    for attempt in range(1, config.max_retries + 1):\n        try:\n            logger.debug(\n                f\"Notification attempt {attempt}/{config.max_retries} \"\n                f\"for provider={provider_name}, request_id={payload.request_id}\"\n            )\n\n            result = await send_func(payload)\n            attempt_results.append(result)\n            last_result = result\n\n            # Success - return immediately\n            if result.is_success:\n                if attempt > 1:\n                    logger.info(\n                        f\"Notification succeeded on attempt {attempt} \"\n                        f\"for provider={provider_name}, request_id={payload.request_id}\"\n                    )\n                return result\n\n            # Check if we should retry\n            if not result.should_retry:\n                # Non-retryable failure (e.g., invalid config)\n                logger.warning(\n                    f\"Notification failed with non-retryable status: \"\n                    f\"status={result.status.value}, provider={provider_name}, \"\n                    f\"request_id={payload.request_id}, error={result.error}\"\n                )\n                break\n\n            # Retryable failure - calculate delay and wait\n            if attempt < config.max_retries:\n                delay = calculate_backoff_delay(attempt, config, result.retry_after)\n                logger.info(\n                    f\"Notification failed, retrying in {delay:.2f}s: \"\n                    f\"attempt={attempt}/{config.max_retries}, \"\n                    f\"provider={provider_name}, request_id={payload.request_id}, \"\n                    f\"error={result.error}\"\n                )\n                await asyncio.sleep(delay)\n\n        except Exception as e:\n            # Unexpected exception during send\n            logger.error(\n                f\"Unexpected error during notification attempt {attempt}: \"\n                f\"provider={provider_name}, request_id={payload.request_id}, error={e}\"\n            )\n            last_result = NotificationResult(\n                status=NotificationStatus.FAILED,\n                provider=provider_name,\n                error=f\"Unexpected error: {e}\",\n            )\n            attempt_results.append(last_result)\n\n            # Wait before retry on exception\n            if attempt < config.max_retries:\n                delay = calculate_backoff_delay(attempt, config)\n                await asyncio.sleep(delay)\n\n    # All retries exhausted - persist for manual review if enabled\n    if last_result and not last_result.is_success and persist_failures:\n        failed_notification = FailedNotification(\n            payload=payload,\n            provider=provider_name,\n            attempts=len(attempt_results),\n            last_error=last_result.error or \"Unknown error\",\n            first_attempt_at=first_attempt_at,\n            last_attempt_at=datetime.utcnow(),\n            results=attempt_results,\n        )\n        await _failed_notification_store.add(failed_notification)\n\n    if last_result is None:\n        last_result = NotificationResult(\n            status=NotificationStatus.FAILED,\n            provider=provider_name,\n            error=\"No attempts made\",\n        )\n\n    logger.error(\n        f\"Notification failed after {config.max_retries} attempts: \"\n        f\"provider={provider_name}, request_id={payload.request_id}, \"\n        f\"final_status={last_result.status.value}, error={last_result.error}\"\n    )\n\n    return last_result\n\n\ndef with_retry(\n    config: Optional[RetryConfig] = None,\n    persist_failures: bool = True,\n) -> Callable:\n    \"\"\"\n    Decorator to add retry logic to a notification provider's send method.\n\n    Args:\n        config: Optional retry configuration\n        persist_failures: Whether to persist failed notifications\n\n    Returns:\n        Decorated function with retry logic\n\n    Example:\n        @with_retry(config=RetryConfig(max_retries=5))\n        async def send_notification(self, payload: NotificationPayload) -> NotificationResult:\n            ...\n    \"\"\"\n\n    def decorator(\n        func: Callable[..., Awaitable[NotificationResult]],\n    ) -> Callable[..., Awaitable[NotificationResult]]:\n        @wraps(func)\n        async def wrapper(\n            self: \"NotificationProvider\",\n            payload: NotificationPayload,\n            *args: ArgsType,\n            **kwargs: KwargsType,\n        ) -> NotificationResult:\n            provider_name = getattr(self, \"name\", self.__class__.__name__)\n\n            async def send_once(p: NotificationPayload) -> NotificationResult:\n                return await func(self, p, *args, **kwargs)\n\n            return await retry_with_backoff(\n                send_func=send_once,\n                payload=payload,\n                provider_name=provider_name,\n                config=config,\n                persist_failures=persist_failures,\n            )\n\n        return wrapper\n\n    return decorator\n\n\nclass RetryableNotificationSender:\n    \"\"\"\n    Wrapper class to send notifications with automatic retry.\n\n    Provides a unified interface for sending notifications through\n    any provider with consistent retry behavior.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[RetryConfig] = None,\n        persist_failures: bool = True,\n    ):\n        \"\"\"\n        Initialize the retryable sender.\n\n        Args:\n            config: Retry configuration\n            persist_failures: Whether to persist failed notifications\n        \"\"\"\n        self._config = config or RetryConfig()\n        self._persist_failures = persist_failures\n\n    async def send(\n        self,\n        provider: \"NotificationProvider\",\n        payload: NotificationPayload,\n    ) -> NotificationResult:\n        \"\"\"\n        Send a notification with retry logic.\n\n        Args:\n            provider: The notification provider to use\n            payload: The notification payload\n\n        Returns:\n            NotificationResult from the send attempt\n        \"\"\"\n        return await retry_with_backoff(\n            send_func=provider.send_notification,\n            payload=payload,\n            provider_name=provider.name,\n            config=self._config,\n            persist_failures=self._persist_failures,\n        )\n\n    async def send_to_multiple(\n        self,\n        providers: List[\"NotificationProvider\"],\n        payload: NotificationPayload,\n    ) -> Dict[str, NotificationResult]:\n        \"\"\"\n        Send a notification to multiple providers concurrently.\n\n        Args:\n            providers: List of notification providers\n            payload: The notification payload\n\n        Returns:\n            Dictionary mapping provider names to their results\n        \"\"\"\n        tasks = [\n            retry_with_backoff(\n                send_func=provider.send_notification,\n                payload=payload,\n                provider_name=provider.name,\n                config=self._config,\n                persist_failures=self._persist_failures,\n            )\n            for provider in providers\n            if provider.is_enabled\n        ]\n\n        if not tasks:\n            logger.warning(\"No enabled providers to send notification to\")\n            return {}\n\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        return {\n            provider.name: (\n                result\n                if isinstance(result, NotificationResult)\n                else NotificationResult(\n                    status=NotificationStatus.FAILED,\n                    provider=provider.name,\n                    error=str(result),\n                )\n            )\n            for provider, result in zip(\n                [p for p in providers if p.is_enabled],\n                results,\n                strict=False,\n            )\n        }\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.100895",
  "last_updated": "2026-01-04T05:35:59.133125"
}