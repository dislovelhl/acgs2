{
  "file_path": "adaptive-learning-engine/src/registry/mlflow_client.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nAdaptive Learning Engine - MLflow Registry Client\nConstitutional Hash: cdd01ef066bc6cf2\n\nMLflow integration for model versioning, rollback, and lifecycle management.\nProvides resilient model persistence with fallback to local storage.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport pickle\nimport shutil\nimport tempfile\nimport threading\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Optional, Tuple\n\nlogger = logging.getLogger(__name__)\n\n\nclass ModelStage(Enum):\n    \"\"\"MLflow model lifecycle stages.\"\"\"\n\n    NONE = \"None\"\n    STAGING = \"Staging\"\n    PRODUCTION = \"Production\"\n    ARCHIVED = \"Archived\"\n\n\nclass RegistryStatus(Enum):\n    \"\"\"Status of the MLflow registry connection.\"\"\"\n\n    CONNECTED = \"connected\"\n    DISCONNECTED = \"disconnected\"\n    DEGRADED = \"degraded\"  # Using local fallback\n\n\n@dataclass\nclass ModelVersion:\n    \"\"\"Information about a registered model version.\"\"\"\n\n    version: str\n    name: str\n    stage: ModelStage\n    description: str\n    tags: Dict[str, str]\n    creation_timestamp: float\n    last_updated_timestamp: float\n    run_id: Optional[str] = None\n    source: Optional[str] = None\n    aliases: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass RegistrationResult:\n    \"\"\"Result from model registration.\"\"\"\n\n    success: bool\n    version: Optional[str]\n    model_uri: Optional[str]\n    message: str\n    timestamp: float = field(default_factory=time.time)\n\n\n@dataclass\nclass RollbackResult:\n    \"\"\"Result from model rollback.\"\"\"\n\n    success: bool\n    previous_version: Optional[str]\n    new_version: Optional[str]\n    message: str\n    timestamp: float = field(default_factory=time.time)\n\n\n@dataclass\nclass ModelMetadata:\n    \"\"\"Metadata logged with model versions.\"\"\"\n\n    accuracy: float\n    drift_score: float\n    sample_count: int\n    model_type: str\n    learning_rate: float\n    l2_regularization: float\n    algorithm: str\n    training_timestamp: float\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n\nclass MLflowRegistry:\n    \"\"\"MLflow model registry client for versioning and rollback.\n\n    Provides resilient model persistence with:\n    - MLflow registry for production model management\n    - Local disk fallback when MLflow is unavailable\n    - Automatic retry for failed registry operations\n    - Champion/challenger alias management\n    - Version history tracking\n\n    Example usage:\n        registry = MLflowRegistry()\n\n        # Register a new model version\n        result = registry.register_model(\n            model=learner.model,\n            metadata=ModelMetadata(\n                accuracy=0.92,\n                drift_score=0.15,\n                sample_count=1000,\n                model_type=\"logistic_regression\",\n                learning_rate=0.1,\n                l2_regularization=0.01,\n                algorithm=\"LogisticRegression\",\n                training_timestamp=time.time(),\n            ),\n        )\n\n        # Load the champion model\n        model = registry.load_champion_model()\n\n        # Rollback to a previous version\n        result = registry.rollback_to_version(\"2\")\n    \"\"\"\n\n    # Default paths\n    DEFAULT_TRACKING_URI = \"sqlite:///mlruns/mlflow.db\"\n    DEFAULT_MODEL_NAME = \"governance_model\"\n    DEFAULT_CHAMPION_ALIAS = \"champion\"\n    DEFAULT_CHALLENGER_ALIAS = \"challenger\"\n\n    # Local fallback paths\n    LOCAL_FALLBACK_DIR = \"model_cache\"\n    LOCAL_METADATA_FILE = \"metadata.json\"\n\n    # Retry settings\n    MAX_RETRY_ATTEMPTS = 3\n    RETRY_DELAY_SECONDS = 1.0\n\n    def __init__(\n        self,\n        tracking_uri: Optional[str] = None,\n        model_name: Optional[str] = None,\n        champion_alias: Optional[str] = None,\n        challenger_alias: Optional[str] = None,\n        local_fallback_dir: Optional[str] = None,\n        enable_local_fallback: bool = True,\n    ) -> None:\n        \"\"\"Initialize the MLflow registry client.\n\n        Args:\n            tracking_uri: MLflow tracking URI. Defaults to sqlite:///mlruns/mlflow.db.\n            model_name: Name of the registered model. Defaults to \"governance_model\".\n            champion_alias: Alias for the production model. Defaults to \"champion\".\n            challenger_alias: Alias for the candidate model. Defaults to \"challenger\".\n            local_fallback_dir: Directory for local model cache. Defaults to \"model_cache\".\n            enable_local_fallback: Whether to enable local disk fallback.\n        \"\"\"\n        self.tracking_uri = tracking_uri or self.DEFAULT_TRACKING_URI\n        self.model_name = model_name or self.DEFAULT_MODEL_NAME\n        self.champion_alias = champion_alias or self.DEFAULT_CHAMPION_ALIAS\n        self.challenger_alias = challenger_alias or self.DEFAULT_CHALLENGER_ALIAS\n        self.local_fallback_dir = Path(local_fallback_dir or self.LOCAL_FALLBACK_DIR)\n        self.enable_local_fallback = enable_local_fallback\n\n        # Thread safety\n        self._lock = threading.RLock()\n\n        # Connection status\n        self._status = RegistryStatus.DISCONNECTED\n        self._last_error: Optional[str] = None\n        self._last_successful_connection: Optional[float] = None\n\n        # Version tracking (in-memory cache)\n        self._version_cache: Dict[str, ModelVersion] = {}\n        self._current_champion_version: Optional[str] = None\n\n        # MLflow client (lazy initialization)\n        self._mlflow_client: Optional[Any] = None\n        self._mlflow_initialized = False\n\n        # Callbacks for registry events\n        self._on_registration_callbacks: List[Callable[[RegistrationResult], None]] = []\n        self._on_rollback_callbacks: List[Callable[[RollbackResult], None]] = []\n\n        # Pending operations queue for retry\n        self._pending_operations: List[Dict[str, Any]] = []\n        self._retry_lock = threading.Lock()\n\n        logger.info(\n            \"MLflowRegistry initialized\",\n            extra={\n                \"tracking_uri\": self.tracking_uri,\n                \"model_name\": self.model_name,\n                \"champion_alias\": self.champion_alias,\n                \"enable_local_fallback\": self.enable_local_fallback,\n            },\n        )\n\n    def _initialize_mlflow(self) -> bool:\n        \"\"\"Initialize MLflow connection.\n\n        Returns:\n            True if initialization successful, False otherwise.\n        \"\"\"\n        if self._mlflow_initialized:\n            return self._status == RegistryStatus.CONNECTED\n\n        try:\n            import mlflow\n            from mlflow.tracking import MlflowClient\n\n            # Set tracking URI\n            mlflow.set_tracking_uri(self.tracking_uri)\n\n            # Create the MLflow client\n            self._mlflow_client = MlflowClient()\n\n            # Test connection by trying to list registered models\n            # This will create tables if using SQLite\n            try:\n                # Try to get the registered model (may not exist yet)\n                self._mlflow_client.search_registered_models(max_results=1)\n            except Exception:\n                # Model doesn't exist yet, that's fine\n                pass\n\n            self._status = RegistryStatus.CONNECTED\n            self._last_successful_connection = time.time()\n            self._mlflow_initialized = True\n\n            logger.info(\"MLflow connection established\", extra={\"tracking_uri\": self.tracking_uri})\n            return True\n\n        except ImportError as e:\n            logger.error(f\"MLflow not installed: {e}\")\n            self._status = RegistryStatus.DISCONNECTED\n            self._last_error = f\"MLflow not installed: {e}\"\n            return False\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize MLflow: {e}\")\n            self._status = RegistryStatus.DISCONNECTED\n            self._last_error = str(e)\n\n            if self.enable_local_fallback:\n                self._status = RegistryStatus.DEGRADED\n                logger.warning(\"Falling back to local model storage\")\n\n            return False\n\n    def _ensure_local_fallback_dir(self) -> Path:\n        \"\"\"Ensure local fallback directory exists.\n\n        Returns:\n            Path to the fallback directory.\n        \"\"\"\n        self.local_fallback_dir.mkdir(parents=True, exist_ok=True)\n        return self.local_fallback_dir\n\n    def register_model(\n        self,\n        model: Any,\n        metadata: ModelMetadata,\n        description: Optional[str] = None,\n        tags: Optional[Dict[str, str]] = None,\n        promote_to_champion: bool = True,\n    ) -> RegistrationResult:\n        \"\"\"Register a new model version in the registry.\n\n        Args:\n            model: The model object to register (River pipeline or pickled object).\n            metadata: Metadata to log with the model version.\n            description: Optional description for this version.\n            tags: Optional tags for this version.\n            promote_to_champion: Whether to promote this version to champion.\n\n        Returns:\n            RegistrationResult with success status and version info.\n        \"\"\"\n        with self._lock:\n            timestamp = time.time()\n\n            # Try MLflow registration first\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                result = self._register_with_mlflow(\n                    model=model,\n                    metadata=metadata,\n                    description=description,\n                    tags=tags,\n                    promote_to_champion=promote_to_champion,\n                )\n\n                if result.success:\n                    # Notify callbacks\n                    for callback in self._on_registration_callbacks:\n                        try:\n                            callback(result)\n                        except Exception as e:\n                            logger.warning(f\"Registration callback error: {e}\")\n\n                    return result\n\n                # MLflow failed, fall through to local fallback\n                logger.warning(\"MLflow registration failed, using local fallback\")\n\n            # Use local fallback\n            if self.enable_local_fallback:\n                result = self._register_locally(\n                    model=model,\n                    metadata=metadata,\n                    description=description,\n                    tags=tags,\n                    promote_to_champion=promote_to_champion,\n                )\n\n                # Queue for retry with MLflow\n                self._queue_retry_operation(\n                    operation=\"register\",\n                    model=model,\n                    metadata=metadata,\n                    description=description,\n                    tags=tags,\n                    promote_to_champion=promote_to_champion,\n                )\n\n                # Notify callbacks\n                for callback in self._on_registration_callbacks:\n                    try:\n                        callback(result)\n                    except Exception as e:\n                        logger.warning(f\"Registration callback error: {e}\")\n\n                return result\n\n            return RegistrationResult(\n                success=False,\n                version=None,\n                model_uri=None,\n                message=\"MLflow unavailable and local fallback disabled\",\n                timestamp=timestamp,\n            )\n\n    def _register_with_mlflow(\n        self,\n        model: Any,\n        metadata: ModelMetadata,\n        description: Optional[str],\n        tags: Optional[Dict[str, str]],\n        promote_to_champion: bool,\n    ) -> RegistrationResult:\n        \"\"\"Register model with MLflow registry.\n\n        Args:\n            model: Model to register.\n            metadata: Model metadata.\n            description: Version description.\n            tags: Version tags.\n            promote_to_champion: Whether to set champion alias.\n\n        Returns:\n            RegistrationResult with MLflow version info.\n        \"\"\"\n        import mlflow\n\n        timestamp = time.time()\n\n        try:\n            # Start a new MLflow run\n            with mlflow.start_run() as run:\n                # Log parameters\n                mlflow.log_param(\"algorithm\", metadata.algorithm)\n                mlflow.log_param(\"model_type\", metadata.model_type)\n                mlflow.log_param(\"learning_rate\", metadata.learning_rate)\n                mlflow.log_param(\"l2_regularization\", metadata.l2_regularization)\n\n                # Log metrics\n                mlflow.log_metric(\"accuracy\", metadata.accuracy)\n                mlflow.log_metric(\"drift_score\", metadata.drift_score)\n                mlflow.log_metric(\"sample_count\", metadata.sample_count)\n                mlflow.log_metric(\"training_timestamp\", metadata.training_timestamp)\n\n                # Log extra metrics\n                for key, value in metadata.extra.items():\n                    if isinstance(value, (int, float)):\n                        mlflow.log_metric(key, value)\n                    else:\n                        mlflow.log_param(key, str(value))\n\n                # Log tags\n                if tags:\n                    mlflow.set_tags(tags)\n\n                # Save model as artifact\n                # Create a temporary directory for the model\n                with tempfile.TemporaryDirectory() as tmpdir:\n                    model_path = os.path.join(tmpdir, \"model.pkl\")\n                    with open(model_path, \"wb\") as f:\n                        pickle.dump(model, f)\n\n                    # Log the model artifact\n                    mlflow.log_artifact(model_path, artifact_path=\"model\")\n\n                model_uri = f\"runs:/{run.info.run_id}/model\"\n\n            # Register the model\n            try:\n                result = mlflow.register_model(model_uri, self.model_name)\n                version = result.version\n            except Exception as e:\n                # Model might not be registered yet, create it\n                logger.debug(f\"Creating new registered model: {e}\")\n                try:\n                    self._mlflow_client.create_registered_model(\n                        name=self.model_name,\n                        description=description or \"Governance online learning model\",\n                    )\n                    result = mlflow.register_model(model_uri, self.model_name)\n                    version = result.version\n                except Exception:\n                    # Model already exists, retry registration\n                    result = mlflow.register_model(model_uri, self.model_name)\n                    version = result.version\n\n            # Update description if provided\n            if description:\n                self._mlflow_client.update_model_version(\n                    name=self.model_name,\n                    version=version,\n                    description=description,\n                )\n\n            # Promote to production and set champion alias\n            if promote_to_champion:\n                # Transition to Production stage\n                self._mlflow_client.transition_model_version_stage(\n                    name=self.model_name,\n                    version=version,\n                    stage=\"Production\",\n                    archive_existing_versions=True,\n                )\n\n                # Set champion alias\n                try:\n                    self._mlflow_client.set_registered_model_alias(\n                        name=self.model_name,\n                        alias=self.champion_alias,\n                        version=version,\n                    )\n                except Exception as alias_error:\n                    # Alias API might not be available in older MLflow versions\n                    logger.warning(f\"Could not set alias (older MLflow?): {alias_error}\")\n\n                self._current_champion_version = version\n\n            # Update version cache\n            self._version_cache[version] = ModelVersion(\n                version=version,\n                name=self.model_name,\n                stage=ModelStage.PRODUCTION if promote_to_champion else ModelStage.NONE,\n                description=description or \"\",\n                tags=tags or {},\n                creation_timestamp=timestamp,\n                last_updated_timestamp=timestamp,\n                run_id=run.info.run_id,\n                source=model_uri,\n                aliases=[self.champion_alias] if promote_to_champion else [],\n            )\n\n            logger.info(\n                \"Model registered with MLflow\",\n                extra={\n                    \"version\": version,\n                    \"accuracy\": metadata.accuracy,\n                    \"promoted\": promote_to_champion,\n                },\n            )\n\n            return RegistrationResult(\n                success=True,\n                version=version,\n                model_uri=model_uri,\n                message=f\"Model registered as version {version}\",\n                timestamp=timestamp,\n            )\n\n        except Exception as e:\n            logger.error(f\"MLflow registration failed: {e}\")\n            return RegistrationResult(\n                success=False,\n                version=None,\n                model_uri=None,\n                message=f\"MLflow registration failed: {e}\",\n                timestamp=timestamp,\n            )\n\n    def _register_locally(\n        self,\n        model: Any,\n        metadata: ModelMetadata,\n        description: Optional[str],\n        tags: Optional[Dict[str, str]],\n        promote_to_champion: bool,\n    ) -> RegistrationResult:\n        \"\"\"Register model to local disk as fallback.\n\n        Args:\n            model: Model to save.\n            metadata: Model metadata.\n            description: Version description.\n            tags: Version tags.\n            promote_to_champion: Whether to mark as champion.\n\n        Returns:\n            RegistrationResult with local version info.\n        \"\"\"\n        timestamp = time.time()\n\n        try:\n            fallback_dir = self._ensure_local_fallback_dir()\n\n            # Generate version number\n            existing_versions = self._get_local_versions()\n            version = str(max([0] + [int(v) for v in existing_versions]) + 1)\n\n            # Create version directory\n            version_dir = fallback_dir / f\"v{version}\"\n            version_dir.mkdir(parents=True, exist_ok=True)\n\n            # Save model\n            model_path = version_dir / \"model.pkl\"\n            with open(model_path, \"wb\") as f:\n                pickle.dump(model, f)\n\n            # Save metadata\n            metadata_dict = {\n                \"version\": version,\n                \"name\": self.model_name,\n                \"stage\": (\n                    ModelStage.PRODUCTION.value if promote_to_champion else ModelStage.NONE.value\n                ),\n                \"description\": description or \"\",\n                \"tags\": tags or {},\n                \"creation_timestamp\": timestamp,\n                \"last_updated_timestamp\": timestamp,\n                \"is_champion\": promote_to_champion,\n                \"metadata\": {\n                    \"accuracy\": metadata.accuracy,\n                    \"drift_score\": metadata.drift_score,\n                    \"sample_count\": metadata.sample_count,\n                    \"model_type\": metadata.model_type,\n                    \"learning_rate\": metadata.learning_rate,\n                    \"l2_regularization\": metadata.l2_regularization,\n                    \"algorithm\": metadata.algorithm,\n                    \"training_timestamp\": metadata.training_timestamp,\n                    \"extra\": metadata.extra,\n                },\n            }\n\n            metadata_path = version_dir / self.LOCAL_METADATA_FILE\n            with open(metadata_path, \"w\") as f:\n                json.dump(metadata_dict, f, indent=2)\n\n            # Update champion pointer if needed\n            if promote_to_champion:\n                champion_path = fallback_dir / \"champion\"\n                champion_path.write_text(version)\n                self._current_champion_version = version\n\n            # Update version cache\n            self._version_cache[version] = ModelVersion(\n                version=version,\n                name=self.model_name,\n                stage=ModelStage.PRODUCTION if promote_to_champion else ModelStage.NONE,\n                description=description or \"\",\n                tags=tags or {},\n                creation_timestamp=timestamp,\n                last_updated_timestamp=timestamp,\n                source=str(model_path),\n                aliases=[self.champion_alias] if promote_to_champion else [],\n            )\n\n            self._status = RegistryStatus.DEGRADED\n\n            logger.info(\n                \"Model saved to local fallback\",\n                extra={\n                    \"version\": version,\n                    \"path\": str(version_dir),\n                    \"promoted\": promote_to_champion,\n                },\n            )\n\n            return RegistrationResult(\n                success=True,\n                version=version,\n                model_uri=str(model_path),\n                message=f\"Model saved locally as version {version} (MLflow unavailable)\",\n                timestamp=timestamp,\n            )\n\n        except Exception as e:\n            logger.error(f\"Local registration failed: {e}\")\n            return RegistrationResult(\n                success=False,\n                version=None,\n                model_uri=None,\n                message=f\"Local registration failed: {e}\",\n                timestamp=timestamp,\n            )\n\n    def _get_local_versions(self) -> List[str]:\n        \"\"\"Get list of locally stored version numbers.\n\n        Returns:\n            List of version strings.\n        \"\"\"\n        if not self.local_fallback_dir.exists():\n            return []\n\n        versions = []\n        for path in self.local_fallback_dir.iterdir():\n            if path.is_dir() and path.name.startswith(\"v\"):\n                try:\n                    version = path.name[1:]  # Remove 'v' prefix\n                    int(version)  # Validate it's a number\n                    versions.append(version)\n                except ValueError:\n                    pass\n        return versions\n\n    def load_champion_model(self) -> Optional[Any]:\n        \"\"\"Load the current champion model.\n\n        Returns:\n            The loaded model object, or None if no champion exists.\n        \"\"\"\n        with self._lock:\n            # Try MLflow first\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                model = self._load_from_mlflow_alias(self.champion_alias)\n                if model is not None:\n                    return model\n\n            # Try local fallback\n            if self.enable_local_fallback:\n                return self._load_local_champion()\n\n            return None\n\n    def load_model_by_version(self, version: str) -> Optional[Any]:\n        \"\"\"Load a specific model version.\n\n        Args:\n            version: Version number to load.\n\n        Returns:\n            The loaded model object, or None if version doesn't exist.\n        \"\"\"\n        with self._lock:\n            # Try MLflow first\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                model = self._load_from_mlflow_version(version)\n                if model is not None:\n                    return model\n\n            # Try local fallback\n            if self.enable_local_fallback:\n                return self._load_local_version(version)\n\n            return None\n\n    def _load_from_mlflow_alias(self, alias: str) -> Optional[Any]:\n        \"\"\"Load model from MLflow by alias.\n\n        Args:\n            alias: Model alias (e.g., \"champion\").\n\n        Returns:\n            Loaded model or None.\n        \"\"\"\n        try:\n            import mlflow\n\n            model_uri = f\"models:/{self.model_name}@{alias}\"\n            model_path = mlflow.artifacts.download_artifacts(artifact_uri=f\"{model_uri}/model.pkl\")\n\n            with open(model_path, \"rb\") as f:\n                model = pickle.load(f)\n\n            logger.debug(f\"Loaded model from MLflow alias: {alias}\")\n            return model\n\n        except Exception as e:\n            logger.warning(f\"Failed to load model by alias {alias}: {e}\")\n            return None\n\n    def _load_from_mlflow_version(self, version: str) -> Optional[Any]:\n        \"\"\"Load model from MLflow by version.\n\n        Args:\n            version: Model version number.\n\n        Returns:\n            Loaded model or None.\n        \"\"\"\n        try:\n            import mlflow\n\n            model_uri = f\"models:/{self.model_name}/{version}\"\n            model_path = mlflow.artifacts.download_artifacts(artifact_uri=f\"{model_uri}/model.pkl\")\n\n            with open(model_path, \"rb\") as f:\n                model = pickle.load(f)\n\n            logger.debug(f\"Loaded model from MLflow version: {version}\")\n            return model\n\n        except Exception as e:\n            logger.warning(f\"Failed to load model version {version}: {e}\")\n            return None\n\n    def _load_local_champion(self) -> Optional[Any]:\n        \"\"\"Load champion model from local storage.\n\n        Returns:\n            Loaded model or None.\n        \"\"\"\n        try:\n            champion_path = self.local_fallback_dir / \"champion\"\n            if not champion_path.exists():\n                return None\n\n            version = champion_path.read_text().strip()\n            return self._load_local_version(version)\n\n        except Exception as e:\n            logger.warning(f\"Failed to load local champion: {e}\")\n            return None\n\n    def _load_local_version(self, version: str) -> Optional[Any]:\n        \"\"\"Load model from local storage by version.\n\n        Args:\n            version: Version number.\n\n        Returns:\n            Loaded model or None.\n        \"\"\"\n        try:\n            version_dir = self.local_fallback_dir / f\"v{version}\"\n            model_path = version_dir / \"model.pkl\"\n\n            if not model_path.exists():\n                return None\n\n            with open(model_path, \"rb\") as f:\n                model = pickle.load(f)\n\n            logger.debug(f\"Loaded model from local version: {version}\")\n            return model\n\n        except Exception as e:\n            logger.warning(f\"Failed to load local version {version}: {e}\")\n            return None\n\n    def rollback_to_version(self, version: str) -> RollbackResult:\n        \"\"\"Rollback to a specific model version.\n\n        Args:\n            version: Version number to rollback to.\n\n        Returns:\n            RollbackResult with status and version info.\n        \"\"\"\n        with self._lock:\n            timestamp = time.time()\n            previous_version = self._current_champion_version\n\n            # Check if version exists\n            if not self._version_exists(version):\n                available_versions = self.list_versions()\n                version_list = [v.version for v in available_versions]\n                return RollbackResult(\n                    success=False,\n                    previous_version=previous_version,\n                    new_version=None,\n                    message=f\"Version {version} not found. Available versions: {version_list}\",\n                    timestamp=timestamp,\n                )\n\n            # Try MLflow rollback first\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                result = self._rollback_mlflow(version, previous_version)\n                if result.success:\n                    # Notify callbacks\n                    for callback in self._on_rollback_callbacks:\n                        try:\n                            callback(result)\n                        except Exception as e:\n                            logger.warning(f\"Rollback callback error: {e}\")\n                    return result\n\n            # Try local rollback\n            if self.enable_local_fallback:\n                result = self._rollback_local(version, previous_version)\n                # Notify callbacks\n                for callback in self._on_rollback_callbacks:\n                    try:\n                        callback(result)\n                    except Exception as e:\n                        logger.warning(f\"Rollback callback error: {e}\")\n                return result\n\n            return RollbackResult(\n                success=False,\n                previous_version=previous_version,\n                new_version=None,\n                message=\"Registry unavailable and local fallback disabled\",\n                timestamp=timestamp,\n            )\n\n    def _rollback_mlflow(self, version: str, previous_version: Optional[str]) -> RollbackResult:\n        \"\"\"Rollback using MLflow registry.\n\n        Args:\n            version: Target version.\n            previous_version: Current champion version.\n\n        Returns:\n            RollbackResult.\n        \"\"\"\n        timestamp = time.time()\n\n        try:\n            # Transition target version to Production\n            self._mlflow_client.transition_model_version_stage(\n                name=self.model_name,\n                version=version,\n                stage=\"Production\",\n                archive_existing_versions=True,\n            )\n\n            # Update champion alias\n            try:\n                self._mlflow_client.set_registered_model_alias(\n                    name=self.model_name,\n                    alias=self.champion_alias,\n                    version=version,\n                )\n            except Exception as alias_error:\n                logger.warning(f\"Could not set alias: {alias_error}\")\n\n            self._current_champion_version = version\n\n            logger.info(\n                \"Model rolled back via MLflow\",\n                extra={\n                    \"previous_version\": previous_version,\n                    \"new_version\": version,\n                },\n            )\n\n            return RollbackResult(\n                success=True,\n                previous_version=previous_version,\n                new_version=version,\n                message=f\"Rolled back from version {previous_version} to {version}\",\n                timestamp=timestamp,\n            )\n\n        except Exception as e:\n            logger.error(f\"MLflow rollback failed: {e}\")\n            return RollbackResult(\n                success=False,\n                previous_version=previous_version,\n                new_version=None,\n                message=f\"MLflow rollback failed: {e}\",\n                timestamp=timestamp,\n            )\n\n    def _rollback_local(self, version: str, previous_version: Optional[str]) -> RollbackResult:\n        \"\"\"Rollback using local storage.\n\n        Args:\n            version: Target version.\n            previous_version: Current champion version.\n\n        Returns:\n            RollbackResult.\n        \"\"\"\n        timestamp = time.time()\n\n        try:\n            # Update champion pointer\n            champion_path = self.local_fallback_dir / \"champion\"\n            champion_path.write_text(version)\n            self._current_champion_version = version\n\n            # Update version cache\n            if version in self._version_cache:\n                self._version_cache[version].stage = ModelStage.PRODUCTION\n                self._version_cache[version].aliases = [self.champion_alias]\n\n            if previous_version and previous_version in self._version_cache:\n                self._version_cache[previous_version].stage = ModelStage.ARCHIVED\n                if self.champion_alias in self._version_cache[previous_version].aliases:\n                    self._version_cache[previous_version].aliases.remove(self.champion_alias)\n\n            logger.info(\n                \"Model rolled back via local storage\",\n                extra={\n                    \"previous_version\": previous_version,\n                    \"new_version\": version,\n                },\n            )\n\n            return RollbackResult(\n                success=True,\n                previous_version=previous_version,\n                new_version=version,\n                message=f\"Rolled back from version {previous_version} to {version} (local)\",\n                timestamp=timestamp,\n            )\n\n        except Exception as e:\n            logger.error(f\"Local rollback failed: {e}\")\n            return RollbackResult(\n                success=False,\n                previous_version=previous_version,\n                new_version=None,\n                message=f\"Local rollback failed: {e}\",\n                timestamp=timestamp,\n            )\n\n    def _version_exists(self, version: str) -> bool:\n        \"\"\"Check if a version exists in registry or local storage.\n\n        Args:\n            version: Version to check.\n\n        Returns:\n            True if version exists.\n        \"\"\"\n        # Check cache first\n        if version in self._version_cache:\n            return True\n\n        # Check MLflow\n        if self._status == RegistryStatus.CONNECTED:\n            try:\n                self._mlflow_client.get_model_version(self.model_name, version)\n                return True\n            except Exception:\n                pass\n\n        # Check local\n        version_dir = self.local_fallback_dir / f\"v{version}\"\n        return version_dir.exists()\n\n    def list_versions(self) -> List[ModelVersion]:\n        \"\"\"List all model versions.\n\n        Returns:\n            List of ModelVersion objects.\n        \"\"\"\n        with self._lock:\n            versions = []\n\n            # Get from MLflow\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                try:\n                    mlflow_versions = self._mlflow_client.search_model_versions(\n                        f\"name='{self.model_name}'\"\n                    )\n                    for mv in mlflow_versions:\n                        version = ModelVersion(\n                            version=mv.version,\n                            name=mv.name,\n                            stage=ModelStage(mv.current_stage),\n                            description=mv.description or \"\",\n                            tags=mv.tags or {},\n                            creation_timestamp=mv.creation_timestamp / 1000.0,\n                            last_updated_timestamp=mv.last_updated_timestamp / 1000.0,\n                            run_id=mv.run_id,\n                            source=mv.source,\n                            aliases=(\n                                list(mv.aliases) if hasattr(mv, \"aliases\") and mv.aliases else []\n                            ),\n                        )\n                        versions.append(version)\n                        self._version_cache[version.version] = version\n                except Exception as e:\n                    logger.warning(f\"Could not list MLflow versions: {e}\")\n\n            # Get from local storage\n            if self.enable_local_fallback:\n                for local_version in self._get_local_versions():\n                    if local_version not in [v.version for v in versions]:\n                        version_dir = self.local_fallback_dir / f\"v{local_version}\"\n                        metadata_path = version_dir / self.LOCAL_METADATA_FILE\n\n                        try:\n                            with open(metadata_path) as f:\n                                metadata = json.load(f)\n\n                            version = ModelVersion(\n                                version=local_version,\n                                name=self.model_name,\n                                stage=ModelStage(metadata.get(\"stage\", \"None\")),\n                                description=metadata.get(\"description\", \"\"),\n                                tags=metadata.get(\"tags\", {}),\n                                creation_timestamp=metadata.get(\"creation_timestamp\", 0),\n                                last_updated_timestamp=metadata.get(\"last_updated_timestamp\", 0),\n                                source=str(version_dir / \"model.pkl\"),\n                                aliases=(\n                                    [self.champion_alias] if metadata.get(\"is_champion\") else []\n                                ),\n                            )\n                            versions.append(version)\n                        except Exception as e:\n                            logger.debug(f\"Could not load local version metadata: {e}\")\n\n            # Sort by version number\n            versions.sort(key=lambda v: int(v.version), reverse=True)\n            return versions\n\n    def get_version_info(self, version: str) -> Optional[ModelVersion]:\n        \"\"\"Get information about a specific version.\n\n        Args:\n            version: Version number.\n\n        Returns:\n            ModelVersion object or None if not found.\n        \"\"\"\n        with self._lock:\n            # Check cache\n            if version in self._version_cache:\n                return self._version_cache[version]\n\n            # Refresh from registry\n            versions = self.list_versions()\n            for v in versions:\n                if v.version == version:\n                    return v\n\n            return None\n\n    def get_champion_version(self) -> Optional[str]:\n        \"\"\"Get the current champion version.\n\n        Returns:\n            Version string or None.\n        \"\"\"\n        with self._lock:\n            if self._current_champion_version:\n                return self._current_champion_version\n\n            # Try to find from versions list\n            versions = self.list_versions()\n            for v in versions:\n                if self.champion_alias in v.aliases or v.stage == ModelStage.PRODUCTION:\n                    self._current_champion_version = v.version\n                    return v.version\n\n            return None\n\n    def get_status(self) -> Tuple[RegistryStatus, Optional[str]]:\n        \"\"\"Get registry connection status.\n\n        Returns:\n            Tuple of (status, error_message).\n        \"\"\"\n        return self._status, self._last_error\n\n    def _queue_retry_operation(self, operation: str, **kwargs: Any) -> None:\n        \"\"\"Queue an operation for async retry.\n\n        Args:\n            operation: Operation type (e.g., \"register\").\n            **kwargs: Operation arguments.\n        \"\"\"\n        with self._retry_lock:\n            self._pending_operations.append(\n                {\n                    \"operation\": operation,\n                    \"timestamp\": time.time(),\n                    \"attempts\": 0,\n                    \"kwargs\": kwargs,\n                }\n            )\n\n    async def retry_pending_operations(self) -> int:\n        \"\"\"Retry pending operations asynchronously.\n\n        Returns:\n            Number of successful retries.\n        \"\"\"\n        successful = 0\n\n        with self._retry_lock:\n            pending = list(self._pending_operations)\n            self._pending_operations.clear()\n\n        for op in pending:\n            if op[\"attempts\"] >= self.MAX_RETRY_ATTEMPTS:\n                logger.warning(f\"Giving up on operation after {op['attempts']} attempts\")\n                continue\n\n            op[\"attempts\"] += 1\n\n            # Re-initialize MLflow\n            if self._initialize_mlflow() and self._status == RegistryStatus.CONNECTED:\n                if op[\"operation\"] == \"register\":\n                    result = self._register_with_mlflow(**op[\"kwargs\"])\n                    if result.success:\n                        successful += 1\n                        logger.info(\"Retry successful for registration\")\n                        continue\n\n            # Re-queue for later\n            with self._retry_lock:\n                self._pending_operations.append(op)\n\n            await asyncio.sleep(self.RETRY_DELAY_SECONDS)\n\n        return successful\n\n    def register_registration_callback(\n        self, callback: Callable[[RegistrationResult], None]\n    ) -> None:\n        \"\"\"Register a callback for model registration events.\n\n        Args:\n            callback: Function to call on registration.\n        \"\"\"\n        self._on_registration_callbacks.append(callback)\n\n    def register_rollback_callback(self, callback: Callable[[RollbackResult], None]) -> None:\n        \"\"\"Register a callback for rollback events.\n\n        Args:\n            callback: Function to call on rollback.\n        \"\"\"\n        self._on_rollback_callbacks.append(callback)\n\n    def delete_version(self, version: str) -> bool:\n        \"\"\"Delete a model version.\n\n        Args:\n            version: Version to delete.\n\n        Returns:\n            True if deletion successful.\n        \"\"\"\n        with self._lock:\n            # Prevent deleting champion\n            if version == self._current_champion_version:\n                logger.error(\"Cannot delete current champion version\")\n                return False\n\n            success = False\n\n            # Delete from MLflow\n            if self._status == RegistryStatus.CONNECTED:\n                try:\n                    self._mlflow_client.delete_model_version(self.model_name, version)\n                    success = True\n                except Exception as e:\n                    logger.warning(f\"Could not delete from MLflow: {e}\")\n\n            # Delete from local\n            if self.enable_local_fallback:\n                version_dir = self.local_fallback_dir / f\"v{version}\"\n                if version_dir.exists():\n                    shutil.rmtree(version_dir)\n                    success = True\n\n            # Remove from cache\n            self._version_cache.pop(version, None)\n\n            return success\n\n    def cleanup_old_versions(self, keep_count: int = 5) -> int:\n        \"\"\"Clean up old model versions, keeping the most recent.\n\n        Args:\n            keep_count: Number of versions to keep.\n\n        Returns:\n            Number of versions deleted.\n        \"\"\"\n        with self._lock:\n            versions = self.list_versions()\n            deleted = 0\n\n            # Keep the first N versions (already sorted newest first)\n            for version in versions[keep_count:]:\n                if version.version == self._current_champion_version:\n                    continue  # Never delete champion\n\n                if self.delete_version(version.version):\n                    deleted += 1\n\n            return deleted\n\n    def __repr__(self) -> str:\n        \"\"\"String representation.\"\"\"\n        return (\n            f\"MLflowRegistry(\"\n            f\"model={self.model_name}, \"\n            f\"status={self._status.value}, \"\n            f\"champion={self._current_champion_version})\"\n        )\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.090358",
  "last_updated": "2026-01-04T05:35:58.708622"
}