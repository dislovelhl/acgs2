{
  "file_path": "integration-service/tests/integrations/test_splunk.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nTests for Splunk integration adapter with HEC event submission.\n\nTests cover:\n- SplunkCredentials validation\n- HEC authentication\n- Event formatting and submission\n- Batch event submission\n- Error handling (rate limits, auth failures, index errors)\n- Connection testing\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\nfrom unittest.mock import MagicMock, patch\n\nimport httpx\nimport pytest\nfrom pydantic import SecretStr\n\nfrom src.exceptions.auth import AuthenticationError\nfrom src.exceptions.delivery import DeliveryError\nfrom src.exceptions.integration import RateLimitError\nfrom src.integrations.base import (\n    EventSeverity,\n    IntegrationEvent,\n    IntegrationStatus,\n    IntegrationType,\n)\nfrom src.integrations.splunk_adapter import (\n    SplunkAdapter,\n    SplunkCredentials,\n    SplunkDeploymentType,\n)\n\nif TYPE_CHECKING:\n    pass\n\n\n# ============================================================================\n# Fixtures\n# ============================================================================\n\n\n@pytest.fixture\ndef sample_credentials() -> SplunkCredentials:\n    \"\"\"Create sample Splunk credentials for testing.\"\"\"\n    return SplunkCredentials(\n        integration_name=\"Test Splunk\",\n        hec_url=\"https://splunk.example.com:8088\",\n        hec_token=SecretStr(\"test-hec-token-12345\"),\n        index=\"governance_events\",\n        source=\"acgs2\",\n        sourcetype=\"acgs2:governance\",\n        deployment_type=SplunkDeploymentType.ON_PREMISE,\n        verify_ssl=False,  # Disable for testing\n    )\n\n\n@pytest.fixture\ndef sample_event() -> IntegrationEvent:\n    \"\"\"Create a sample governance event for testing.\"\"\"\n    return IntegrationEvent(\n        event_id=\"evt-test-001\",\n        event_type=\"policy_violation\",\n        severity=EventSeverity.HIGH,\n        source=\"acgs2\",\n        policy_id=\"POL-001\",\n        resource_id=\"res-123\",\n        resource_type=\"compute\",\n        action=\"create\",\n        outcome=\"blocked\",\n        title=\"Policy Violation Detected\",\n        description=\"Resource creation blocked due to policy violation\",\n        details={\"region\": \"us-east-1\", \"cost_estimate\": 150.00},\n        user_id=\"user-456\",\n        tenant_id=\"tenant-789\",\n        correlation_id=\"corr-123\",\n        tags=[\"security\", \"compliance\"],\n    )\n\n\n@pytest.fixture\ndef splunk_adapter(sample_credentials: SplunkCredentials) -> SplunkAdapter:\n    \"\"\"Create a Splunk adapter for testing.\"\"\"\n    return SplunkAdapter(sample_credentials)\n\n\n# ============================================================================\n# Credentials Tests\n# ============================================================================\n\n\nclass TestSplunkCredentials:\n    \"\"\"Tests for SplunkCredentials validation.\"\"\"\n\n    def test_valid_credentials(self, sample_credentials: SplunkCredentials):\n        \"\"\"Test creating valid credentials.\"\"\"\n        assert sample_credentials.integration_type == IntegrationType.SIEM\n        assert sample_credentials.hec_url == \"https://splunk.example.com:8088\"\n        assert sample_credentials.index == \"governance_events\"\n        assert sample_credentials.sourcetype == \"acgs2:governance\"\n\n    def test_hec_url_trailing_slash_removed(self):\n        \"\"\"Test that trailing slash is removed from HEC URL.\"\"\"\n        creds = SplunkCredentials(\n            integration_name=\"Test\",\n            hec_url=\"https://splunk.example.com:8088/\",\n            hec_token=SecretStr(\"token\"),\n        )\n        assert creds.hec_url == \"https://splunk.example.com:8088\"\n\n    def test_hec_url_requires_protocol(self):\n        \"\"\"Test that HEC URL must start with http:// or https://.\"\"\"\n        with pytest.raises(ValueError, match=\"must start with http\"):\n            SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"splunk.example.com:8088\",\n                hec_token=SecretStr(\"token\"),\n            )\n\n    def test_empty_hec_url_fails(self):\n        \"\"\"Test that empty HEC URL is rejected.\"\"\"\n        with pytest.raises(ValueError, match=\"required\"):\n            SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"\",\n                hec_token=SecretStr(\"token\"),\n            )\n\n    def test_valid_index_names(self):\n        \"\"\"Test valid index name patterns.\"\"\"\n        for index in [\"main\", \"governance_events\", \"acgs2-logs\", \"my_index_123\"]:\n            creds = SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"https://splunk.example.com:8088\",\n                hec_token=SecretStr(\"token\"),\n                index=index,\n            )\n            assert creds.index == index\n\n    def test_invalid_index_name_fails(self):\n        \"\"\"Test that invalid index names are rejected.\"\"\"\n        with pytest.raises(ValueError, match=\"alphanumeric\"):\n            SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"https://splunk.example.com:8088\",\n                hec_token=SecretStr(\"token\"),\n                index=\"invalid index!@#\",\n            )\n\n    def test_batch_size_limits(self):\n        \"\"\"Test batch size validation.\"\"\"\n        # Valid range\n        creds = SplunkCredentials(\n            integration_name=\"Test\",\n            hec_url=\"https://splunk.example.com:8088\",\n            hec_token=SecretStr(\"token\"),\n            batch_size=100,\n        )\n        assert creds.batch_size == 100\n\n        # Too small\n        with pytest.raises(ValueError):\n            SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"https://splunk.example.com:8088\",\n                hec_token=SecretStr(\"token\"),\n                batch_size=0,\n            )\n\n        # Too large\n        with pytest.raises(ValueError):\n            SplunkCredentials(\n                integration_name=\"Test\",\n                hec_url=\"https://splunk.example.com:8088\",\n                hec_token=SecretStr(\"token\"),\n                batch_size=2000,\n            )\n\n    def test_token_is_secret(self, sample_credentials: SplunkCredentials):\n        \"\"\"Test that HEC token is properly secured.\"\"\"\n        assert isinstance(sample_credentials.hec_token, SecretStr)\n        # Token should not appear in string representation\n        creds_str = str(sample_credentials.model_dump())\n        assert \"test-hec-token-12345\" not in creds_str\n\n\n# ============================================================================\n# Adapter Initialization Tests\n# ============================================================================\n\n\nclass TestSplunkAdapterInit:\n    \"\"\"Tests for SplunkAdapter initialization.\"\"\"\n\n    def test_initialization(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test adapter initializes correctly.\"\"\"\n        assert splunk_adapter.name == \"Test Splunk\"\n        assert splunk_adapter.integration_type == IntegrationType.SIEM\n        assert splunk_adapter.status == IntegrationStatus.INACTIVE\n        assert splunk_adapter.is_authenticated is False\n\n    def test_custom_timeout_and_retries(self, sample_credentials: SplunkCredentials):\n        \"\"\"Test adapter accepts custom timeout and retry settings.\"\"\"\n        adapter = SplunkAdapter(\n            sample_credentials,\n            max_retries=5,\n            timeout=60.0,\n        )\n        assert adapter.max_retries == 5\n        assert adapter.timeout == 60.0\n\n    def test_splunk_credentials_property(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test splunk_credentials property returns typed credentials.\"\"\"\n        creds = splunk_adapter.splunk_credentials\n        assert isinstance(creds, SplunkCredentials)\n        assert creds.hec_url == \"https://splunk.example.com:8088\"\n\n\n# ============================================================================\n# Authentication Tests\n# ============================================================================\n\n\nclass TestSplunkAuthentication:\n    \"\"\"Tests for Splunk HEC authentication.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_authentication(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test successful HEC authentication.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n            mock_client.return_value.get = MagicMock(return_value=mock_response)\n            mock_client.return_value.get.return_value = mock_response\n\n            # Use async mock\n            async def async_get(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.authenticate()\n\n        assert result.success is True\n        assert splunk_adapter.is_authenticated is True\n        assert splunk_adapter.status == IntegrationStatus.ACTIVE\n\n    @pytest.mark.asyncio\n    async def test_authentication_invalid_token(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test authentication with invalid token.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 401\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.authenticate()\n\n        assert result.success is False\n        assert result.error_code == \"AUTH_FAILED\"\n        assert splunk_adapter.is_authenticated is False\n\n    @pytest.mark.asyncio\n    async def test_authentication_forbidden(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test authentication with insufficient permissions.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 403\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.authenticate()\n\n        assert result.success is False\n        assert result.error_code == \"INSUFFICIENT_PERMISSIONS\"\n\n    @pytest.mark.asyncio\n    async def test_authentication_timeout(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test authentication handles timeout.\"\"\"\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.TimeoutException(\"Connection timed out\")\n\n            mock_client.return_value.get = async_get\n\n            with pytest.raises(AuthenticationError, match=\"timed out\"):\n                await splunk_adapter.authenticate()\n\n    @pytest.mark.asyncio\n    async def test_authentication_network_error(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test authentication handles network errors.\"\"\"\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.NetworkError(\"Connection refused\")\n\n            mock_client.return_value.get = async_get\n\n            with pytest.raises(AuthenticationError, match=\"Network error\"):\n                await splunk_adapter.authenticate()\n\n\n# ============================================================================\n# Validation Tests\n# ============================================================================\n\n\nclass TestSplunkValidation:\n    \"\"\"Tests for Splunk configuration validation.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_validation(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test successful configuration validation.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\", \"ackId\": 123}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await splunk_adapter.validate()\n\n        assert result.success is True\n        assert result.external_id == \"123\"\n\n    @pytest.mark.asyncio\n    async def test_validation_index_not_found(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test validation when index doesn't exist.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 400\n        mock_response.json.return_value = {\"code\": 7, \"text\": \"Index does not exist\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await splunk_adapter.validate()\n\n        assert result.success is False\n        assert \"does not exist\" in result.error_message\n\n    @pytest.mark.asyncio\n    async def test_validation_permission_denied(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test validation when token lacks permissions.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 403\n        mock_response.json.return_value = {}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await splunk_adapter.validate()\n\n        assert result.success is False\n        assert \"permission\" in result.error_message.lower()\n\n\n# ============================================================================\n# Event Submission Tests\n# ============================================================================\n\n\nclass TestSplunkEventSubmission:\n    \"\"\"Tests for Splunk HEC event submission.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_event_submission(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test successful single event submission.\"\"\"\n        # Authenticate first\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\", \"ackId\": 456}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            result = await splunk_adapter.send_event(sample_event)\n\n        assert result.success is True\n        assert result.external_id == \"456\"\n        assert splunk_adapter._events_sent == 1\n\n    @pytest.mark.asyncio\n    async def test_event_submission_requires_auth(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that event submission requires authentication.\"\"\"\n        with pytest.raises(AuthenticationError, match=\"not authenticated\"):\n            await splunk_adapter.send_event(sample_event)\n\n    @pytest.mark.asyncio\n    async def test_event_submission_rate_limited(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test rate limit handling during event submission.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"30\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(RateLimitError) as exc_info:\n                await splunk_adapter.send_event(sample_event)\n\n            assert exc_info.value.retry_after == 30\n\n    @pytest.mark.asyncio\n    async def test_event_submission_index_error(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test handling of index not found error.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 400\n        mock_response.json.return_value = {\"code\": 7, \"text\": \"Index does not exist\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"not found\"):\n                await splunk_adapter.send_event(sample_event)\n\n    @pytest.mark.asyncio\n    async def test_event_submission_server_unavailable(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test handling of server unavailable (503).\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 503\n        mock_response.json.return_value = {}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"unavailable\"):\n                await splunk_adapter.send_event(sample_event)\n\n\n# ============================================================================\n# Event Formatting Tests\n# ============================================================================\n\n\nclass TestSplunkEventFormatting:\n    \"\"\"Tests for Splunk event formatting.\"\"\"\n\n    def test_event_formatting(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that events are properly formatted for Splunk HEC.\"\"\"\n        formatted = splunk_adapter._format_event_for_splunk(sample_event)\n\n        # Check HEC envelope\n        assert \"event\" in formatted\n        assert \"time\" in formatted\n        assert \"source\" in formatted\n        assert \"sourcetype\" in formatted\n        assert \"index\" in formatted\n        assert \"host\" in formatted\n\n        # Check event content\n        event_data = formatted[\"event\"]\n        assert event_data[\"event_id\"] == \"evt-test-001\"\n        assert event_data[\"event_type\"] == \"policy_violation\"\n        assert event_data[\"severity\"] == \"high\"\n        assert event_data[\"severity_level\"] == 2  # Mapped severity\n        assert event_data[\"title\"] == \"Policy Violation Detected\"\n        assert event_data[\"policy_id\"] == \"POL-001\"\n        assert event_data[\"resource_id\"] == \"res-123\"\n\n        # Check metadata\n        assert formatted[\"source\"] == \"acgs2\"\n        assert formatted[\"sourcetype\"] == \"acgs2:governance\"\n        assert formatted[\"index\"] == \"governance_events\"\n\n    def test_event_formatting_removes_none_values(\n        self,\n        splunk_adapter: SplunkAdapter,\n    ):\n        \"\"\"Test that None values are removed from formatted events.\"\"\"\n        event = IntegrationEvent(\n            event_type=\"test\",\n            title=\"Test Event\",\n            # Leave optional fields as None\n        )\n\n        formatted = splunk_adapter._format_event_for_splunk(event)\n        event_data = formatted[\"event\"]\n\n        # None fields should not be present\n        assert \"policy_id\" not in event_data\n        assert \"resource_id\" not in event_data\n        assert \"user_id\" not in event_data\n\n    def test_severity_mapping(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test severity mapping to Splunk levels.\"\"\"\n        test_cases = [\n            (EventSeverity.CRITICAL, 1),\n            (EventSeverity.HIGH, 2),\n            (EventSeverity.MEDIUM, 3),\n            (EventSeverity.LOW, 4),\n            (EventSeverity.INFO, 5),\n        ]\n\n        for severity, expected_level in test_cases:\n            event = IntegrationEvent(\n                event_type=\"test\",\n                title=\"Test\",\n                severity=severity,\n            )\n            formatted = splunk_adapter._format_event_for_splunk(event)\n            assert formatted[\"event\"][\"severity_level\"] == expected_level\n\n\n# ============================================================================\n# Batch Submission Tests\n# ============================================================================\n\n\nclass TestSplunkBatchSubmission:\n    \"\"\"Tests for batch event submission.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_batch_submission(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test successful batch event submission.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(5)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await splunk_adapter.send_events_batch(events)\n\n        assert len(results) == 5\n        assert all(r.success for r in results)\n        # Verify event metrics\n        assert splunk_adapter._events_sent == 5\n        # Verify batch-specific metrics\n        assert splunk_adapter._batches_sent == 1\n        assert splunk_adapter._batch_events_total == 5\n        assert splunk_adapter._batches_failed == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_requires_auth(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that batch submission requires authentication.\"\"\"\n        with pytest.raises(AuthenticationError, match=\"not authenticated\"):\n            await splunk_adapter.send_events_batch([sample_event])\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_empty_list(\n        self,\n        splunk_adapter: SplunkAdapter,\n    ):\n        \"\"\"Test batch submission with empty list returns empty results.\"\"\"\n        splunk_adapter._authenticated = True\n\n        results = await splunk_adapter.send_events_batch([])\n\n        assert results == []\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_failure(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission failure returns failures for all events.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(3)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 500\n        mock_response.json.return_value = {\"code\": 8, \"text\": \"Internal error\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await splunk_adapter.send_events_batch(events)\n\n        assert len(results) == 3\n        assert all(not r.success for r in results)\n        # Verify event metrics\n        assert splunk_adapter._events_failed == 3\n        # Verify batch-specific metrics\n        assert splunk_adapter._batches_failed == 1\n        assert splunk_adapter._batches_sent == 0\n        assert splunk_adapter._batch_events_total == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_rate_limited(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission handles rate limiting.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(3)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"60\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(RateLimitError) as exc_info:\n                await splunk_adapter.send_events_batch(events)\n\n            assert exc_info.value.retry_after == 60\n\n    @pytest.mark.asyncio\n    async def test_batch_metrics_accumulation(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that batch metrics accumulate across multiple batches.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            # Send first batch of 3 events\n            await splunk_adapter.send_events_batch([sample_event for _ in range(3)])\n\n            # Send second batch of 5 events\n            await splunk_adapter.send_events_batch([sample_event for _ in range(5)])\n\n        # Verify accumulated metrics\n        assert splunk_adapter._batches_sent == 2\n        assert splunk_adapter._events_sent == 8\n        assert splunk_adapter._batch_events_total == 8\n        assert splunk_adapter._batches_failed == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_index_error(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission handles index not found error.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(2)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 400\n        mock_response.json.return_value = {\"code\": 7, \"text\": \"Index does not exist\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            with pytest.raises(DeliveryError, match=\"not found\"):\n                await splunk_adapter.send_events_batch(events)\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_network_error_retry(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission retries on network errors.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(2)]\n\n        # First two calls fail with network error, third succeeds\n        call_count = 0\n\n        async def async_post_with_retry(*args, **kwargs):\n            nonlocal call_count\n            call_count += 1\n            if call_count < 3:\n                raise httpx.NetworkError(\"Connection failed\")\n            mock_response = MagicMock(spec=httpx.Response)\n            mock_response.status_code = 200\n            mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\"}\n            return mock_response\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n            mock_client.return_value.post = async_post_with_retry\n\n            results = await splunk_adapter.send_events_batch(events)\n\n        assert len(results) == 2\n        assert all(r.success for r in results)\n        assert call_count == 3  # Verify retry happened\n        assert splunk_adapter._batches_sent == 1\n\n    @pytest.mark.asyncio\n    async def test_batch_submission_external_id(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch submission sets external_id correctly in results.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        events = [sample_event for _ in range(3)]\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0, \"text\": \"Success\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            results = await splunk_adapter.send_events_batch(events)\n\n        # Verify each result has external_id set to event_id\n        assert len(results) == 3\n        for event, result in zip(events, results, strict=True):\n            assert result.success is True\n            assert result.external_id == event.event_id\n\n\n# ============================================================================\n# Connection Testing Tests\n# ============================================================================\n\n\nclass TestSplunkConnectionTest:\n    \"\"\"Tests for connection testing.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_success(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test successful connection test.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.test_connection()\n\n        assert result.success is True\n        assert result.operation == \"test_connection\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_server_error(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test connection test with server error.\"\"\"\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 500\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.test_connection()\n\n        assert result.success is False\n        assert result.error_code == \"HTTP_500\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_timeout(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test connection test handles timeout.\"\"\"\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.TimeoutException(\"Timed out\")\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.test_connection()\n\n        assert result.success is False\n        assert result.error_code == \"TIMEOUT\"\n\n    @pytest.mark.asyncio\n    async def test_connection_test_network_error(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test connection test handles network errors.\"\"\"\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_get(*args, **kwargs):\n                raise httpx.NetworkError(\"Connection refused\")\n\n            mock_client.return_value.get = async_get\n\n            result = await splunk_adapter.test_connection()\n\n        assert result.success is False\n        assert result.error_code == \"NETWORK_ERROR\"\n\n\n# ============================================================================\n# HEC Headers Tests\n# ============================================================================\n\n\nclass TestSplunkHECHeaders:\n    \"\"\"Tests for HEC header generation.\"\"\"\n\n    def test_hec_headers_format(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test HEC headers are properly formatted.\"\"\"\n        headers = splunk_adapter._get_hec_headers()\n\n        assert \"Authorization\" in headers\n        assert headers[\"Authorization\"].startswith(\"Splunk \")\n        assert headers[\"Content-Type\"] == \"application/json\"\n        assert \"X-Splunk-Request-Channel\" in headers\n\n    def test_hec_headers_token_included(\n        self,\n        sample_credentials: SplunkCredentials,\n    ):\n        \"\"\"Test that HEC token is included in headers.\"\"\"\n        adapter = SplunkAdapter(sample_credentials)\n        headers = adapter._get_hec_headers()\n\n        # Token should be in Authorization header\n        auth_header = headers[\"Authorization\"]\n        assert \"test-hec-token-12345\" in auth_header\n\n\n# ============================================================================\n# Metrics Tests\n# ============================================================================\n\n\nclass TestSplunkMetrics:\n    \"\"\"Tests for metrics tracking.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_metrics_tracking(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that metrics are properly tracked.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        # Successful submission\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"code\": 0}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            await splunk_adapter.send_event(sample_event)\n\n        metrics = splunk_adapter.metrics\n        assert metrics[\"events_sent\"] == 1\n        assert metrics[\"events_failed\"] == 0\n        assert metrics[\"last_success\"] is not None\n        assert metrics[\"status\"] == \"active\"\n\n    @pytest.mark.asyncio\n    async def test_failure_metrics(\n        self,\n        splunk_adapter: SplunkAdapter,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test that failure metrics are tracked.\"\"\"\n        splunk_adapter._authenticated = True\n        splunk_adapter._status = IntegrationStatus.ACTIVE\n\n        mock_response = MagicMock(spec=httpx.Response)\n        mock_response.status_code = 400\n        mock_response.json.return_value = {\"code\": 6, \"text\": \"Invalid data\"}\n\n        with patch.object(splunk_adapter, \"get_http_client\") as mock_client:\n\n            async def async_post(*args, **kwargs):\n                return mock_response\n\n            mock_client.return_value.post = async_post\n\n            try:\n                await splunk_adapter.send_event(sample_event)\n            except DeliveryError:\n                pass\n\n        # Note: send_event raises exception before updating metrics\n        # Batch failures do update metrics\n\n\n# ============================================================================\n# Cleanup Tests\n# ============================================================================\n\n\nclass TestSplunkCleanup:\n    \"\"\"Tests for adapter cleanup.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_close_cleans_up_client(self, splunk_adapter: SplunkAdapter):\n        \"\"\"Test that close() properly cleans up HTTP client.\"\"\"\n        # Create a mock client\n        mock_client = MagicMock()\n        mock_client.is_closed = False\n        splunk_adapter._http_client = mock_client\n\n        async def mock_aclose():\n            mock_client.is_closed = True\n\n        mock_client.aclose = mock_aclose\n\n        await splunk_adapter.close()\n\n        assert splunk_adapter._http_client is None\n        assert splunk_adapter.is_authenticated is False\n        assert splunk_adapter.status == IntegrationStatus.INACTIVE\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.729382",
  "last_updated": "2026-01-04T00:39:57.735790"
}