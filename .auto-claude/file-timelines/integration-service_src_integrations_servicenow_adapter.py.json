{
  "file_path": "integration-service/src/integrations/servicenow_adapter.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nServiceNow Integration Adapter\n\nProvides integration with ServiceNow for creating incidents from governance events.\nSupports incident creation with configurable field mappings, priority levels,\nand category assignment.\n\nFeatures:\n- Basic authentication with username/password\n- OAuth 2.0 client credentials flow support\n- Configurable field mappings for incident creation\n- Automatic severity to impact/urgency mapping\n- Assignment group and user configuration\n- Rate limit handling\n- Incident updates and comments\n\"\"\"\n\nimport json\nimport logging\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom pydantic import Field, SecretStr, field_validator, model_validator\n\n# Import exceptions from centralized exceptions module\nfrom exceptions.auth import AuthenticationError\nfrom exceptions.delivery import DeliveryError\nfrom exceptions.integration import RateLimitError\n\n# Import base integration classes and models\nfrom .base import (\n    BaseIntegration,\n    EventSeverity,\n    IntegrationCredentials,\n    IntegrationEvent,\n    IntegrationResult,\n    IntegrationType,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass ServiceNowAuthType(str, Enum):\n    \"\"\"ServiceNow authentication types\"\"\"\n\n    BASIC = \"basic\"\n    OAUTH = \"oauth\"\n\n\nclass ServiceNowIncidentState(str, Enum):\n    \"\"\"ServiceNow incident states\"\"\"\n\n    NEW = \"1\"\n    IN_PROGRESS = \"2\"\n    ON_HOLD = \"3\"\n    RESOLVED = \"6\"\n    CLOSED = \"7\"\n    CANCELED = \"8\"\n\n\n# Default impact/urgency mapping from ACGS-2 severity\n# ServiceNow uses: 1 = High, 2 = Medium, 3 = Low\nDEFAULT_IMPACT_MAP: Dict[EventSeverity, str] = {\n    EventSeverity.CRITICAL: \"1\",\n    EventSeverity.HIGH: \"1\",\n    EventSeverity.MEDIUM: \"2\",\n    EventSeverity.LOW: \"3\",\n    EventSeverity.INFO: \"3\",\n}\n\nDEFAULT_URGENCY_MAP: Dict[EventSeverity, str] = {\n    EventSeverity.CRITICAL: \"1\",\n    EventSeverity.HIGH: \"2\",\n    EventSeverity.MEDIUM: \"2\",\n    EventSeverity.LOW: \"3\",\n    EventSeverity.INFO: \"3\",\n}\n\n\nclass ServiceNowCredentials(IntegrationCredentials):\n    \"\"\"\n    Credentials for ServiceNow integration.\n\n    Supports both Basic authentication and OAuth 2.0 client credentials flow.\n\n    For Basic Auth:\n    - instance: your-instance.service-now.com\n    - username: service account username\n    - password: service account password\n\n    For OAuth:\n    - instance: your-instance.service-now.com\n    - client_id: OAuth client ID\n    - client_secret: OAuth client secret\n    \"\"\"\n\n    integration_type: IntegrationType = Field(\n        default=IntegrationType.TICKETING,\n        description=\"Integration type (always TICKETING for ServiceNow)\",\n    )\n\n    # Connection settings\n    instance: str = Field(\n        ...,\n        description=\"ServiceNow instance name (e.g., 'your-instance')\",\n    )\n\n    # Authentication settings\n    auth_type: ServiceNowAuthType = Field(\n        default=ServiceNowAuthType.BASIC,\n        description=\"Authentication type (basic or oauth)\",\n    )\n\n    # Basic auth credentials\n    username: Optional[str] = Field(\n        None,\n        description=\"Username for basic authentication\",\n    )\n    password: Optional[SecretStr] = Field(\n        None,\n        description=\"Password for basic authentication\",\n    )\n\n    # OAuth credentials\n    client_id: Optional[str] = Field(\n        None,\n        description=\"OAuth client ID\",\n    )\n    client_secret: Optional[SecretStr] = Field(\n        None,\n        description=\"OAuth client secret\",\n    )\n\n    # Incident configuration\n    category: str = Field(\n        default=\"Governance\",\n        description=\"Default category for incidents\",\n    )\n    subcategory: Optional[str] = Field(\n        None,\n        description=\"Default subcategory for incidents\",\n    )\n    assignment_group: Optional[str] = Field(\n        None,\n        description=\"Default assignment group sys_id or name\",\n    )\n    assigned_to: Optional[str] = Field(\n        None,\n        description=\"Default assigned user sys_id or username\",\n    )\n    caller_id: Optional[str] = Field(\n        None,\n        description=\"Default caller sys_id or username\",\n    )\n\n    # Field mappings\n    impact_mapping: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Custom severity to impact mapping (severity -> impact value 1-3)\",\n    )\n    urgency_mapping: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Custom severity to urgency mapping (severity -> urgency value 1-3)\",\n    )\n    custom_fields: Dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Additional field values to set on incidents\",\n    )\n\n    # Incident content settings\n    include_event_details: bool = Field(\n        default=True,\n        description=\"Include full event details in incident description\",\n    )\n    short_description_template: str = Field(\n        default=\"[ACGS-2] {title}\",\n        description=\"Template for short description (supports {title}, {event_type}, {severity})\",\n    )\n\n    @field_validator(\"instance\")\n    @classmethod\n    def validate_instance(cls, v: str) -> str:\n        \"\"\"Validate and normalize instance name.\"\"\"\n        if not v:\n            raise ValueError(\"Instance is required\")\n\n        v = v.strip().lower()\n\n        # Remove protocol if present\n        if v.startswith(\"https://\"):\n            v = v[8:]\n        elif v.startswith(\"http://\"):\n            v = v[7:]\n\n        # Remove trailing slash\n        v = v.rstrip(\"/\")\n\n        # Add .service-now.com if not present\n        if not v.endswith(\".service-now.com\"):\n            v = f\"{v}.service-now.com\"\n\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_auth_credentials(self) -> \"ServiceNowCredentials\":\n        \"\"\"Validate that appropriate credentials are provided for auth type.\"\"\"\n        if self.auth_type == ServiceNowAuthType.BASIC:\n            if not self.username:\n                raise ValueError(\"Username is required for basic authentication\")\n            if not self.password:\n                raise ValueError(\"Password is required for basic authentication\")\n        elif self.auth_type == ServiceNowAuthType.OAUTH:\n            if not self.client_id:\n                raise ValueError(\"Client ID is required for OAuth authentication\")\n            if not self.client_secret:\n                raise ValueError(\"Client secret is required for OAuth authentication\")\n        return self\n\n\nclass ServiceNowAdapter(BaseIntegration):\n    \"\"\"\n    ServiceNow incident management integration adapter.\n\n    Creates incidents in ServiceNow when governance events require remediation.\n    Supports both basic authentication and OAuth 2.0 client credentials flow.\n\n    Usage:\n        credentials = ServiceNowCredentials(\n            integration_name=\"Production ServiceNow\",\n            instance=\"your-instance\",\n            username=\"integration-user\",\n            password=SecretStr(\"password\"),\n        )\n        adapter = ServiceNowAdapter(credentials)\n        await adapter.authenticate()\n        result = await adapter.send_event(event)\n\n    Features:\n        - Basic auth and OAuth 2.0 authentication\n        - Configurable field mappings (severity -> impact/urgency)\n        - Automatic incident description generation\n        - Rate limit handling\n        - Assignment group and user configuration\n        - Detailed error reporting\n    \"\"\"\n\n    # ServiceNow Table API path\n    TABLE_API_PATH = \"/api/now/table\"\n    INCIDENT_TABLE = \"incident\"\n\n    # OAuth token endpoint\n    OAUTH_TOKEN_PATH = \"/oauth_token.do\"  # nosec B105 - URL path, not a password\n\n    def __init__(\n        self,\n        credentials: ServiceNowCredentials,\n        max_retries: int = BaseIntegration.DEFAULT_MAX_RETRIES,\n        timeout: float = BaseIntegration.DEFAULT_TIMEOUT,\n    ):\n        \"\"\"\n        Initialize ServiceNow adapter.\n\n        Args:\n            credentials: ServiceNow credentials and configuration\n            max_retries: Maximum retry attempts for failed operations\n            timeout: HTTP request timeout in seconds\n        \"\"\"\n        super().__init__(credentials, max_retries, timeout)\n        self._snow_credentials = credentials\n        self._access_token: Optional[str] = None\n        self._token_expires_at: Optional[datetime] = None\n\n    @property\n    def snow_credentials(self) -> ServiceNowCredentials:\n        \"\"\"Get typed ServiceNow credentials\"\"\"\n        return self._snow_credentials\n\n    def _get_base_url(self) -> str:\n        \"\"\"Get the base URL for ServiceNow API\"\"\"\n        return f\"https://{self.snow_credentials.instance}\"\n\n    def _get_table_url(self, table: str) -> str:\n        \"\"\"Get the URL for a specific table\"\"\"\n        return f\"{self._get_base_url()}{self.TABLE_API_PATH}/{table}\"\n\n    async def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Get authentication headers for ServiceNow API requests\"\"\"\n        import base64\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        }\n\n        if self.snow_credentials.auth_type == ServiceNowAuthType.BASIC:\n            credentials = (\n                f\"{self.snow_credentials.username}:\"\n                f\"{self.snow_credentials.password.get_secret_value()}\"\n            )\n            encoded = base64.b64encode(credentials.encode()).decode()\n            headers[\"Authorization\"] = f\"Basic {encoded}\"\n        else:\n            # OAuth - use access token\n            if not self._access_token:\n                raise AuthenticationError(\n                    \"No access token available - authenticate first\",\n                    self.name,\n                )\n            headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n\n        return headers\n\n    async def _refresh_oauth_token(self) -> bool:\n        \"\"\"\n        Refresh OAuth access token if needed.\n\n        Returns:\n            True if token was refreshed or is still valid\n        \"\"\"\n        if self.snow_credentials.auth_type != ServiceNowAuthType.OAUTH:\n            return True\n\n        # Check if token is still valid (with 5 minute buffer)\n        if self._access_token and self._token_expires_at:\n            if datetime.now(timezone.utc) < self._token_expires_at:\n                return True\n\n        logger.debug(f\"Refreshing OAuth token for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n            token_url = f\"{self._get_base_url()}{self.OAUTH_TOKEN_PATH}\"\n\n            response = await client.post(\n                token_url,\n                data={\n                    \"grant_type\": \"client_credentials\",\n                    \"client_id\": self.snow_credentials.client_id,\n                    \"client_secret\": self.snow_credentials.client_secret.get_secret_value(),\n                },\n            )\n\n            if response.status_code == 200:\n                token_data = response.json()\n                self._access_token = token_data.get(\"access_token\")\n                expires_in = int(token_data.get(\"expires_in\", 3600))\n                # Set expiry with 5 minute buffer\n                self._token_expires_at = datetime.now(timezone.utc).replace(second=0, microsecond=0)\n                from datetime import timedelta\n\n                self._token_expires_at += timedelta(seconds=expires_in - 300)\n                logger.debug(f\"OAuth token refreshed for '{self.name}'\")\n                return True\n            else:\n                logger.error(f\"Failed to refresh OAuth token: HTTP {response.status_code}\")\n                return False\n\n        except Exception as e:\n            logger.error(f\"Error refreshing OAuth token: {str(e)}\")\n            return False\n\n    async def _do_authenticate(self) -> IntegrationResult:\n        \"\"\"\n        Authenticate with ServiceNow and verify credentials.\n\n        For basic auth, verifies credentials by fetching the user record.\n        For OAuth, obtains and validates an access token.\n\n        Returns:\n            IntegrationResult indicating authentication success/failure\n        \"\"\"\n        logger.debug(f\"Authenticating with ServiceNow for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n\n            if self.snow_credentials.auth_type == ServiceNowAuthType.OAUTH:\n                # Get OAuth token\n                if not await self._refresh_oauth_token():\n                    return IntegrationResult(\n                        success=False,\n                        integration_name=self.name,\n                        operation=\"authenticate\",\n                        error_code=\"AUTH_FAILED\",\n                        error_message=\"Failed to obtain OAuth access token\",\n                    )\n\n            # Verify access by querying sys_user table\n            verify_url = f\"{self._get_table_url('sys_user')}\"\n            params = {\"sysparm_limit\": \"1\"}\n\n            headers = await self._get_auth_headers()\n            response = await client.get(\n                verify_url,\n                headers=headers,\n                params=params,\n            )\n\n            if response.status_code == 200:\n                logger.info(f\"ServiceNow authentication successful for '{self.name}'\")\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                )\n\n            elif response.status_code == 401:\n                error_msg = \"Invalid credentials\"\n                logger.error(f\"ServiceNow authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"AUTH_FAILED\",\n                    error_message=error_msg,\n                )\n\n            elif response.status_code == 403:\n                error_msg = \"Access denied - check user permissions and roles\"\n                logger.error(f\"ServiceNow authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"ACCESS_DENIED\",\n                    error_message=error_msg,\n                )\n\n            else:\n                error_msg = f\"Unexpected response: HTTP {response.status_code}\"\n                logger.error(f\"ServiceNow authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=error_msg,\n                )\n\n        except httpx.TimeoutException as e:\n            raise AuthenticationError(\n                f\"Connection timed out: {str(e)}\",\n                self.name,\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise AuthenticationError(\n                f\"Network error: {str(e)}\",\n                self.name,\n            ) from e\n\n        except Exception as e:\n            error_msg = f\"Unexpected error during authentication: {str(e)}\"\n            logger.error(f\"ServiceNow authentication error: {error_msg}\")\n            raise AuthenticationError(error_msg, self.name) from e\n\n    async def _do_validate(self) -> IntegrationResult:\n        \"\"\"\n        Validate ServiceNow configuration and prerequisites.\n\n        Checks:\n        - Credentials are valid\n        - Incident table is accessible\n        - Required fields can be written\n        - Assignment group exists (if configured)\n\n        Returns:\n            IntegrationResult with validation status and any issues found\n        \"\"\"\n        logger.debug(f\"Validating ServiceNow integration '{self.name}'\")\n\n        validation_issues: List[str] = []\n\n        try:\n            # Refresh token if needed\n            if self.snow_credentials.auth_type == ServiceNowAuthType.OAUTH:\n                if not await self._refresh_oauth_token():\n                    validation_issues.append(\"Failed to refresh OAuth token\")\n                    return IntegrationResult(\n                        success=False,\n                        integration_name=self.name,\n                        operation=\"validate\",\n                        error_code=\"AUTH_FAILED\",\n                        error_message=\"; \".join(validation_issues),\n                        error_details={\"issues\": validation_issues},\n                    )\n\n            client = await self.get_http_client()\n            headers = await self._get_auth_headers()\n\n            # Validate incident table access\n            incident_url = f\"{self._get_table_url(self.INCIDENT_TABLE)}\"\n            params = {\"sysparm_limit\": \"1\"}\n\n            incident_response = await client.get(\n                incident_url,\n                headers=headers,\n                params=params,\n            )\n\n            if incident_response.status_code == 200:\n                logger.debug(\"Incident table accessible\")\n            elif incident_response.status_code == 401:\n                validation_issues.append(\"Authentication failed - invalid credentials\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"validate\",\n                    error_code=\"AUTH_FAILED\",\n                    error_message=\"; \".join(validation_issues),\n                    error_details={\"issues\": validation_issues},\n                )\n            elif incident_response.status_code == 403:\n                validation_issues.append(\"Access denied to incident table\")\n            else:\n                validation_issues.append(\n                    f\"Failed to access incident table: HTTP {incident_response.status_code}\"\n                )\n\n            # Validate assignment group if configured\n            if self.snow_credentials.assignment_group and not validation_issues:\n                group_url = f\"{self._get_table_url('sys_user_group')}\"\n                group_name = self.snow_credentials.assignment_group\n                group_params = {\n                    \"sysparm_limit\": \"1\",\n                    \"sysparm_query\": f\"name={group_name}^ORsys_id={group_name}\",\n                }\n\n                group_response = await client.get(\n                    group_url,\n                    headers=headers,\n                    params=group_params,\n                )\n\n                if group_response.status_code == 200:\n                    group_data = group_response.json()\n                    if not group_data.get(\"result\"):\n                        validation_issues.append(\n                            f\"Assignment group '{self.snow_credentials.assignment_group}' not found\"\n                        )\n                else:\n                    logger.warning(\n                        f\"Could not validate assignment group: HTTP {group_response.status_code}\"\n                    )\n\n        except httpx.TimeoutException:\n            validation_issues.append(\"Connection timed out\")\n\n        except httpx.NetworkError as e:\n            validation_issues.append(f\"Network error: {str(e)}\")\n\n        except Exception as e:\n            validation_issues.append(f\"Validation error: {str(e)}\")\n\n        if validation_issues:\n            error_msg = \"; \".join(validation_issues)\n            logger.warning(f\"ServiceNow validation failed for '{self.name}': {error_msg}\")\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"validate\",\n                error_code=\"VALIDATION_FAILED\",\n                error_message=error_msg,\n                error_details={\"issues\": validation_issues},\n            )\n\n        logger.info(f\"ServiceNow validation successful for '{self.name}'\")\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"validate\",\n        )\n\n    async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n        \"\"\"\n        Create a ServiceNow incident for the governance event.\n\n        Args:\n            event: The governance event to create an incident for\n\n        Returns:\n            IntegrationResult with incident creation status\n\n        Raises:\n            DeliveryError: If incident creation fails\n            RateLimitError: If rate limited by ServiceNow\n        \"\"\"\n        logger.debug(f\"Creating ServiceNow incident for event {event.event_id}\")\n\n        try:\n            # Refresh OAuth token if needed\n            if self.snow_credentials.auth_type == ServiceNowAuthType.OAUTH:\n                if not await self._refresh_oauth_token():\n                    raise AuthenticationError(\n                        \"Failed to refresh OAuth token\",\n                        self.name,\n                    )\n\n            client = await self.get_http_client()\n            headers = await self._get_auth_headers()\n\n            # Build the incident payload\n            incident_data = self._build_incident_payload(event)\n\n            # Create the incident\n            create_url = f\"{self._get_table_url(self.INCIDENT_TABLE)}\"\n\n            response = await client.post(\n                create_url,\n                headers=headers,\n                json=incident_data,\n            )\n\n            # Handle rate limiting\n            if response.status_code == 429:\n                retry_after = int(response.headers.get(\"Retry-After\", 60))\n                raise RateLimitError(\n                    \"ServiceNow rate limit exceeded\",\n                    self.name,\n                    retry_after=retry_after,\n                )\n\n            # Handle success (201 Created or 200 OK)\n            if response.status_code in (200, 201):\n                incident_response = response.json()\n                result_data = incident_response.get(\"result\", {})\n                incident_number = result_data.get(\"number\")\n                incident_sys_id = result_data.get(\"sys_id\")\n                incident_url = (\n                    f\"{self._get_base_url()}/nav_to.do?uri=incident.do?sys_id={incident_sys_id}\"\n                )\n\n                logger.info(\n                    f\"Created ServiceNow incident {incident_number} for event {event.event_id}\"\n                )\n\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    external_id=incident_number,\n                    external_url=incident_url,\n                )\n\n            # Handle errors\n            if response.status_code == 400:\n                try:\n                    error_data = response.json()\n                    error_msg = error_data.get(\"error\", {}).get(\"message\", \"Bad request\")\n                except json.JSONDecodeError:\n                    error_msg = \"Invalid request format\"\n\n                raise DeliveryError(\n                    f\"Failed to create incident: {error_msg}\",\n                    self.name,\n                    details={\"status_code\": 400},\n                )\n\n            elif response.status_code == 401:\n                raise AuthenticationError(\n                    \"Authentication failed - credentials may be expired\",\n                    self.name,\n                )\n\n            elif response.status_code == 403:\n                raise DeliveryError(\n                    \"Access denied - user lacks permission to create incidents\",\n                    self.name,\n                    details={\"status_code\": 403},\n                )\n\n            else:\n                raise DeliveryError(\n                    f\"Unexpected response: HTTP {response.status_code}\",\n                    self.name,\n                    details={\"status_code\": response.status_code},\n                )\n\n        except (RateLimitError, AuthenticationError, DeliveryError):\n            raise\n\n        except httpx.TimeoutException as e:\n            raise DeliveryError(\n                f\"Request timed out: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise DeliveryError(\n                f\"Network error: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except Exception as e:\n            raise DeliveryError(\n                f\"Unexpected error: {str(e)}\",\n                self.name,\n            ) from e\n\n    def _build_incident_payload(self, event: IntegrationEvent) -> Dict[str, Any]:\n        \"\"\"\n        Build the ServiceNow incident creation payload from an event.\n\n        Args:\n            event: The governance event to convert to an incident\n\n        Returns:\n            Dictionary formatted for ServiceNow incident creation API\n        \"\"\"\n        # Build short description from template\n        short_description = self.snow_credentials.short_description_template.format(\n            title=event.title,\n            event_type=event.event_type,\n            severity=event.severity.value,\n        )\n        # ServiceNow short_description max length is 160 characters\n        if len(short_description) > 160:\n            short_description = short_description[:157] + \"...\"\n\n        # Build description\n        description = self._build_description(event)\n\n        # Get impact and urgency\n        impact = self._get_impact_for_severity(event.severity)\n        urgency = self._get_urgency_for_severity(event.severity)\n\n        # Build the incident payload\n        payload: Dict[str, Any] = {\n            \"short_description\": short_description,\n            \"description\": description,\n            \"impact\": impact,\n            \"urgency\": urgency,\n            \"category\": self.snow_credentials.category,\n        }\n\n        # Add subcategory if configured\n        if self.snow_credentials.subcategory:\n            payload[\"subcategory\"] = self.snow_credentials.subcategory\n\n        # Add assignment group if configured\n        if self.snow_credentials.assignment_group:\n            payload[\"assignment_group\"] = self.snow_credentials.assignment_group\n\n        # Add assigned_to if configured\n        if self.snow_credentials.assigned_to:\n            payload[\"assigned_to\"] = self.snow_credentials.assigned_to\n\n        # Add caller_id if configured\n        if self.snow_credentials.caller_id:\n            payload[\"caller_id\"] = self.snow_credentials.caller_id\n\n        # Add correlation ID for tracking\n        if event.correlation_id:\n            payload[\"correlation_id\"] = event.correlation_id\n\n        # Add custom fields\n        for field_name, value in self.snow_credentials.custom_fields.items():\n            payload[field_name] = value\n\n        return payload\n\n    def _build_description(self, event: IntegrationEvent) -> str:\n        \"\"\"\n        Build the incident description from an event.\n\n        Args:\n            event: The governance event\n\n        Returns:\n            Formatted description string\n        \"\"\"\n        lines = [\n            f\"Event ID: {event.event_id}\",\n            f\"Event Type: {event.event_type}\",\n            f\"Severity: {event.severity.value.upper()}\",\n            f\"Timestamp: {event.timestamp.isoformat()}\",\n            f\"Source: {event.source}\",\n            \"\",\n        ]\n\n        if event.description:\n            lines.extend([\"Description:\", event.description, \"\"])\n\n        # Add policy information\n        if event.policy_id:\n            lines.append(f\"Policy ID: {event.policy_id}\")\n\n        # Add resource information\n        if event.resource_id or event.resource_type:\n            lines.append(\"\")\n            lines.append(\"=== Resource Information ===\")\n            if event.resource_id:\n                lines.append(f\"Resource ID: {event.resource_id}\")\n            if event.resource_type:\n                lines.append(f\"Resource Type: {event.resource_type}\")\n\n        # Add action/outcome\n        if event.action or event.outcome:\n            lines.append(\"\")\n            lines.append(\"=== Action Details ===\")\n            if event.action:\n                lines.append(f\"Action: {event.action}\")\n            if event.outcome:\n                lines.append(f\"Outcome: {event.outcome}\")\n\n        # Add metadata\n        if event.user_id or event.tenant_id or event.correlation_id:\n            lines.append(\"\")\n            lines.append(\"=== Metadata ===\")\n            if event.user_id:\n                lines.append(f\"User ID: {event.user_id}\")\n            if event.tenant_id:\n                lines.append(f\"Tenant ID: {event.tenant_id}\")\n            if event.correlation_id:\n                lines.append(f\"Correlation ID: {event.correlation_id}\")\n\n        # Add full event details if configured\n        if self.snow_credentials.include_event_details and event.details:\n            lines.append(\"\")\n            lines.append(\"=== Event Details (JSON) ===\")\n            lines.append(json.dumps(event.details, indent=2))\n\n        # Add tags\n        if event.tags:\n            lines.append(\"\")\n            lines.append(f\"Tags: {', '.join(event.tags)}\")\n\n        # Footer\n        lines.extend(\n            [\n                \"\",\n                \"---\",\n                \"This incident was automatically created by ACGS-2 Governance Platform.\",\n            ]\n        )\n\n        return \"\\n\".join(lines)\n\n    def _get_impact_for_severity(self, severity: EventSeverity) -> str:\n        \"\"\"\n        Get ServiceNow impact value for a given severity level.\n\n        Uses custom mapping if configured, otherwise uses defaults.\n        ServiceNow impact: 1 = High, 2 = Medium, 3 = Low\n\n        Args:\n            severity: Event severity level\n\n        Returns:\n            ServiceNow impact value (1, 2, or 3)\n        \"\"\"\n        # Check custom mapping first\n        custom_impact = self.snow_credentials.impact_mapping.get(severity.value)\n        if custom_impact:\n            return custom_impact\n\n        # Use default mapping\n        return DEFAULT_IMPACT_MAP.get(severity, \"2\")\n\n    def _get_urgency_for_severity(self, severity: EventSeverity) -> str:\n        \"\"\"\n        Get ServiceNow urgency value for a given severity level.\n\n        Uses custom mapping if configured, otherwise uses defaults.\n        ServiceNow urgency: 1 = High, 2 = Medium, 3 = Low\n\n        Args:\n            severity: Event severity level\n\n        Returns:\n            ServiceNow urgency value (1, 2, or 3)\n        \"\"\"\n        # Check custom mapping first\n        custom_urgency = self.snow_credentials.urgency_mapping.get(severity.value)\n        if custom_urgency:\n            return custom_urgency\n\n        # Use default mapping\n        return DEFAULT_URGENCY_MAP.get(severity, \"2\")\n\n    async def _do_test_connection(self) -> IntegrationResult:\n        \"\"\"\n        Test connection to ServiceNow without authenticating.\n\n        Returns:\n            IntegrationResult indicating connection status\n        \"\"\"\n        logger.debug(f\"Testing ServiceNow connection for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Try to reach the instance (will get auth error but confirms reachability)\n            test_url = f\"{self._get_base_url()}/api/now/table/sys_properties\"\n\n            response = await client.get(\n                test_url,\n                params={\"sysparm_limit\": \"1\"},\n            )\n\n            # Any response (even 401) indicates the server is reachable\n            if response.status_code < 500:\n                logger.debug(f\"ServiceNow instance reachable at {self.snow_credentials.instance}\")\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                )\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Server returned status {response.status_code}\",\n                )\n\n        except httpx.TimeoutException:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"TIMEOUT\",\n                error_message=f\"Connection timed out after {self.timeout}s\",\n            )\n\n        except httpx.NetworkError as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"NETWORK_ERROR\",\n                error_message=str(e),\n            )\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"UNKNOWN_ERROR\",\n                error_message=str(e),\n            )\n\n    async def get_incident(self, incident_number: str) -> IntegrationResult:\n        \"\"\"\n        Get details of an existing ServiceNow incident.\n\n        Args:\n            incident_number: The incident number (e.g., INC0010001)\n\n        Returns:\n            IntegrationResult with incident details or error\n        \"\"\"\n        if not self._authenticated:\n            raise AuthenticationError(\"Integration is not authenticated\", self.name)\n\n        logger.debug(f\"Fetching ServiceNow incident {incident_number}\")\n\n        try:\n            # Refresh OAuth token if needed\n            if self.snow_credentials.auth_type == ServiceNowAuthType.OAUTH:\n                if not await self._refresh_oauth_token():\n                    raise AuthenticationError(\n                        \"Failed to refresh OAuth token\",\n                        self.name,\n                    )\n\n            client = await self.get_http_client()\n            headers = await self._get_auth_headers()\n\n            incident_url = f\"{self._get_table_url(self.INCIDENT_TABLE)}\"\n            params = {\"sysparm_query\": f\"number={incident_number}\"}\n\n            response = await client.get(\n                incident_url,\n                headers=headers,\n                params=params,\n            )\n\n            if response.status_code == 200:\n                response_data = response.json()\n                results = response_data.get(\"result\", [])\n\n                if results:\n                    incident = results[0]\n                    sys_id = incident.get(\"sys_id\")\n                    return IntegrationResult(\n                        success=True,\n                        integration_name=self.name,\n                        operation=\"get_incident\",\n                        external_id=incident_number,\n                        external_url=f\"{self._get_base_url()}/nav_to.do?uri=incident.do?sys_id={sys_id}\",\n                        error_details=incident,  # Using error_details to pass data\n                    )\n                else:\n                    return IntegrationResult(\n                        success=False,\n                        integration_name=self.name,\n                        operation=\"get_incident\",\n                        error_code=\"NOT_FOUND\",\n                        error_message=f\"Incident {incident_number} not found\",\n                    )\n\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"get_incident\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Failed to fetch incident: HTTP {response.status_code}\",\n                )\n\n        except AuthenticationError:\n            raise\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"get_incident\",\n                error_code=\"ERROR\",\n                error_message=str(e),\n            )\n\n    async def add_work_note(self, incident_number: str, note: str) -> IntegrationResult:\n        \"\"\"\n        Add a work note to an existing ServiceNow incident.\n\n        Args:\n            incident_number: The incident number (e.g., INC0010001)\n            note: The work note text\n\n        Returns:\n            IntegrationResult with update status or error\n        \"\"\"\n        if not self._authenticated:\n            raise AuthenticationError(\"Integration is not authenticated\", self.name)\n\n        logger.debug(f\"Adding work note to ServiceNow incident {incident_number}\")\n\n        try:\n            # Refresh OAuth token if needed\n            if self.snow_credentials.auth_type == ServiceNowAuthType.OAUTH:\n                if not await self._refresh_oauth_token():\n                    raise AuthenticationError(\n                        \"Failed to refresh OAuth token\",\n                        self.name,\n                    )\n\n            # First, get the incident sys_id\n            get_result = await self.get_incident(incident_number)\n            if not get_result.success:\n                return get_result\n\n            sys_id = get_result.error_details.get(\"sys_id\")\n\n            client = await self.get_http_client()\n            headers = await self._get_auth_headers()\n\n            update_url = f\"{self._get_table_url(self.INCIDENT_TABLE)}/{sys_id}\"\n\n            response = await client.patch(\n                update_url,\n                headers=headers,\n                json={\"work_notes\": note},\n            )\n\n            if response.status_code == 200:\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"add_work_note\",\n                    external_id=incident_number,\n                )\n\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"add_work_note\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Failed to add work note: HTTP {response.status_code}\",\n                )\n\n        except AuthenticationError:\n            raise\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"add_work_note\",\n                error_code=\"ERROR\",\n                error_message=str(e),\n            )\n\n    async def close(self) -> None:\n        \"\"\"Close the integration and cleanup resources\"\"\"\n        self._access_token = None\n        self._token_expires_at = None\n        await super().close()\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.752911",
  "last_updated": "2026-01-04T00:39:57.755978"
}