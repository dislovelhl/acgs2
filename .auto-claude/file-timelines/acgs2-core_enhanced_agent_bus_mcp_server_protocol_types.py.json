{
  "file_path": "acgs2-core/enhanced_agent_bus/mcp_server/protocol/types.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nMCP Protocol Types for ACGS-2 Constitutional Governance.\n\nImplements JSON-RPC 2.0 based MCP protocol types as per the Model Context Protocol\nspecification.\n\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport json\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\n\nclass MCPErrorCode(Enum):\n    \"\"\"Standard MCP error codes.\"\"\"\n\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n\n    # ACGS-2 specific error codes\n    CONSTITUTIONAL_VIOLATION = -32001\n    GOVERNANCE_DENIED = -32002\n    VALIDATION_FAILED = -32003\n    AUDIT_REQUIRED = -32004\n    HASH_MISMATCH = -32005\n\n\n@dataclass\nclass MCPRequest:\n    \"\"\"JSON-RPC 2.0 request for MCP.\"\"\"\n\n    jsonrpc: str\n    method: str\n    id: Optional[Union[str, int]] = None\n    params: Optional[Dict[str, Any]] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        result = {\n            \"jsonrpc\": self.jsonrpc,\n            \"method\": self.method,\n        }\n        if self.id is not None:\n            result[\"id\"] = self.id\n        if self.params is not None:\n            result[\"params\"] = self.params\n        return result\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"MCPRequest\":\n        \"\"\"Create from dictionary.\"\"\"\n        return cls(\n            jsonrpc=data.get(\"jsonrpc\", \"2.0\"),\n            method=data[\"method\"],\n            id=data.get(\"id\"),\n            params=data.get(\"params\"),\n        )\n\n    def to_json(self) -> str:\n        \"\"\"Serialize to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> \"MCPRequest\":\n        \"\"\"Parse from JSON string.\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def is_notification(self) -> bool:\n        \"\"\"Check if this is a notification (no id means no response expected).\"\"\"\n        return self.id is None\n\n\n@dataclass\nclass MCPError:\n    \"\"\"JSON-RPC 2.0 error object.\"\"\"\n\n    code: int\n    message: str\n    data: Optional[Dict[str, Any]] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        result = {\n            \"code\": self.code,\n            \"message\": self.message,\n        }\n        if self.data is not None:\n            result[\"data\"] = self.data\n        return result\n\n    @classmethod\n    def from_code(\n        cls,\n        code: MCPErrorCode,\n        message: Optional[str] = None,\n        data: Optional[Dict[str, Any]] = None,\n    ) -> \"MCPError\":\n        \"\"\"Create error from error code enum.\"\"\"\n        return cls(\n            code=code.value,\n            message=message or code.name.replace(\"_\", \" \").title(),\n            data=data,\n        )\n\n    @classmethod\n    def constitutional_violation(\n        cls, reason: str, context: Optional[Dict[str, Any]] = None\n    ) -> \"MCPError\":\n        \"\"\"Create constitutional violation error.\"\"\"\n        return cls(\n            code=MCPErrorCode.CONSTITUTIONAL_VIOLATION.value,\n            message=f\"Constitutional violation: {reason}\",\n            data={\n                \"constitutional_hash\": \"cdd01ef066bc6cf2\",\n                \"violation_reason\": reason,\n                \"context\": context or {},\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            },\n        )\n\n    @classmethod\n    def governance_denied(\n        cls, reason: str, violations: Optional[List[Dict[str, Any]]] = None\n    ) -> \"MCPError\":\n        \"\"\"Create governance denied error.\"\"\"\n        return cls(\n            code=MCPErrorCode.GOVERNANCE_DENIED.value,\n            message=f\"Governance denied: {reason}\",\n            data={\n                \"constitutional_hash\": \"cdd01ef066bc6cf2\",\n                \"denial_reason\": reason,\n                \"violations\": violations or [],\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            },\n        )\n\n    @classmethod\n    def validation_failed(cls, field: str, reason: str) -> \"MCPError\":\n        \"\"\"Create validation failed error.\"\"\"\n        return cls(\n            code=MCPErrorCode.VALIDATION_FAILED.value,\n            message=f\"Validation failed for '{field}': {reason}\",\n            data={\n                \"constitutional_hash\": \"cdd01ef066bc6cf2\",\n                \"field\": field,\n                \"reason\": reason,\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            },\n        )\n\n\n@dataclass\nclass MCPResponse:\n    \"\"\"JSON-RPC 2.0 response for MCP.\"\"\"\n\n    jsonrpc: str\n    id: Optional[Union[str, int]]\n    result: Optional[Any] = None\n    error: Optional[MCPError] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        response = {\n            \"jsonrpc\": self.jsonrpc,\n            \"id\": self.id,\n        }\n        if self.error is not None:\n            response[\"error\"] = self.error.to_dict()\n        else:\n            response[\"result\"] = self.result\n        return response\n\n    @classmethod\n    def success(cls, id: Optional[Union[str, int]], result: Any) -> \"MCPResponse\":\n        \"\"\"Create success response.\"\"\"\n        return cls(jsonrpc=\"2.0\", id=id, result=result)\n\n    @classmethod\n    def failure(cls, id: Optional[Union[str, int]], error: MCPError) -> \"MCPResponse\":\n        \"\"\"Create error response.\"\"\"\n        return cls(jsonrpc=\"2.0\", id=id, error=error)\n\n    def to_json(self) -> str:\n        \"\"\"Serialize to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n\n\n@dataclass\nclass MCPNotification:\n    \"\"\"JSON-RPC 2.0 notification (no id, no response expected).\"\"\"\n\n    jsonrpc: str\n    method: str\n    params: Optional[Dict[str, Any]] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        result = {\n            \"jsonrpc\": self.jsonrpc,\n            \"method\": self.method,\n        }\n        if self.params is not None:\n            result[\"params\"] = self.params\n        return result\n\n    def to_json(self) -> str:\n        \"\"\"Serialize to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n\n\n@dataclass\nclass ToolInputSchema:\n    \"\"\"JSON Schema for tool input.\"\"\"\n\n    type: str = \"object\"\n    properties: Dict[str, Any] = field(default_factory=dict)\n    required: List[str] = field(default_factory=list)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"type\": self.type,\n            \"properties\": self.properties,\n            \"required\": self.required,\n        }\n\n\n@dataclass\nclass ToolDefinition:\n    \"\"\"MCP Tool definition.\"\"\"\n\n    name: str\n    description: str\n    inputSchema: Union[ToolInputSchema, Dict[str, Any]]\n    constitutional_required: bool = True  # ACGS-2 specific\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for MCP protocol.\"\"\"\n        # Handle both ToolInputSchema and raw dict\n        if isinstance(self.inputSchema, dict):\n            schema = self.inputSchema\n        else:\n            schema = self.inputSchema.to_dict()\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"inputSchema\": schema,\n        }\n\n\n@dataclass\nclass ResourceDefinition:\n    \"\"\"MCP Resource definition.\"\"\"\n\n    uri: str\n    name: str\n    description: str\n    mimeType: str = \"application/json\"\n    constitutional_scope: str = \"read\"  # ACGS-2: read, write, governance\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for MCP protocol.\"\"\"\n        return {\n            \"uri\": self.uri,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"mimeType\": self.mimeType,\n        }\n\n\n@dataclass\nclass PromptArgument:\n    \"\"\"MCP Prompt argument.\"\"\"\n\n    name: str\n    description: str\n    required: bool = True\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"required\": self.required,\n        }\n\n\n@dataclass\nclass PromptDefinition:\n    \"\"\"MCP Prompt definition.\"\"\"\n\n    name: str\n    description: str\n    arguments: List[PromptArgument] = field(default_factory=list)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for MCP protocol.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"arguments\": [arg.to_dict() for arg in self.arguments],\n        }\n\n\n# Server capability types\n@dataclass\nclass ServerCapabilities:\n    \"\"\"MCP Server capabilities.\"\"\"\n\n    tools: Optional[Dict[str, Any]] = None\n    resources: Optional[Dict[str, Any]] = None\n    prompts: Optional[Dict[str, Any]] = None\n    logging: Optional[Dict[str, Any]] = None\n\n    # ACGS-2 specific capabilities\n    constitutional_governance: bool = True\n    audit_trail: bool = True\n    maci_separation: bool = True\n\n    def __post_init__(self):\n        \"\"\"Set defaults for capabilities.\"\"\"\n        if self.tools is None:\n            self.tools = {\"listChanged\": True}\n        if self.resources is None:\n            self.resources = {\"subscribe\": True, \"listChanged\": True}\n        if self.prompts is None:\n            self.prompts = {\"listChanged\": False}\n        if self.logging is None:\n            self.logging = {}\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        capabilities = {}\n        if self.tools is not None:\n            capabilities[\"tools\"] = self.tools\n        if self.resources is not None:\n            capabilities[\"resources\"] = self.resources\n        if self.prompts is not None:\n            capabilities[\"prompts\"] = self.prompts\n        if self.logging is not None:\n            capabilities[\"logging\"] = self.logging\n\n        # ACGS-2 experimental capabilities\n        capabilities[\"experimental\"] = {\n            \"constitutional_governance\": self.constitutional_governance,\n            \"audit_trail\": self.audit_trail,\n            \"maci_separation\": self.maci_separation,\n            \"constitutional_hash\": \"cdd01ef066bc6cf2\",\n        }\n\n        return capabilities\n\n\n@dataclass\nclass ServerInfo:\n    \"\"\"MCP Server information.\"\"\"\n\n    name: str\n    version: str\n    constitutional_hash: str = \"cdd01ef066bc6cf2\"\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"version\": self.version,\n        }\n\n\n@dataclass\nclass InitializeResult:\n    \"\"\"Result of MCP initialize request.\"\"\"\n\n    protocolVersion: str\n    capabilities: ServerCapabilities\n    serverInfo: ServerInfo\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"protocolVersion\": self.protocolVersion,\n            \"capabilities\": self.capabilities.to_dict(),\n            \"serverInfo\": self.serverInfo.to_dict(),\n        }\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.309227",
  "last_updated": "2026-01-04T05:35:58.886501"
}