{
  "file_path": "integration-service/src/webhooks/delivery.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhook delivery engine with exponential backoff retry logic.\n\nProvides the core delivery infrastructure for sending webhook events to\nconfigured endpoints with authentication, retry logic, and delivery tracking.\n\"\"\"\n\nimport asyncio\nimport hashlib\nimport hmac\nimport json\nimport logging\nimport time\nimport warnings\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional, Set\nfrom uuid import uuid4\n\nimport httpx\n\nfrom exceptions.auth import AuthenticationError\nfrom exceptions.delivery import (\n    DeliveryConnectionError,\n    DeliveryError,\n    DeliveryTimeoutError,\n)\n\nfrom .config import WebhookFrameworkConfig, WebhookRetryPolicy\nfrom .models import (\n    WebhookAuthType,\n    WebhookConfig,\n    WebhookDelivery,\n    WebhookDeliveryResult,\n    WebhookDeliveryStatus,\n    WebhookEvent,\n    WebhookSubscription,\n)\nfrom .retry import (\n    ExponentialBackoff,\n    NonRetryableError,\n    RetryableError,\n    RetryState,\n    extract_retry_after,\n    should_retry_status_code,\n)\n\nlogger = logging.getLogger(__name__)\n\n\n# Backward compatibility aliases\n# These maintain API compatibility for existing code that imports from webhooks.delivery\nclass WebhookDeliveryError(DeliveryError):\n    \"\"\"\n    Deprecated: Use DeliveryError from exceptions.delivery instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookDeliveryError is deprecated. \"\n            \"Use DeliveryError from exceptions.delivery instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n\nclass WebhookAuthenticationError(AuthenticationError):\n    \"\"\"\n    Deprecated: Use AuthenticationError from exceptions.auth instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookAuthenticationError is deprecated. \"\n            \"Use AuthenticationError from exceptions.auth instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n\nclass WebhookTimeoutError(DeliveryTimeoutError):\n    \"\"\"\n    Deprecated: Use DeliveryTimeoutError from exceptions.delivery instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookTimeoutError is deprecated. \"\n            \"Use DeliveryTimeoutError from exceptions.delivery instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n\nclass WebhookConnectionError(DeliveryConnectionError):\n    \"\"\"\n    Deprecated: Use DeliveryConnectionError from exceptions.delivery instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookConnectionError is deprecated. \"\n            \"Use DeliveryConnectionError from exceptions.delivery instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n# Public API exports - make exceptions and classes available for import from this module\n__all__ = [\n    \"WebhookDeliveryError\",\n    \"WebhookAuthenticationError\",\n    \"WebhookTimeoutError\",\n    \"WebhookConnectionError\",\n    \"DeliveryError\",\n    \"DeliveryTimeoutError\",\n    \"DeliveryConnectionError\",\n    \"AuthenticationError\",\n    \"DeadLetterQueue\",\n    \"WebhookDeliveryEngine\",\n]\n\n\nclass DeadLetterQueue:\n    \"\"\"\n    Simple in-memory dead letter queue for failed webhook deliveries.\n\n    In production, this would be backed by Redis or a database.\n    \"\"\"\n\n    def __init__(self, max_size: int = 10000):\n        self.max_size = max_size\n        self._queue: List[Dict[str, Any]] = []\n        self._lock = asyncio.Lock()\n\n    async def add(\n        self,\n        delivery: WebhookDelivery,\n        event: WebhookEvent,\n        error_message: str,\n    ) -> None:\n        \"\"\"Add a failed delivery to the dead letter queue.\"\"\"\n        async with self._lock:\n            if len(self._queue) >= self.max_size:\n                # Remove oldest entry\n                self._queue.pop(0)\n\n            self._queue.append(\n                {\n                    \"delivery_id\": delivery.id,\n                    \"subscription_id\": delivery.subscription_id,\n                    \"event_id\": event.id,\n                    \"event_type\": event.event_type.value,\n                    \"error_message\": error_message,\n                    \"attempt_count\": delivery.attempt_number,\n                    \"dead_lettered_at\": datetime.now(timezone.utc).isoformat(),\n                    \"payload\": event.to_payload(),\n                }\n            )\n\n            logger.info(\n                f\"Delivery {delivery.id} dead-lettered after {delivery.attempt_number} attempts: \"\n                f\"{error_message}\"\n            )\n\n    async def get_all(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all dead-lettered deliveries.\"\"\"\n        async with self._lock:\n            return list(self._queue)\n\n    async def get_by_subscription(self, subscription_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get dead-lettered deliveries for a specific subscription.\"\"\"\n        async with self._lock:\n            return [d for d in self._queue if d[\"subscription_id\"] == subscription_id]\n\n    async def remove(self, delivery_id: str) -> bool:\n        \"\"\"Remove a delivery from the dead letter queue.\"\"\"\n        async with self._lock:\n            for i, item in enumerate(self._queue):\n                if item[\"delivery_id\"] == delivery_id:\n                    self._queue.pop(i)\n                    return True\n            return False\n\n    async def clear(self) -> int:\n        \"\"\"Clear all dead-lettered deliveries. Returns count of removed items.\"\"\"\n        async with self._lock:\n            count = len(self._queue)\n            self._queue.clear()\n            return count\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get current queue size.\"\"\"\n        return len(self._queue)\n\n\nclass WebhookDeliveryEngine:\n    \"\"\"\n    Core webhook delivery engine with exponential backoff retry logic.\n\n    Handles:\n    - Webhook payload delivery with configurable authentication\n    - HMAC signature generation for payload verification\n    - Exponential backoff retry with jitter\n    - Dead letter queue for failed deliveries\n    - Delivery tracking and metrics\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[WebhookFrameworkConfig] = None,\n        http_client: Optional[httpx.AsyncClient] = None,\n    ):\n        \"\"\"\n        Initialize the webhook delivery engine.\n\n        Args:\n            config: Framework configuration (defaults to standard config)\n            http_client: Optional pre-configured HTTP client\n        \"\"\"\n        self.config = config or WebhookFrameworkConfig()\n        self._http_client = http_client\n        self._owns_client = http_client is None\n        self.dead_letter_queue = DeadLetterQueue()\n\n        # Metrics\n        self._deliveries_attempted = 0\n        self._deliveries_succeeded = 0\n        self._deliveries_failed = 0\n        self._deliveries_retried = 0\n\n        # Semaphore for concurrency control\n        self._semaphore = asyncio.Semaphore(self.config.max_concurrent_deliveries)\n\n        # Active deliveries tracking\n        self._active_deliveries: Set[str] = set()\n\n    async def _get_http_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create the HTTP client.\"\"\"\n        if self._http_client is None or self._http_client.is_closed:\n            self._http_client = httpx.AsyncClient(\n                timeout=self.config.default_timeout_seconds,\n                follow_redirects=True,\n            )\n            self._owns_client = True\n        return self._http_client\n\n    async def close(self) -> None:\n        \"\"\"Close the delivery engine and cleanup resources.\"\"\"\n        if self._owns_client and self._http_client is not None:\n            await self._http_client.aclose()\n            self._http_client = None\n\n    @property\n    def metrics(self) -> Dict[str, Any]:\n        \"\"\"Get delivery metrics.\"\"\"\n        total = self._deliveries_attempted or 1  # Avoid division by zero\n        return {\n            \"deliveries_attempted\": self._deliveries_attempted,\n            \"deliveries_succeeded\": self._deliveries_succeeded,\n            \"deliveries_failed\": self._deliveries_failed,\n            \"deliveries_retried\": self._deliveries_retried,\n            \"success_rate\": self._deliveries_succeeded / total,\n            \"failure_rate\": self._deliveries_failed / total,\n            \"dead_letter_queue_size\": self.dead_letter_queue.size,\n            \"active_deliveries\": len(self._active_deliveries),\n        }\n\n    def _generate_hmac_signature(\n        self,\n        payload: bytes,\n        secret: str,\n        algorithm: str = \"sha256\",\n    ) -> str:\n        \"\"\"\n        Generate HMAC signature for a webhook payload.\n\n        Uses constant-time comparison to prevent timing attacks.\n\n        Args:\n            payload: The payload bytes to sign\n            secret: The HMAC secret key\n            algorithm: Hash algorithm (sha256 or sha512)\n\n        Returns:\n            Hex-encoded HMAC signature\n        \"\"\"\n        if algorithm == \"sha512\":\n            hash_func = hashlib.sha512\n        else:\n            hash_func = hashlib.sha256\n\n        signature = hmac.new(\n            secret.encode(\"utf-8\"),\n            payload,\n            hash_func,\n        ).hexdigest()\n\n        return f\"{algorithm}={signature}\"\n\n    def _build_headers(\n        self,\n        webhook_config: WebhookConfig,\n        payload: bytes,\n        timestamp: Optional[str] = None,\n    ) -> Dict[str, str]:\n        \"\"\"\n        Build request headers including authentication and signatures.\n\n        Args:\n            webhook_config: Webhook endpoint configuration\n            payload: Request payload bytes\n            timestamp: Optional timestamp string for replay protection\n\n        Returns:\n            Dictionary of HTTP headers\n        \"\"\"\n        headers: Dict[str, str] = {\n            \"Content-Type\": webhook_config.content_type,\n            \"User-Agent\": \"ACGS2-Webhook/1.0\",\n            \"X-Webhook-Delivery-ID\": str(uuid4()),\n        }\n\n        # Add timestamp for replay protection\n        if timestamp is None:\n            timestamp = datetime.now(timezone.utc).isoformat()\n        headers[self.config.security.timestamp_header] = timestamp\n\n        # Add custom headers\n        headers.update(webhook_config.custom_headers)\n\n        # Add authentication\n        if webhook_config.auth_type == WebhookAuthType.API_KEY:\n            if webhook_config.auth_value:\n                headers[webhook_config.auth_header] = webhook_config.auth_value.get_secret_value()\n\n        elif webhook_config.auth_type == WebhookAuthType.BEARER:\n            if webhook_config.auth_value:\n                headers[webhook_config.auth_header] = (\n                    f\"Bearer {webhook_config.auth_value.get_secret_value()}\"\n                )\n\n        elif webhook_config.auth_type == WebhookAuthType.BASIC:\n            if webhook_config.auth_value:\n                import base64\n\n                credentials = webhook_config.auth_value.get_secret_value()\n                encoded = base64.b64encode(credentials.encode(\"utf-8\")).decode(\"utf-8\")\n                headers[webhook_config.auth_header] = f\"Basic {encoded}\"\n\n        elif webhook_config.auth_type == WebhookAuthType.HMAC:\n            if webhook_config.hmac_secret:\n                signature = self._generate_hmac_signature(\n                    payload,\n                    webhook_config.hmac_secret.get_secret_value(),\n                    webhook_config.hmac_algorithm.value,\n                )\n                headers[webhook_config.hmac_header] = signature\n\n        return headers\n\n    async def _make_request(\n        self,\n        webhook_config: WebhookConfig,\n        payload: Dict[str, Any],\n    ) -> httpx.Response:\n        \"\"\"\n        Make an HTTP request to the webhook endpoint.\n\n        Args:\n            webhook_config: Webhook endpoint configuration\n            payload: JSON payload to send\n\n        Returns:\n            HTTP response\n\n        Raises:\n            RetryableError: For retryable failures\n            NonRetryableError: For non-retryable failures\n        \"\"\"\n        client = await self._get_http_client()\n        payload_bytes = json.dumps(payload).encode(\"utf-8\")\n        headers = self._build_headers(webhook_config, payload_bytes)\n\n        try:\n            if webhook_config.method == \"POST\":\n                response = await client.post(\n                    webhook_config.url,\n                    content=payload_bytes,\n                    headers=headers,\n                    timeout=webhook_config.timeout_seconds,\n                )\n            else:\n                response = await client.put(\n                    webhook_config.url,\n                    content=payload_bytes,\n                    headers=headers,\n                    timeout=webhook_config.timeout_seconds,\n                )\n\n            return response\n\n        except httpx.TimeoutException as e:\n            raise RetryableError(f\"Request timed out: {e}\") from e\n\n        except httpx.ConnectError as e:\n            raise RetryableError(f\"Connection failed: {e}\") from e\n\n        except httpx.NetworkError as e:\n            raise RetryableError(f\"Network error: {e}\") from e\n\n        except Exception as e:\n            raise NonRetryableError(f\"Unexpected error: {e}\") from e\n\n    async def deliver(\n        self,\n        subscription: WebhookSubscription,\n        event: WebhookEvent,\n    ) -> WebhookDeliveryResult:\n        \"\"\"\n        Deliver a webhook event to a subscription endpoint with retry logic.\n\n        Args:\n            subscription: The webhook subscription\n            event: The event to deliver\n\n        Returns:\n            WebhookDeliveryResult with delivery outcome\n        \"\"\"\n        delivery = WebhookDelivery(\n            subscription_id=subscription.id,\n            event_id=event.id,\n            max_attempts=subscription.max_retries + 1,  # Initial + retries\n        )\n\n        # Track active delivery\n        self._active_deliveries.add(delivery.id)\n        self._deliveries_attempted += 1\n\n        # Get retry policy from subscription or use defaults\n        retry_policy = WebhookRetryPolicy(\n            max_attempts=subscription.max_retries + 1,\n            initial_delay_seconds=subscription.retry_delay_seconds,\n            max_delay_seconds=subscription.max_retry_delay_seconds,\n            exponential_base=subscription.retry_exponential_base,\n        )\n        backoff = ExponentialBackoff.from_policy(retry_policy)\n        retry_state = RetryState(\n            max_attempts=retry_policy.max_attempts,\n            backoff=backoff,\n        )\n\n        payload = event.to_payload()\n        start_time = time.monotonic()\n\n        try:\n            async with self._semaphore:\n                return await self._deliver_with_retry(\n                    subscription=subscription,\n                    event=event,\n                    delivery=delivery,\n                    payload=payload,\n                    retry_policy=retry_policy,\n                    retry_state=retry_state,\n                    start_time=start_time,\n                )\n        finally:\n            self._active_deliveries.discard(delivery.id)\n\n    async def _deliver_with_retry(\n        self,\n        subscription: WebhookSubscription,\n        event: WebhookEvent,\n        delivery: WebhookDelivery,\n        payload: Dict[str, Any],\n        retry_policy: WebhookRetryPolicy,\n        retry_state: RetryState,\n        start_time: float,\n    ) -> WebhookDeliveryResult:\n        \"\"\"\n        Execute delivery with exponential backoff retry logic.\n\n        Args:\n            subscription: The webhook subscription\n            event: The event being delivered\n            delivery: The delivery tracking object\n            payload: Event payload\n            retry_policy: Retry configuration\n            retry_state: Retry state tracker\n            start_time: Delivery start time (monotonic)\n\n        Returns:\n            WebhookDeliveryResult with outcome\n        \"\"\"\n        retryable_codes = set(retry_policy.retry_on_status_codes)\n        last_status_code: Optional[int] = None\n\n        while retry_state.current_attempt < retry_policy.max_attempts:\n            retry_state.start()\n            delivery.attempt_number = retry_state.current_attempt\n            delivery.started_at = datetime.now(timezone.utc)\n            delivery.status = (\n                WebhookDeliveryStatus.RETRYING\n                if retry_state.current_attempt > 1\n                else WebhookDeliveryStatus.PENDING\n            )\n            delivery.request_url = subscription.config.url\n            delivery.request_method = subscription.config.method\n\n            try:\n                response = await self._make_request(subscription.config, payload)\n                duration_ms = int((time.monotonic() - start_time) * 1000)\n                delivery.completed_at = datetime.now(timezone.utc)\n                delivery.duration_ms = duration_ms\n                delivery.response_status_code = response.status_code\n                delivery.response_body = (\n                    response.text[: self.config.max_response_size_bytes] if response.text else None\n                )\n\n                # Check if we should retry based on status code\n                if should_retry_status_code(response.status_code, retryable_codes):\n                    last_status_code = response.status_code\n                    retry_after = extract_retry_after(response)\n\n                    error = RetryableError(\n                        f\"HTTP {response.status_code}\",\n                        status_code=response.status_code,\n                        retry_after=retry_after,\n                    )\n                    retry_state.record_error(error, response.status_code)\n\n                    if retry_state.can_retry:\n                        self._deliveries_retried += 1\n                        delay = retry_after if retry_after else retry_state.next_delay\n                        delivery.next_retry_at = datetime.now(timezone.utc)\n                        delivery.next_retry_at = retry_state.next_retry_at\n\n                        logger.warning(\n                            f\"Delivery {delivery.id} attempt {retry_state.current_attempt} \"\n                            f\"got HTTP {response.status_code}. Retrying in {delay:.2f}s\"\n                        )\n                        await asyncio.sleep(delay)\n                        continue\n                    else:\n                        # Exhausted retries\n                        err_msg = (\n                            f\"Delivery failed with HTTP {response.status_code} \"\n                            f\"after {retry_state.current_attempt} attempts\"\n                        )\n                        return await self._handle_delivery_failure(\n                            delivery=delivery,\n                            event=event,\n                            error_code=f\"HTTP_{response.status_code}\",\n                            error_message=err_msg,\n                            duration_ms=duration_ms,\n                            status_code=response.status_code,\n                            max_attempts=retry_policy.max_attempts,\n                        )\n\n                # Check for client errors (4xx) - these are typically not retryable\n                if 400 <= response.status_code < 500:\n                    delivery.status = WebhookDeliveryStatus.FAILED\n                    self._deliveries_failed += 1\n\n                    error_code = f\"HTTP_{response.status_code}\"\n                    error_message = f\"Client error: HTTP {response.status_code}\"\n\n                    return WebhookDeliveryResult.failure_result(\n                        delivery_id=delivery.id,\n                        subscription_id=subscription.id,\n                        event_id=event.id,\n                        error_code=error_code,\n                        error_message=error_message,\n                        status_code=response.status_code,\n                        duration_ms=duration_ms,\n                        attempt_number=retry_state.current_attempt,\n                        should_retry=False,\n                        max_attempts=retry_policy.max_attempts,\n                    )\n\n                # Success (2xx or 3xx)\n                if response.status_code < 400:\n                    delivery.status = WebhookDeliveryStatus.DELIVERED\n                    self._deliveries_succeeded += 1\n\n                    logger.info(\n                        f\"Delivery {delivery.id} succeeded on attempt \"\n                        f\"{retry_state.current_attempt} with HTTP {response.status_code}\"\n                    )\n\n                    return WebhookDeliveryResult.success_result(\n                        delivery_id=delivery.id,\n                        subscription_id=subscription.id,\n                        event_id=event.id,\n                        status_code=response.status_code,\n                        duration_ms=duration_ms,\n                        attempt_number=retry_state.current_attempt,\n                    )\n\n            except RetryableError as e:\n                last_status_code = e.status_code\n                retry_state.record_error(e, e.status_code)\n                delivery.error_code = \"RETRYABLE_ERROR\"\n                delivery.error_message = str(e)\n\n                if retry_state.can_retry:\n                    self._deliveries_retried += 1\n                    delay = e.retry_after if e.retry_after else retry_state.next_delay\n                    delivery.next_retry_at = retry_state.next_retry_at\n\n                    logger.warning(\n                        f\"Delivery {delivery.id} attempt \"\n                        f\"{retry_state.current_attempt} failed: {e}. \"\n                        f\"Retrying in {delay:.2f}s\"\n                    )\n                    await asyncio.sleep(delay)\n                    continue\n                else:\n                    duration_ms = int((time.monotonic() - start_time) * 1000)\n                    err_msg = (\n                        f\"Delivery failed after \" f\"{retry_state.current_attempt} attempts: {e}\"\n                    )\n                    return await self._handle_delivery_failure(\n                        delivery=delivery,\n                        event=event,\n                        error_code=\"MAX_RETRIES_EXCEEDED\",\n                        error_message=err_msg,\n                        duration_ms=duration_ms,\n                        status_code=e.status_code,\n                        max_attempts=retry_policy.max_attempts,\n                    )\n\n            except NonRetryableError as e:\n                duration_ms = int((time.monotonic() - start_time) * 1000)\n                delivery.completed_at = datetime.now(timezone.utc)\n                delivery.duration_ms = duration_ms\n                delivery.status = WebhookDeliveryStatus.FAILED\n                delivery.error_code = \"NON_RETRYABLE_ERROR\"\n                delivery.error_message = str(e)\n                self._deliveries_failed += 1\n\n                logger.error(f\"Delivery {delivery.id} failed with non-retryable error: {e}\")\n\n                return WebhookDeliveryResult.failure_result(\n                    delivery_id=delivery.id,\n                    subscription_id=subscription.id,\n                    event_id=event.id,\n                    error_code=\"NON_RETRYABLE_ERROR\",\n                    error_message=str(e),\n                    status_code=e.status_code,\n                    duration_ms=duration_ms,\n                    attempt_number=retry_state.current_attempt,\n                    should_retry=False,\n                    max_attempts=retry_policy.max_attempts,\n                )\n\n            except Exception as e:\n                duration_ms = int((time.monotonic() - start_time) * 1000)\n                delivery.completed_at = datetime.now(timezone.utc)\n                delivery.duration_ms = duration_ms\n                delivery.status = WebhookDeliveryStatus.FAILED\n                delivery.error_code = \"UNEXPECTED_ERROR\"\n                delivery.error_message = str(e)\n                self._deliveries_failed += 1\n\n                logger.exception(f\"Delivery {delivery.id} failed with unexpected error: {e}\")\n\n                return WebhookDeliveryResult.failure_result(\n                    delivery_id=delivery.id,\n                    subscription_id=subscription.id,\n                    event_id=event.id,\n                    error_code=\"UNEXPECTED_ERROR\",\n                    error_message=str(e),\n                    duration_ms=duration_ms,\n                    attempt_number=retry_state.current_attempt,\n                    should_retry=False,\n                    max_attempts=retry_policy.max_attempts,\n                )\n\n        # Should not reach here, but handle just in case\n        duration_ms = int((time.monotonic() - start_time) * 1000)\n        return await self._handle_delivery_failure(\n            delivery=delivery,\n            event=event,\n            error_code=\"MAX_RETRIES_EXCEEDED\",\n            error_message=f\"Delivery failed after {retry_policy.max_attempts} attempts\",\n            duration_ms=duration_ms,\n            status_code=last_status_code,\n            max_attempts=retry_policy.max_attempts,\n        )\n\n    async def _handle_delivery_failure(\n        self,\n        delivery: WebhookDelivery,\n        event: WebhookEvent,\n        error_code: str,\n        error_message: str,\n        duration_ms: int,\n        status_code: Optional[int],\n        max_attempts: int,\n    ) -> WebhookDeliveryResult:\n        \"\"\"\n        Handle a failed delivery by updating status and adding to dead letter queue.\n\n        Args:\n            delivery: The delivery object\n            event: The event that failed\n            error_code: Error code for the failure\n            error_message: Human-readable error message\n            duration_ms: Total delivery duration\n            status_code: Last HTTP status code if any\n            max_attempts: Maximum attempts configured\n\n        Returns:\n            WebhookDeliveryResult indicating failure\n        \"\"\"\n        delivery.completed_at = datetime.now(timezone.utc)\n        delivery.duration_ms = duration_ms\n        delivery.status = WebhookDeliveryStatus.DEAD_LETTERED\n        delivery.error_code = error_code\n        delivery.error_message = error_message\n        delivery.response_status_code = status_code\n        self._deliveries_failed += 1\n\n        # Add to dead letter queue\n        if self.config.enable_dead_letter_queue:\n            await self.dead_letter_queue.add(delivery, event, error_message)\n\n        logger.error(\n            f\"Delivery {delivery.id} failed permanently after {delivery.attempt_number} attempts: \"\n            f\"{error_message}\"\n        )\n\n        return WebhookDeliveryResult.failure_result(\n            delivery_id=delivery.id,\n            subscription_id=delivery.subscription_id,\n            event_id=event.id,\n            error_code=error_code,\n            error_message=error_message,\n            status_code=status_code,\n            duration_ms=duration_ms,\n            attempt_number=delivery.attempt_number,\n            should_retry=False,\n            max_attempts=max_attempts,\n        )\n\n    async def deliver_batch(\n        self,\n        subscription: WebhookSubscription,\n        events: List[WebhookEvent],\n    ) -> List[WebhookDeliveryResult]:\n        \"\"\"\n        Deliver multiple events to a subscription.\n\n        Events are delivered concurrently up to the configured concurrency limit.\n\n        Args:\n            subscription: The webhook subscription\n            events: List of events to deliver\n\n        Returns:\n            List of delivery results\n        \"\"\"\n        tasks = [self.deliver(subscription, event) for event in events]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        delivery_results = []\n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                # Convert exception to failure result\n                delivery_results.append(\n                    WebhookDeliveryResult.failure_result(\n                        delivery_id=str(uuid4()),\n                        subscription_id=subscription.id,\n                        event_id=events[i].id,\n                        error_code=\"DELIVERY_EXCEPTION\",\n                        error_message=str(result),\n                    )\n                )\n            else:\n                delivery_results.append(result)\n\n        return delivery_results\n\n    async def deliver_to_all(\n        self,\n        subscriptions: List[WebhookSubscription],\n        event: WebhookEvent,\n    ) -> List[WebhookDeliveryResult]:\n        \"\"\"\n        Deliver an event to multiple subscriptions.\n\n        Only delivers to subscriptions that match the event filters.\n\n        Args:\n            subscriptions: List of webhook subscriptions\n            event: The event to deliver\n\n        Returns:\n            List of delivery results for matching subscriptions\n        \"\"\"\n        # Filter subscriptions that should receive this event\n        matching = [s for s in subscriptions if s.should_deliver_event(event)]\n\n        if not matching:\n            logger.debug(f\"Event {event.id} did not match any subscriptions\")\n            return []\n\n        tasks = [self.deliver(subscription, event) for subscription in matching]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        delivery_results = []\n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                delivery_results.append(\n                    WebhookDeliveryResult.failure_result(\n                        delivery_id=str(uuid4()),\n                        subscription_id=matching[i].id,\n                        event_id=event.id,\n                        error_code=\"DELIVERY_EXCEPTION\",\n                        error_message=str(result),\n                    )\n                )\n            else:\n                delivery_results.append(result)\n\n        return delivery_results\n\n\n# Convenience function for creating a configured delivery engine\ndef create_delivery_engine(\n    config: Optional[WebhookFrameworkConfig] = None,\n    development_mode: bool = False,\n) -> WebhookDeliveryEngine:\n    \"\"\"\n    Create a configured webhook delivery engine.\n\n    Args:\n        config: Optional explicit configuration\n        development_mode: If True, use development-friendly settings\n\n    Returns:\n        Configured WebhookDeliveryEngine instance\n    \"\"\"\n    if config is None:\n        if development_mode:\n            config = WebhookFrameworkConfig.development()\n        else:\n            config = WebhookFrameworkConfig.production()\n\n    return WebhookDeliveryEngine(config=config)\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.607287",
  "last_updated": "2026-01-04T05:35:51.186272"
}