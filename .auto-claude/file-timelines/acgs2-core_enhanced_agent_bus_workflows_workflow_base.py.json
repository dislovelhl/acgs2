{
  "file_path": "acgs2-core/enhanced_agent_bus/workflows/workflow_base.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Enhanced Agent Bus - Workflow Base Abstractions\nConstitutional Hash: cdd01ef066bc6cf2\n\nBase classes and protocols for workflow orchestration.\nProvides abstractions compatible with Temporal patterns.\n\"\"\"\n\nimport asyncio\nimport logging\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import (\n    Any,\n    Awaitable,\n    Callable,\n    Dict,\n    Generic,\n    List,\n    Optional,\n    Protocol,\n    TypeVar,\n    runtime_checkable,\n)\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\n# Type variables for generic workflow definitions\nTInput = TypeVar(\"TInput\")\nTOutput = TypeVar(\"TOutput\")\nTState = TypeVar(\"TState\")\n\n\nclass WorkflowStatus(Enum):\n    \"\"\"Workflow execution status.\"\"\"\n\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    TIMED_OUT = \"timed_out\"\n\n\n@dataclass\nclass WorkflowContext:\n    \"\"\"Context for workflow execution.\n\n    Provides workflow-scoped information and utilities.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    workflow_id: str\n    run_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    parent_workflow_id: Optional[str] = None\n    tenant_id: str = \"\"\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    started_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    # Event signaling\n    _signals: Dict[str, asyncio.Queue] = field(default_factory=dict)\n    _signal_data: Dict[str, List[Any]] = field(default_factory=dict)\n\n    # Workflow state\n    status: WorkflowStatus = WorkflowStatus.PENDING\n    result: Optional[Any] = None\n    error: Optional[str] = None\n\n    def get_signal_queue(self, signal_name: str) -> asyncio.Queue:\n        \"\"\"Get or create a signal queue.\"\"\"\n        if signal_name not in self._signals:\n            self._signals[signal_name] = asyncio.Queue()\n        return self._signals[signal_name]\n\n    async def wait_for_signal(self, signal_name: str, timeout: Optional[float] = None) -> Any:\n        \"\"\"Wait for a signal with optional timeout.\"\"\"\n        queue = self.get_signal_queue(signal_name)\n        try:\n            if timeout:\n                return await asyncio.wait_for(queue.get(), timeout=timeout)\n            return await queue.get()\n        except asyncio.TimeoutError:\n            return None\n\n    async def send_signal(self, signal_name: str, data: Any = None) -> None:\n        \"\"\"Send a signal to the workflow.\"\"\"\n        queue = self.get_signal_queue(signal_name)\n        await queue.put(data)\n        # Store signal data for query access\n        if signal_name not in self._signal_data:\n            self._signal_data[signal_name] = []\n        self._signal_data[signal_name].append(data)\n\n\n@runtime_checkable\nclass Activity(Protocol[TInput, TOutput]):\n    \"\"\"Protocol for workflow activities.\n\n    Activities are the building blocks of workflows that perform\n    actual work (I/O, computations, external calls).\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    async def execute(self, input_data: TInput, context: WorkflowContext) -> TOutput:\n        \"\"\"Execute the activity.\n\n        Args:\n            input_data: Activity input\n            context: Workflow context\n\n        Returns:\n            Activity output\n        \"\"\"\n        ...\n\n    @property\n    def name(self) -> str:\n        \"\"\"Activity name for registration and logging.\"\"\"\n        ...\n\n    @property\n    def timeout_seconds(self) -> float:\n        \"\"\"Activity timeout in seconds.\"\"\"\n        ...\n\n\n@dataclass\nclass Signal:\n    \"\"\"Signal definition for workflow communication.\n\n    Signals allow external events to be sent to running workflows.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    name: str\n    handler: Optional[Callable[[Any], Awaitable[None]]] = None\n    description: str = \"\"\n\n\n@dataclass\nclass Query:\n    \"\"\"Query definition for workflow state inspection.\n\n    Queries allow read-only access to workflow state.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    name: str\n    handler: Callable[[], Any]\n    description: str = \"\"\n\n\nclass WorkflowDefinition(ABC, Generic[TInput, TOutput]):\n    \"\"\"Abstract base class for workflow definitions.\n\n    Workflows define long-running business processes with\n    signals for external input and queries for state inspection.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._signals: Dict[str, Signal] = {}\n        self._queries: Dict[str, Query] = {}\n        self._context: Optional[WorkflowContext] = None\n        self._register_signals_and_queries()\n\n    @property\n    def context(self) -> WorkflowContext:\n        \"\"\"Get the workflow context.\"\"\"\n        if self._context is None:\n            raise RuntimeError(\"Workflow context not initialized\")\n        return self._context\n\n    @context.setter\n    def context(self, value: WorkflowContext) -> None:\n        \"\"\"Set the workflow context.\"\"\"\n        self._context = value\n\n    @abstractmethod\n    async def run(self, input_data: TInput) -> TOutput:\n        \"\"\"Main workflow execution logic.\n\n        Args:\n            input_data: Workflow input\n\n        Returns:\n            Workflow output\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Workflow name for registration.\"\"\"\n        ...\n\n    def _register_signals_and_queries(self) -> None:\n        \"\"\"Register signals and queries from decorated methods.\"\"\"\n        # Skip properties that may raise errors when accessed\n        skip_attrs = {\"context\", \"name\", \"state\", \"config\"}\n        for attr_name in dir(self):\n            if attr_name.startswith(\"_\") or attr_name in skip_attrs:\n                continue\n            try:\n                attr = getattr(self, attr_name, None)\n            except (RuntimeError, AttributeError):\n                # Skip attributes that raise errors when accessed\n                continue\n            if hasattr(attr, \"_is_signal\"):\n                signal = Signal(name=attr._signal_name, handler=attr)\n                self._signals[signal.name] = signal\n            if hasattr(attr, \"_is_query\"):\n                query = Query(name=attr._query_name, handler=attr)\n                self._queries[query.name] = query\n\n    async def execute_activity(\n        self,\n        activity: Activity[TInput, TOutput],\n        input_data: TInput,\n        **kwargs: Any,\n    ) -> TOutput:\n        \"\"\"Execute an activity within the workflow.\n\n        Args:\n            activity: The activity to execute\n            input_data: Activity input\n            **kwargs: Additional activity options\n\n        Returns:\n            Activity output\n        \"\"\"\n        timeout = kwargs.get(\"timeout\", activity.timeout_seconds)\n        try:\n            return await asyncio.wait_for(\n                activity.execute(input_data, self.context),\n                timeout=timeout,\n            )\n        except asyncio.TimeoutError as e:\n            logger.error(\n                f\"[{CONSTITUTIONAL_HASH}] Activity {activity.name} timed out after {timeout}s\"\n            )\n            raise e\n\n    async def wait_condition(\n        self,\n        condition: Callable[[], bool],\n        timeout: Optional[float] = None,\n        poll_interval: float = 0.1,\n    ) -> bool:\n        \"\"\"Wait for a condition to become true.\n\n        Args:\n            condition: Callable returning bool\n            timeout: Maximum wait time in seconds\n            poll_interval: How often to check condition\n\n        Returns:\n            True if condition was met, False if timed out\n        \"\"\"\n        start_time = datetime.now(timezone.utc)\n        while not condition():\n            if timeout:\n                elapsed = (datetime.now(timezone.utc) - start_time).total_seconds()\n                if elapsed >= timeout:\n                    return False\n            await asyncio.sleep(poll_interval)\n        return True\n\n    def get_signals(self) -> Dict[str, Signal]:\n        \"\"\"Get registered signals.\"\"\"\n        return self._signals.copy()\n\n    def get_queries(self) -> Dict[str, Query]:\n        \"\"\"Get registered queries.\"\"\"\n        return self._queries.copy()\n\n\ndef signal(name: Optional[str] = None) -> Callable:\n    \"\"\"Decorator to mark a method as a signal handler.\n\n    Args:\n        name: Optional signal name (defaults to method name)\n\n    Returns:\n        Decorated method\n    \"\"\"\n\n    def decorator(func: Callable) -> Callable:\n        func._is_signal = True  # type: ignore\n        func._signal_name = name or func.__name__  # type: ignore\n        return func\n\n    return decorator\n\n\ndef query(name: Optional[str] = None) -> Callable:\n    \"\"\"Decorator to mark a method as a query handler.\n\n    Args:\n        name: Optional query name (defaults to method name)\n\n    Returns:\n        Decorated method\n    \"\"\"\n\n    def decorator(func: Callable) -> Callable:\n        func._is_query = True  # type: ignore\n        func._query_name = name or func.__name__  # type: ignore\n        return func\n\n    return decorator\n\n\nclass WorkflowExecutor(ABC):\n    \"\"\"Abstract base class for workflow execution.\n\n    Implementations handle workflow lifecycle management.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    @abstractmethod\n    async def start(\n        self,\n        workflow: WorkflowDefinition[TInput, TOutput],\n        workflow_id: str,\n        input_data: TInput,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Start a workflow execution.\n\n        Args:\n            workflow: Workflow definition\n            workflow_id: Unique workflow identifier\n            input_data: Workflow input\n            **kwargs: Additional options\n\n        Returns:\n            Run ID for the started workflow\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def send_signal(self, workflow_id: str, signal_name: str, data: Any = None) -> None:\n        \"\"\"Send a signal to a running workflow.\n\n        Args:\n            workflow_id: Target workflow ID\n            signal_name: Signal name\n            data: Signal payload\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def query(self, workflow_id: str, query_name: str) -> Any:\n        \"\"\"Query workflow state.\n\n        Args:\n            workflow_id: Target workflow ID\n            query_name: Query name\n\n        Returns:\n            Query result\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def get_result(self, workflow_id: str, timeout: Optional[float] = None) -> Any:\n        \"\"\"Get workflow result.\n\n        Args:\n            workflow_id: Target workflow ID\n            timeout: Maximum wait time\n\n        Returns:\n            Workflow result\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def cancel(self, workflow_id: str) -> None:\n        \"\"\"Cancel a running workflow.\n\n        Args:\n            workflow_id: Target workflow ID\n        \"\"\"\n        ...\n\n\nclass InMemoryWorkflowExecutor(WorkflowExecutor):\n    \"\"\"In-memory workflow executor for testing and development.\n\n    Runs workflows in-process without external dependencies.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._workflows: Dict[str, WorkflowDefinition] = {}\n        self._contexts: Dict[str, WorkflowContext] = {}\n        self._tasks: Dict[str, asyncio.Task] = {}\n        self._results: Dict[str, Any] = {}\n        self._errors: Dict[str, str] = {}\n\n    async def start(\n        self,\n        workflow: WorkflowDefinition[TInput, TOutput],\n        workflow_id: str,\n        input_data: TInput,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Start a workflow execution.\"\"\"\n        # Create context\n        context = WorkflowContext(\n            workflow_id=workflow_id,\n            tenant_id=kwargs.get(\"tenant_id\", \"\"),\n            metadata=kwargs.get(\"metadata\", {}),\n        )\n        context.status = WorkflowStatus.RUNNING\n\n        # Register workflow\n        workflow.context = context\n        self._workflows[workflow_id] = workflow\n        self._contexts[workflow_id] = context\n\n        # Start workflow task\n        async def run_workflow() -> None:\n            try:\n                result = await workflow.run(input_data)\n                self._results[workflow_id] = result\n                context.result = result\n                context.status = WorkflowStatus.COMPLETED\n            except asyncio.CancelledError:\n                context.status = WorkflowStatus.CANCELLED\n                raise\n            except Exception as e:\n                context.status = WorkflowStatus.FAILED\n                context.error = str(e)\n                self._errors[workflow_id] = str(e)\n                logger.error(f\"[{CONSTITUTIONAL_HASH}] Workflow {workflow_id} failed: {e}\")\n\n        task = asyncio.create_task(run_workflow())\n        self._tasks[workflow_id] = task\n\n        return context.run_id\n\n    async def send_signal(self, workflow_id: str, signal_name: str, data: Any = None) -> None:\n        \"\"\"Send a signal to a running workflow.\"\"\"\n        if workflow_id not in self._workflows:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n\n        workflow = self._workflows[workflow_id]\n        context = self._contexts[workflow_id]\n\n        # Check if workflow has this signal registered\n        if signal_name in workflow.get_signals():\n            signal_handler = workflow.get_signals()[signal_name].handler\n            if signal_handler:\n                await signal_handler(data)\n\n        # Also send to context queue for wait_for_signal\n        await context.send_signal(signal_name, data)\n\n    async def query(self, workflow_id: str, query_name: str) -> Any:\n        \"\"\"Query workflow state.\"\"\"\n        if workflow_id not in self._workflows:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n\n        workflow = self._workflows[workflow_id]\n        queries = workflow.get_queries()\n\n        if query_name not in queries:\n            raise ValueError(f\"Query {query_name} not found in workflow\")\n\n        return queries[query_name].handler()\n\n    async def get_result(self, workflow_id: str, timeout: Optional[float] = None) -> Any:\n        \"\"\"Get workflow result.\"\"\"\n        if workflow_id not in self._tasks:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n\n        task = self._tasks[workflow_id]\n\n        try:\n            if timeout:\n                await asyncio.wait_for(asyncio.shield(task), timeout=timeout)\n            else:\n                await task\n        except asyncio.TimeoutError:\n            pass\n        except asyncio.CancelledError:\n            pass\n\n        context = self._contexts[workflow_id]\n        if context.status == WorkflowStatus.FAILED:\n            raise RuntimeError(context.error or \"Workflow failed\")\n\n        return self._results.get(workflow_id)\n\n    async def cancel(self, workflow_id: str) -> None:\n        \"\"\"Cancel a running workflow.\"\"\"\n        if workflow_id not in self._tasks:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n\n        task = self._tasks[workflow_id]\n        task.cancel()\n\n        try:\n            await task\n        except asyncio.CancelledError:\n            pass\n\n        context = self._contexts[workflow_id]\n        context.status = WorkflowStatus.CANCELLED\n\n    def get_status(self, workflow_id: str) -> WorkflowStatus:\n        \"\"\"Get workflow status.\"\"\"\n        if workflow_id not in self._contexts:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n        return self._contexts[workflow_id].status\n\n    def get_context(self, workflow_id: str) -> WorkflowContext:\n        \"\"\"Get workflow context.\"\"\"\n        if workflow_id not in self._contexts:\n            raise ValueError(f\"Workflow {workflow_id} not found\")\n        return self._contexts[workflow_id]\n\n\n__all__ = [\n    \"WorkflowStatus\",\n    \"WorkflowContext\",\n    \"Activity\",\n    \"Signal\",\n    \"Query\",\n    \"WorkflowDefinition\",\n    \"signal\",\n    \"query\",\n    \"WorkflowExecutor\",\n    \"InMemoryWorkflowExecutor\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.271718",
  "last_updated": "2026-01-04T05:35:58.725700"
}