{
  "file_path": "acgs2-core/enhanced_agent_bus/workflows/graph_workflow.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Enhanced Agent Bus - Graph-based Workflows (LangGraph Pattern)\nConstitutional Hash: cdd01ef066bc6cf2\n\nImplements stateful cyclic graphs for multi-agent governance orchestration.\nFeatures conditional branching, state persistence, and human-in-the-loop interrupts.\n\"\"\"\n\nimport logging\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    List,\n    Optional,\n    Set,\n    TypeVar,\n)\n\nfrom .workflow_base import CONSTITUTIONAL_HASH, WorkflowContext\n\nlogger = logging.getLogger(__name__)\n\nTState = TypeVar(\"TState\", bound=Dict[str, Any])\n\nclass NodeStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\n@dataclass\nclass GraphNode:\n    \"\"\"A node in the state graph representing an agent or a function.\"\"\"\n    name: str\n    func: Callable[[TState], Awaitable[TState]]\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n@dataclass\nclass GraphEdge:\n    \"\"\"An edge in the state graph.\"\"\"\n    source: str\n    target: str\n    condition: Optional[Callable[[TState], bool]] = None\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\nclass StateGraph:\n    \"\"\"\n    LangGraph-style state machine for multi-agent orchestration.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, state_schema: Any):\n        self.state_schema = state_schema\n        self.nodes: Dict[str, GraphNode] = {}\n        self.edges: List[GraphEdge] = []\n        self.entry_point: Optional[str] = None\n        self.finish_point: Optional[str] = \"END\"\n\n        # State persistence and checkpointing\n        self._checkpoints: List[TState] = []\n        self._interrupts: Set[str] = set() # Node names where to interrupt\n\n    def add_node(self, name: str, func: Callable[[TState], Awaitable[TState]]) -> \"StateGraph\":\n        \"\"\"Add a node to the graph.\"\"\"\n        self.nodes[name] = GraphNode(name=name, func=func)\n        return self\n\n    def add_edge(self, source: str, target: str, condition: Optional[Callable[[TState], bool]] = None) -> \"StateGraph\":\n        \"\"\"Add an edge between nodes.\"\"\"\n        if source not in self.nodes and source != \"START\":\n            raise ValueError(f\"Source node {source} not found\")\n        if target not in self.nodes and target != \"END\":\n            raise ValueError(f\"Target node {target} not found\")\n\n        self.edges.append(GraphEdge(source=source, target=target, condition=condition))\n        return self\n\n    def set_entry_point(self, name: str) -> \"StateGraph\":\n        \"\"\"Set the starting node of the graph.\"\"\"\n        if name not in self.nodes:\n            raise ValueError(f\"Node {name} not found\")\n        self.entry_point = name\n        return self\n\n    def add_interrupt(self, node_name: str) -> \"StateGraph\":\n        \"\"\"Add an interrupt point for Human-in-the-Loop.\"\"\"\n        self._interrupts.add(node_name)\n        return self\n\n    async def execute(self, initial_state: TState, context: Optional[WorkflowContext] = None) -> TState:\n        \"\"\"\n        Execute the state graph.\n\n        Args:\n            initial_state: The starting state\n            context: Optional workflow context\n\n        Returns:\n            The final state\n        \"\"\"\n        if not self.entry_point:\n            raise ValueError(\"Entry point not set\")\n\n        current_node = self.entry_point\n        state = initial_state\n        self._checkpoints.append(state.copy())\n\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Starting graph execution from {current_node}\")\n\n        while current_node != \"END\":\n            # 1. Check for interrupts (Human-in-the-Loop)\n            if current_node in self._interrupts:\n                logger.info(f\"[{CONSTITUTIONAL_HASH}] Interrupting execution at {current_node}\")\n                # In a real implementation, we would wait for a signal here\n                if context:\n                    await context.wait_for_signal(f\"resume_{current_node}\")\n\n            # 2. Execute node\n            node = self.nodes[current_node]\n            logger.debug(f\"[{CONSTITUTIONAL_HASH}] Executing node: {current_node}\")\n\n            try:\n                state = await node.func(state)\n                self._checkpoints.append(state.copy())\n            except Exception as e:\n                logger.error(f\"[{CONSTITUTIONAL_HASH}] Node {current_node} failed: {e}\")\n                raise e\n\n            # 3. Determine next node\n            next_node = self._get_next_node(current_node, state)\n            if not next_node:\n                logger.warning(f\"[{CONSTITUTIONAL_HASH}] No valid edge from {current_node}, terminating.\")\n                break\n\n            current_node = next_node\n\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Graph execution completed\")\n        return state\n\n    def _get_next_node(self, current_node: str, state: TState) -> Optional[str]:\n        \"\"\"Determine the next node based on edges and current state.\"\"\"\n        possible_edges = [e for e in self.edges if e.source == current_node]\n\n        for edge in possible_edges:\n            if edge.condition is None or edge.condition(state):\n                return edge.target\n\n        return None\n\n    def get_history(self) -> List[TState]:\n        \"\"\"Get the history of state checkpoints.\"\"\"\n        return self._checkpoints\n\nclass GovernanceGraph(StateGraph):\n    \"\"\"\n    Specialized graph for multi-agent governance.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(state_schema={})\n        self._build_standard_governance_graph()\n\n    def _build_standard_governance_graph(self):\n        \"\"\"Build a standard governance workflow graph.\"\"\"\n        # Nodes\n        self.add_node(\"classify\", self._classify_node)\n        self.add_node(\"validate\", self._validate_node)\n        self.add_node(\"deliberate\", self._deliberate_node)\n        self.add_node(\"execute\", self._execute_node)\n        self.add_node(\"audit\", self._audit_node)\n\n        # Edges\n        self.set_entry_point(\"classify\")\n\n        self.add_edge(\"classify\", \"execute\", condition=lambda s: s.get(\"complexity\") == \"simple\")\n        self.add_edge(\"classify\", \"validate\", condition=lambda s: s.get(\"complexity\") == \"requires_validation\")\n        self.add_edge(\"classify\", \"deliberate\", condition=lambda s: s.get(\"complexity\") == \"complex\")\n\n        self.add_edge(\"validate\", \"deliberate\")\n        self.add_edge(\"deliberate\", \"execute\")\n        self.add_edge(\"execute\", \"audit\")\n        self.add_edge(\"audit\", \"END\")\n\n    async def _classify_node(self, state: TState) -> TState:\n        # Mock classification logic\n        content = state.get(\"content\", \"\")\n        if \"critical\" in content:\n            state[\"complexity\"] = \"complex\"\n        elif \"validate\" in content:\n            state[\"complexity\"] = \"requires_validation\"\n        else:\n            state[\"complexity\"] = \"simple\"\n        return state\n\n    async def _validate_node(self, state: TState) -> TState:\n        state[\"validated\"] = True\n        return state\n\n    async def _deliberate_node(self, state: TState) -> TState:\n        state[\"deliberated\"] = True\n        return state\n\n    async def _execute_node(self, state: TState) -> TState:\n        state[\"executed\"] = True\n        return state\n\n    async def _audit_node(self, state: TState) -> TState:\n        state[\"audited\"] = True\n        return state\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.170181",
  "last_updated": "2026-01-04T05:35:59.093434"
}