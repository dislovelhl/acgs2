{
  "file_path": "acgs2-core/integrations/nemo_agent_toolkit/agent_wrapper.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Agent Wrapper for NeMo-Agent-Toolkit\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides wrapper classes that add constitutional guardrails to\npopular AI agent frameworks: LangChain, LlamaIndex, CrewAI, etc.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport functools\nimport logging\nfrom dataclasses import dataclass, field\nfrom datetime import UTC, datetime\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, TypeVar\n\nfrom nemo_agent_toolkit.constitutional_guardrails import (\n    ConstitutionalGuardrails,\n    GuardrailAction,\n    GuardrailConfig,\n    GuardrailResult,\n)\n\nif TYPE_CHECKING:\n    pass\n\nCONSTITUTIONAL_HASH: str = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar(\"T\")\nAgentT = TypeVar(\"AgentT\")\n\n\n@dataclass\nclass WrapperConfig:\n    \"\"\"Configuration for agent wrapper.\"\"\"\n\n    validate_inputs: bool = True\n    validate_outputs: bool = True\n    audit_enabled: bool = True\n    block_on_input_violation: bool = True\n    block_on_output_violation: bool = False\n    redact_output_pii: bool = True\n    max_retries: int = 3\n    timeout_seconds: float = 30.0\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n\n\n@dataclass\nclass ExecutionResult(Generic[T]):\n    \"\"\"Result of a wrapped agent execution.\"\"\"\n\n    success: bool\n    output: T | None = None\n    error: str | None = None\n    input_check: GuardrailResult | None = None\n    output_check: GuardrailResult | None = None\n    execution_time_ms: float = 0.0\n    constitutional_hash: str = CONSTITUTIONAL_HASH\n    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n\nclass ConstitutionalAgentWrapper(Generic[AgentT]):\n    \"\"\"\n    Generic wrapper that adds constitutional guardrails to any agent.\n\n    This wrapper intercepts input and output, validates against\n    constitutional principles, and provides audit logging.\n    \"\"\"\n\n    def __init__(\n        self,\n        agent: AgentT,\n        guardrails: ConstitutionalGuardrails | None = None,\n        config: WrapperConfig | None = None,\n        acgs2_client: Any | None = None,\n    ) -> None:\n        \"\"\"\n        Initialize the wrapper.\n\n        Args:\n            agent: The agent to wrap\n            guardrails: Constitutional guardrails instance\n            config: Wrapper configuration\n            acgs2_client: ACGS-2 SDK client for backend operations\n        \"\"\"\n        self._agent = agent\n        self._config = config or WrapperConfig()\n        self._guardrails = guardrails or ConstitutionalGuardrails(\n            config=GuardrailConfig(\n                block_on_violation=self._config.block_on_input_violation,\n            ),\n            acgs2_client=acgs2_client,\n        )\n        self._client = acgs2_client\n        self._execution_history: list[dict[str, Any]] = []\n\n    @property\n    def agent(self) -> AgentT:\n        \"\"\"Get the wrapped agent.\"\"\"\n        return self._agent\n\n    @property\n    def guardrails(self) -> ConstitutionalGuardrails:\n        \"\"\"Get the guardrails instance.\"\"\"\n        return self._guardrails\n\n    async def run(\n        self,\n        input_data: str | dict[str, Any],\n        context: dict[str, Any] | None = None,\n    ) -> ExecutionResult[Any]:\n        \"\"\"\n        Run the agent with constitutional guardrails.\n\n        Args:\n            input_data: Input for the agent\n            context: Optional context for validation\n\n        Returns:\n            ExecutionResult with output and validation results\n        \"\"\"\n        start_time = datetime.now(UTC)\n\n        # Convert input to string for validation\n        input_str = input_data if isinstance(input_data, str) else str(input_data)\n\n        # Validate input\n        input_check = None\n        if self._config.validate_inputs:\n            input_check = await self._guardrails.check_input(input_str, context)\n            if not input_check.allowed and self._config.block_on_input_violation:\n                return ExecutionResult(\n                    success=False,\n                    error=f\"Input blocked by constitutional guardrails: {input_check.reasoning}\",\n                    input_check=input_check,\n                    execution_time_ms=self._calculate_elapsed(start_time),\n                )\n\n        # Execute agent\n        try:\n            output = await self._execute_agent(input_data)\n        except Exception as e:\n            logger.error(f\"Agent execution failed: {e}\")\n            return ExecutionResult(\n                success=False,\n                error=str(e),\n                input_check=input_check,\n                execution_time_ms=self._calculate_elapsed(start_time),\n            )\n\n        # Convert output to string for validation\n        output_str = str(output) if output is not None else \"\"\n\n        # Validate output\n        output_check = None\n        if self._config.validate_outputs:\n            output_check = await self._guardrails.check_output(output_str, context)\n\n            if output_check.action == GuardrailAction.MODIFY and output_check.modified_content:\n                # Use modified (redacted) output\n                output = output_check.modified_content\n\n            if not output_check.allowed and self._config.block_on_output_violation:\n                return ExecutionResult(\n                    success=False,\n                    error=f\"Output blocked by constitutional guardrails: {output_check.reasoning}\",\n                    input_check=input_check,\n                    output_check=output_check,\n                    execution_time_ms=self._calculate_elapsed(start_time),\n                )\n\n        # Record execution\n        execution_time = self._calculate_elapsed(start_time)\n        self._record_execution(input_str, output_str, input_check, output_check, execution_time)\n\n        return ExecutionResult(\n            success=True,\n            output=output,\n            input_check=input_check,\n            output_check=output_check,\n            execution_time_ms=execution_time,\n        )\n\n    async def _execute_agent(self, input_data: str | dict[str, Any]) -> Any:\n        \"\"\"Execute the wrapped agent.\"\"\"\n        # Try common agent interfaces\n        agent = self._agent\n\n        # LangChain-style invoke\n        if hasattr(agent, \"invoke\"):\n            result = agent.invoke(input_data)\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n\n        # LangChain-style ainvoke\n        if hasattr(agent, \"ainvoke\"):\n            return await agent.ainvoke(input_data)\n\n        # LlamaIndex-style query\n        if hasattr(agent, \"query\"):\n            result = agent.query(input_data)\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n\n        # LlamaIndex-style aquery\n        if hasattr(agent, \"aquery\"):\n            return await agent.aquery(input_data)\n\n        # CrewAI-style kickoff\n        if hasattr(agent, \"kickoff\"):\n            result = agent.kickoff(\n                inputs=input_data if isinstance(input_data, dict) else {\"input\": input_data}\n            )\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n\n        # Generic run method\n        if hasattr(agent, \"run\"):\n            result = agent.run(input_data)\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n\n        # Callable\n        if callable(agent):\n            result = agent(input_data)\n            if asyncio.iscoroutine(result):\n                result = await result\n            return result\n\n        raise TypeError(f\"Unknown agent type: {type(agent)}. Cannot determine execution method.\")\n\n    def _calculate_elapsed(self, start_time: datetime) -> float:\n        \"\"\"Calculate elapsed time in milliseconds.\"\"\"\n        elapsed = datetime.now(UTC) - start_time\n        return elapsed.total_seconds() * 1000\n\n    def _record_execution(\n        self,\n        input_str: str,\n        output_str: str,\n        input_check: GuardrailResult | None,\n        output_check: GuardrailResult | None,\n        execution_time: float,\n    ) -> None:\n        \"\"\"Record execution for audit.\"\"\"\n        if not self._config.audit_enabled:\n            return\n\n        import hashlib\n\n        record = {\n            \"input_hash\": hashlib.sha256(input_str.encode()).hexdigest()[:16],\n            \"output_hash\": hashlib.sha256(output_str.encode()).hexdigest()[:16],\n            \"input_allowed\": input_check.allowed if input_check else True,\n            \"output_allowed\": output_check.allowed if output_check else True,\n            \"input_violations\": len(input_check.violations) if input_check else 0,\n            \"output_violations\": len(output_check.violations) if output_check else 0,\n            \"execution_time_ms\": execution_time,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n        self._execution_history.append(record)\n\n    def get_execution_history(self) -> list[dict[str, Any]]:\n        \"\"\"Get execution history.\"\"\"\n        return self._execution_history.copy()\n\n    async def get_metrics(self) -> dict[str, Any]:\n        \"\"\"Get wrapper metrics.\"\"\"\n        total = len(self._execution_history)\n        if total == 0:\n            return {\n                \"total_executions\": 0,\n                \"success_rate\": 1.0,\n                \"average_execution_time_ms\": 0.0,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            }\n\n        successful = sum(\n            1\n            for e in self._execution_history\n            if e.get(\"input_allowed\", True) and e.get(\"output_allowed\", True)\n        )\n        total_time = sum(e.get(\"execution_time_ms\", 0) for e in self._execution_history)\n\n        return {\n            \"total_executions\": total,\n            \"successful_executions\": successful,\n            \"success_rate\": successful / total,\n            \"average_execution_time_ms\": total_time / total,\n            \"input_violation_count\": sum(\n                e.get(\"input_violations\", 0) for e in self._execution_history\n            ),\n            \"output_violation_count\": sum(\n                e.get(\"output_violations\", 0) for e in self._execution_history\n            ),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n        }\n\n\ndef wrap_langchain_agent(\n    agent: Any,\n    config: WrapperConfig | None = None,\n    acgs2_client: Any | None = None,\n) -> ConstitutionalAgentWrapper[Any]:\n    \"\"\"\n    Wrap a LangChain agent with constitutional guardrails.\n\n    Args:\n        agent: LangChain agent (chain, agent executor, etc.)\n        config: Wrapper configuration\n        acgs2_client: ACGS-2 SDK client\n\n    Returns:\n        ConstitutionalAgentWrapper wrapping the agent\n\n    Example:\n        ```python\n        from langchain.agents import create_openai_agent\n        from integrations.nemo_agent_toolkit import wrap_langchain_agent\n\n        agent = create_openai_agent(llm, tools, prompt)\n        wrapped = wrap_langchain_agent(agent)\n        result = await wrapped.run(\"What is the weather?\")\n        ```\n    \"\"\"\n    return ConstitutionalAgentWrapper(\n        agent=agent,\n        config=config,\n        acgs2_client=acgs2_client,\n    )\n\n\ndef wrap_llamaindex_agent(\n    agent: Any,\n    config: WrapperConfig | None = None,\n    acgs2_client: Any | None = None,\n) -> ConstitutionalAgentWrapper[Any]:\n    \"\"\"\n    Wrap a LlamaIndex agent with constitutional guardrails.\n\n    Args:\n        agent: LlamaIndex agent or query engine\n        config: Wrapper configuration\n        acgs2_client: ACGS-2 SDK client\n\n    Returns:\n        ConstitutionalAgentWrapper wrapping the agent\n\n    Example:\n        ```python\n        from llama_index.core.agent import ReActAgent\n        from integrations.nemo_agent_toolkit import wrap_llamaindex_agent\n\n        agent = ReActAgent.from_tools(tools, llm=llm)\n        wrapped = wrap_llamaindex_agent(agent)\n        result = await wrapped.run(\"Analyze this document\")\n        ```\n    \"\"\"\n    return ConstitutionalAgentWrapper(\n        agent=agent,\n        config=config,\n        acgs2_client=acgs2_client,\n    )\n\n\ndef wrap_crewai_agent(\n    crew: Any,\n    config: WrapperConfig | None = None,\n    acgs2_client: Any | None = None,\n) -> ConstitutionalAgentWrapper[Any]:\n    \"\"\"\n    Wrap a CrewAI crew with constitutional guardrails.\n\n    Args:\n        crew: CrewAI Crew instance\n        config: Wrapper configuration\n        acgs2_client: ACGS-2 SDK client\n\n    Returns:\n        ConstitutionalAgentWrapper wrapping the crew\n\n    Example:\n        ```python\n        from crewai import Crew, Agent, Task\n        from integrations.nemo_agent_toolkit import wrap_crewai_agent\n\n        crew = Crew(agents=[agent], tasks=[task])\n        wrapped = wrap_crewai_agent(crew)\n        result = await wrapped.run({\"topic\": \"AI Safety\"})\n        ```\n    \"\"\"\n    return ConstitutionalAgentWrapper(\n        agent=crew,\n        config=config,\n        acgs2_client=acgs2_client,\n    )\n\n\ndef constitutional_guardrail(\n    guardrails: ConstitutionalGuardrails | None = None,\n    validate_input: bool = True,\n    validate_output: bool = True,\n) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    Decorator to add constitutional guardrails to any async function.\n\n    Args:\n        guardrails: Constitutional guardrails instance\n        validate_input: Whether to validate input\n        validate_output: Whether to validate output\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        @constitutional_guardrail()\n        async def process_request(query: str) -> str:\n            # Process the query\n            return response\n        ```\n    \"\"\"\n    _guardrails = guardrails or ConstitutionalGuardrails()\n\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @functools.wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -> T:\n            # Validate input\n            if validate_input and args:\n                input_str = str(args[0])\n                result = await _guardrails.check_input(input_str)\n                if not result.allowed:\n                    raise ValueError(f\"Input blocked: {result.reasoning}\")\n\n            # Execute function\n            output = func(*args, **kwargs)\n            if asyncio.iscoroutine(output):\n                output = await output\n\n            # Validate output\n            if validate_output and output is not None:\n                output_str = str(output)\n                result = await _guardrails.check_output(output_str)\n                if result.action == GuardrailAction.MODIFY and result.modified_content:\n                    return result.modified_content  # type: ignore\n                if not result.allowed:\n                    raise ValueError(f\"Output blocked: {result.reasoning}\")\n\n            return output\n\n        return wrapper  # type: ignore\n\n    return decorator\n\n\nclass NeMoAgentIntegration:\n    \"\"\"\n    Direct integration with NeMo-Agent-Toolkit.\n\n    Provides hooks for NeMo's agent optimization pipeline\n    with constitutional compliance.\n    \"\"\"\n\n    def __init__(\n        self,\n        guardrails: ConstitutionalGuardrails | None = None,\n        acgs2_client: Any | None = None,\n    ) -> None:\n        \"\"\"\n        Initialize NeMo integration.\n\n        Args:\n            guardrails: Constitutional guardrails instance\n            acgs2_client: ACGS-2 SDK client\n        \"\"\"\n        self._guardrails = guardrails or ConstitutionalGuardrails(acgs2_client=acgs2_client)\n        self._client = acgs2_client\n\n    def create_input_hook(self) -> Callable[[str], str]:\n        \"\"\"\n        Create an input hook for NeMo's agent pipeline.\n\n        Returns:\n            Hook function for input processing\n        \"\"\"\n\n        async def hook(input_text: str) -> str:\n            result = await self._guardrails.check_input(input_text)\n            if not result.allowed:\n                raise ValueError(f\"Constitutional violation: {result.reasoning}\")\n            return input_text\n\n        return lambda x: asyncio.get_event_loop().run_until_complete(hook(x))\n\n    def create_output_hook(self) -> Callable[[str], str]:\n        \"\"\"\n        Create an output hook for NeMo's agent pipeline.\n\n        Returns:\n            Hook function for output processing\n        \"\"\"\n\n        async def hook(output_text: str) -> str:\n            result = await self._guardrails.check_output(output_text)\n            if result.modified_content:\n                return result.modified_content\n            if not result.allowed:\n                raise ValueError(f\"Constitutional violation: {result.reasoning}\")\n            return output_text\n\n        return lambda x: asyncio.get_event_loop().run_until_complete(hook(x))\n\n    def get_profiler_callback(self) -> Callable[[dict[str, Any]], None]:\n        \"\"\"\n        Get a callback for NeMo's profiler integration.\n\n        Returns:\n            Callback function for profiler events\n        \"\"\"\n\n        def callback(event: dict[str, Any]) -> None:\n            logger.info(f\"NeMo profiler event: {event}\")\n            # Add constitutional hash to events\n            event[\"constitutional_hash\"] = CONSTITUTIONAL_HASH\n\n        return callback\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.250404",
  "last_updated": "2026-01-04T05:35:59.226340"
}