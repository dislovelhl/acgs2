{
  "file_path": "acgs2-core/shared/auth/saml_handler.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 SAML 2.0 Handler Service\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides enterprise-grade SAML 2.0 Service Provider (SP) implementation using\nPySAML2. Supports multiple Identity Providers including Okta, Azure AD, and\ncustom SAML IdPs.\n\nFeatures:\n    - SP-initiated and IdP-initiated SSO flows\n    - Assertion Consumer Service (ACS) with signature validation\n    - Single Logout Service (SLS) support\n    - SP metadata generation\n    - Outstanding request tracking for replay attack prevention\n    - Clock skew tolerance handling\n    - Multiple IdP configuration\n\nUsage:\n    from shared.auth.saml_handler import SAMLHandler\n    from shared.auth.saml_config import SAMLSPConfig, SAMLIdPConfig\n\n    # Create handler with default configuration\n    handler = SAMLHandler()\n\n    # Or with custom configuration\n    sp_config = SAMLSPConfig(\n        entity_id=\"https://acgs2.example.com/saml/metadata\",\n        acs_url=\"https://acgs2.example.com/saml/acs\",\n    )\n    handler = SAMLHandler(sp_config=sp_config)\n\n    # Register an IdP\n    handler.register_idp(\n        name=\"okta\",\n        metadata_url=\"https://dev-123.okta.com/app/exk123/sso/saml/metadata\",\n    )\n\n    # Initiate login\n    redirect_url, request_id = await handler.initiate_login(\"okta\")\n\n    # Handle ACS callback\n    user_info = await handler.process_acs_response(saml_response, request_id)\n\"\"\"\n\nimport logging\nimport secrets\nimport tempfile\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Optional\nfrom urllib.parse import urlencode\n\nfrom .saml_config import (\n    CONSTITUTIONAL_HASH,\n    SAMLConfig,\n    SAMLConfigurationError,\n    SAMLIdPConfig,\n    SAMLSPConfig,\n)\n\n# Optional PySAML2 imports\ntry:\n    from saml2 import BINDING_HTTP_POST, BINDING_HTTP_REDIRECT\n    from saml2.client import Saml2Client\n    from saml2.config import Config as Saml2Config\n    from saml2.metadata import create_metadata_string\n    from saml2.response import AuthnResponse\n    from saml2.s_utils import UnknownPrincipal, UnsupportedBinding\n    from saml2.saml import NAMEID_FORMAT_EMAILADDRESS, NAMEID_FORMAT_PERSISTENT\n\n    HAS_PYSAML2 = True\nexcept ImportError:\n    HAS_PYSAML2 = False\n    BINDING_HTTP_POST = \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n    BINDING_HTTP_REDIRECT = \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n    Saml2Client = None  # type: ignore[misc, assignment]\n    Saml2Config = None  # type: ignore[misc, assignment]\n    AuthnResponse = None  # type: ignore[misc, assignment]\n    UnknownPrincipal = Exception  # type: ignore[misc, assignment]\n    UnsupportedBinding = Exception  # type: ignore[misc, assignment]\n    NAMEID_FORMAT_EMAILADDRESS = \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    NAMEID_FORMAT_PERSISTENT = \"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"\n\ntry:\n    import httpx\n\n    HAS_HTTPX = True\nexcept ImportError:\n    HAS_HTTPX = False\n    httpx = None  # type: ignore[assignment]\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass SAMLError(Exception):\n    \"\"\"Base exception for SAML-related errors.\"\"\"\n\n    pass\n\n\nclass SAMLValidationError(SAMLError):\n    \"\"\"SAML signature or assertion validation failed.\"\"\"\n\n    pass\n\n\nclass SAMLAuthenticationError(SAMLError):\n    \"\"\"SAML authentication failed.\"\"\"\n\n    pass\n\n\nclass SAMLProviderError(SAMLError):\n    \"\"\"Error communicating with SAML IdP.\"\"\"\n\n    pass\n\n\nclass SAMLReplayError(SAMLError):\n    \"\"\"Replay attack detected - response already processed.\"\"\"\n\n    pass\n\n\n@dataclass\nclass SAMLUserInfo:\n    \"\"\"User information extracted from SAML assertion.\n\n    Attributes:\n        name_id: SAML NameID (unique user identifier from IdP)\n        name_id_format: Format of the NameID\n        session_index: Session index for logout\n        email: User's email address\n        name: Full name\n        given_name: First name\n        family_name: Last name\n        groups: Group memberships from IdP\n        attributes: All SAML attributes as dict\n        issuer: IdP entity ID that issued the assertion\n        authn_instant: When authentication occurred\n        session_not_on_or_after: When session expires\n    \"\"\"\n\n    name_id: str\n    name_id_format: str = NAMEID_FORMAT_EMAILADDRESS\n    session_index: Optional[str] = None\n    email: Optional[str] = None\n    name: Optional[str] = None\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    groups: list[str] = field(default_factory=list)\n    attributes: dict[str, Any] = field(default_factory=dict)\n    issuer: Optional[str] = None\n    authn_instant: Optional[datetime] = None\n    session_not_on_or_after: Optional[datetime] = None\n\n    @classmethod\n    def from_response(cls, response: Any) -> \"SAMLUserInfo\":\n        \"\"\"Create SAMLUserInfo from PySAML2 AuthnResponse.\n\n        Args:\n            response: PySAML2 AuthnResponse object\n\n        Returns:\n            SAMLUserInfo instance\n        \"\"\"\n        if not HAS_PYSAML2:\n            raise SAMLError(\"PySAML2 is required for SAML operations\")\n\n        # Extract NameID\n        name_id = response.name_id\n        name_id_value = str(name_id) if name_id else \"\"\n        name_id_format = getattr(name_id, \"format\", NAMEID_FORMAT_EMAILADDRESS)\n\n        # Extract session info\n        session_info = response.session_info()\n        session_index = session_info.get(\"session_index\")\n\n        # Extract attributes\n        ava = response.ava  # Attribute Value Assertion\n\n        # Common attribute mappings\n        email = None\n        name = None\n        given_name = None\n        family_name = None\n        groups = []\n\n        # Email attribute names\n        for attr in [\n            \"email\",\n            \"emailAddress\",\n            \"mail\",\n            \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n        ]:\n            if attr in ava:\n                email = ava[attr][0] if ava[attr] else None\n                break\n\n        # Name attributes\n        for attr in [\n            \"name\",\n            \"displayName\",\n            \"cn\",\n            \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n        ]:\n            if attr in ava:\n                name = ava[attr][0] if ava[attr] else None\n                break\n\n        # Given name\n        for attr in [\n            \"givenName\",\n            \"firstName\",\n            \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n        ]:\n            if attr in ava:\n                given_name = ava[attr][0] if ava[attr] else None\n                break\n\n        # Family name\n        for attr in [\n            \"surname\",\n            \"sn\",\n            \"lastName\",\n            \"familyName\",\n            \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n        ]:\n            if attr in ava:\n                family_name = ava[attr][0] if ava[attr] else None\n                break\n\n        # Groups\n        for attr in [\n            \"groups\",\n            \"memberOf\",\n            \"http://schemas.microsoft.com/ws/2008/06/identity/claims/groups\",\n        ]:\n            if attr in ava:\n                groups = list(ava[attr]) if ava[attr] else []\n                break\n\n        # Parse timestamps\n        authn_instant = None\n        session_not_on_or_after = None\n\n        # Get issuer\n        issuer = response.issuer() if hasattr(response, \"issuer\") else None\n\n        return cls(\n            name_id=name_id_value,\n            name_id_format=str(name_id_format) if name_id_format else NAMEID_FORMAT_EMAILADDRESS,\n            session_index=session_index,\n            email=email or name_id_value,  # Fall back to NameID if no email\n            name=name,\n            given_name=given_name,\n            family_name=family_name,\n            groups=groups,\n            attributes=dict(ava),\n            issuer=issuer,\n            authn_instant=authn_instant,\n            session_not_on_or_after=session_not_on_or_after,\n        )\n\n\nclass SAMLHandler:\n    \"\"\"SAML 2.0 Service Provider handler for enterprise SSO authentication.\n\n    This handler manages SAML authentication flows for multiple identity\n    providers. It supports:\n    - SP-initiated SSO (redirect to IdP)\n    - IdP-initiated SSO (unsolicited responses)\n    - Single Logout (SLO)\n    - SP metadata generation\n    - Outstanding request tracking for replay prevention\n\n    Example:\n        handler = SAMLHandler()\n\n        # Register an IdP\n        handler.register_idp(\n            name=\"okta\",\n            metadata_url=\"https://dev-123.okta.com/app/exk123/sso/saml/metadata\"\n        )\n\n        # Start login\n        redirect_url, request_id = await handler.initiate_login(\"okta\")\n\n        # Store request_id in session for replay prevention\n\n        # After IdP redirects back with SAML response:\n        user_info = await handler.process_acs_response(saml_response, request_id)\n    \"\"\"\n\n    def __init__(\n        self,\n        sp_config: Optional[SAMLSPConfig] = None,\n        config: Optional[SAMLConfig] = None,\n    ) -> None:\n        \"\"\"Initialize SAML handler.\n\n        Args:\n            sp_config: Service Provider configuration (creates default if not provided)\n            config: Full SAML configuration (overrides sp_config if provided)\n        \"\"\"\n        if config:\n            self._config = config\n        elif sp_config:\n            self._config = SAMLConfig(sp=sp_config)\n        else:\n            # Create minimal default configuration for testing\n            self._config = SAMLConfig(\n                sp=SAMLSPConfig(\n                    entity_id=\"urn:acgs2:saml:sp\",\n                    acs_url=\"/sso/saml/acs\",\n                )\n            )\n\n        self._idp_configs: dict[str, SAMLIdPConfig] = {}\n        self._saml_clients: dict[str, Any] = {}  # Cached Saml2Client per IdP\n        self._metadata_cache: dict[str, tuple[str, datetime]] = {}\n        self._outstanding_requests: dict[str, dict[str, Any]] = {}  # In-memory tracking\n        self._http_client: Optional[Any] = None\n\n        logger.info(\n            \"SAML handler initialized\",\n            extra={\n                \"entity_id\": self._config.sp.entity_id,\n                \"has_signing_creds\": self._config.sp.has_signing_credentials(),\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n    @property\n    def sp_config(self) -> SAMLSPConfig:\n        \"\"\"Get SP configuration.\"\"\"\n        return self._config.sp\n\n    def register_idp(\n        self,\n        name: str,\n        metadata_url: Optional[str] = None,\n        metadata_xml: Optional[str] = None,\n        entity_id: Optional[str] = None,\n        sso_url: Optional[str] = None,\n        slo_url: Optional[str] = None,\n        certificate: Optional[str] = None,\n        want_assertions_signed: bool = True,\n    ) -> None:\n        \"\"\"Register an Identity Provider.\n\n        Args:\n            name: Unique IdP name\n            metadata_url: URL to fetch IdP metadata\n            metadata_xml: Inline IdP metadata XML\n            entity_id: IdP entity ID (required if not using metadata)\n            sso_url: IdP SSO endpoint URL\n            slo_url: IdP SLO endpoint URL\n            certificate: IdP signing certificate (PEM format)\n            want_assertions_signed: Require signed assertions\n\n        Raises:\n            SAMLConfigurationError: If configuration is invalid\n        \"\"\"\n        idp = SAMLIdPConfig(\n            name=name,\n            metadata_url=metadata_url,\n            metadata_xml=metadata_xml,\n            entity_id=entity_id,\n            sso_url=sso_url,\n            slo_url=slo_url,\n            certificate=certificate,\n            want_assertions_signed=want_assertions_signed,\n        )\n\n        errors = idp.validate()\n        if errors:\n            raise SAMLConfigurationError(f\"Invalid IdP configuration: {'; '.join(errors)}\")\n\n        self._idp_configs[name] = idp\n        self._config.add_idp(idp)\n\n        # Clear cached client to force rebuild\n        if name in self._saml_clients:\n            del self._saml_clients[name]\n\n        logger.info(\n            \"SAML IdP registered\",\n            extra={\n                \"idp_name\": name,\n                \"has_metadata_url\": bool(metadata_url),\n                \"has_metadata_xml\": bool(metadata_xml),\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n    def register_idp_from_model(self, provider: Any) -> None:\n        \"\"\"Register an IdP from database model.\n\n        Args:\n            provider: SSOProvider model instance\n\n        Raises:\n            SAMLConfigurationError: If provider is not SAML or config invalid\n        \"\"\"\n        if not provider.is_saml:\n            raise SAMLConfigurationError(f\"Provider '{provider.name}' is not a SAML provider\")\n\n        errors = provider.validate_saml_config()\n        if errors:\n            raise SAMLConfigurationError(\n                f\"Invalid SAML configuration for '{provider.name}': {'; '.join(errors)}\"\n            )\n\n        self.register_idp(\n            name=provider.name,\n            metadata_url=provider.saml_metadata_url,\n            metadata_xml=provider.saml_metadata_xml,\n            entity_id=provider.saml_entity_id,\n            certificate=provider.saml_sp_cert,  # IdP cert for validation\n            want_assertions_signed=provider.saml_sign_assertions,\n        )\n\n    def get_idp(self, name: str) -> SAMLIdPConfig:\n        \"\"\"Get registered IdP configuration.\n\n        Args:\n            name: IdP name\n\n        Returns:\n            IdP configuration\n\n        Raises:\n            SAMLConfigurationError: If IdP not found\n        \"\"\"\n        if name not in self._idp_configs:\n            raise SAMLConfigurationError(f\"SAML IdP '{name}' not registered\")\n        return self._idp_configs[name]\n\n    def list_idps(self) -> list[str]:\n        \"\"\"List all registered IdP names.\n\n        Returns:\n            List of IdP names\n        \"\"\"\n        return list(self._idp_configs.keys())\n\n    async def _get_http_client(self) -> Any:\n        \"\"\"Get or create HTTP client.\n\n        Returns:\n            httpx AsyncClient instance\n        \"\"\"\n        if self._http_client is None:\n            if not HAS_HTTPX:\n                raise SAMLError(\"httpx library is required for SAML metadata fetching\")\n            self._http_client = httpx.AsyncClient(timeout=30.0)\n        return self._http_client\n\n    async def _fetch_metadata(\n        self, idp: SAMLIdPConfig, force_refresh: bool = False\n    ) -> Optional[str]:\n        \"\"\"Fetch IdP metadata from URL.\n\n        Args:\n            idp: IdP configuration\n            force_refresh: Force metadata refresh even if cached\n\n        Returns:\n            Metadata XML string or None\n        \"\"\"\n        if not idp.metadata_url:\n            return idp.metadata_xml\n\n        cache_key = idp.name\n        if not force_refresh and cache_key in self._metadata_cache:\n            xml, cached_at = self._metadata_cache[cache_key]\n            age = datetime.now(timezone.utc) - cached_at\n            if age.total_seconds() < self._config.metadata_cache_duration:\n                return xml\n\n        try:\n            client = await self._get_http_client()\n            response = await client.get(idp.metadata_url)\n            response.raise_for_status()\n            xml = response.text\n\n            self._metadata_cache[cache_key] = (xml, datetime.now(timezone.utc))\n\n            logger.info(\n                \"SAML IdP metadata fetched\",\n                extra={\n                    \"idp_name\": idp.name,\n                    \"metadata_url\": idp.metadata_url,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return xml\n\n        except Exception as e:\n            # Try to use cached metadata on error\n            if cache_key in self._metadata_cache:\n                logger.warning(\n                    \"Failed to refresh SAML metadata, using cached version\",\n                    extra={\n                        \"idp_name\": idp.name,\n                        \"error\": str(e),\n                        \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                    },\n                )\n                return self._metadata_cache[cache_key][0]\n\n            raise SAMLProviderError(f\"Failed to fetch metadata for IdP '{idp.name}': {e}\") from e\n\n    def _build_pysaml2_config(self, idp: SAMLIdPConfig, metadata_xml: Optional[str]) -> dict:\n        \"\"\"Build PySAML2 configuration dictionary.\n\n        Args:\n            idp: IdP configuration\n            metadata_xml: IdP metadata XML content\n\n        Returns:\n            PySAML2 configuration dictionary\n        \"\"\"\n        sp = self._config.sp\n\n        config: dict[str, Any] = {\n            \"entityid\": sp.entity_id,\n            \"xmlsec_binary\": sp.xmlsec_binary,\n            \"allow_unsolicited\": sp.allow_unsolicited,\n            \"accepted_time_diff\": sp.clock_skew_tolerance,\n            \"service\": {\n                \"sp\": {\n                    \"name\": sp.name,\n                    \"description\": sp.description,\n                    \"endpoints\": {\n                        \"assertion_consumer_service\": [\n                            (sp.acs_url, BINDING_HTTP_POST),\n                        ],\n                    },\n                    \"want_assertions_signed\": sp.want_assertions_signed,\n                    \"want_response_signed\": idp.want_response_signed,\n                    \"authn_requests_signed\": sp.sign_authn_requests,\n                },\n            },\n            \"debug\": self._config.debug,\n        }\n\n        # Add SLS endpoint if configured\n        if sp.sls_url:\n            config[\"service\"][\"sp\"][\"endpoints\"][\"single_logout_service\"] = [\n                (sp.sls_url, BINDING_HTTP_REDIRECT),\n                (sp.sls_url, BINDING_HTTP_POST),\n            ]\n\n        # Add SP certificate and key\n        cert_content = sp.get_cert_content()\n        key_content = sp.get_key_content()\n\n        if cert_content and key_content:\n            # Write to temporary files for PySAML2\n            self._temp_cert_file = tempfile.NamedTemporaryFile(\n                mode=\"w\", suffix=\".crt\", delete=False\n            )\n            self._temp_cert_file.write(cert_content)\n            self._temp_cert_file.flush()\n\n            self._temp_key_file = tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".key\", delete=False)\n            self._temp_key_file.write(key_content)\n            self._temp_key_file.flush()\n\n            config[\"cert_file\"] = self._temp_cert_file.name\n            config[\"key_file\"] = self._temp_key_file.name\n\n        # Add IdP metadata\n        if metadata_xml:\n            # Write metadata to temp file\n            self._temp_metadata_file = tempfile.NamedTemporaryFile(\n                mode=\"w\", suffix=\".xml\", delete=False\n            )\n            self._temp_metadata_file.write(metadata_xml)\n            self._temp_metadata_file.flush()\n\n            config[\"metadata\"] = {\n                \"local\": [self._temp_metadata_file.name],\n            }\n        elif idp.entity_id and idp.sso_url:\n            # Manual IdP configuration\n            config[\"metadata\"] = {\n                \"inline\": [\n                    {\n                        \"entity_id\": idp.entity_id,\n                        \"sso_url\": idp.sso_url,\n                        \"slo_url\": idp.slo_url,\n                        \"cert\": idp.certificate,\n                    }\n                ]\n            }\n\n        return config\n\n    async def _get_saml_client(self, idp_name: str) -> Any:\n        \"\"\"Get or create SAML client for an IdP.\n\n        Args:\n            idp_name: IdP name\n\n        Returns:\n            PySAML2 Saml2Client instance\n\n        Raises:\n            SAMLError: If PySAML2 is not available\n            SAMLConfigurationError: If IdP not found\n        \"\"\"\n        if not HAS_PYSAML2:\n            raise SAMLError(\n                \"PySAML2 is required for SAML operations. \" \"Install with: pip install pysaml2\"\n            )\n\n        idp = self.get_idp(idp_name)\n\n        # Return cached client if available\n        if idp_name in self._saml_clients:\n            return self._saml_clients[idp_name]\n\n        # Fetch metadata\n        metadata_xml = await self._fetch_metadata(idp)\n\n        # Build configuration\n        config_dict = self._build_pysaml2_config(idp, metadata_xml)\n\n        # Create PySAML2 config\n        saml_config = Saml2Config()\n        saml_config.load(config_dict)\n\n        # Create client\n        client = Saml2Client(config=saml_config)\n\n        self._saml_clients[idp_name] = client\n        return client\n\n    def _generate_request_id(self) -> str:\n        \"\"\"Generate a unique SAML request ID.\n\n        Returns:\n            Unique request ID string\n        \"\"\"\n        return f\"_saml_{secrets.token_hex(16)}\"\n\n    def store_outstanding_request(\n        self,\n        request_id: Optional[str] = None,\n        idp_name: Optional[str] = None,\n        relay_state: Optional[str] = None,\n        expiry_minutes: int = 5,\n    ) -> str:\n        \"\"\"Store an outstanding SAML request for replay prevention.\n\n        Args:\n            request_id: Request ID (generated if not provided)\n            idp_name: Name of the IdP\n            relay_state: Relay state for redirect after authentication\n            expiry_minutes: Minutes until request expires\n\n        Returns:\n            The request ID\n        \"\"\"\n        if request_id is None:\n            request_id = self._generate_request_id()\n\n        now = datetime.now(timezone.utc)\n        self._outstanding_requests[request_id] = {\n            \"idp_name\": idp_name,\n            \"relay_state\": relay_state,\n            \"created_at\": now,\n            \"expires_at\": now + timedelta(minutes=expiry_minutes),\n        }\n\n        logger.debug(\n            \"SAML outstanding request stored\",\n            extra={\n                \"request_id\": request_id[:16] + \"...\",\n                \"idp_name\": idp_name,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n        return request_id\n\n    def verify_and_remove_request(self, request_id: str) -> bool:\n        \"\"\"Verify an outstanding request exists and remove it.\n\n        Args:\n            request_id: Request ID to verify\n\n        Returns:\n            True if request was valid, False otherwise\n        \"\"\"\n        if request_id not in self._outstanding_requests:\n            return False\n\n        request = self._outstanding_requests.pop(request_id)\n\n        # Check expiration\n        if datetime.now(timezone.utc) > request[\"expires_at\"]:\n            logger.warning(\n                \"SAML request expired\",\n                extra={\n                    \"request_id\": request_id[:16] + \"...\",\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            return False\n\n        return True\n\n    def get_outstanding_requests(self) -> dict[str, str]:\n        \"\"\"Get all outstanding requests in PySAML2 format.\n\n        Returns:\n            Dictionary mapping request IDs to creation timestamps\n        \"\"\"\n        # Clean expired requests\n        now = datetime.now(timezone.utc)\n        expired = [\n            rid for rid, req in self._outstanding_requests.items() if now > req[\"expires_at\"]\n        ]\n        for rid in expired:\n            del self._outstanding_requests[rid]\n\n        return {\n            rid: req[\"created_at\"].isoformat() for rid, req in self._outstanding_requests.items()\n        }\n\n    def clear_expired_requests(self) -> int:\n        \"\"\"Clear expired outstanding requests.\n\n        Returns:\n            Number of requests cleared\n        \"\"\"\n        now = datetime.now(timezone.utc)\n        expired = [\n            rid for rid, req in self._outstanding_requests.items() if now > req[\"expires_at\"]\n        ]\n\n        for rid in expired:\n            del self._outstanding_requests[rid]\n\n        if expired:\n            logger.info(\n                \"Cleared expired SAML requests\",\n                extra={\n                    \"count\": len(expired),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n        return len(expired)\n\n    async def initiate_login(\n        self,\n        idp_name: str,\n        relay_state: Optional[str] = None,\n        force_authn: bool = False,\n    ) -> tuple[str, str]:\n        \"\"\"Initiate SP-initiated SAML login.\n\n        Args:\n            idp_name: Name of the IdP to use\n            relay_state: URL to redirect to after authentication\n            force_authn: Force re-authentication even if user has session\n\n        Returns:\n            Tuple of (redirect_url, request_id)\n\n        Raises:\n            SAMLError: If PySAML2 is not available\n            SAMLConfigurationError: If IdP not found\n        \"\"\"\n        client = await self._get_saml_client(idp_name)\n        idp = self.get_idp(idp_name)\n\n        # Get IdP entity ID from metadata\n        idp_entity_id = idp.entity_id\n        if not idp_entity_id:\n            # Try to get from client metadata\n            try:\n                idps = client.metadata.identity_providers()\n                if idps:\n                    idp_entity_id = idps[0]\n            except Exception:\n                pass\n\n        if not idp_entity_id:\n            raise SAMLConfigurationError(f\"Cannot determine entity ID for IdP '{idp_name}'\")\n\n        try:\n            # Prepare authentication request\n            req_id, info = client.prepare_for_authenticate(\n                entityid=idp_entity_id,\n                relay_state=relay_state or \"\",\n                force_authn=force_authn,\n            )\n\n            # Store outstanding request\n            self.store_outstanding_request(\n                request_id=req_id,\n                idp_name=idp_name,\n                relay_state=relay_state,\n            )\n\n            # Extract redirect URL from headers\n            headers_dict = dict(info[\"headers\"])\n            redirect_url = headers_dict.get(\"Location\", \"\")\n\n            if not redirect_url:\n                raise SAMLError(\"Failed to get redirect URL from SAML request\")\n\n            logger.info(\n                \"SAML login initiated\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"request_id\": req_id[:16] + \"...\",\n                    \"force_authn\": force_authn,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return redirect_url, req_id\n\n        except (UnknownPrincipal, UnsupportedBinding) as e:\n            raise SAMLConfigurationError(\n                f\"SAML configuration error for IdP '{idp_name}': {e}\"\n            ) from e\n        except Exception as e:\n            raise SAMLError(f\"Failed to initiate SAML login: {e}\") from e\n\n    async def process_acs_response(\n        self,\n        saml_response: str,\n        request_id: Optional[str] = None,\n        idp_name: Optional[str] = None,\n    ) -> SAMLUserInfo:\n        \"\"\"Process SAML response at Assertion Consumer Service.\n\n        Args:\n            saml_response: Base64-encoded SAML response\n            request_id: Original request ID for replay prevention (optional for IdP-initiated)\n            idp_name: IdP name (will auto-detect from response if not provided)\n\n        Returns:\n            SAMLUserInfo with user details\n\n        Raises:\n            SAMLValidationError: If signature validation fails\n            SAMLReplayError: If replay attack detected\n            SAMLAuthenticationError: If authentication failed\n        \"\"\"\n        if not HAS_PYSAML2:\n            raise SAMLError(\"PySAML2 is required for SAML operations\")\n\n        # Get outstanding requests for validation\n        outstanding = self.get_outstanding_requests()\n\n        # Determine which IdP to use\n        if not idp_name:\n            # Try to find from outstanding request\n            if request_id and request_id in self._outstanding_requests:\n                idp_name = self._outstanding_requests[request_id].get(\"idp_name\")\n            else:\n                # Use first registered IdP\n                idp_list = self.list_idps()\n                if not idp_list:\n                    raise SAMLConfigurationError(\"No IdPs registered\")\n                idp_name = idp_list[0]\n\n        client = await self._get_saml_client(idp_name)\n\n        try:\n            # Parse and validate response\n            response = client.parse_authn_request_response(\n                saml_response,\n                BINDING_HTTP_POST,\n                outstanding=outstanding if outstanding else None,\n            )\n\n            if response is None:\n                raise SAMLValidationError(\"Failed to parse SAML response\")\n\n            # Verify this response hasn't been used before (replay prevention)\n            if request_id:\n                if not self.verify_and_remove_request(request_id):\n                    logger.warning(\n                        \"SAML replay attack detected or request expired\",\n                        extra={\n                            \"request_id\": request_id[:16] + \"...\",\n                            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                        },\n                    )\n                    raise SAMLReplayError(\"SAML response replay detected or request expired\")\n\n            # Extract user information\n            user_info = SAMLUserInfo.from_response(response)\n\n            logger.info(\n                \"SAML authentication successful\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"name_id\": user_info.name_id[:16] + \"...\" if user_info.name_id else \"N/A\",\n                    \"email\": user_info.email,\n                    \"groups_count\": len(user_info.groups),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return user_info\n\n        except SAMLReplayError:\n            raise\n        except Exception as e:\n            logger.error(\n                \"SAML validation failed\",\n                extra={\n                    \"error\": str(e),\n                    \"idp_name\": idp_name,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            raise SAMLValidationError(f\"SAML response validation failed: {e}\") from e\n\n    async def initiate_logout(\n        self,\n        idp_name: str,\n        name_id: str,\n        session_index: Optional[str] = None,\n        relay_state: Optional[str] = None,\n    ) -> Optional[str]:\n        \"\"\"Initiate SAML Single Logout (SLO).\n\n        Args:\n            idp_name: IdP name\n            name_id: User's SAML NameID\n            session_index: Session index from login\n            relay_state: URL to redirect after logout\n\n        Returns:\n            Logout redirect URL, or None if IdP doesn't support SLO\n        \"\"\"\n        if not HAS_PYSAML2:\n            return None\n\n        idp = self.get_idp(idp_name)\n        if not idp.slo_url:\n            logger.info(\n                \"IdP does not support SLO\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            return None\n\n        try:\n            client = await self._get_saml_client(idp_name)\n\n            # Get IdP entity ID\n            idp_entity_id = idp.entity_id\n            if not idp_entity_id:\n                idps = client.metadata.identity_providers()\n                if idps:\n                    idp_entity_id = idps[0]\n\n            if not idp_entity_id:\n                return None\n\n            # Create logout request\n            req_id, info = client.do_logout(\n                name_id,\n                entity_ids=[idp_entity_id],\n                session_indexes=[session_index] if session_index else None,\n                sign=self._config.sp.sign_authn_requests,\n            )\n\n            headers_dict = dict(info.get(\"headers\", []))\n            logout_url = headers_dict.get(\"Location\")\n\n            if logout_url and relay_state:\n                # Add relay state to logout URL\n                separator = \"&\" if \"?\" in logout_url else \"?\"\n                logout_url = f\"{logout_url}{separator}{urlencode({'RelayState': relay_state})}\"\n\n            logger.info(\n                \"SAML logout initiated\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return logout_url\n\n        except Exception as e:\n            logger.warning(\n                \"Failed to initiate SAML logout\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"error\": str(e),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            return None\n\n    async def process_sls_response(\n        self,\n        saml_response: str,\n        idp_name: str,\n    ) -> bool:\n        \"\"\"Process SAML logout response.\n\n        Args:\n            saml_response: Base64-encoded SAML logout response\n            idp_name: IdP name\n\n        Returns:\n            True if logout was successful\n        \"\"\"\n        if not HAS_PYSAML2:\n            return True\n\n        try:\n            client = await self._get_saml_client(idp_name)\n\n            # Parse logout response\n            response = client.parse_logout_request_response(\n                saml_response,\n                BINDING_HTTP_REDIRECT,\n            )\n\n            success = response.status_ok()\n\n            logger.info(\n                \"SAML logout response processed\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"success\": success,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return success\n\n        except Exception as e:\n            logger.warning(\n                \"Failed to process SAML logout response\",\n                extra={\n                    \"idp_name\": idp_name,\n                    \"error\": str(e),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            return False\n\n    async def generate_metadata(self) -> str:\n        \"\"\"Generate SP metadata XML.\n\n        Returns:\n            SP metadata XML string\n\n        Raises:\n            SAMLError: If metadata generation fails\n        \"\"\"\n        if not HAS_PYSAML2:\n            # Return minimal metadata without PySAML2\n            sp = self._config.sp\n            cert_content = sp.get_cert_content() or \"\"\n\n            # Strip PEM headers for metadata\n            cert_for_xml = (\n                cert_content.replace(\"-----BEGIN CERTIFICATE-----\", \"\")\n                .replace(\"-----END CERTIFICATE-----\", \"\")\n                .replace(\"\\n\", \"\")\n                .strip()\n            )\n\n            return f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<md:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\"\n                     entityID=\"{sp.entity_id}\">\n  <md:SPSSODescriptor\n      AuthnRequestsSigned=\"{str(sp.sign_authn_requests).lower()}\"\n      WantAssertionsSigned=\"{str(sp.want_assertions_signed).lower()}\"\n      protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\">\n    <md:KeyDescriptor use=\"signing\">\n      <ds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\">\n        <ds:X509Data>\n          <ds:X509Certificate>{cert_for_xml}</ds:X509Certificate>\n        </ds:X509Data>\n      </ds:KeyInfo>\n    </md:KeyDescriptor>\n    <md:NameIDFormat>{NAMEID_FORMAT_EMAILADDRESS}</md:NameIDFormat>\n    <md:AssertionConsumerService\n        Binding=\"{BINDING_HTTP_POST}\"\n        Location=\"{sp.acs_url}\"\n        index=\"0\"\n        isDefault=\"true\"/>\n  </md:SPSSODescriptor>\n  <md:Organization>\n    <md:OrganizationName xml:lang=\"en\">{sp.org_name}</md:OrganizationName>\n    <md:OrganizationDisplayName xml:lang=\"en\">{sp.org_display_name}</md:OrganizationDisplayName>\n    <md:OrganizationURL xml:lang=\"en\">{sp.org_url}</md:OrganizationURL>\n  </md:Organization>\n  <md:ContactPerson contactType=\"technical\">\n    <md:GivenName>{sp.contact_name}</md:GivenName>\n    <md:EmailAddress>{sp.contact_email}</md:EmailAddress>\n  </md:ContactPerson>\n</md:EntityDescriptor>\"\"\"\n\n        try:\n            # Use a dummy IdP just to generate SP metadata\n            idps = self.list_idps()\n            if idps:\n                client = await self._get_saml_client(idps[0])\n            else:\n                # Create minimal client just for metadata\n                config_dict = self._build_pysaml2_config(\n                    SAMLIdPConfig(name=\"dummy\"),\n                    None,\n                )\n                saml_config = Saml2Config()\n                saml_config.load(config_dict)\n                client = Saml2Client(config=saml_config)\n\n            # Generate metadata\n            metadata = create_metadata_string(\n                None,\n                config=client.config,\n                sign=False,  # Don't sign metadata\n            )\n\n            return metadata.decode(\"utf-8\") if isinstance(metadata, bytes) else str(metadata)\n\n        except Exception as e:\n            raise SAMLError(f\"Failed to generate SP metadata: {e}\") from e\n\n    async def close(self) -> None:\n        \"\"\"Close HTTP client and clean up resources.\"\"\"\n        if self._http_client is not None:\n            await self._http_client.aclose()\n            self._http_client = None\n\n        # Clean up temporary files\n        for attr in [\"_temp_cert_file\", \"_temp_key_file\", \"_temp_metadata_file\"]:\n            if hasattr(self, attr):\n                temp_file = getattr(self, attr)\n                if temp_file:\n                    try:\n                        Path(temp_file.name).unlink(missing_ok=True)\n                    except Exception:\n                        pass\n\n        logger.info(\n            \"SAML handler closed\",\n            extra={\"constitutional_hash\": CONSTITUTIONAL_HASH},\n        )\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.165786",
  "last_updated": "2026-01-04T05:35:59.053907"
}