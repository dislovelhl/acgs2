{
  "file_path": "integration-service/src/config/validation.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nConfiguration validation utilities.\n\nProvides validators for integration configurations, including\nconnectivity checks, credential validation, and schema enforcement.\n\"\"\"\n\nimport logging\nimport re\nfrom typing import Any, Dict, List, Optional, Type, Union\n\nfrom pydantic import ValidationError as PydanticValidationError\n\nfrom exceptions.validation import ConfigValidationError\n\nfrom .models import (\n    BaseIntegrationConfig,\n    GitHubActionsConfig,\n    GitLabCIConfig,\n    JiraConfig,\n    SentinelConfig,\n    ServiceNowConfig,\n    SplunkConfig,\n    WebhookConfig,\n)\n\nlogger = logging.getLogger(__name__)\n\n\n# Public API exports - make exceptions and validators available for import from this module\n__all__ = [\n    \"ConfigValidationError\",\n    \"ValidationResult\",\n    \"ConfigValidator\",\n]\n\n\nclass ValidationResult:\n    \"\"\"Result of a configuration validation check.\"\"\"\n\n    def __init__(\n        self,\n        valid: bool,\n        errors: Optional[List[str]] = None,\n        warnings: Optional[List[str]] = None,\n    ):\n        self.valid = valid\n        self.errors = errors or []\n        self.warnings = warnings or []\n\n    def __bool__(self) -> bool:\n        return self.valid\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert result to dictionary.\"\"\"\n        return {\n            \"valid\": self.valid,\n            \"errors\": self.errors,\n            \"warnings\": self.warnings,\n        }\n\n\nclass ConfigValidator:\n    \"\"\"\n    Validator for integration configurations.\n\n    Provides comprehensive validation including:\n    - Schema validation via Pydantic\n    - Business rule validation\n    - Cross-field validation\n    - Environment-specific checks\n    \"\"\"\n\n    # URL patterns for validation\n    URL_PATTERN = re.compile(\n        r\"^https?://\"\n        r\"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|\"\n        r\"localhost|\"\n        r\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n        r\"(?::\\d+)?\"\n        r\"(?:/?|[/?]\\S+)$\",\n        re.IGNORECASE,\n    )\n\n    # Email pattern for validation\n    EMAIL_PATTERN = re.compile(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\")\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the validator.\"\"\"\n        self._custom_validators: Dict[str, callable] = {}\n\n    def register_validator(self, provider: str, validator: callable) -> None:\n        \"\"\"\n        Register a custom validator for a specific provider.\n\n        Args:\n            provider: Integration provider name (e.g., 'splunk')\n            validator: Callable that takes config and returns ValidationResult\n        \"\"\"\n        self._custom_validators[provider] = validator\n\n    def validate(\n        self,\n        config: Union[Dict[str, Any], BaseIntegrationConfig],\n        config_type: Optional[Type[BaseIntegrationConfig]] = None,\n    ) -> ValidationResult:\n        \"\"\"\n        Validate an integration configuration.\n\n        Args:\n            config: Configuration dict or Pydantic model\n            config_type: Optional type hint for dict configs\n\n        Returns:\n            ValidationResult with validation status and any errors/warnings\n        \"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Convert dict to Pydantic model if needed\n        if isinstance(config, dict):\n            try:\n                if config_type:\n                    config = config_type(**config)\n                else:\n                    config = self._infer_and_parse_config(config)\n            except PydanticValidationError as e:\n                for error in e.errors():\n                    field = \".\".join(str(loc) for loc in error[\"loc\"])\n                    errors.append(f\"{field}: {error['msg']}\")\n                return ValidationResult(valid=False, errors=errors)\n\n        # Run provider-specific validation\n        provider = getattr(config, \"provider\", None)\n        if provider:\n            provider_result = self._validate_provider(config)\n            errors.extend(provider_result.errors)\n            warnings.extend(provider_result.warnings)\n\n        # Run custom validators if registered\n        if provider and provider in self._custom_validators:\n            try:\n                custom_result = self._custom_validators[provider](config)\n                if isinstance(custom_result, ValidationResult):\n                    errors.extend(custom_result.errors)\n                    warnings.extend(custom_result.warnings)\n            except Exception as e:\n                logger.warning(f\"Custom validator failed for {provider}: {e}\")\n                warnings.append(f\"Custom validation skipped: {str(e)}\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _infer_and_parse_config(self, config: Dict[str, Any]) -> BaseIntegrationConfig:\n        \"\"\"\n        Infer the config type from the dict and parse it.\n\n        Args:\n            config: Configuration dictionary\n\n        Returns:\n            Parsed Pydantic model\n\n        Raises:\n            ValueError: If config type cannot be inferred\n        \"\"\"\n        provider = config.get(\"provider\")\n        if not provider:\n            raise ValueError(\"Cannot infer config type: 'provider' field is required\")\n\n        provider_map: Dict[str, Type[BaseIntegrationConfig]] = {\n            \"splunk\": SplunkConfig,\n            \"sentinel\": SentinelConfig,\n            \"jira\": JiraConfig,\n            \"servicenow\": ServiceNowConfig,\n            \"github\": GitHubActionsConfig,\n            \"gitlab\": GitLabCIConfig,\n            \"webhook\": WebhookConfig,\n        }\n\n        config_class = provider_map.get(provider)\n        if not config_class:\n            raise ValueError(f\"Unknown provider: {provider}\")\n\n        return config_class(**config)\n\n    def _validate_provider(self, config: BaseIntegrationConfig) -> ValidationResult:\n        \"\"\"\n        Run provider-specific validation rules.\n\n        Args:\n            config: Parsed configuration model\n\n        Returns:\n            ValidationResult with provider-specific errors/warnings\n        \"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if isinstance(config, SplunkConfig):\n            result = self._validate_splunk(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n        elif isinstance(config, SentinelConfig):\n            result = self._validate_sentinel(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n        elif isinstance(config, JiraConfig):\n            result = self._validate_jira(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n        elif isinstance(config, ServiceNowConfig):\n            result = self._validate_servicenow(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n        elif isinstance(config, (GitHubActionsConfig, GitLabCIConfig)):\n            result = self._validate_cicd(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n        elif isinstance(config, WebhookConfig):\n            result = self._validate_webhook(config)\n            errors.extend(result.errors)\n            warnings.extend(result.warnings)\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_splunk(self, config: SplunkConfig) -> ValidationResult:\n        \"\"\"Validate Splunk-specific configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Check host format\n        if \"/\" in config.host:\n            errors.append(\n                \"host should not contain paths, only hostname (e.g., 'splunk.example.com')\"\n            )\n\n        # Warn about SSL settings\n        if not config.use_ssl:\n            warnings.append(\"SSL is disabled - credentials will be sent in plain text\")\n        elif not config.verify_ssl:\n            warnings.append(\"SSL verification is disabled - vulnerable to MITM attacks\")\n\n        # Check for common HEC port\n        if config.port not in [8088, 443]:\n            warnings.append(f\"Non-standard HEC port {config.port} - verify this is correct\")\n\n        # Index name validation\n        if config.index == \"main\":\n            warnings.append(\"Using default 'main' index - consider using a dedicated index\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_sentinel(self, config: SentinelConfig) -> ValidationResult:\n        \"\"\"Validate Azure Sentinel-specific configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Validate tenant ID format (GUID)\n        guid_pattern = re.compile(\n            r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\",\n            re.IGNORECASE,\n        )\n        if not guid_pattern.match(config.tenant_id):\n            errors.append(\"tenant_id must be a valid GUID\")\n        if not guid_pattern.match(config.client_id):\n            errors.append(\"client_id must be a valid GUID\")\n\n        # Validate DCR immutable ID format\n        if not config.dcr_immutable_id.startswith(\"dcr-\"):\n            warnings.append(\n                \"dcr_immutable_id typically starts with 'dcr-' - verify this is correct\"\n            )\n\n        # Stream name validation\n        if not config.stream_name.startswith(\"Custom-\"):\n            warnings.append(\"stream_name should typically start with 'Custom-' for custom tables\")\n        if not config.stream_name.endswith(\"_CL\"):\n            warnings.append(\"stream_name should typically end with '_CL' for custom logs\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_jira(self, config: JiraConfig) -> ValidationResult:\n        \"\"\"Validate Jira-specific configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Validate base URL\n        if not self.URL_PATTERN.match(config.base_url):\n            errors.append(\"base_url is not a valid URL\")\n\n        # Check for Atlassian Cloud\n        if \"atlassian.net\" in config.base_url and not config.is_cloud:\n            warnings.append(\"URL appears to be Jira Cloud but is_cloud is False\")\n\n        # Validate email for API token auth\n        if config.auth_type == \"api_token\" and config.user_email:\n            if not self.EMAIL_PATTERN.match(config.user_email):\n                errors.append(\"user_email is not a valid email address\")\n\n        # Project key format\n        if not re.match(r\"^[A-Z][A-Z0-9]*$\", config.project_key):\n            warnings.append(\"project_key should be uppercase letters/numbers (e.g., 'GOV')\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_servicenow(self, config: ServiceNowConfig) -> ValidationResult:\n        \"\"\"Validate ServiceNow-specific configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Validate instance URL\n        if not self.URL_PATTERN.match(config.instance):\n            errors.append(\"instance is not a valid URL\")\n\n        # Check for service-now.com domain\n        if \"service-now.com\" not in config.instance:\n            warnings.append(\n                \"instance URL does not contain 'service-now.com' - verify this is correct\"\n            )\n\n        # Impact and urgency should be 1-3\n        valid_levels = {\"1\", \"2\", \"3\"}\n        if config.impact not in valid_levels:\n            errors.append(\"impact must be '1', '2', or '3'\")\n        if config.urgency not in valid_levels:\n            errors.append(\"urgency must be '1', '2', or '3'\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_cicd(\n        self, config: Union[GitHubActionsConfig, GitLabCIConfig]\n    ) -> ValidationResult:\n        \"\"\"Validate CI/CD integration configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Validate severity threshold\n        valid_severities = {\"critical\", \"high\", \"medium\", \"low\", \"info\"}\n        if config.severity_threshold.lower() not in valid_severities:\n            errors.append(f\"severity_threshold must be one of: {', '.join(valid_severities)}\")\n\n        if isinstance(config, GitHubActionsConfig):\n            # Validate GitHub API URL\n            if not self.URL_PATTERN.match(config.api_url):\n                errors.append(\"api_url is not a valid URL\")\n\n            # Warn about token permissions\n            if config.app_id and not config.app_private_key:\n                errors.append(\"app_private_key is required when using GitHub App authentication\")\n\n        elif isinstance(config, GitLabCIConfig):\n            # Validate GitLab API URL\n            if not self.URL_PATTERN.match(config.api_url):\n                errors.append(\"api_url is not a valid URL\")\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n    def _validate_webhook(self, config: WebhookConfig) -> ValidationResult:\n        \"\"\"Validate webhook configuration.\"\"\"\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        # Validate URL\n        if not self.URL_PATTERN.match(config.url):\n            errors.append(\"url is not a valid URL\")\n\n        # Warn about HTTP endpoints\n        if config.url.startswith(\"http://\"):\n            warnings.append(\"Using HTTP instead of HTTPS - credentials may be exposed\")\n\n        # HMAC validation\n        if config.auth_type.value == \"hmac\" and not config.hmac_secret:\n            errors.append(\"hmac_secret is required when using HMAC authentication\")\n\n        # Auth value validation\n        if config.auth_type.value in (\"api_key\", \"bearer\") and not config.auth_value:\n            errors.append(\n                f\"auth_value is required when using {config.auth_type.value} authentication\"\n            )\n\n        return ValidationResult(\n            valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n        )\n\n\ndef validate_integration_config(\n    config: Union[Dict[str, Any], BaseIntegrationConfig],\n    config_type: Optional[Type[BaseIntegrationConfig]] = None,\n    raise_on_error: bool = False,\n) -> ValidationResult:\n    \"\"\"\n    Convenience function to validate an integration configuration.\n\n    Args:\n        config: Configuration dict or Pydantic model\n        config_type: Optional type hint for dict configs\n        raise_on_error: If True, raise ConfigValidationError on validation failure\n\n    Returns:\n        ValidationResult with validation status\n\n    Raises:\n        ConfigValidationError: If raise_on_error is True and validation fails\n    \"\"\"\n    validator = ConfigValidator()\n    result = validator.validate(config, config_type)\n\n    if raise_on_error and not result.valid:\n        raise ConfigValidationError(\n            message=\"Configuration validation failed\",\n            details={\"errors\": result.errors, \"warnings\": result.warnings},\n        )\n\n    return result\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.558937",
  "last_updated": "2026-01-04T05:35:51.200807"
}