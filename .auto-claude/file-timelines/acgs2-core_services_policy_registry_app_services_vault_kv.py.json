{
  "file_path": "acgs2-core/services/policy_registry/app/services/vault_kv.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Vault Crypto Service - KV Secrets Engine Operations\nConstitutional Hash: cdd01ef066bc6cf2\n\nKey-Value secrets engine operations for secure secret storage\nand retrieval using HashiCorp Vault.\n\"\"\"\n\nimport logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, Protocol\n\n# Add acgs2-core/shared to path for type imports\nshared_path = Path(__file__).parent.parent.parent.parent.parent / \"shared\"\nif str(shared_path) not in sys.path:\n    sys.path.insert(0, str(shared_path))\n\nfrom types import JSONDict\n\nlogger = logging.getLogger(__name__)\n\n\nclass VaultHttpClient(Protocol):\n    \"\"\"Protocol for Vault HTTP client.\"\"\"\n\n    async def request(self, method: str, path: str, data: Optional[JSONDict] = None) -> JSONDict:\n        \"\"\"Make HTTP request to Vault API.\"\"\"\n        ...\n\n\nclass VaultKVOperations:\n    \"\"\"\n    Vault KV secrets engine operations wrapper.\n\n    Provides high-level methods for secret storage operations\n    using the Vault KV secrets engine (v1 and v2).\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: VaultHttpClient,\n        kv_mount: str = \"secret\",\n        kv_version: int = 2,\n    ):\n        \"\"\"\n        Initialize KV operations.\n\n        Args:\n            http_client: VaultHttpClient instance for API calls\n            kv_mount: Mount path for KV engine\n            kv_version: KV engine version (1 or 2)\n        \"\"\"\n        self._http_client = http_client\n        self._kv_mount = kv_mount\n        self._kv_version = kv_version\n\n    async def put(\n        self,\n        path: str,\n        data: JSONDict,\n        metadata: Optional[dict[str, str]] = None,\n    ) -> None:\n        \"\"\"\n        Store a secret in KV engine.\n\n        Args:\n            path: Secret path\n            data: Secret data to store\n            metadata: Optional metadata\n        \"\"\"\n        if self._kv_version == 2:\n            api_path = f\"/v1/{self._kv_mount}/data/{path}\"\n            payload: JSONDict = {\"data\": data}\n            if metadata:\n                payload[\"options\"] = {\"cas\": 0}  # Check-and-set\n        else:\n            api_path = f\"/v1/{self._kv_mount}/{path}\"\n            payload = data\n\n        await self._http_client.request(\"POST\", api_path, data=payload)\n        logger.debug(f\"Stored secret at: {path}\")\n\n    async def get(\n        self,\n        path: str,\n        version: Optional[int] = None,\n    ) -> JSONDict:\n        \"\"\"\n        Get a secret from KV engine.\n\n        Args:\n            path: Secret path\n            version: Specific version (None for latest, KV v2 only)\n\n        Returns:\n            Secret data dictionary\n        \"\"\"\n        if self._kv_version == 2:\n            api_path = f\"/v1/{self._kv_mount}/data/{path}\"\n            if version:\n                api_path += f\"?version={version}\"\n        else:\n            api_path = f\"/v1/{self._kv_mount}/{path}\"\n\n        response = await self._http_client.request(\"GET\", api_path)\n\n        if self._kv_version == 2:\n            return response.get(\"data\", {}).get(\"data\", {})\n        return response.get(\"data\", {})\n\n    async def delete(self, path: str) -> None:\n        \"\"\"\n        Delete a secret from KV engine.\n\n        Args:\n            path: Secret path\n        \"\"\"\n        if self._kv_version == 2:\n            api_path = f\"/v1/{self._kv_mount}/data/{path}\"\n        else:\n            api_path = f\"/v1/{self._kv_mount}/{path}\"\n\n        await self._http_client.request(\"DELETE\", api_path)\n        logger.debug(f\"Deleted secret at: {path}\")\n\n    async def list_secrets(self, path: str = \"\") -> JSONDict:\n        \"\"\"\n        List secrets at a path in KV engine.\n\n        Args:\n            path: Path to list (empty for root)\n\n        Returns:\n            Dictionary with keys list\n        \"\"\"\n        if self._kv_version == 2:\n            api_path = f\"/v1/{self._kv_mount}/metadata/{path}\"\n        else:\n            api_path = f\"/v1/{self._kv_mount}/{path}\"\n\n        # Use LIST method via query parameter\n        api_path += \"?list=true\"\n        response = await self._http_client.request(\"GET\", api_path)\n        return response.get(\"data\", {})\n\n    async def get_metadata(self, path: str) -> JSONDict:\n        \"\"\"\n        Get secret metadata (KV v2 only).\n\n        Args:\n            path: Secret path\n\n        Returns:\n            Metadata dictionary\n        \"\"\"\n        if self._kv_version != 2:\n            raise RuntimeError(\"Metadata operations require KV v2\")\n\n        api_path = f\"/v1/{self._kv_mount}/metadata/{path}\"\n        response = await self._http_client.request(\"GET\", api_path)\n        return response.get(\"data\", {})\n\n    async def delete_versions(\n        self,\n        path: str,\n        versions: list[int],\n    ) -> None:\n        \"\"\"\n        Delete specific versions of a secret (KV v2 only).\n\n        Args:\n            path: Secret path\n            versions: List of version numbers to delete\n        \"\"\"\n        if self._kv_version != 2:\n            raise RuntimeError(\"Version operations require KV v2\")\n\n        api_path = f\"/v1/{self._kv_mount}/delete/{path}\"\n        await self._http_client.request(\"POST\", api_path, data={\"versions\": versions})\n        logger.debug(f\"Deleted versions {versions} at: {path}\")\n\n    async def undelete_versions(\n        self,\n        path: str,\n        versions: list[int],\n    ) -> None:\n        \"\"\"\n        Undelete specific versions of a secret (KV v2 only).\n\n        Args:\n            path: Secret path\n            versions: List of version numbers to undelete\n        \"\"\"\n        if self._kv_version != 2:\n            raise RuntimeError(\"Version operations require KV v2\")\n\n        api_path = f\"/v1/{self._kv_mount}/undelete/{path}\"\n        await self._http_client.request(\"POST\", api_path, data={\"versions\": versions})\n        logger.debug(f\"Undeleted versions {versions} at: {path}\")\n\n    async def destroy_versions(\n        self,\n        path: str,\n        versions: list[int],\n    ) -> None:\n        \"\"\"\n        Permanently destroy specific versions of a secret (KV v2 only).\n\n        Args:\n            path: Secret path\n            versions: List of version numbers to destroy\n        \"\"\"\n        if self._kv_version != 2:\n            raise RuntimeError(\"Version operations require KV v2\")\n\n        api_path = f\"/v1/{self._kv_mount}/destroy/{path}\"\n        await self._http_client.request(\"POST\", api_path, data={\"versions\": versions})\n        logger.warning(f\"Permanently destroyed versions {versions} at: {path}\")\n\n\n__all__ = [\"VaultKVOperations\"]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.069425",
  "last_updated": "2026-01-04T05:35:58.859241"
}