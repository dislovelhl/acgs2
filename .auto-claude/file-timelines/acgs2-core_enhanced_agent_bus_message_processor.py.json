{
  "file_path": "src/core/enhanced_agent_bus/message_processor.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport hashlib\nimport logging\nimport re\nimport time\nfrom contextlib import nullcontext\nfrom typing import Any, Callable, Dict, List, Optional\n\ntry:\n    from .config import BusConfiguration\n    from .imports import (\n        CIRCUIT_BREAKER_ENABLED,\n        METERING_AVAILABLE,\n        METRICS_ENABLED,\n        POLICY_CLIENT_AVAILABLE,\n        USE_RUST,\n        CircuitBreakerConfig,\n        get_circuit_breaker,\n        get_metering_hooks,\n        get_opa_client,\n        get_policy_client,\n        rust_bus,\n    )\n    from .interfaces import ProcessingStrategy\n    from .memory_profiler import ProfilingLevel, get_memory_profiler\n    from .models import CONSTITUTIONAL_HASH, AgentMessage, MessageStatus, MessageType, Priority\n    from .runtime_security import get_runtime_security_scanner\n    from .utils import LRUCache\n    from .validators import ValidationResult\nexcept (ImportError, ValueError):\n    from imports import (\n        CIRCUIT_BREAKER_ENABLED,  # type: ignore\n        METERING_AVAILABLE,\n        POLICY_CLIENT_AVAILABLE,\n        USE_RUST,\n        CircuitBreakerConfig,\n        get_circuit_breaker,\n        get_metering_hooks,\n        get_opa_client,\n        get_policy_client,\n        rust_bus,\n    )\n    from interfaces import ProcessingStrategy  # type: ignore\n    from memory_profiler import get_memory_profiler  # type: ignore\n    from models import CONSTITUTIONAL_HASH, AgentMessage, MessageType, Priority  # type: ignore\n    from runtime_security import get_runtime_security_scanner  # type: ignore\n    from utils import LRUCache  # type: ignore\n    from validators import ValidationResult  # type: ignore\n\n    from config import BusConfiguration  # type: ignore  # type: ignore\n\nlogger = logging.getLogger(__name__)\n\nPROMPT_INJECTION_PATTERNS = [\n    r\"ignore (all )?previous instructions\",\n    r\"system prompt (leak|override|manipulation)\",\n    r\"do anything now\",\n    r\"jailbreak\",\n    r\"persona (adoption|override)\",\n    r\"\\(note to self: .*\\)\",\n    r\"\\[INST\\].*\\[/INST\\]\",\n]\n_INJECTION_RE = re.compile(\"|\".join(PROMPT_INJECTION_PATTERNS), re.IGNORECASE)\n\n\nclass MessageProcessor:\n    \"\"\"\n    Core message processing engine with constitutional validation and strategy selection.\n\n    The MessageProcessor handles the validation and routing of agent messages through\n    configurable processing strategies including constitutional hash validation,\n    OPA policy evaluation, and MACI role separation.\n\n    Processing flow:\n    1. Auto-select appropriate processing strategy based on configuration\n    2. Validate message against constitutional requirements\n    3. Route through deliberation layer if impact score > 0.8\n    4. Execute message handlers with proper error handling\n\n    Args:\n        isolated_mode: Run without external dependencies (default: False)\n        use_dynamic_policy: Use policy registry instead of static validation (default: False)\n        enable_maci: Enable MACI role separation enforcement (default: False)\n        opa_client: Optional OPA client for policy evaluation\n        processing_strategy: Custom processing strategy (auto-selected if None)\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        self._isolated_mode = kwargs.get(\"isolated_mode\", False)\n        self._use_dynamic_policy = (\n            kwargs.get(\"use_dynamic_policy\", False)\n            and POLICY_CLIENT_AVAILABLE\n            and not self._isolated_mode\n        )\n        self._policy_fail_closed = kwargs.get(\"policy_fail_closed\", False)\n        self._use_rust = kwargs.get(\"use_rust\", True)\n        self._enable_metering = kwargs.get(\"enable_metering\", True)\n        self._handlers, self._processed_count, self._failed_count = {}, 0, 0\n        self._metering_hooks = kwargs.get(\"metering_hooks\") or (\n            get_metering_hooks()\n            if (self._enable_metering and METERING_AVAILABLE and not self._isolated_mode)\n            else None\n        )\n        self._enable_maci = kwargs.get(\"enable_maci\", True) and not self._isolated_mode\n        self._maci_registry, self._maci_enforcer, self._maci_strict_mode = (\n            kwargs.get(\"maci_registry\"),\n            kwargs.get(\"maci_enforcer\"),\n            kwargs.get(\"maci_strict_mode\", True),\n        )\n        self._rust_processor = (\n            rust_bus.MessageProcessor() if (USE_RUST and rust_bus and self._use_rust) else None\n        )\n        self._policy_client = (\n            get_policy_client(fail_closed=self._policy_fail_closed)\n            if self._use_dynamic_policy\n            else None\n        )\n        self.constitutional_hash = CONSTITUTIONAL_HASH\n        self._opa_client, self._audit_client = get_opa_client(), kwargs.get(\"audit_client\")\n        self._validation_cache = LRUCache(maxsize=1000)\n\n        # SDPC Phase 2/3 Verifiers\n        try:\n            from .deliberation_layer.intent_classifier import IntentClassifier, IntentType\n            from .sdpc.ampo_engine import AMPOEngine\n            from .sdpc.asc_verifier import ASCVerifier\n            from .sdpc.evolution_controller import EvolutionController\n            from .sdpc.graph_check import GraphCheckVerifier\n            from .sdpc.pacar_verifier import PACARVerifier\n        except (ImportError, ValueError):\n            try:\n                from deliberation_layer.intent_classifier import (  # type: ignore\n                    IntentClassifier,\n                    IntentType,\n                )\n                from sdpc.ampo_engine import AMPOEngine  # type: ignore\n                from sdpc.asc_verifier import ASCVerifier  # type: ignore\n                from sdpc.evolution_controller import EvolutionController  # type: ignore\n                from sdpc.graph_check import GraphCheckVerifier  # type: ignore\n                from sdpc.pacar_verifier import PACARVerifier  # type: ignore\n            except (ImportError, ValueError):\n                # Third fallback for deep module nesting in some test runners\n                from enhanced_agent_bus.deliberation_layer.intent_classifier import (  # type: ignore\n                    IntentClassifier,\n                    IntentType,\n                )\n                from enhanced_agent_bus.sdpc.ampo_engine import AMPOEngine  # type: ignore\n                from enhanced_agent_bus.sdpc.asc_verifier import ASCVerifier  # type: ignore\n                from enhanced_agent_bus.sdpc.evolution_controller import (\n                    EvolutionController,\n                )  # type: ignore\n                from enhanced_agent_bus.sdpc.graph_check import GraphCheckVerifier  # type: ignore\n                from enhanced_agent_bus.sdpc.pacar_verifier import PACARVerifier  # type: ignore\n\n        self.config = kwargs.get(\"config\") or BusConfiguration.from_environment()\n        self.intent_classifier = IntentClassifier(config=self.config)\n        self.asc_verifier = ASCVerifier()\n        self.graph_check = GraphCheckVerifier()\n        self.pacar_verifier = PACARVerifier(config=self.config)\n        self.evolution_controller = EvolutionController()\n        self.ampo_engine = AMPOEngine(evolution_controller=self.evolution_controller)\n        self._IntentType = IntentType\n\n        self._processing_strategy = (\n            kwargs.get(\"processing_strategy\") or self._auto_select_strategy()\n        )\n        if CIRCUIT_BREAKER_ENABLED:\n            self._process_cb = get_circuit_breaker(\n                \"message_processor\", CircuitBreakerConfig(fail_max=5, reset_timeout=30)\n            )\n\n    def _auto_select_strategy(self) -> ProcessingStrategy:\n        try:\n            from .processing_strategies import (\n                CompositeProcessingStrategy,\n                OPAProcessingStrategy,\n                PythonProcessingStrategy,\n                RustProcessingStrategy,\n            )\n            from .validation_strategies import StaticHashValidationStrategy\n        except (ImportError, ValueError):\n            from processing_strategies import (  # type: ignore\n                CompositeProcessingStrategy,\n                OPAProcessingStrategy,\n                PythonProcessingStrategy,\n                RustProcessingStrategy,\n            )\n            from validation_strategies import StaticHashValidationStrategy  # type: ignore\n\n        py_proc = PythonProcessingStrategy(StaticHashValidationStrategy(strict=True))\n        if self._isolated_mode:\n            return py_proc\n        strategies = []\n        if self._rust_processor and self._use_rust:\n            strategies.append(RustProcessingStrategy(self._rust_processor, rust_bus))\n        if self._use_dynamic_policy and self._opa_client:\n            strategies.append(OPAProcessingStrategy(self._opa_client))\n        strategies.append(py_proc)\n        base = CompositeProcessingStrategy(strategies) if len(strategies) > 1 else strategies[0]\n        if self._enable_maci:\n            try:\n                from .processing_strategies import MACIProcessingStrategy\n            except (ImportError, ValueError):\n                from processing_strategies import MACIProcessingStrategy  # type: ignore\n            return MACIProcessingStrategy(\n                base, self._maci_registry, self._maci_enforcer, self._maci_strict_mode\n            )\n        return base\n\n    async def process(self, msg: AgentMessage) -> ValidationResult:\n        if CIRCUIT_BREAKER_ENABLED:\n            return await self._process_cb.call(self._do_process, msg)\n        return await self._do_process(msg)\n\n    async def _do_process(self, msg: AgentMessage) -> ValidationResult:\n        start = time.perf_counter()\n\n        # Memory profiling integration (fire-and-forget, <5\u03bcs impact)\n        # Only create profiler context if profiling is actually enabled\n        profiler = get_memory_profiler()\n        operation_name = f\"message_processing_{msg.message_type.value}_{msg.priority.value}\"\n\n        context_manager = (\n            profiler.profile_async(operation_name, trace_id=msg.message_id)\n            if profiler and profiler.config.enabled\n            else nullcontext()\n        )\n\n        async with context_manager:\n            # Phase 2 Breakthrough: Unified Runtime Security Scanning\n            security_scanner = get_runtime_security_scanner()\n            security_res = await security_scanner.scan(\n                content=msg.content,\n                tenant_id=msg.tenant_id,\n                agent_id=msg.from_agent,\n                constitutional_hash=msg.constitutional_hash,\n                context={\"priority\": msg.priority.value, \"message_type\": msg.message_type.value}\n            )\n\n            if security_res.blocked:\n                self._failed_count += 1\n                return ValidationResult(\n                    is_valid=False,\n                    errors=[security_res.block_reason],\n                    metadata={\n                        \"rejection_reason\": \"security_block\",\n                        \"security_events\": [e.to_dict() for e in security_res.events]\n                    }\n                )\n\n        ckey = f\"{hashlib.sha256(str(msg.content).encode()).hexdigest()[:16]}:{msg.constitutional_hash}\"\n        cached = self._validation_cache.get(ckey)\n        if cached:\n            return cached\n\n        # Extract session_id for multi-turn PACAR context tracking\n        # Priority: headers > content > payload (for flexibility)\n        session_id: Optional[str] = None\n        if hasattr(msg, \"headers\") and msg.headers:\n            session_id = msg.headers.get(\"X-Session-ID\") or msg.headers.get(\"x-session-id\")\n        if not session_id and hasattr(msg, \"content\") and isinstance(msg.content, dict):\n            session_id = msg.content.get(\"session_id\")\n        if not session_id and hasattr(msg, \"payload\") and isinstance(msg.payload, dict):\n            session_id = msg.payload.get(\"session_id\")\n\n        # SDPC Logic (Phase 2/3)\n        sdpc_metadata = {}\n        content_str = str(msg.content)\n        intent = await self.intent_classifier.classify_async(content_str)\n        # Handle case where impact_score is None or explicitly set to None\n        impact_score = getattr(msg, \"impact_score\", 0.0)\n        if impact_score is None:\n            impact_score = 0.0\n\n        verifications = {}\n        if (\n            intent.value in [self._IntentType.FACTUAL.value, self._IntentType.REASONING.value]\n            or impact_score >= 0.8\n        ):\n            sdpc_metadata[\"sdpc_intent\"] = intent.value\n            asc_res = await self.asc_verifier.verify(content_str, intent)\n            sdpc_metadata[\"sdpc_asc_valid\"] = asc_res.get(\"is_valid\", False)\n            sdpc_metadata[\"sdpc_asc_confidence\"] = asc_res.get(\"confidence\", 0.0)\n            verifications[\"asc\"] = sdpc_metadata[\"sdpc_asc_valid\"]\n\n            graph_res = await self.graph_check.verify_entities(content_str)\n            sdpc_metadata[\"sdpc_graph_grounded\"] = graph_res.get(\"is_valid\", False)\n            sdpc_metadata[\"sdpc_graph_results\"] = graph_res.get(\"results\", [])\n            verifications[\"graph\"] = sdpc_metadata[\"sdpc_graph_grounded\"]\n\n        if impact_score > 0.8 or msg.message_type == MessageType.TASK_REQUEST:\n            pacar_res = await self.pacar_verifier.verify(\n                content_str, intent.value, session_id=msg.conversation_id\n            )\n            sdpc_metadata[\"sdpc_pacar_valid\"] = pacar_res.get(\"is_valid\", False)\n            sdpc_metadata[\"sdpc_pacar_confidence\"] = pacar_res.get(\"confidence\", 0.0)\n            verifications[\"pacar\"] = sdpc_metadata[\"sdpc_pacar_valid\"]\n            if \"critique\" in pacar_res:\n                sdpc_metadata[\"sdpc_pacar_critique\"] = pacar_res[\"critique\"]\n\n        # Phase 3 Evolution Loop: Record feedback for intent branches\n        if verifications:\n            self.evolution_controller.record_feedback(intent, verifications)\n\n        res = await self._processing_strategy.process(msg, self._handlers)\n        lat = (time.perf_counter() - start) * 1000\n\n        res.metadata.update(sdpc_metadata)\n\n        if res.is_valid:\n            self._validation_cache.set(ckey, res)\n            self._processed_count += 1\n            if self._metering_hooks:\n                self._metering_hooks.on_constitutional_validation(\n                    tenant_id=msg.tenant_id, agent_id=msg.from_agent, is_valid=True, latency_ms=lat\n                )\n        else:\n            self._failed_count += 1\n        res.metadata[\"latency_ms\"] = lat\n        return res\n\n    def _detect_prompt_injection(self, msg: AgentMessage) -> Optional[ValidationResult]:\n        content = msg.content\n        content_str = content if isinstance(content, str) else str(content)\n        if _INJECTION_RE.search(content_str):\n            return ValidationResult(\n                is_valid=False,\n                errors=[\"Prompt injection detected\"],\n                metadata={\"rejection_reason\": \"prompt_injection\"},\n            )\n        return None\n\n    @property\n    def processed_count(self) -> int:\n        return self._processed_count\n\n    @property\n    def failed_count(self) -> int:\n        return self._failed_count\n\n    @property\n    def processing_strategy(self) -> ProcessingStrategy:\n        return self._processing_strategy\n\n    @property\n    def opa_client(self) -> Optional[Any]:\n        return self._opa_client\n\n    def register_handler(self, message_type: MessageType, handler: Callable) -> None:\n        if message_type not in self._handlers:\n            self._handlers[message_type] = []\n        self._handlers[message_type].append(handler)\n\n    def unregister_handler(self, message_type: MessageType, handler: Callable) -> bool:\n        if message_type in self._handlers and handler in self._handlers[message_type]:\n            self._handlers[message_type].remove(handler)\n            return True\n        return False\n\n    def get_metrics(self) -> Dict[str, Any]:\n        total = self._processed_count + self._failed_count\n        success_rate = self._processed_count / max(1, total) if total > 0 else 0.0\n        return {\n            \"processed_count\": self._processed_count,\n            \"failed_count\": self._failed_count,\n            \"success_rate\": success_rate,\n            \"rust_enabled\": self._use_rust and self._rust_processor is not None,\n            \"dynamic_policy_enabled\": self._use_dynamic_policy,\n            \"opa_enabled\": self._opa_client is not None,\n            \"processing_strategy\": (\n                self._processing_strategy.get_name() if self._processing_strategy else \"none\"\n            ),\n            \"metering_enabled\": self._enable_metering and self._metering_hooks is not None,\n        }\n\n    def _set_strategy(self, strategy: ProcessingStrategy):\n        self._processing_strategy = strategy\n\n    def _log_decision(self, msg: AgentMessage, result: ValidationResult, span: Any = None) -> None:\n        logger.info(f\"Decision for {msg.message_id}: {result.is_valid}\")\n        if span and hasattr(span, \"set_attribute\"):\n            span.set_attribute(\"msg.id\", msg.message_id)\n            span.set_attribute(\"msg.valid\", result.is_valid)\n            if hasattr(span, \"get_span_context\"):\n                ctx = span.get_span_context()\n                if hasattr(ctx, \"trace_id\"):\n                    logger.info(f\"Trace ID: {ctx.trace_id:x}\")\n\n    def _get_compliance_tags(self, msg: AgentMessage, result: ValidationResult) -> List[str]:\n        tags = [\"constitutional_validated\"]\n        if result.is_valid:\n            tags.append(\"approved\")\n        else:\n            tags.append(\"rejected\")\n        if hasattr(msg, \"priority\") and msg.priority == Priority.CRITICAL:\n            tags.append(\"high_priority\")\n        return tags\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.344506",
  "last_updated": "2026-01-04T05:35:59.041652"
}