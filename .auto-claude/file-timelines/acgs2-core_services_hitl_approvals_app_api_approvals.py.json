{
  "file_path": "acgs2-core/services/hitl_approvals/app/api/approvals.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nAPI routes for approval requests\n\"\"\"\n\nimport logging\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import selectinload\n\nfrom ..database import get_db\nfrom ..models.approval_request import ApprovalRequest\nfrom ..schemas.approval import ApprovalDecisionCreate, ApprovalRequestCreate, ApprovalRequestSchema\nfrom ..services.approval_chain_engine import ApprovalChainEngine\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.post(\"/\", response_model=ApprovalRequestSchema)\nasync def create_approval_request(\n    request: ApprovalRequestCreate, db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Create a new approval request\"\"\"\n    engine = ApprovalChainEngine(db)\n    try:\n        # If chain_id not provided, determine it based on priority and context\n        # (Simplified: assumes 'standard' chain exists for now)\n        if not request.chain_id:\n            # TODO: Implement dynamic chain resolution via OPA\n            from ..models.approval_chain import ApprovalChain\n\n            query = select(ApprovalChain).where(ApprovalChain.priority == request.priority).limit(1)\n            result = await db.execute(query)\n            chain = result.scalar_one_or_none()\n            if not chain:\n                # Fallback to any chain\n                query = select(ApprovalChain).limit(1)\n                result = await db.execute(query)\n                chain = result.scalar_one_or_none()\n\n            if not chain:\n                raise HTTPException(status_code=400, detail=\"No suitable approval chain found\")\n            request.chain_id = chain.id\n\n        approval_request = await engine.create_request(\n            chain_id=request.chain_id,\n            decision_id=request.decision_id,\n            tenant_id=request.tenant_id,\n            requested_by=request.requested_by,\n            title=request.title,\n            priority=request.priority,\n            context=request.context,\n            description=request.description,\n        )\n        return approval_request\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e)) from e\n\n\n@router.get(\"/{request_id}\", response_model=ApprovalRequestSchema)\nasync def get_approval_request(request_id: UUID, db: AsyncSession = Depends(get_db)):\n    \"\"\"Get an approval request by ID\"\"\"\n    query = (\n        select(ApprovalRequest)\n        .where(ApprovalRequest.id == request_id)\n        .options(selectinload(ApprovalRequest.approvals), selectinload(ApprovalRequest.chain))\n    )\n    result = await db.execute(query)\n    request = result.scalar_one_or_none()\n    if not request:\n        raise HTTPException(status_code=404, detail=\"Approval request not found\")\n    return request\n\n\n@router.post(\"/{request_id}/decisions\", response_model=ApprovalRequestSchema)\nasync def submit_decision(\n    request_id: UUID,\n    decision: ApprovalDecisionCreate,\n    fastapi_request: Request,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Submit an approval or rejection decision\"\"\"\n    engine = ApprovalChainEngine(db)\n    try:\n        updated_request = await engine.submit_decision(\n            request_id=request_id,\n            approver_id=decision.approver_id,\n            decision=decision.decision,\n            rationale=decision.rationale,\n            ip_address=fastapi_request.client.host if fastapi_request.client else None,\n        )\n        return updated_request\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e)) from e\n\n\n@router.get(\"/\", response_model=List[ApprovalRequestSchema])\nasync def list_approval_requests(\n    tenant_id: Optional[str] = None,\n    status: Optional[str] = None,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List approval requests with optional filtering\"\"\"\n    query = select(ApprovalRequest).options(selectinload(ApprovalRequest.approvals))\n    if tenant_id:\n        query = query.where(ApprovalRequest.tenant_id == tenant_id)\n    if status:\n        query = query.where(ApprovalRequest.status == status)\n\n    result = await db.execute(query)\n    return result.scalars().all()\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.639523",
  "last_updated": "2026-01-04T05:35:51.194571"
}