{
  "file_path": "integration-service/src/webhooks/retry.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhook retry logic with exponential backoff using tenacity.\n\nProvides configurable retry strategies with jitter to prevent thundering herd,\nand utilities for calculating backoff delays for webhook deliveries.\n\"\"\"\n\nimport asyncio\nimport logging\nimport random\nimport warnings\nfrom datetime import datetime, timedelta, timezone\nfrom functools import wraps\nfrom typing import Any, Callable, Optional, Set, TypeVar\n\nimport httpx\nfrom tenacity import (\n    AsyncRetrying,\n    before_sleep_log,\n    retry_if_exception_type,\n    stop_after_attempt,\n    wait_exponential,\n)\n\nfrom exceptions.retry import (\n    MaxRetriesExceededError,\n    NonRetryableError,\n    RetryableError,\n)\n\nfrom .config import WebhookRetryPolicy\n\nlogger = logging.getLogger(__name__)\n\n\n# Type variable for generic return types\nT = TypeVar(\"T\")\n\n\n# Backward compatibility aliases\n# These maintain API compatibility for existing code that imports from webhooks.retry\nclass WebhookRetryError(MaxRetriesExceededError):\n    \"\"\"\n    Deprecated: Use MaxRetriesExceededError from exceptions.retry instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookRetryError is deprecated. \"\n            \"Use MaxRetriesExceededError from exceptions.retry instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n\nclass ExponentialBackoff:\n    \"\"\"\n    Calculates exponential backoff delays with optional jitter.\n\n    Implements the formula: delay = min(base * (multiplier ^ attempt), max_delay)\n    With optional jitter to prevent thundering herd.\n    \"\"\"\n\n    def __init__(\n        self,\n        initial_delay: float = 1.0,\n        max_delay: float = 300.0,\n        multiplier: float = 2.0,\n        jitter_factor: float = 0.1,\n    ):\n        \"\"\"\n        Initialize exponential backoff calculator.\n\n        Args:\n            initial_delay: Base delay in seconds\n            max_delay: Maximum delay cap in seconds\n            multiplier: Exponential multiplier (base)\n            jitter_factor: Random jitter factor (0-1)\n        \"\"\"\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.multiplier = multiplier\n        self.jitter_factor = jitter_factor\n\n    def calculate(self, attempt: int) -> float:\n        \"\"\"\n        Calculate delay for a given attempt number.\n\n        Args:\n            attempt: Attempt number (1-based)\n\n        Returns:\n            Delay in seconds with jitter applied\n        \"\"\"\n        if attempt <= 1:\n            delay = self.initial_delay\n        else:\n            # Exponential backoff: initial * multiplier^(attempt-1)\n            delay = self.initial_delay * (self.multiplier ** (attempt - 1))\n\n        # Apply maximum cap\n        delay = min(delay, self.max_delay)\n\n        # Add jitter to prevent thundering herd\n        if self.jitter_factor > 0:\n            jitter = delay * self.jitter_factor * random.random()\n            delay = delay + jitter\n\n        return delay\n\n    def calculate_next_retry_time(self, attempt: int) -> datetime:\n        \"\"\"\n        Calculate the datetime for the next retry.\n\n        Args:\n            attempt: Current attempt number\n\n        Returns:\n            Datetime when next retry should occur\n        \"\"\"\n        delay_seconds = self.calculate(attempt)\n        return datetime.now(timezone.utc) + timedelta(seconds=delay_seconds)\n\n    @classmethod\n    def from_policy(cls, policy: WebhookRetryPolicy) -> \"ExponentialBackoff\":\n        \"\"\"\n        Create ExponentialBackoff from a WebhookRetryPolicy.\n\n        Args:\n            policy: Webhook retry policy configuration\n\n        Returns:\n            Configured ExponentialBackoff instance\n        \"\"\"\n        return cls(\n            initial_delay=policy.initial_delay_seconds,\n            max_delay=policy.max_delay_seconds,\n            multiplier=policy.exponential_base,\n            jitter_factor=policy.jitter_factor,\n        )\n\n\nclass RetryState:\n    \"\"\"\n    Tracks the state of retry attempts for a single delivery.\n    \"\"\"\n\n    def __init__(\n        self,\n        max_attempts: int = 3,\n        backoff: Optional[ExponentialBackoff] = None,\n    ):\n        self.max_attempts = max_attempts\n        self.backoff = backoff or ExponentialBackoff()\n        self.current_attempt = 0\n        self.errors: list[Exception] = []\n        self.status_codes: list[int] = []\n        self.started_at: Optional[datetime] = None\n        self.completed_at: Optional[datetime] = None\n\n    def start(self) -> None:\n        \"\"\"Mark the start of a delivery attempt.\"\"\"\n        if self.started_at is None:\n            self.started_at = datetime.now(timezone.utc)\n        self.current_attempt += 1\n\n    def record_error(\n        self,\n        error: Exception,\n        status_code: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Record an error from a delivery attempt.\n\n        Args:\n            error: The exception that occurred\n            status_code: HTTP status code if available\n        \"\"\"\n        self.errors.append(error)\n        if status_code is not None:\n            self.status_codes.append(status_code)\n\n    def complete(self) -> None:\n        \"\"\"Mark the delivery as complete.\"\"\"\n        self.completed_at = datetime.now(timezone.utc)\n\n    @property\n    def can_retry(self) -> bool:\n        \"\"\"Check if more retries are allowed.\"\"\"\n        return self.current_attempt < self.max_attempts\n\n    @property\n    def next_delay(self) -> float:\n        \"\"\"Get the delay before the next retry.\"\"\"\n        return self.backoff.calculate(self.current_attempt)\n\n    @property\n    def next_retry_at(self) -> datetime:\n        \"\"\"Get the datetime for the next retry.\"\"\"\n        return self.backoff.calculate_next_retry_time(self.current_attempt)\n\n    @property\n    def last_error(self) -> Optional[Exception]:\n        \"\"\"Get the most recent error.\"\"\"\n        return self.errors[-1] if self.errors else None\n\n    @property\n    def last_status_code(self) -> Optional[int]:\n        \"\"\"Get the most recent status code.\"\"\"\n        return self.status_codes[-1] if self.status_codes else None\n\n    @property\n    def total_duration(self) -> Optional[timedelta]:\n        \"\"\"Get total duration of all attempts.\"\"\"\n        if self.started_at is None:\n            return None\n        end = self.completed_at or datetime.now(timezone.utc)\n        return end - self.started_at\n\n\ndef should_retry_status_code(\n    status_code: int,\n    retryable_codes: Optional[Set[int]] = None,\n) -> bool:\n    \"\"\"\n    Determine if an HTTP status code should trigger a retry.\n\n    Args:\n        status_code: HTTP status code received\n        retryable_codes: Set of status codes that are retryable\n\n    Returns:\n        True if the status code should trigger a retry\n    \"\"\"\n    if retryable_codes is None:\n        # Default retryable codes: rate limit, server errors\n        retryable_codes = {429, 500, 502, 503, 504}\n\n    return status_code in retryable_codes\n\n\ndef is_retryable_exception(exc: Exception) -> bool:\n    \"\"\"\n    Determine if an exception should trigger a retry.\n\n    Args:\n        exc: The exception to check\n\n    Returns:\n        True if the exception should trigger a retry\n    \"\"\"\n    # Explicitly retryable\n    if isinstance(exc, RetryableError):\n        return True\n\n    # Explicitly not retryable\n    if isinstance(exc, NonRetryableError):\n        return False\n\n    # Network and timeout errors are retryable\n    retryable_types = (\n        httpx.TimeoutException,\n        httpx.NetworkError,\n        httpx.ConnectError,\n        httpx.ReadError,\n        ConnectionError,\n        TimeoutError,\n        OSError,\n    )\n\n    return isinstance(exc, retryable_types)\n\n\ndef create_tenacity_retry(\n    policy: WebhookRetryPolicy,\n    logger_instance: Optional[logging.Logger] = None,\n) -> AsyncRetrying:\n    \"\"\"\n    Create a tenacity AsyncRetrying configuration from a WebhookRetryPolicy.\n\n    Args:\n        policy: Webhook retry policy configuration\n        logger_instance: Logger for retry events\n\n    Returns:\n        Configured AsyncRetrying instance\n    \"\"\"\n    log = logger_instance or logger\n\n    return AsyncRetrying(\n        stop=stop_after_attempt(policy.max_attempts),\n        wait=wait_exponential(\n            multiplier=policy.initial_delay_seconds,\n            min=policy.initial_delay_seconds,\n            max=policy.max_delay_seconds,\n            exp_base=policy.exponential_base,\n        ),\n        retry=retry_if_exception_type((RetryableError, httpx.TimeoutException, httpx.NetworkError)),\n        before_sleep=before_sleep_log(log, logging.WARNING),\n        reraise=True,\n    )\n\n\ndef with_retry(\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 300.0,\n    multiplier: float = 2.0,\n    jitter_factor: float = 0.1,\n    retryable_exceptions: Optional[tuple] = None,\n    retryable_status_codes: Optional[Set[int]] = None,\n) -> Callable:\n    \"\"\"\n    Decorator for async functions to add retry logic with exponential backoff.\n\n    Args:\n        max_attempts: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        max_delay: Maximum delay cap in seconds\n        multiplier: Exponential backoff multiplier\n        jitter_factor: Random jitter factor\n        retryable_exceptions: Tuple of exception types to retry on\n        retryable_status_codes: Set of HTTP status codes to retry on\n\n    Returns:\n        Decorated function with retry logic\n    \"\"\"\n    if retryable_exceptions is None:\n        retryable_exceptions = (\n            RetryableError,\n            httpx.TimeoutException,\n            httpx.NetworkError,\n            httpx.ConnectError,\n            httpx.ReadError,\n        )\n\n    if retryable_status_codes is None:\n        retryable_status_codes = {429, 500, 502, 503, 504}\n\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -> Any:\n            backoff = ExponentialBackoff(\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                multiplier=multiplier,\n                jitter_factor=jitter_factor,\n            )\n            state = RetryState(max_attempts=max_attempts, backoff=backoff)\n            last_exception: Optional[Exception] = None\n            last_status_code: Optional[int] = None\n\n            while state.current_attempt < max_attempts:\n                state.start()\n\n                try:\n                    result = await func(*args, **kwargs)\n\n                    # If result is an httpx.Response, check status code\n                    if isinstance(result, httpx.Response):\n                        if should_retry_status_code(result.status_code, retryable_status_codes):\n                            last_status_code = result.status_code\n                            raise RetryableError(\n                                f\"HTTP {result.status_code}\",\n                                status_code=result.status_code,\n                            )\n\n                    state.complete()\n                    return result\n\n                except retryable_exceptions as e:\n                    last_exception = e\n                    if isinstance(e, RetryableError):\n                        last_status_code = e.status_code\n                    state.record_error(e, last_status_code)\n\n                    if state.can_retry:\n                        delay = state.next_delay\n                        logger.warning(\n                            f\"Retry {state.current_attempt}/{max_attempts} failed: {e}. \"\n                            f\"Retrying in {delay:.2f}s\"\n                        )\n                        await asyncio.sleep(delay)\n                    else:\n                        state.complete()\n                        raise WebhookRetryError(\n                            f\"All {max_attempts} retry attempts failed\",\n                            attempts=max_attempts,\n                            last_error=last_exception,\n                            last_status_code=last_status_code,\n                        ) from e\n\n                except NonRetryableError:\n                    state.complete()\n                    raise\n\n                except Exception:\n                    # Unknown errors - complete and re-raise without retry\n                    state.complete()\n                    raise\n\n            state.complete()\n            raise WebhookRetryError(\n                f\"All {max_attempts} retry attempts failed\",\n                attempts=max_attempts,\n                last_error=last_exception,\n                last_status_code=last_status_code,\n            )\n\n        return wrapper\n\n    return decorator\n\n\nasync def retry_with_backoff(\n    func: Callable[[], T],\n    policy: WebhookRetryPolicy,\n    on_retry: Optional[Callable[[int, Exception, float], None]] = None,\n) -> T:\n    \"\"\"\n    Execute a function with retry logic based on a WebhookRetryPolicy.\n\n    Args:\n        func: Async function to execute\n        policy: Retry policy configuration\n        on_retry: Optional callback called before each retry (attempt, error, delay)\n\n    Returns:\n        Result of the function\n\n    Raises:\n        WebhookRetryError: If all retries are exhausted\n    \"\"\"\n    backoff = ExponentialBackoff.from_policy(policy)\n    state = RetryState(max_attempts=policy.max_attempts, backoff=backoff)\n    retryable_codes = set(policy.retry_on_status_codes)\n\n    while True:\n        state.start()\n\n        try:\n            result = await func()\n\n            # Check if result is retryable\n            if isinstance(result, httpx.Response):\n                if should_retry_status_code(result.status_code, retryable_codes):\n                    raise RetryableError(\n                        f\"HTTP {result.status_code}\",\n                        status_code=result.status_code,\n                    )\n\n            state.complete()\n            return result\n\n        except Exception as e:\n            status_code = getattr(e, \"status_code\", None)\n            state.record_error(e, status_code)\n\n            # Determine if we should retry\n            should_retry = False\n\n            if isinstance(e, RetryableError):\n                should_retry = True\n            elif isinstance(e, NonRetryableError):\n                should_retry = False\n            elif isinstance(e, httpx.TimeoutException) and policy.retry_on_timeout:\n                should_retry = True\n            elif (\n                isinstance(e, (httpx.NetworkError, httpx.ConnectError))\n                and policy.retry_on_connection_error\n            ):\n                should_retry = True\n\n            if should_retry and state.can_retry:\n                delay = state.next_delay\n\n                if on_retry:\n                    on_retry(state.current_attempt, e, delay)\n\n                logger.warning(\n                    f\"Attempt {state.current_attempt}/{policy.max_attempts} failed: {e}. \"\n                    f\"Retrying in {delay:.2f}s\"\n                )\n                await asyncio.sleep(delay)\n            else:\n                state.complete()\n                raise WebhookRetryError(\n                    f\"Delivery failed after {state.current_attempt} attempt(s)\",\n                    attempts=state.current_attempt,\n                    last_error=e,\n                    last_status_code=status_code,\n                ) from e\n\n\ndef extract_retry_after(response: httpx.Response) -> Optional[float]:\n    \"\"\"\n    Extract Retry-After value from an HTTP response.\n\n    Args:\n        response: HTTP response object\n\n    Returns:\n        Retry delay in seconds, or None if not specified\n    \"\"\"\n    retry_after = response.headers.get(\"Retry-After\")\n\n    if retry_after is None:\n        return None\n\n    try:\n        # Try parsing as seconds\n        return float(retry_after)\n    except ValueError:\n        pass\n\n    try:\n        # Try parsing as HTTP date\n        from email.utils import parsedate_to_datetime\n\n        retry_date = parsedate_to_datetime(retry_after)\n        delta = retry_date - datetime.now(timezone.utc)\n        return max(0, delta.total_seconds())\n    except (ValueError, TypeError):\n        pass\n\n    return None\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhook retry logic with exponential backoff using tenacity.\n\nProvides configurable retry strategies with jitter to prevent thundering herd,\nand utilities for calculating backoff delays for webhook deliveries.\n\"\"\"\n\nimport asyncio\nimport logging\nimport random\nimport warnings\nfrom datetime import datetime, timedelta, timezone\nfrom functools import wraps\nfrom typing import Any, Callable, Optional, Set, TypeVar\n\nimport httpx\nfrom tenacity import (\n    AsyncRetrying,\n    before_sleep_log,\n    retry_if_exception_type,\n    stop_after_attempt,\n    wait_exponential,\n)\n\nfrom exceptions.retry import (\n    MaxRetriesExceededError,\n    NonRetryableError,\n    RetryableError,\n)\n\nfrom .config import WebhookRetryPolicy\n\nlogger = logging.getLogger(__name__)\n\n\n# Type variable for generic return types\nT = TypeVar(\"T\")\n\n\n# Backward compatibility aliases\n# These maintain API compatibility for existing code that imports from webhooks.retry\nclass WebhookRetryError(MaxRetriesExceededError):\n    \"\"\"\n    Deprecated: Use MaxRetriesExceededError from exceptions.retry instead.\n\n    This alias is maintained for backward compatibility but will be removed in a future version.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"WebhookRetryError is deprecated. \"\n            \"Use MaxRetriesExceededError from exceptions.retry instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n\nclass ExponentialBackoff:\n    \"\"\"\n    Calculates exponential backoff delays with optional jitter.\n\n    Implements the formula: delay = min(base * (multiplier ^ attempt), max_delay)\n    With optional jitter to prevent thundering herd.\n    \"\"\"\n\n    def __init__(\n        self,\n        initial_delay: float = 1.0,\n        max_delay: float = 300.0,\n        multiplier: float = 2.0,\n        jitter_factor: float = 0.1,\n    ):\n        \"\"\"\n        Initialize exponential backoff calculator.\n\n        Args:\n            initial_delay: Base delay in seconds\n            max_delay: Maximum delay cap in seconds\n            multiplier: Exponential multiplier (base)\n            jitter_factor: Random jitter factor (0-1)\n        \"\"\"\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.multiplier = multiplier\n        self.jitter_factor = jitter_factor\n\n    def calculate(self, attempt: int) -> float:\n        \"\"\"\n        Calculate delay for a given attempt number.\n\n        Args:\n            attempt: Attempt number (1-based)\n\n        Returns:\n            Delay in seconds with jitter applied\n        \"\"\"\n        if attempt <= 1:\n            delay = self.initial_delay\n        else:\n            # Exponential backoff: initial * multiplier^(attempt-1)\n            delay = self.initial_delay * (self.multiplier ** (attempt - 1))\n\n        # Apply maximum cap\n        delay = min(delay, self.max_delay)\n\n        # Add jitter to prevent thundering herd\n        if self.jitter_factor > 0:\n            jitter = delay * self.jitter_factor * random.random()\n            delay = delay + jitter\n\n        return delay\n\n    def calculate_next_retry_time(self, attempt: int) -> datetime:\n        \"\"\"\n        Calculate the datetime for the next retry.\n\n        Args:\n            attempt: Current attempt number\n\n        Returns:\n            Datetime when next retry should occur\n        \"\"\"\n        delay_seconds = self.calculate(attempt)\n        return datetime.now(timezone.utc) + timedelta(seconds=delay_seconds)\n\n    @classmethod\n    def from_policy(cls, policy: WebhookRetryPolicy) -> \"ExponentialBackoff\":\n        \"\"\"\n        Create ExponentialBackoff from a WebhookRetryPolicy.\n\n        Args:\n            policy: Webhook retry policy configuration\n\n        Returns:\n            Configured ExponentialBackoff instance\n        \"\"\"\n        return cls(\n            initial_delay=policy.initial_delay_seconds,\n            max_delay=policy.max_delay_seconds,\n            multiplier=policy.exponential_base,\n            jitter_factor=policy.jitter_factor,\n        )\n\n\nclass RetryState:\n    \"\"\"\n    Tracks the state of retry attempts for a single delivery.\n    \"\"\"\n\n    def __init__(\n        self,\n        max_attempts: int = 3,\n        backoff: Optional[ExponentialBackoff] = None,\n    ):\n        self.max_attempts = max_attempts\n        self.backoff = backoff or ExponentialBackoff()\n        self.current_attempt = 0\n        self.errors: list[Exception] = []\n        self.status_codes: list[int] = []\n        self.started_at: Optional[datetime] = None\n        self.completed_at: Optional[datetime] = None\n\n    def start(self) -> None:\n        \"\"\"Mark the start of a delivery attempt.\"\"\"\n        if self.started_at is None:\n            self.started_at = datetime.now(timezone.utc)\n        self.current_attempt += 1\n\n    def record_error(\n        self,\n        error: Exception,\n        status_code: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        Record an error from a delivery attempt.\n\n        Args:\n            error: The exception that occurred\n            status_code: HTTP status code if available\n        \"\"\"\n        self.errors.append(error)\n        if status_code is not None:\n            self.status_codes.append(status_code)\n\n    def complete(self) -> None:\n        \"\"\"Mark the delivery as complete.\"\"\"\n        self.completed_at = datetime.now(timezone.utc)\n\n    @property\n    def can_retry(self) -> bool:\n        \"\"\"Check if more retries are allowed.\"\"\"\n        return self.current_attempt < self.max_attempts\n\n    @property\n    def next_delay(self) -> float:\n        \"\"\"Get the delay before the next retry.\"\"\"\n        return self.backoff.calculate(self.current_attempt)\n\n    @property\n    def next_retry_at(self) -> datetime:\n        \"\"\"Get the datetime for the next retry.\"\"\"\n        return self.backoff.calculate_next_retry_time(self.current_attempt)\n\n    @property\n    def last_error(self) -> Optional[Exception]:\n        \"\"\"Get the most recent error.\"\"\"\n        return self.errors[-1] if self.errors else None\n\n    @property\n    def last_status_code(self) -> Optional[int]:\n        \"\"\"Get the most recent status code.\"\"\"\n        return self.status_codes[-1] if self.status_codes else None\n\n    @property\n    def total_duration(self) -> Optional[timedelta]:\n        \"\"\"Get total duration of all attempts.\"\"\"\n        if self.started_at is None:\n            return None\n        end = self.completed_at or datetime.now(timezone.utc)\n        return end - self.started_at\n\n\ndef should_retry_status_code(\n    status_code: int,\n    retryable_codes: Optional[Set[int]] = None,\n) -> bool:\n    \"\"\"\n    Determine if an HTTP status code should trigger a retry.\n\n    Args:\n        status_code: HTTP status code received\n        retryable_codes: Set of status codes that are retryable\n\n    Returns:\n        True if the status code should trigger a retry\n    \"\"\"\n    if retryable_codes is None:\n        # Default retryable codes: rate limit, server errors\n        retryable_codes = {429, 500, 502, 503, 504}\n\n    return status_code in retryable_codes\n\n\ndef is_retryable_exception(exc: Exception) -> bool:\n    \"\"\"\n    Determine if an exception should trigger a retry.\n\n    Args:\n        exc: The exception to check\n\n    Returns:\n        True if the exception should trigger a retry\n    \"\"\"\n    # Explicitly retryable\n    if isinstance(exc, RetryableError):\n        return True\n\n    # Explicitly not retryable\n    if isinstance(exc, NonRetryableError):\n        return False\n\n    # Network and timeout errors are retryable\n    retryable_types = (\n        httpx.TimeoutException,\n        httpx.NetworkError,\n        httpx.ConnectError,\n        httpx.ReadError,\n        ConnectionError,\n        TimeoutError,\n        OSError,\n    )\n\n    return isinstance(exc, retryable_types)\n\n\ndef create_tenacity_retry(\n    policy: WebhookRetryPolicy,\n    logger_instance: Optional[logging.Logger] = None,\n) -> AsyncRetrying:\n    \"\"\"\n    Create a tenacity AsyncRetrying configuration from a WebhookRetryPolicy.\n\n    Args:\n        policy: Webhook retry policy configuration\n        logger_instance: Logger for retry events\n\n    Returns:\n        Configured AsyncRetrying instance\n    \"\"\"\n    log = logger_instance or logger\n\n    return AsyncRetrying(\n        stop=stop_after_attempt(policy.max_attempts),\n        wait=wait_exponential(\n            multiplier=policy.initial_delay_seconds,\n            min=policy.initial_delay_seconds,\n            max=policy.max_delay_seconds,\n            exp_base=policy.exponential_base,\n        ),\n        retry=retry_if_exception_type((RetryableError, httpx.TimeoutException, httpx.NetworkError)),\n        before_sleep=before_sleep_log(log, logging.WARNING),\n        reraise=True,\n    )\n\n\ndef with_retry(\n    max_attempts: int = 3,\n    initial_delay: float = 1.0,\n    max_delay: float = 300.0,\n    multiplier: float = 2.0,\n    jitter_factor: float = 0.1,\n    retryable_exceptions: Optional[tuple] = None,\n    retryable_status_codes: Optional[Set[int]] = None,\n) -> Callable:\n    \"\"\"\n    Decorator for async functions to add retry logic with exponential backoff.\n\n    Args:\n        max_attempts: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        max_delay: Maximum delay cap in seconds\n        multiplier: Exponential backoff multiplier\n        jitter_factor: Random jitter factor\n        retryable_exceptions: Tuple of exception types to retry on\n        retryable_status_codes: Set of HTTP status codes to retry on\n\n    Returns:\n        Decorated function with retry logic\n    \"\"\"\n    if retryable_exceptions is None:\n        retryable_exceptions = (\n            RetryableError,\n            httpx.TimeoutException,\n            httpx.NetworkError,\n            httpx.ConnectError,\n            httpx.ReadError,\n        )\n\n    if retryable_status_codes is None:\n        retryable_status_codes = {429, 500, 502, 503, 504}\n\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        async def wrapper(*args: Any, **kwargs: Any) -> Any:\n            backoff = ExponentialBackoff(\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                multiplier=multiplier,\n                jitter_factor=jitter_factor,\n            )\n            state = RetryState(max_attempts=max_attempts, backoff=backoff)\n            last_exception: Optional[Exception] = None\n            last_status_code: Optional[int] = None\n\n            while state.current_attempt < max_attempts:\n                state.start()\n\n                try:\n                    result = await func(*args, **kwargs)\n\n                    # If result is an httpx.Response, check status code\n                    if isinstance(result, httpx.Response):\n                        if should_retry_status_code(result.status_code, retryable_status_codes):\n                            last_status_code = result.status_code\n                            raise RetryableError(\n                                f\"HTTP {result.status_code}\",\n                                status_code=result.status_code,\n                            )\n\n                    state.complete()\n                    return result\n\n                except retryable_exceptions as e:\n                    last_exception = e\n                    if isinstance(e, RetryableError):\n                        last_status_code = e.status_code\n                    state.record_error(e, last_status_code)\n\n                    if state.can_retry:\n                        delay = state.next_delay\n                        logger.warning(\n                            f\"Retry {state.current_attempt}/{max_attempts} failed: {e}. \"\n                            f\"Retrying in {delay:.2f}s\"\n                        )\n                        await asyncio.sleep(delay)\n                    else:\n                        state.complete()\n                        raise WebhookRetryError(\n                            f\"All {max_attempts} retry attempts failed\",\n                            attempts=max_attempts,\n                            last_error=last_exception,\n                            last_status_code=last_status_code,\n                        ) from e\n\n                except NonRetryableError:\n                    state.complete()\n                    raise\n\n                except Exception:\n                    # Unknown errors - complete and re-raise without retry\n                    state.complete()\n                    raise\n\n            state.complete()\n            raise WebhookRetryError(\n                f\"All {max_attempts} retry attempts failed\",\n                attempts=max_attempts,\n                last_error=last_exception,\n                last_status_code=last_status_code,\n            )\n\n        return wrapper\n\n    return decorator\n\n\nasync def retry_with_backoff(\n    func: Callable[[], T],\n    policy: WebhookRetryPolicy,\n    on_retry: Optional[Callable[[int, Exception, float], None]] = None,\n) -> T:\n    \"\"\"\n    Execute a function with retry logic based on a WebhookRetryPolicy.\n\n    Args:\n        func: Async function to execute\n        policy: Retry policy configuration\n        on_retry: Optional callback called before each retry (attempt, error, delay)\n\n    Returns:\n        Result of the function\n\n    Raises:\n        WebhookRetryError: If all retries are exhausted\n    \"\"\"\n    backoff = ExponentialBackoff.from_policy(policy)\n    state = RetryState(max_attempts=policy.max_attempts, backoff=backoff)\n    retryable_codes = set(policy.retry_on_status_codes)\n\n    while True:\n        state.start()\n\n        try:\n            result = await func()\n\n            # Check if result is retryable\n            if isinstance(result, httpx.Response):\n                if should_retry_status_code(result.status_code, retryable_codes):\n                    raise RetryableError(\n                        f\"HTTP {result.status_code}\",\n                        status_code=result.status_code,\n                    )\n\n            state.complete()\n            return result\n\n        except Exception as e:\n            status_code = getattr(e, \"status_code\", None)\n            state.record_error(e, status_code)\n\n            # Determine if we should retry\n            should_retry = False\n\n            if isinstance(e, RetryableError):\n                should_retry = True\n            elif isinstance(e, NonRetryableError):\n                should_retry = False\n            elif isinstance(e, httpx.TimeoutException) and policy.retry_on_timeout:\n                should_retry = True\n            elif (\n                isinstance(e, (httpx.NetworkError, httpx.ConnectError))\n                and policy.retry_on_connection_error\n            ):\n                should_retry = True\n\n            if should_retry and state.can_retry:\n                delay = state.next_delay\n\n                if on_retry:\n                    on_retry(state.current_attempt, e, delay)\n\n                logger.warning(\n                    f\"Attempt {state.current_attempt}/{policy.max_attempts} failed: {e}. \"\n                    f\"Retrying in {delay:.2f}s\"\n                )\n                await asyncio.sleep(delay)\n            else:\n                state.complete()\n                raise WebhookRetryError(\n                    f\"Delivery failed after {state.current_attempt} attempt(s)\",\n                    attempts=state.current_attempt,\n                    last_error=e,\n                    last_status_code=status_code,\n                ) from e\n\n\ndef extract_retry_after(response: httpx.Response) -> Optional[float]:\n    \"\"\"\n    Extract Retry-After value from an HTTP response.\n\n    Args:\n        response: HTTP response object\n\n    Returns:\n        Retry delay in seconds, or None if not specified\n    \"\"\"\n    retry_after = response.headers.get(\"Retry-After\")\n\n    if retry_after is None:\n        return None\n\n    try:\n        # Try parsing as seconds\n        return float(retry_after)\n    except ValueError:\n        pass\n\n    try:\n        # Try parsing as HTTP date\n        from email.utils import parsedate_to_datetime\n\n        retry_date = parsedate_to_datetime(retry_after)\n        delta = retry_date - datetime.now(timezone.utc)\n        return max(0, delta.total_seconds())\n    except (ValueError, TypeError):\n        pass\n\n    return None\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.590387",
  "last_updated": "2026-01-04T05:35:58.457850"
}