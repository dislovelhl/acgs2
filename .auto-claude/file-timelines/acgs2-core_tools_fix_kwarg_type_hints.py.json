{
  "file_path": "acgs2-core/tools/fix_kwarg_type_hints.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "#!/usr/bin/env python3\n\"\"\"\nACGS-2 Keyword Argument Type Hint Repair Tool.\n\nConstitutional Hash: cdd01ef066bc6cf2\n\nFixes incorrectly placed type annotations in function call keyword arguments.\nFor example:\n    BehaviorPattern(\n        pattern_type=\"value\",  # WRONG\n    )\nShould be:\n    BehaviorPattern(\n        pattern_type=\"value\",  # CORRECT\n    )\n\"\"\"\n\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Tuple\n\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\ndef fix_kwarg_type_hints(content: str) -> Tuple[str, int]:\n    \"\"\"\n    Fix keyword argument type hints in function calls.\n\n    Returns:\n        Tuple of (fixed_content, number_of_fixes)\n    \"\"\"\n    fixes = 0\n\n    # Pattern: keyword argument with type hint inside function call\n    # Matches: name: Type = value, (with comma at end, inside function call context)\n    # We need to be careful not to match dataclass field definitions\n\n    # Pattern for keyword args with simple types\n    pattern1 = re.compile(\n        r'(\\s+)(\\w+):\\s*(?:str|int|float|bool)\\s*=\\s*(\"(?:[^\"\\\\]|\\\\.)*\"|\\'(?:[^\\'\\\\]|\\\\.)*\\'|[\\d.]+|True|False|None)(,?\\s*(?:#[^\\n]*)?\\n)',\n        re.MULTILINE,\n    )\n\n    # Only replace if we're inside a function call (preceded by ( or , on a previous line)\n    def replace_kwarg(match):\n        indent = match.group(1)\n        name = match.group(2)\n        value = match.group(3)\n        trailing = match.group(4)\n        return f\"{indent}{name}={value}{trailing}\"\n\n    # Find all matches and check context\n    new_content = content\n    for match in list(pattern1.finditer(content)):\n        # Check if this looks like a function call context\n        # Look backward for opening paren or previous argument\n        start = match.start()\n        context = content[max(0, start - 200) : start]\n\n        # If we see a class definition or dataclass, skip\n        if re.search(r\"@dataclass|class\\s+\\w+.*:\\s*$\", context, re.MULTILINE):\n            # Check if this is at class level (field definition)\n            lines_before = context.split(\"\\n\")\n            if lines_before and not any(\"(\" in line for line in lines_before[-3:]):\n                continue\n\n        # If we see an opening paren in recent lines, it's likely a function call\n        if \"(\" in context.split(\"\\n\")[-1] or any(\n            \"(\" in line and \")\" not in line for line in context.split(\"\\n\")[-5:]\n        ):\n            new_content = (\n                new_content[: match.start()] + replace_kwarg(match) + new_content[match.end() :]\n            )\n            fixes += 1\n\n    # Simpler approach: target specific patterns in function calls\n    # Pattern: inside parentheses with multiple arguments\n    lines = new_content.split(\"\\n\")\n    new_lines = []\n    in_call = 0\n\n    for _i, line in enumerate(lines):\n        # Track parentheses depth\n        in_call += line.count(\"(\") - line.count(\")\")\n\n        # If we're inside a call (paren depth > 0), fix type-hinted kwargs\n        if in_call > 0:\n            # Match kwarg with type hint\n            kwarg_pattern = re.compile(\n                r\"^(\\s*)(\\w+):\\s*(?:str|int|float|bool|dict|list|Any|Optional)(?:\\[[^\\]]*\\])?\\s*=\\s*(.+)$\"\n            )\n            match = kwarg_pattern.match(line)\n            if match:\n                indent = match.group(1)\n                name = match.group(2)\n                value = match.group(3)\n                # Only fix if it looks like a function argument (not a field default)\n                if not line.strip().startswith(\"@\") and \"(\" not in line[: line.find(\"=\")]:\n                    new_line = f\"{indent}{name}={value}\"\n                    new_lines.append(new_line)\n                    fixes += 1\n                    continue\n\n        new_lines.append(line)\n\n    return \"\\n\".join(new_lines), fixes\n\n\ndef fix_double_type_annotations(content: str) -> Tuple[str, int]:\n    \"\"\"\n    Fix double type annotations in function parameters.\n    e.g., entry: dict[str, Any] -> entry: dict[str, Any]\n    \"\"\"\n    fixes = 0\n\n    # Pattern: param: Type[...]: Type\n    pattern = re.compile(\n        r\"(\\w+:\\s*(?:dict|list|Optional|Union|Any|Callable)\\[[^\\]]+\\]):\\s*(?:Any|str|int|float|bool|None|Self)\"\n    )\n\n    while pattern.search(content):\n        content = pattern.sub(r\"\\1\", content)\n        fixes += 1\n\n    return content, fixes\n\n\ndef fix_self_type_hint(content: str) -> Tuple[str, int]:\n    \"\"\"\n    Fix self: Self type hints (not valid in older Python).\n    \"\"\"\n    fixes = 0\n\n    # Pattern: (self, or (self)\n    pattern = re.compile(r\"\\(self:\\s*Self([,)])\")\n\n    while pattern.search(content):\n        content = pattern.sub(r\"(self\\1\", content)\n        fixes += 1\n\n    return content, fixes\n\n\ndef process_file(filepath: Path, dry_run: bool = False) -> Tuple[bool, int]:\n    \"\"\"Process a single file.\"\"\"\n    try:\n        content = filepath.read_text(encoding=\"utf-8\")\n    except Exception as e:\n        logging.error(f\"  Error reading {filepath}: {e}\")\n        return False, 0\n\n    total_fixes = 0\n\n    # Apply fixes\n    content, fixes = fix_double_type_annotations(content)\n    total_fixes += fixes\n\n    content, fixes = fix_self_type_hint(content)\n    total_fixes += fixes\n\n    content, fixes = fix_kwarg_type_hints(content)\n    total_fixes += fixes\n\n    if total_fixes > 0:\n        if not dry_run:\n            filepath.write_text(content, encoding=\"utf-8\")\n        return True, total_fixes\n\n    return False, 0\n\n\ndef main():\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        description=\"Fix keyword argument type hints in ACGS-2 codebase\"\n    )\n    parser.add_argument(\"paths\", nargs=\"*\", default=[\".\"])\n    parser.add_argument(\"--dry-run\", action=\"store_true\")\n    parser.add_argument(\"--verbose\", \"-v\", action=\"store_true\")\n\n    args = parser.parse_args()\n\n    logging.info(\"ACGS-2 Keyword Argument Type Hint Repair Tool\")\n    logging.info(f\"Constitutional Hash: {CONSTITUTIONAL_HASH}\")\n    logging.info(\"\")\n\n    total_files = 0\n    modified_files = 0\n    total_fixes = 0\n\n    for path_str in args.paths:\n        path = Path(path_str)\n\n        if path.is_file() and path.suffix == \".py\":\n            files = [path]\n        elif path.is_dir():\n            files = list(path.rglob(\"*.py\"))\n        else:\n            continue\n\n        for filepath in files:\n            skip_dirs = [\"__pycache__\", \".git\", \"node_modules\", \".venv\"]\n            if any(skip_dir in str(filepath) for skip_dir in skip_dirs):\n                continue\n\n            total_files += 1\n            was_modified, fixes = process_file(filepath, args.dry_run)\n\n            if was_modified:\n                modified_files += 1\n                total_fixes += fixes\n                if args.verbose:\n                    action = \"Would fix\" if args.dry_run else \"Fixed\"\n                    logging.info(f\"  {action} {fixes} patterns in {filepath}\")\n\n    logging.info(\"Summary:\")\n    logging.info(f\"  Files scanned: {total_files}\")\n    logging.info(f\"  Files modified: {modified_files}\")\n    logging.info(f\"  Total fixes: {total_fixes}\")\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.307159",
  "last_updated": "2026-01-04T05:35:58.422678"
}