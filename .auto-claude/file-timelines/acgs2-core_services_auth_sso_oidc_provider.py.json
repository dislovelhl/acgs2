{
  "file_path": "acgs2-core/services/auth_sso/oidc_provider.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nOpenID Connect Relying Party Implementation\nConstitutional Hash: cdd01ef066bc6cf2\n\nImplements OIDC RP functionality:\n- Authorization Code Flow with PKCE\n- ID Token validation via JWKS\n- User info retrieval\n- RP-initiated logout\n\"\"\"\n\nimport base64\nimport hashlib\nimport logging\nimport secrets\nimport time\nfrom typing import Any, Dict, Optional\nfrom urllib.parse import urlencode\n\nfrom .config import IdPConfig\nfrom .models import SSOProtocol, SSOUser\n\nlogger = logging.getLogger(__name__)\n\n# Check if authlib is available\nAUTHLIB_AVAILABLE = False\ntry:\n    from authlib.integrations.httpx_client import AsyncOAuth2Client\n    from authlib.jose import JsonWebKey, jwt\n    AUTHLIB_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\n        \"authlib not installed. OIDC authentication will be unavailable. \"\n        \"Install with: pip install authlib httpx\"\n    )\n\n# Check if httpx is available\nHTTPX_AVAILABLE = False\ntry:\n    import httpx\n    HTTPX_AVAILABLE = True\nexcept ImportError:\n    pass\n\n\nclass OIDCDiscoveryCache:\n    \"\"\"Cache for OIDC discovery document and JWKS.\"\"\"\n\n    def __init__(self, ttl_seconds: int = 86400):\n        \"\"\"\n        Initialize discovery cache.\n\n        Args:\n            ttl_seconds: Time-to-live for cached data (default 24 hours)\n        \"\"\"\n        self.ttl_seconds = ttl_seconds\n        self._discovery: Dict[str, Dict[str, Any]] = {}\n        self._jwks: Dict[str, Any] = {}\n        self._timestamps: Dict[str, float] = {}\n\n    def get_discovery(self, discovery_url: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get cached discovery document if not expired.\"\"\"\n        if discovery_url not in self._discovery:\n            return None\n\n        if time.time() - self._timestamps.get(f\"disc:{discovery_url}\", 0) > self.ttl_seconds:\n            return None\n\n        return self._discovery[discovery_url]\n\n    def set_discovery(self, discovery_url: str, data: Dict[str, Any]) -> None:\n        \"\"\"Cache discovery document.\"\"\"\n        self._discovery[discovery_url] = data\n        self._timestamps[f\"disc:{discovery_url}\"] = time.time()\n\n    def get_jwks(self, jwks_uri: str) -> Optional[Any]:\n        \"\"\"Get cached JWKS if not expired.\"\"\"\n        if jwks_uri not in self._jwks:\n            return None\n\n        if time.time() - self._timestamps.get(f\"jwks:{jwks_uri}\", 0) > self.ttl_seconds:\n            return None\n\n        return self._jwks[jwks_uri]\n\n    def set_jwks(self, jwks_uri: str, jwks: Any) -> None:\n        \"\"\"Cache JWKS.\"\"\"\n        self._jwks[jwks_uri] = jwks\n        self._timestamps[f\"jwks:{jwks_uri}\"] = time.time()\n\n\n# Global discovery cache\n_discovery_cache = OIDCDiscoveryCache()\n\n\nclass OIDCRelyingParty:\n    \"\"\"\n    OpenID Connect Relying Party implementation.\n\n    Handles OIDC authentication flows including:\n    - Authorization Code Flow with PKCE\n    - ID token validation via JWKS\n    - User info endpoint retrieval\n    - RP-initiated logout\n\n    Usage:\n        rp = OIDCRelyingParty(idp_config, callback_url)\n\n        # Get authorization URL\n        auth_url, state, nonce = rp.create_auth_request()\n\n        # Exchange code for tokens\n        user = await rp.process_callback(code, state, nonce)\n    \"\"\"\n\n    def __init__(\n        self,\n        idp_config: IdPConfig,\n        callback_url: str,\n        discovery_cache: Optional[OIDCDiscoveryCache] = None,\n    ):\n        \"\"\"\n        Initialize OIDC Relying Party.\n\n        Args:\n            idp_config: IdP configuration with OIDC settings\n            callback_url: URL for authorization callback\n            discovery_cache: Optional cache for discovery/JWKS\n        \"\"\"\n        self.idp_config = idp_config\n        self.callback_url = callback_url\n        self._cache = discovery_cache or _discovery_cache\n        self._discovery: Optional[Dict[str, Any]] = None\n\n        if not AUTHLIB_AVAILABLE or not HTTPX_AVAILABLE:\n            logger.error(\"OIDC libraries not available - RP will not function\")\n\n    async def _fetch_discovery(self) -> Dict[str, Any]:\n        \"\"\"Fetch OIDC discovery document.\"\"\"\n        if not self.idp_config.oidc_discovery_url:\n            raise ValueError(\"OIDC discovery URL not configured\")\n\n        # Check cache first\n        cached = self._cache.get_discovery(self.idp_config.oidc_discovery_url)\n        if cached:\n            return cached\n\n        # Fetch discovery document\n        async with httpx.AsyncClient() as client:\n            response = await client.get(self.idp_config.oidc_discovery_url)\n            response.raise_for_status()\n            discovery = response.json()\n\n        # Cache for future use\n        self._cache.set_discovery(self.idp_config.oidc_discovery_url, discovery)\n\n        return discovery\n\n    async def _fetch_jwks(self, jwks_uri: str) -> Any:\n        \"\"\"Fetch JWKS for ID token validation.\"\"\"\n        # Check cache first\n        cached = self._cache.get_jwks(jwks_uri)\n        if cached:\n            return cached\n\n        # Fetch JWKS\n        async with httpx.AsyncClient() as client:\n            response = await client.get(jwks_uri)\n            response.raise_for_status()\n            jwks_data = response.json()\n\n        # Cache for future use\n        self._cache.set_jwks(jwks_uri, jwks_data)\n\n        return jwks_data\n\n    def _generate_pkce(self) -> tuple[str, str]:\n        \"\"\"Generate PKCE code verifier and challenge.\"\"\"\n        verifier = secrets.token_urlsafe(32)\n        challenge = base64.urlsafe_b64encode(\n            hashlib.sha256(verifier.encode()).digest()\n        ).rstrip(b\"=\").decode()\n        return verifier, challenge\n\n    async def create_auth_request(\n        self,\n        state: Optional[str] = None,\n        nonce: Optional[str] = None,\n        extra_params: Optional[Dict[str, str]] = None,\n    ) -> tuple[str, str, str, str]:\n        \"\"\"\n        Create OIDC authorization request URL.\n\n        Args:\n            state: Optional state parameter (generated if not provided)\n            nonce: Optional nonce parameter (generated if not provided)\n            extra_params: Additional query parameters\n\n        Returns:\n            Tuple of (auth_url, state, nonce, code_verifier)\n        \"\"\"\n        if not AUTHLIB_AVAILABLE:\n            raise RuntimeError(\"OIDC library not available\")\n\n        discovery = await self._fetch_discovery()\n        authorization_endpoint = discovery[\"authorization_endpoint\"]\n\n        # Generate security parameters\n        state = state or secrets.token_urlsafe(16)\n        nonce = nonce or secrets.token_urlsafe(16)\n        code_verifier, code_challenge = self._generate_pkce()\n\n        # Build authorization URL\n        params = {\n            \"client_id\": self.idp_config.oidc_client_id,\n            \"response_type\": \"code\",\n            \"scope\": \" \".join(self.idp_config.oidc_scopes),\n            \"redirect_uri\": self.callback_url,\n            \"state\": state,\n            \"nonce\": nonce,\n            \"code_challenge\": code_challenge,\n            \"code_challenge_method\": \"S256\",\n        }\n\n        if extra_params:\n            params.update(extra_params)\n\n        auth_url = f\"{authorization_endpoint}?{urlencode(params)}\"\n\n        logger.info(f\"Created OIDC auth request with state: {state[:8]}...\")\n        return auth_url, state, nonce, code_verifier\n\n    async def process_callback(\n        self,\n        code: str,\n        state: str,\n        nonce: str,\n        code_verifier: str,\n        expected_state: str,\n    ) -> SSOUser:\n        \"\"\"\n        Process OIDC authorization callback.\n\n        Args:\n            code: Authorization code from callback\n            state: State parameter from callback\n            nonce: Original nonce from auth request\n            code_verifier: PKCE code verifier\n            expected_state: Expected state to validate against\n\n        Returns:\n            SSOUser with authenticated user information\n\n        Raises:\n            ValueError: If validation fails\n        \"\"\"\n        if not AUTHLIB_AVAILABLE or not HTTPX_AVAILABLE:\n            raise RuntimeError(\"OIDC library not available\")\n\n        # Validate state (CSRF protection)\n        if state != expected_state:\n            raise ValueError(\"State mismatch - possible CSRF attack\")\n\n        discovery = await self._fetch_discovery()\n        token_endpoint = discovery[\"token_endpoint\"]\n        userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n        jwks_uri = discovery[\"jwks_uri\"]\n\n        # Exchange code for tokens\n        async with httpx.AsyncClient() as client:\n            token_response = await client.post(\n                token_endpoint,\n                data={\n                    \"grant_type\": \"authorization_code\",\n                    \"code\": code,\n                    \"redirect_uri\": self.callback_url,\n                    \"client_id\": self.idp_config.oidc_client_id,\n                    \"client_secret\": self.idp_config.oidc_client_secret,\n                    \"code_verifier\": code_verifier,\n                },\n            )\n            token_response.raise_for_status()\n            tokens = token_response.json()\n\n        # Extract tokens\n        id_token = tokens.get(\"id_token\")\n        access_token = tokens.get(\"access_token\")\n\n        if not id_token:\n            raise ValueError(\"No ID token in response\")\n\n        # Validate ID token\n        claims = await self._validate_id_token(id_token, nonce, jwks_uri)\n\n        # Get additional user info if available\n        user_info = claims\n        if userinfo_endpoint and access_token:\n            try:\n                user_info = await self._fetch_user_info(userinfo_endpoint, access_token)\n                # Merge with claims\n                user_info = {**claims, **user_info}\n            except Exception as e:\n                logger.warning(f\"Failed to fetch user info: {e}\")\n\n        # Build SSOUser from claims\n        user = self._build_user_from_claims(user_info)\n\n        logger.info(f\"OIDC authentication successful for: {user.email}\")\n        return user\n\n    async def _validate_id_token(\n        self,\n        id_token: str,\n        nonce: str,\n        jwks_uri: str,\n    ) -> Dict[str, Any]:\n        \"\"\"Validate ID token signature and claims.\"\"\"\n        # Fetch JWKS\n        jwks_data = await self._fetch_jwks(jwks_uri)\n\n        # Decode and validate token\n        claims = jwt.decode(\n            id_token,\n            JsonWebKey.import_key_set(jwks_data),\n            claims_options={\n                \"iss\": {\"essential\": True},\n                \"aud\": {\"essential\": True, \"value\": self.idp_config.oidc_client_id},\n                \"exp\": {\"essential\": True},\n                \"nonce\": {\"essential\": True, \"value\": nonce},\n            },\n        )\n\n        # Validate claims\n        claims.validate()\n\n        return dict(claims)\n\n    async def _fetch_user_info(\n        self,\n        userinfo_endpoint: str,\n        access_token: str,\n    ) -> Dict[str, Any]:\n        \"\"\"Fetch user info from userinfo endpoint.\"\"\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                userinfo_endpoint,\n                headers={\"Authorization\": f\"Bearer {access_token}\"},\n            )\n            response.raise_for_status()\n            return response.json()\n\n    def _build_user_from_claims(self, claims: Dict[str, Any]) -> SSOUser:\n        \"\"\"Build SSOUser from OIDC claims.\"\"\"\n        # Standard OIDC claims\n        external_id = claims.get(\"sub\", \"\")\n        email = claims.get(\"email\", \"\")\n        name = claims.get(\"name\")\n        given_name = claims.get(\"given_name\")\n        family_name = claims.get(\"family_name\")\n        groups = claims.get(\"groups\", [])\n\n        # Apply custom attribute mapping if configured\n        mapping = self.idp_config.attribute_mapping\n        if mapping.external_id:\n            external_id = claims.get(mapping.external_id, external_id)\n        if mapping.email != \"email\":\n            email = claims.get(mapping.email, email)\n        if mapping.display_name != \"name\":\n            name = claims.get(mapping.display_name, name)\n        if mapping.groups != \"groups\":\n            groups = claims.get(mapping.groups, groups)\n\n        return SSOUser(\n            external_id=external_id,\n            email=email,\n            display_name=name,\n            first_name=given_name,\n            last_name=family_name,\n            groups=groups if isinstance(groups, list) else [],\n            idp_type=self.idp_config.idp_type,\n            protocol=SSOProtocol.OIDC,\n            raw_attributes=claims,\n        )\n\n    async def create_logout_url(\n        self,\n        id_token_hint: Optional[str] = None,\n        post_logout_redirect_uri: Optional[str] = None,\n        state: Optional[str] = None,\n    ) -> Optional[str]:\n        \"\"\"\n        Create RP-initiated logout URL.\n\n        Args:\n            id_token_hint: ID token for logout\n            post_logout_redirect_uri: URL to redirect after logout\n            state: State parameter for logout\n\n        Returns:\n            Logout URL or None if not supported\n        \"\"\"\n        discovery = await self._fetch_discovery()\n        end_session_endpoint = discovery.get(\"end_session_endpoint\")\n\n        if not end_session_endpoint:\n            logger.warning(\"IdP does not support RP-initiated logout\")\n            return None\n\n        params = {}\n        if id_token_hint:\n            params[\"id_token_hint\"] = id_token_hint\n        if post_logout_redirect_uri:\n            params[\"post_logout_redirect_uri\"] = post_logout_redirect_uri\n        if state:\n            params[\"state\"] = state\n\n        if params:\n            return f\"{end_session_endpoint}?{urlencode(params)}\"\n        return end_session_endpoint\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.092927",
  "last_updated": "2026-01-04T05:35:58.656576"
}