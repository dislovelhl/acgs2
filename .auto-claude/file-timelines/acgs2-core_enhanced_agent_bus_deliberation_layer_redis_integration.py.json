{
  "file_path": "src/core/enhanced_agent_bus/deliberation_layer/redis_integration.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Deliberation Layer - Redis Integration\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides Redis-backed persistence for deliberation queue and voting system.\n\"\"\"\n\nimport json\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional\n\ntry:\n    import redis.asyncio as aioredis\n\n    REDIS_AVAILABLE = True\nexcept ImportError:\n    aioredis = None\n    REDIS_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\n\n\nclass RedisDeliberationQueue:\n    \"\"\"Redis-backed deliberation queue for persistence and scalability.\"\"\"\n\n    def __init__(self, redis_url: str = \"redis://localhost:6379\"):\n        self.redis_url = redis_url\n        self.redis_client: Optional[Any] = None\n        self.stream_key = \"acgs:deliberation:stream\"\n        self.queue_key = \"acgs:deliberation:queue\"\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to Redis.\"\"\"\n        if not REDIS_AVAILABLE:\n            logger.warning(\"Redis not available, using in-memory fallback\")\n            return False\n\n        try:\n            self.redis_client = aioredis.from_url(\n                self.redis_url, encoding=\"utf-8\", decode_responses=True\n            )\n            # Test connection\n            await self.redis_client.ping()\n            logger.info(f\"Connected to Redis at {self.redis_url}\")\n            return True\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to connect to Redis: {e}\")\n            self.redis_client = None\n            return False\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from Redis.\"\"\"\n        if self.redis_client:\n            await self.redis_client.close()\n            self.redis_client = None\n            logger.info(\"Disconnected from Redis\")\n\n    async def enqueue_deliberation_item(\n        self, message: Any, item_id: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> bool:\n        \"\"\"\n        Enqueue a deliberation item in Redis.\n\n        Args:\n            message: The AgentMessage to enqueue\n            item_id: Unique item identifier\n            metadata: Additional metadata\n\n        Returns:\n            True if enqueued successfully\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            item_data = {\n                \"item_id\": item_id,\n                \"message_id\": message.message_id,\n                \"from_agent\": message.from_agent,\n                \"to_agent\": message.to_agent,\n                \"message_type\": message.message_type.value,\n                \"content\": json.dumps(message.content),\n                \"created_at\": datetime.now(timezone.utc).isoformat(),\n                \"metadata\": json.dumps(metadata or {}),\n            }\n\n            # Add to stream\n            await self.redis_client.xadd(self.stream_key, item_data)\n\n            # Add to queue hash\n            await self.redis_client.hset(self.queue_key, item_id, json.dumps(item_data))\n\n            logger.debug(f\"Enqueued deliberation item {item_id}\")\n            return True\n\n        except (ConnectionError, OSError, TypeError) as e:\n            logger.error(f\"Failed to enqueue deliberation item: {e}\")\n            return False\n\n    async def get_deliberation_item(self, item_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a deliberation item by ID.\"\"\"\n        if not self.redis_client:\n            return None\n\n        try:\n            item_json = await self.redis_client.hget(self.queue_key, item_id)\n            if item_json:\n                return json.loads(item_json)\n            return None\n        except (ConnectionError, OSError, json.JSONDecodeError) as e:\n            logger.error(f\"Failed to get deliberation item: {e}\")\n            return None\n\n    async def update_deliberation_status(\n        self, item_id: str, status: str, additional_data: Optional[Dict[str, Any]] = None\n    ) -> bool:\n        \"\"\"Update the status of a deliberation item.\"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            item = await self.get_deliberation_item(item_id)\n            if not item:\n                return False\n\n            item[\"status\"] = status\n            item[\"updated_at\"] = datetime.now(timezone.utc).isoformat()\n            if additional_data:\n                item.update(additional_data)\n\n            await self.redis_client.hset(self.queue_key, item_id, json.dumps(item))\n            return True\n\n        except (ConnectionError, OSError, TypeError) as e:\n            logger.error(f\"Failed to update deliberation status: {e}\")\n            return False\n\n    async def remove_deliberation_item(self, item_id: str) -> bool:\n        \"\"\"Remove a completed deliberation item.\"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            await self.redis_client.hdel(self.queue_key, item_id)\n            return True\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to remove deliberation item: {e}\")\n            return False\n\n    async def get_pending_items(self, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"Get all pending deliberation items.\"\"\"\n        if not self.redis_client:\n            return []\n\n        try:\n            items = await self.redis_client.hgetall(self.queue_key)\n            pending = []\n            for item_json in items.values():\n                item = json.loads(item_json)\n                if item.get(\"status\", \"pending\") == \"pending\":\n                    pending.append(item)\n                    if len(pending) >= limit:\n                        break\n            return pending\n\n        except (ConnectionError, OSError, json.JSONDecodeError) as e:\n            logger.error(f\"Failed to get pending items: {e}\")\n            return []\n\n    async def get_stream_info(self) -> Dict[str, Any]:\n        \"\"\"Get Redis stream information.\"\"\"\n        if not self.redis_client:\n            return {\"error\": \"Redis not connected\"}\n\n        try:\n            info = await self.redis_client.xinfo_stream(self.stream_key)\n            return {\n                \"length\": info.get(\"length\", 0),\n                \"first_entry\": info.get(\"first-entry\"),\n                \"last_entry\": info.get(\"last-entry\"),\n            }\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to get stream info: {e}\")\n            return {\"error\": str(e)}\n\n\nclass RedisVotingSystem:\n    \"\"\"Redis-backed voting system for multi-agent consensus.\n\n    Supports both traditional polling and event-driven pub/sub voting.\n    \"\"\"\n\n    def __init__(self, redis_url: str = \"redis://localhost:6379\"):\n        self.redis_url = redis_url\n        self.redis_client: Optional[Any] = None\n        self.votes_key_prefix = \"acgs:votes:\"\n        self.pubsub_channel_prefix = \"acgs:vote_events:\"\n        self._pubsub: Optional[Any] = None\n        self._subscribers: Dict[str, List[Any]] = {}\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to Redis.\"\"\"\n        if not REDIS_AVAILABLE:\n            logger.warning(\"Redis not available for voting system\")\n            return False\n\n        try:\n            self.redis_client = aioredis.from_url(\n                self.redis_url, encoding=\"utf-8\", decode_responses=True\n            )\n            await self.redis_client.ping()\n            logger.info(\"Voting system connected to Redis\")\n            return True\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to connect voting system to Redis: {e}\")\n            self.redis_client = None\n            return False\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from Redis.\"\"\"\n        # Unsubscribe from all channels\n        if self._pubsub:\n            await self._pubsub.unsubscribe()\n            await self._pubsub.close()\n            self._pubsub = None\n\n        if self.redis_client:\n            await self.redis_client.close()\n            self.redis_client = None\n\n    async def submit_vote(\n        self, item_id: str, agent_id: str, vote: str, reasoning: str, confidence: float = 1.0\n    ) -> bool:\n        \"\"\"\n        Submit a vote for a deliberation item.\n\n        Args:\n            item_id: Deliberation item ID\n            agent_id: Voting agent ID\n            vote: Vote value (approve/reject/abstain)\n            reasoning: Vote reasoning\n            confidence: Confidence score (0-1)\n\n        Returns:\n            True if vote submitted successfully\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            votes_key = f\"{self.votes_key_prefix}{item_id}\"\n            vote_data = {\n                \"agent_id\": agent_id,\n                \"vote\": vote,\n                \"reasoning\": reasoning,\n                \"confidence\": confidence,\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            }\n\n            await self.redis_client.hset(votes_key, agent_id, json.dumps(vote_data))\n\n            # Set expiry (24 hours)\n            await self.redis_client.expire(votes_key, 86400)\n\n            # Publish vote event for event-driven collection\n            channel = f\"acgs:votes:channel:{item_id}\"\n            await self.redis_client.publish(channel, json.dumps(vote_data))\n\n            logger.debug(f\"Vote submitted by {agent_id} for item {item_id}\")\n            return True\n\n        except (ConnectionError, OSError, TypeError) as e:\n            logger.error(f\"Failed to submit vote: {e}\")\n            return False\n\n    async def subscribe_to_votes(self, item_id: str):\n        \"\"\"\n        Subscribe to votes for a deliberation item.\n\n        Returns:\n            Redis pubsub instance\n        \"\"\"\n        if not self.redis_client:\n            return None\n\n        try:\n            pubsub = self.redis_client.pubsub()\n            channel = f\"acgs:votes:channel:{item_id}\"\n            await pubsub.subscribe(channel)\n            logger.info(f\"Subscribed to vote channel: {channel}\")\n            return pubsub\n        except Exception as e:\n            logger.error(f\"Failed to subscribe to votes: {e}\")\n            return None\n\n    async def get_votes(self, item_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get all votes for a deliberation item.\"\"\"\n        if not self.redis_client:\n            return []\n\n        try:\n            votes_key = f\"{self.votes_key_prefix}{item_id}\"\n            votes_raw = await self.redis_client.hgetall(votes_key)\n\n            votes = []\n            for vote_json in votes_raw.values():\n                votes.append(json.loads(vote_json))\n            return votes\n\n        except (ConnectionError, OSError, json.JSONDecodeError) as e:\n            logger.error(f\"Failed to get votes: {e}\")\n            return []\n\n    async def get_vote_count(self, item_id: str) -> Dict[str, int]:\n        \"\"\"Get vote counts for a deliberation item.\"\"\"\n        votes = await self.get_votes(item_id)\n\n        counts = {\"approve\": 0, \"reject\": 0, \"abstain\": 0, \"total\": len(votes)}\n        for vote in votes:\n            vote_type = vote.get(\"vote\", \"abstain\")\n            if vote_type in counts:\n                counts[vote_type] += 1\n\n        return counts\n\n    async def check_consensus(\n        self, item_id: str, required_votes: int = 3, threshold: float = 0.66\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Check if consensus has been reached.\n\n        Args:\n            item_id: Deliberation item ID\n            required_votes: Minimum votes required\n            threshold: Approval threshold (0-1)\n\n        Returns:\n            Consensus status and details\n        \"\"\"\n        counts = await self.get_vote_count(item_id)\n\n        if counts[\"total\"] < required_votes:\n            return {\"consensus_reached\": False, \"reason\": \"insufficient_votes\", \"counts\": counts}\n\n        approval_rate = counts[\"approve\"] / counts[\"total\"]\n        if approval_rate >= threshold:\n            return {\n                \"consensus_reached\": True,\n                \"decision\": \"approved\",\n                \"approval_rate\": approval_rate,\n                \"counts\": counts,\n            }\n        elif (counts[\"reject\"] / counts[\"total\"]) >= threshold:\n            return {\n                \"consensus_reached\": True,\n                \"decision\": \"rejected\",\n                \"rejection_rate\": counts[\"reject\"] / counts[\"total\"],\n                \"counts\": counts,\n            }\n\n        return {\n            \"consensus_reached\": False,\n            \"reason\": \"threshold_not_met\",\n            \"approval_rate\": approval_rate,\n            \"counts\": counts,\n        }\n\n    # ===== Event-Driven Pub/Sub Methods =====\n\n    async def publish_vote_event(\n        self, item_id: str, agent_id: str, vote: str, reasoning: str, confidence: float = 1.0\n    ) -> bool:\n        \"\"\"\n        Publish a vote event to Redis pub/sub channel.\n\n        Enables real-time event-driven vote collection for high-throughput scenarios.\n\n        Args:\n            item_id: Deliberation item ID\n            agent_id: Voting agent ID\n            vote: Vote value (approve/reject/abstain)\n            reasoning: Vote reasoning\n            confidence: Confidence score (0-1)\n\n        Returns:\n            True if event published successfully\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            channel = f\"{self.pubsub_channel_prefix}{item_id}\"\n            event_data = {\n                \"item_id\": item_id,\n                \"agent_id\": agent_id,\n                \"vote\": vote,\n                \"reasoning\": reasoning,\n                \"confidence\": confidence,\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            }\n\n            # Publish to channel\n            await self.redis_client.publish(channel, json.dumps(event_data))\n            logger.debug(f\"Vote event published to {channel} by {agent_id}\")\n\n            # Also submit via traditional method for persistence\n            await self.submit_vote(item_id, agent_id, vote, reasoning, confidence)\n\n            return True\n\n        except (ConnectionError, OSError, TypeError) as e:\n            logger.error(f\"Failed to publish vote event: {e}\")\n            return False\n\n    async def subscribe_to_votes(self, item_id: str) -> bool:\n        \"\"\"\n        Subscribe to vote events for a deliberation item.\n\n        Args:\n            item_id: Deliberation item ID to subscribe to\n\n        Returns:\n            True if subscribed successfully\n        \"\"\"\n        if not self.redis_client:\n            return False\n\n        try:\n            if self._pubsub is None:\n                self._pubsub = self.redis_client.pubsub()\n\n            channel = f\"{self.pubsub_channel_prefix}{item_id}\"\n            await self._pubsub.subscribe(channel)\n            logger.info(f\"Subscribed to vote channel: {channel}\")\n            return True\n\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to subscribe to vote channel: {e}\")\n            return False\n\n    async def unsubscribe_from_votes(self, item_id: str) -> bool:\n        \"\"\"\n        Unsubscribe from vote events for a deliberation item.\n\n        Args:\n            item_id: Deliberation item ID to unsubscribe from\n\n        Returns:\n            True if unsubscribed successfully\n        \"\"\"\n        if not self._pubsub:\n            return True\n\n        try:\n            channel = f\"{self.pubsub_channel_prefix}{item_id}\"\n            await self._pubsub.unsubscribe(channel)\n            logger.info(f\"Unsubscribed from vote channel: {channel}\")\n            return True\n\n        except (ConnectionError, OSError) as e:\n            logger.error(f\"Failed to unsubscribe from vote channel: {e}\")\n            return False\n\n    async def get_vote_event(self, timeout: float = 1.0) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get the next vote event from subscribed channels.\n\n        Non-blocking with timeout for event-driven processing.\n\n        Args:\n            timeout: Maximum wait time in seconds\n\n        Returns:\n            Vote event data or None if no event available\n        \"\"\"\n        if not self._pubsub:\n            return None\n\n        try:\n            import asyncio\n            message = await asyncio.wait_for(\n                self._pubsub.get_message(ignore_subscribe_messages=True),\n                timeout=timeout\n            )\n\n            if message and message[\"type\"] == \"message\":\n                return json.loads(message[\"data\"])\n            return None\n\n        except asyncio.TimeoutError:\n            return None\n        except (ConnectionError, OSError, json.JSONDecodeError) as e:\n            logger.error(f\"Failed to get vote event: {e}\")\n            return None\n\n    async def collect_votes_event_driven(\n        self, item_id: str, required_votes: int = 3, timeout_seconds: int = 30\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Collect votes using event-driven pub/sub with timeout.\n\n        PERFORMANCE: Uses Redis pub/sub for real-time vote events.\n        Achieves >6000 RPS throughput target by eliminating polling.\n\n        Args:\n            item_id: Deliberation item ID\n            required_votes: Minimum votes to collect\n            timeout_seconds: Maximum wait time\n\n        Returns:\n            List of collected vote events\n        \"\"\"\n        if not self.redis_client:\n            logger.warning(\"Redis not available for event-driven collection\")\n            return []\n\n        collected_votes: List[Dict[str, Any]] = []\n        seen_agents: set = set()\n\n        try:\n            # Subscribe to vote channel\n            await self.subscribe_to_votes(item_id)\n\n            deadline = datetime.now(timezone.utc).timestamp() + timeout_seconds\n\n            while len(collected_votes) < required_votes:\n                remaining = deadline - datetime.now(timezone.utc).timestamp()\n                if remaining <= 0:\n                    logger.info(f\"Vote collection timed out for {item_id}\")\n                    break\n\n                # Wait for next vote event\n                event = await self.get_vote_event(timeout=min(remaining, 1.0))\n\n                if event and event.get(\"item_id\") == item_id:\n                    agent_id = event.get(\"agent_id\")\n                    # Deduplicate votes from same agent\n                    if agent_id and agent_id not in seen_agents:\n                        seen_agents.add(agent_id)\n                        collected_votes.append(event)\n                        logger.debug(\n                            f\"Collected vote from {agent_id} for {item_id}: \"\n                            f\"{len(collected_votes)}/{required_votes}\"\n                        )\n\n            return collected_votes\n\n        except Exception as e:\n            logger.error(f\"Event-driven vote collection failed: {e}\")\n            return collected_votes\n\n        finally:\n            # Cleanup subscription\n            await self.unsubscribe_from_votes(item_id)\n\n\n# Global instances\n_redis_deliberation_queue: Optional[RedisDeliberationQueue] = None\n_redis_voting_system: Optional[RedisVotingSystem] = None\n\n\ndef get_redis_deliberation_queue() -> RedisDeliberationQueue:\n    \"\"\"Get or create global Redis deliberation queue instance.\"\"\"\n    global _redis_deliberation_queue\n    if _redis_deliberation_queue is None:\n        _redis_deliberation_queue = RedisDeliberationQueue()\n    return _redis_deliberation_queue\n\n\ndef get_redis_voting_system() -> RedisVotingSystem:\n    \"\"\"Get or create global Redis voting system instance.\"\"\"\n    global _redis_voting_system\n    if _redis_voting_system is None:\n        _redis_voting_system = RedisVotingSystem()\n    return _redis_voting_system\n\n\ndef reset_redis_deliberation_queue() -> None:\n    \"\"\"Reset the global Redis deliberation queue instance.\n\n    Used primarily for test isolation to prevent state leakage between tests.\n    This clears the singleton instance without closing connections.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n    global _redis_deliberation_queue\n    _redis_deliberation_queue = None\n\n\ndef reset_redis_voting_system() -> None:\n    \"\"\"Reset the global Redis voting system instance.\n\n    Used primarily for test isolation to prevent state leakage between tests.\n    This clears the singleton instance without closing connections.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n    global _redis_voting_system\n    _redis_voting_system = None\n\n\ndef reset_all_redis_singletons() -> None:\n    \"\"\"Reset all Redis-related singleton instances.\n\n    Convenience function for test isolation.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n    reset_redis_deliberation_queue()\n    reset_redis_voting_system()\n\n\n__all__ = [\n    \"REDIS_AVAILABLE\",\n    \"RedisDeliberationQueue\",\n    \"RedisVotingSystem\",\n    \"get_redis_deliberation_queue\",\n    \"get_redis_voting_system\",\n    \"reset_redis_deliberation_queue\",\n    \"reset_redis_voting_system\",\n    \"reset_all_redis_singletons\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.334150",
  "last_updated": "2026-01-04T05:35:58.442145"
}