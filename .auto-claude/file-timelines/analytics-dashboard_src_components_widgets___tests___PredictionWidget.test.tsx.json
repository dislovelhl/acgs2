{
  "file_path": "analytics-dashboard/src/components/widgets/__tests__/PredictionWidget.test.tsx",
  "main_branch_history": [],
  "task_views": {
    "054-extract-duplicated-loadingstate-and-api-config-in-": {
      "task_id": "054-extract-duplicated-loadingstate-and-api-config-in-",
      "branch_point": {
        "commit_hash": "4a99fe22e8e0087919301b1aa185d4e2c6da716c",
        "content": "/**\n * PredictionWidget Component Tests\n *\n * Tests for the PredictionWidget component including:\n * - Initial loading state\n * - Displaying forecast chart and data\n * - Summary statistics display\n * - Trend direction indicators\n * - Insufficient data state\n * - Error handling and retry\n * - Integration with analytics-api /predictions endpoint\n */\n\nimport { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, waitFor, fireEvent } from \"@testing-library/react\";\nimport { http, HttpResponse } from \"msw\";\nimport { server } from \"../../../test/mocks/server\";\nimport { errorHandlers } from \"../../../test/mocks/handlers\";\nimport { PredictionWidget } from \"../PredictionWidget\";\n\nconst API_BASE_URL = \"http://localhost:8080\";\n\n// Mock recharts to avoid rendering issues in tests\nvi.mock(\"recharts\", async () => {\n  const actual = await vi.importActual(\"recharts\");\n  return {\n    ...actual,\n    ResponsiveContainer: ({ children }: { children: React.ReactNode }) => (\n      <div data-testid=\"responsive-container\">{children}</div>\n    ),\n    ComposedChart: ({ children }: { children: React.ReactNode }) => (\n      <div data-testid=\"composed-chart\">{children}</div>\n    ),\n    Line: () => <div data-testid=\"line-chart\" />,\n    Area: () => <div data-testid=\"area-chart\" />,\n    XAxis: () => null,\n    YAxis: () => null,\n    Tooltip: () => null,\n  };\n});\n\ndescribe(\"PredictionWidget\", () => {\n  describe(\"Loading State\", () => {\n    it(\"shows loading spinner on initial render\", async () => {\n      render(<PredictionWidget />);\n\n      // Should show Violation Forecast header\n      expect(screen.getByText(\"Violation Forecast\")).toBeInTheDocument();\n\n      // Should show loading message\n      expect(screen.getByText(\"Generating predictions...\")).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Successful API Integration\", () => {\n    it(\"displays forecast chart from /predictions endpoint\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      // Chart components should be rendered\n      expect(screen.getByTestId(\"composed-chart\")).toBeInTheDocument();\n    });\n\n    it(\"displays trend direction badge\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        // Mock data has trend_direction: \"stable\"\n        expect(screen.getByText(\"stable\")).toBeInTheDocument();\n      });\n    });\n\n    it(\"displays summary statistics\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Mean/Day\")).toBeInTheDocument();\n      });\n\n      // Check summary stat values\n      expect(screen.getByText(\"10.5\")).toBeInTheDocument(); // mean\n      expect(screen.getByText(\"13.2\")).toBeInTheDocument(); // max\n      expect(screen.getByText(\"7.8\")).toBeInTheDocument(); // min\n      expect(screen.getByText(\"315\")).toBeInTheDocument(); // total\n    });\n\n    it(\"displays forecast metadata in footer\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Forecast:/)).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"30 days\")).toBeInTheDocument();\n      expect(screen.getByText(/Training:/)).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Insufficient Data State\", () => {\n    it(\"shows insufficient data message when model not trained\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 7,\n            forecast_days: 0,\n            model_trained: false,\n            predictions: [],\n            summary: {\n              status: \"error\",\n              mean_predicted_violations: null,\n              max_predicted_violations: null,\n              min_predicted_violations: null,\n              total_predicted_violations: null,\n              trend_direction: null,\n              reason: \"Insufficient historical data\",\n            },\n            error_message:\n              \"Collect at least 2 weeks of governance events to enable violation forecasting.\",\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(\"Insufficient Data for Predictions\")\n        ).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByText(/Collect at least 2 weeks of governance events/)\n      ).toBeInTheDocument();\n      expect(\n        screen.getByText(/Current data: 7 days \\(minimum 14 required\\)/)\n      ).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Error Handling\", () => {\n    it(\"displays error message when API fails\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(/Insufficient data for predictions/)\n        ).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n    });\n\n    it(\"retries fetch when Try Again is clicked\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n      });\n\n      // Reset handlers\n      server.resetHandlers();\n\n      // Click retry\n      fireEvent.click(screen.getByText(\"Try Again\"));\n\n      await waitFor(\n        () => {\n          expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n        },\n        { timeout: 5000 }\n      );\n    });\n  });\n\n  describe(\"Refresh Functionality\", () => {\n    it(\"has a refresh button that reloads data\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      const refreshButton = screen.getByRole(\"button\", {\n        name: /refresh predictions/i,\n      });\n      expect(refreshButton).toBeInTheDocument();\n\n      fireEvent.click(refreshButton);\n\n      await waitFor(() => {\n        expect(refreshButton).toBeEnabled();\n      });\n    });\n  });\n\n  describe(\"Trend Direction Display\", () => {\n    it(\"shows increasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: 0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 15,\n              max_predicted_violations: 20,\n              min_predicted_violations: 10,\n              total_predicted_violations: 450,\n              trend_direction: \"increasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"increasing\")).toBeInTheDocument();\n      });\n\n      // The increasing badge should have red styling\n      const badge = screen.getByText(\"increasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-red-100\");\n    });\n\n    it(\"shows decreasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: -0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 8,\n              max_predicted_violations: 12,\n              min_predicted_violations: 5,\n              total_predicted_violations: 240,\n              trend_direction: \"decreasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"decreasing\")).toBeInTheDocument();\n      });\n\n      // The decreasing badge should have green styling\n      const badge = screen.getByText(\"decreasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-green-100\");\n    });\n  });\n\n  describe(\"Accessibility\", () => {\n    it(\"has accessible button labels\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByRole(\"button\", { name: /refresh predictions/i })\n      ).toBeInTheDocument();\n    });\n\n    it(\"has proper heading structure\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByRole(\"heading\", { level: 3 })).toHaveTextContent(\n          \"Violation Forecast\"\n        );\n      });\n    });\n  });\n});\n",
        "timestamp": "2026-01-03T18:35:24.567548"
      },
      "worktree_state": {
        "content": "/**\n * PredictionWidget Component Tests\n *\n * Tests for the PredictionWidget component including:\n * - Initial loading state\n * - Displaying forecast chart and data\n * - Summary statistics display\n * - Trend direction indicators\n * - Insufficient data state\n * - Error handling and retry\n * - Integration with analytics-api /predictions endpoint\n */\n\nimport { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, waitFor, fireEvent } from \"@testing-library/react\";\nimport { http, HttpResponse } from \"msw\";\nimport { server } from \"../../../test/mocks/server\";\nimport { errorHandlers } from \"../../../test/mocks/handlers\";\nimport { PredictionWidget } from \"../PredictionWidget\";\nimport { API_BASE_URL } from \"../../../lib\";\n\n// Mock recharts to avoid rendering issues in tests\nvi.mock(\"recharts\", async () => {\n  const actual = await vi.importActual(\"recharts\");\n  return {\n    ...actual,\n    ResponsiveContainer: ({ children }: { children: React.ReactNode }) => (\n      <div data-testid=\"responsive-container\">{children}</div>\n    ),\n    ComposedChart: ({ children }: { children: React.ReactNode }) => (\n      <div data-testid=\"composed-chart\">{children}</div>\n    ),\n    Line: () => <div data-testid=\"line-chart\" />,\n    Area: () => <div data-testid=\"area-chart\" />,\n    XAxis: () => null,\n    YAxis: () => null,\n    Tooltip: () => null,\n  };\n});\n\ndescribe(\"PredictionWidget\", () => {\n  describe(\"Loading State\", () => {\n    it(\"shows loading spinner on initial render\", async () => {\n      render(<PredictionWidget />);\n\n      // Should show Violation Forecast header\n      expect(screen.getByText(\"Violation Forecast\")).toBeInTheDocument();\n\n      // Should show loading message\n      expect(screen.getByText(\"Generating predictions...\")).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Successful API Integration\", () => {\n    it(\"displays forecast chart from /predictions endpoint\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      // Chart components should be rendered\n      expect(screen.getByTestId(\"composed-chart\")).toBeInTheDocument();\n    });\n\n    it(\"displays trend direction badge\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        // Mock data has trend_direction: \"stable\"\n        expect(screen.getByText(\"stable\")).toBeInTheDocument();\n      });\n    });\n\n    it(\"displays summary statistics\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Mean/Day\")).toBeInTheDocument();\n      });\n\n      // Check summary stat values\n      expect(screen.getByText(\"10.5\")).toBeInTheDocument(); // mean\n      expect(screen.getByText(\"13.2\")).toBeInTheDocument(); // max\n      expect(screen.getByText(\"7.8\")).toBeInTheDocument(); // min\n      expect(screen.getByText(\"315\")).toBeInTheDocument(); // total\n    });\n\n    it(\"displays forecast metadata in footer\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Forecast:/)).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"30 days\")).toBeInTheDocument();\n      expect(screen.getByText(/Training:/)).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Insufficient Data State\", () => {\n    it(\"shows insufficient data message when model not trained\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 7,\n            forecast_days: 0,\n            model_trained: false,\n            predictions: [],\n            summary: {\n              status: \"error\",\n              mean_predicted_violations: null,\n              max_predicted_violations: null,\n              min_predicted_violations: null,\n              total_predicted_violations: null,\n              trend_direction: null,\n              reason: \"Insufficient historical data\",\n            },\n            error_message:\n              \"Collect at least 2 weeks of governance events to enable violation forecasting.\",\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(\"Insufficient Data for Predictions\")\n        ).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByText(/Collect at least 2 weeks of governance events/)\n      ).toBeInTheDocument();\n      expect(\n        screen.getByText(/Current data: 7 days \\(minimum 14 required\\)/)\n      ).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Error Handling\", () => {\n    it(\"displays error message when API fails\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(/Insufficient data for predictions/)\n        ).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n    });\n\n    it(\"retries fetch when Try Again is clicked\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n      });\n\n      // Reset handlers\n      server.resetHandlers();\n\n      // Click retry\n      fireEvent.click(screen.getByText(\"Try Again\"));\n\n      await waitFor(\n        () => {\n          expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n        },\n        { timeout: 5000 }\n      );\n    });\n  });\n\n  describe(\"Refresh Functionality\", () => {\n    it(\"has a refresh button that reloads data\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      const refreshButton = screen.getByRole(\"button\", {\n        name: /refresh predictions/i,\n      });\n      expect(refreshButton).toBeInTheDocument();\n\n      fireEvent.click(refreshButton);\n\n      await waitFor(() => {\n        expect(refreshButton).toBeEnabled();\n      });\n    });\n  });\n\n  describe(\"Trend Direction Display\", () => {\n    it(\"shows increasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: 0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 15,\n              max_predicted_violations: 20,\n              min_predicted_violations: 10,\n              total_predicted_violations: 450,\n              trend_direction: \"increasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"increasing\")).toBeInTheDocument();\n      });\n\n      // The increasing badge should have red styling\n      const badge = screen.getByText(\"increasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-red-100\");\n    });\n\n    it(\"shows decreasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: -0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 8,\n              max_predicted_violations: 12,\n              min_predicted_violations: 5,\n              total_predicted_violations: 240,\n              trend_direction: \"decreasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"decreasing\")).toBeInTheDocument();\n      });\n\n      // The decreasing badge should have green styling\n      const badge = screen.getByText(\"decreasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-green-100\");\n    });\n  });\n\n  describe(\"Accessibility\", () => {\n    it(\"has accessible button labels\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByRole(\"button\", { name: /refresh predictions/i })\n      ).toBeInTheDocument();\n    });\n\n    it(\"has proper heading structure\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByRole(\"heading\", { level: 3 })).toHaveTextContent(\n          \"Violation Forecast\"\n        );\n      });\n    });\n  });\n});\n",
        "last_modified": "2026-01-03T19:10:12.021731"
      },
      "task_intent": {
        "title": "054-extract-duplicated-loadingstate-and-api-config-in-",
        "description": "The analytics-dashboard has 4 widget components (PredictionWidget, AnomalyWidget, InsightWidget, QueryInterface) that each independently define the same LoadingState type and API_BASE_URL constant. This pattern is repeated across 7+ files when including tests, leading to maintenance burden and potential inconsistencies.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "052-replace-recharts-with-lightweight-chart-library": {
      "task_id": "052-replace-recharts-with-lightweight-chart-library",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * PredictionWidget Component Tests\n *\n * Tests for the PredictionWidget component including:\n * - Initial loading state\n * - Displaying forecast chart and data\n * - Summary statistics display\n * - Trend direction indicators\n * - Insufficient data state\n * - Error handling and retry\n * - Integration with analytics-api /predictions endpoint\n */\n\nimport { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, waitFor, fireEvent } from \"@testing-library/react\";\nimport { http, HttpResponse } from \"msw\";\nimport { server } from \"../../../test/mocks/server\";\nimport { errorHandlers } from \"../../../test/mocks/handlers\";\nimport { PredictionWidget } from \"../PredictionWidget\";\nimport { API_BASE_URL } from \"../../../lib\";\n\n// Mock visx-based chart components to avoid rendering issues in tests\nvi.mock(\"../charts\", () => ({\n  ResponsiveChart: ({ children }: { children: (dimensions: { width: number; height: number }) => React.ReactNode }) => (\n    <div data-testid=\"responsive-container\">\n      {children({ width: 800, height: 400 })}\n    </div>\n  ),\n  ComposedChart: ({ children }: { children?: React.ReactNode }) => (\n    <div data-testid=\"composed-chart\">{children}</div>\n  ),\n}));\n\n// Mock visx dependencies to avoid SVG rendering issues in tests\nvi.mock(\"@visx/responsive\", () => ({\n  ParentSize: ({ children }: { children: (dimensions: { width: number; height: number }) => React.ReactNode }) => (\n    <div>{children({ width: 800, height: 400 })}</div>\n  ),\n}));\n\ndescribe(\"PredictionWidget\", () => {\n  describe(\"Loading State\", () => {\n    it(\"shows loading spinner on initial render\", async () => {\n      render(<PredictionWidget />);\n\n      // Should show Violation Forecast header\n      expect(screen.getByText(\"Violation Forecast\")).toBeInTheDocument();\n\n      // Should show loading message\n      expect(screen.getByText(\"Generating predictions...\")).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Successful API Integration\", () => {\n    it(\"displays forecast chart from /predictions endpoint\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      // Chart components should be rendered\n      expect(screen.getByTestId(\"composed-chart\")).toBeInTheDocument();\n    });\n\n    it(\"displays trend direction badge\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        // Mock data has trend_direction: \"stable\"\n        expect(screen.getByText(\"stable\")).toBeInTheDocument();\n      });\n    });\n\n    it(\"displays summary statistics\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Mean/Day\")).toBeInTheDocument();\n      });\n\n      // Check summary stat values\n      expect(screen.getByText(\"10.5\")).toBeInTheDocument(); // mean\n      expect(screen.getByText(\"13.2\")).toBeInTheDocument(); // max\n      expect(screen.getByText(\"7.8\")).toBeInTheDocument(); // min\n      expect(screen.getByText(\"315\")).toBeInTheDocument(); // total\n    });\n\n    it(\"displays forecast metadata in footer\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Forecast:/)).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"30 days\")).toBeInTheDocument();\n      expect(screen.getByText(/Training:/)).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Insufficient Data State\", () => {\n    it(\"shows insufficient data message when model not trained\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 7,\n            forecast_days: 0,\n            model_trained: false,\n            predictions: [],\n            summary: {\n              status: \"error\",\n              mean_predicted_violations: null,\n              max_predicted_violations: null,\n              min_predicted_violations: null,\n              total_predicted_violations: null,\n              trend_direction: null,\n              reason: \"Insufficient historical data\",\n            },\n            error_message:\n              \"Collect at least 2 weeks of governance events to enable violation forecasting.\",\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(\"Insufficient Data for Predictions\")\n        ).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByText(/Collect at least 2 weeks of governance events/)\n      ).toBeInTheDocument();\n      expect(\n        screen.getByText(/Current data: 7 days \\(minimum 14 required\\)/)\n      ).toBeInTheDocument();\n    });\n  });\n\n  describe(\"Error Handling\", () => {\n    it(\"displays error message when API fails\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(\n          screen.getByText(/Insufficient data for predictions/)\n        ).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n    });\n\n    it(\"retries fetch when Try Again is clicked\", async () => {\n      server.use(errorHandlers.predictionsError);\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"Try Again\")).toBeInTheDocument();\n      });\n\n      // Reset handlers\n      server.resetHandlers();\n\n      // Click retry\n      fireEvent.click(screen.getByText(\"Try Again\"));\n\n      await waitFor(\n        () => {\n          expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n        },\n        { timeout: 5000 }\n      );\n    });\n  });\n\n  describe(\"Refresh Functionality\", () => {\n    it(\"has a refresh button that reloads data\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      const refreshButton = screen.getByRole(\"button\", {\n        name: /refresh predictions/i,\n      });\n      expect(refreshButton).toBeInTheDocument();\n\n      fireEvent.click(refreshButton);\n\n      await waitFor(() => {\n        expect(refreshButton).toBeEnabled();\n      });\n    });\n  });\n\n  describe(\"Trend Direction Display\", () => {\n    it(\"shows increasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: 0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 15,\n              max_predicted_violations: 20,\n              min_predicted_violations: 10,\n              total_predicted_violations: 450,\n              trend_direction: \"increasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"increasing\")).toBeInTheDocument();\n      });\n\n      // The increasing badge should have red styling\n      const badge = screen.getByText(\"increasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-red-100\");\n    });\n\n    it(\"shows decreasing trend with appropriate styling\", async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/predictions`, () => {\n          return HttpResponse.json({\n            forecast_timestamp: new Date().toISOString(),\n            historical_days: 30,\n            forecast_days: 30,\n            model_trained: true,\n            predictions: [\n              {\n                date: \"2026-01-01\",\n                predicted_value: 10,\n                lower_bound: 8,\n                upper_bound: 12,\n                trend: -0.1,\n              },\n            ],\n            summary: {\n              status: \"success\",\n              mean_predicted_violations: 8,\n              max_predicted_violations: 12,\n              min_predicted_violations: 5,\n              total_predicted_violations: 240,\n              trend_direction: \"decreasing\",\n              reason: null,\n            },\n            error_message: null,\n          });\n        })\n      );\n\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByText(\"decreasing\")).toBeInTheDocument();\n      });\n\n      // The decreasing badge should have green styling\n      const badge = screen.getByText(\"decreasing\").closest(\"span\");\n      expect(badge).toHaveClass(\"bg-green-100\");\n    });\n  });\n\n  describe(\"Accessibility\", () => {\n    it(\"has accessible button labels\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId(\"responsive-container\")).toBeInTheDocument();\n      });\n\n      expect(\n        screen.getByRole(\"button\", { name: /refresh predictions/i })\n      ).toBeInTheDocument();\n    });\n\n    it(\"has proper heading structure\", async () => {\n      render(<PredictionWidget />);\n\n      await waitFor(() => {\n        expect(screen.getByRole(\"heading\", { level: 3 })).toHaveTextContent(\n          \"Violation Forecast\"\n        );\n      });\n    });\n  });\n});\n",
        "timestamp": "2026-01-04T05:36:13.611399"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "052-replace-recharts-with-lightweight-chart-library",
        "description": "Replace recharts (~500KB unparsed, ~150KB gzipped) with a lightweight charting library like visx (~40KB) or uPlot (~30KB) to reduce bundle size and improve dashboard performance. Used in PredictionWidget (analytics-dashboard) and MetricsChart (observability dashboard).",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T18:35:24.596261",
  "last_updated": "2026-01-04T05:36:13.614154"
}