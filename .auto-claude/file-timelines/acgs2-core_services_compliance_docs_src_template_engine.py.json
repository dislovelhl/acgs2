{
  "file_path": "src/core/services/compliance_docs/src/template_engine.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nACGS-2 Compliance Documentation Template Engine\n\nConfigures Jinja2 template engine with security-focused autoescaping\nand performance optimization for enterprise compliance documentation.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom functools import lru_cache\nfrom os import getenv\nfrom pathlib import Path\nfrom typing import Any, Optional\n\nfrom jinja2 import (\n    Environment,\n    FileSystemLoader,\n    TemplateNotFound,\n    select_autoescape,\n)\n\n# Default templates path relative to service directory\n_DEFAULT_TEMPLATES_PATH = Path(__file__).parent / \"templates\"\n\n\ndef _get_templates_path() -> Path:\n    \"\"\"\n    Resolve templates path from environment or use default.\n\n    Returns:\n        Path to templates directory.\n    \"\"\"\n    templates_path = getenv(\"COMPLIANCE_TEMPLATES_PATH\")\n    if templates_path:\n        return Path(templates_path)\n    return _DEFAULT_TEMPLATES_PATH\n\n\ndef _format_date(value: datetime, format_str: str = \"%Y-%m-%d\") -> str:\n    \"\"\"\n    Format a datetime object to string.\n\n    Args:\n        value: The datetime to format.\n        format_str: strftime format string.\n\n    Returns:\n        Formatted date string.\n    \"\"\"\n    if value is None:\n        return \"N/A\"\n    if isinstance(value, str):\n        return value\n    return value.strftime(format_str)\n\n\ndef _format_datetime(value: datetime, format_str: str = \"%Y-%m-%d %H:%M:%S UTC\") -> str:\n    \"\"\"\n    Format a datetime object with time to string.\n\n    Args:\n        value: The datetime to format.\n        format_str: strftime format string.\n\n    Returns:\n        Formatted datetime string.\n    \"\"\"\n    if value is None:\n        return \"N/A\"\n    if isinstance(value, str):\n        return value\n    return value.strftime(format_str)\n\n\ndef _default_value(value: Any, default: str = \"N/A\") -> str:\n    \"\"\"\n    Return a default value if the input is None or empty.\n\n    This filter ensures graceful handling of missing compliance data.\n\n    Args:\n        value: The value to check.\n        default: The default string to return if value is None/empty.\n\n    Returns:\n        The value or default string.\n    \"\"\"\n    if value is None or value == \"\":\n        return default\n    return str(value)\n\n\ndef _status_badge(status: str) -> str:\n    \"\"\"\n    Convert status to a display badge format.\n\n    Args:\n        status: The status string (e.g., 'compliant', 'non_compliant', 'pending').\n\n    Returns:\n        HTML-safe badge representation.\n    \"\"\"\n    status_map = {\n        \"compliant\": \"[COMPLIANT]\",\n        \"non_compliant\": \"[NON-COMPLIANT]\",\n        \"not_compliant\": \"[NON-COMPLIANT]\",\n        \"pending\": \"[PENDING]\",\n        \"in_progress\": \"[IN PROGRESS]\",\n        \"not_applicable\": \"[N/A]\",\n        \"partial\": \"[PARTIAL]\",\n    }\n    normalized = str(status).lower().replace(\"-\", \"_\").replace(\" \", \"_\")\n    return status_map.get(normalized, f\"[{str(status).upper()}]\")\n\n\ndef _control_id_format(control_id: str, framework: str = \"\") -> str:\n    \"\"\"\n    Format control ID for consistent display.\n\n    Args:\n        control_id: The raw control ID.\n        framework: Optional framework prefix.\n\n    Returns:\n        Formatted control ID string.\n    \"\"\"\n    if not control_id:\n        return \"N/A\"\n    if framework:\n        return f\"{framework.upper()}-{control_id}\"\n    return str(control_id)\n\n\ndef _pluralize(count: int, singular: str, plural: Optional[str] = None) -> str:\n    \"\"\"\n    Return singular or plural form based on count.\n\n    Args:\n        count: The count to check.\n        singular: Singular form of the word.\n        plural: Plural form (defaults to singular + 's').\n\n    Returns:\n        Appropriate form of the word with count.\n    \"\"\"\n    if plural is None:\n        plural = singular + \"s\"\n    word = singular if count == 1 else plural\n    return f\"{count} {word}\"\n\n\ndef _now_utc() -> datetime:\n    \"\"\"\n    Return current UTC datetime.\n\n    Returns:\n        Current datetime in UTC.\n    \"\"\"\n    return datetime.now(timezone.utc)\n\n\ndef _current_year() -> int:\n    \"\"\"\n    Return current year.\n\n    Returns:\n        Current year as integer.\n    \"\"\"\n    return datetime.now(timezone.utc).year\n\n\ndef _create_environment(templates_path: Path) -> Environment:\n    \"\"\"\n    Create and configure a Jinja2 Environment.\n\n    Args:\n        templates_path: Path to templates directory.\n\n    Returns:\n        Configured Jinja2 Environment with autoescaping and custom filters.\n    \"\"\"\n    env = Environment(\n        loader=FileSystemLoader(str(templates_path)),\n        autoescape=select_autoescape(\n            enabled_extensions=[\"html\", \"htm\", \"xml\", \"xhtml\"],\n            default_for_string=True,\n            default=True,\n        ),\n        # Performance: Enable bytecode caching\n        auto_reload=True,  # Development: reload templates on change\n        trim_blocks=True,\n        lstrip_blocks=True,\n        keep_trailing_newline=True,\n    )\n\n    # Register custom filters\n    env.filters[\"format_date\"] = _format_date\n    env.filters[\"format_datetime\"] = _format_datetime\n    env.filters[\"default_value\"] = _default_value\n    env.filters[\"status_badge\"] = _status_badge\n    env.filters[\"control_id\"] = _control_id_format\n    env.filters[\"pluralize\"] = _pluralize\n\n    # Register global functions/variables\n    env.globals[\"now_utc\"] = _now_utc\n    env.globals[\"current_year\"] = _current_year\n\n    return env\n\n\n@lru_cache(maxsize=1)\ndef get_template_env() -> Environment:\n    \"\"\"\n    Get or create the cached Jinja2 template environment.\n\n    This function is cached to ensure a single Environment instance\n    is reused across the application for optimal performance.\n\n    Returns:\n        Configured Jinja2 Environment with autoescaping enabled.\n\n    Example:\n        >>> env = get_template_env()\n        >>> template = env.get_template(\"soc2/control_mapping.html.j2\")\n        >>> html = template.render(controls=controls_data)\n    \"\"\"\n    templates_path = _get_templates_path()\n\n    # Ensure templates directory exists\n    if not templates_path.exists():\n        templates_path.mkdir(parents=True, exist_ok=True)\n\n    return _create_environment(templates_path)\n\n\ndef render_template(\n    template_name: str,\n    context: dict[str, Any],\n    framework: Optional[str] = None,\n) -> str:\n    \"\"\"\n    Render a compliance template with the given context.\n\n    Args:\n        template_name: Name of the template file (e.g., 'control_mapping.html.j2').\n        context: Dictionary of variables to pass to the template.\n        framework: Optional framework subdirectory (e.g., 'soc2', 'iso27001').\n\n    Returns:\n        Rendered template as string.\n\n    Raises:\n        TemplateNotFound: If the template does not exist.\n\n    Example:\n        >>> html = render_template(\n        ...     \"control_mapping.html.j2\",\n        ...     {\"controls\": controls},\n        ...     framework=\"soc2\"\n        ... )\n    \"\"\"\n    env = get_template_env()\n\n    # Build full template path\n    if framework:\n        full_template_name = f\"{framework}/{template_name}\"\n    else:\n        full_template_name = template_name\n\n    template = env.get_template(full_template_name)\n\n    # Add framework to context if provided\n    render_context = dict(context)\n    if framework:\n        render_context.setdefault(\"framework\", framework)\n\n    # Add generation metadata\n    render_context.setdefault(\"generated_at\", _now_utc())\n    render_context.setdefault(\"generator_version\", \"1.0.0\")\n\n    return template.render(**render_context)\n\n\ndef template_exists(template_name: str, framework: Optional[str] = None) -> bool:\n    \"\"\"\n    Check if a template exists.\n\n    Args:\n        template_name: Name of the template file.\n        framework: Optional framework subdirectory.\n\n    Returns:\n        True if template exists, False otherwise.\n    \"\"\"\n    env = get_template_env()\n\n    if framework:\n        full_template_name = f\"{framework}/{template_name}\"\n    else:\n        full_template_name = template_name\n\n    try:\n        env.get_template(full_template_name)\n        return True\n    except TemplateNotFound:\n        return False\n\n\ndef list_templates(framework: Optional[str] = None) -> list[str]:\n    \"\"\"\n    List available templates, optionally filtered by framework.\n\n    Args:\n        framework: Optional framework to filter by (e.g., 'soc2', 'iso27001').\n\n    Returns:\n        List of template names.\n    \"\"\"\n    env = get_template_env()\n    all_templates = env.loader.list_templates()\n\n    if framework:\n        prefix = f\"{framework}/\"\n        return [t for t in all_templates if t.startswith(prefix)]\n\n    return all_templates\n\n\ndef clear_template_cache() -> None:\n    \"\"\"\n    Clear the template environment cache.\n\n    This is useful for testing or when templates are updated at runtime.\n    \"\"\"\n    get_template_env.cache_clear()\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.106251",
  "last_updated": "2026-01-04T05:35:58.383550"
}