{
  "file_path": "src/core/enhanced_agent_bus/validation_strategies.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Enhanced Agent Bus - Validation Strategies\nConstitutional Hash: cdd01ef066bc6cf2\n\nValidation strategy implementations for message validation.\n\"\"\"\n\nimport base64\nimport hashlib\nimport logging\nfrom typing import Any, Optional\n\ntry:\n    from .imports import OPA_CLIENT_AVAILABLE, get_opa_client\n    from .models import AgentMessage\nexcept (ImportError, ValueError):\n    from models import AgentMessage  # type: ignore\n\ntry:\n    from .models import CONSTITUTIONAL_HASH, AgentMessage\nexcept ImportError:\n    from models import CONSTITUTIONAL_HASH, AgentMessage  # type: ignore\n\n# PQC imports (lazy loaded for optional dependency)\ntry:\n    from quantum_research.post_quantum_crypto import (\n        PQCAlgorithm,\n        PQCSignature,\n        ConstitutionalHashValidator,\n    )\n    PQC_AVAILABLE = True\nexcept ImportError:\n    PQC_AVAILABLE = False\n    PQCAlgorithm = None  # type: ignore\n    PQCSignature = None  # type: ignore\n    ConstitutionalHashValidator = None  # type: ignore\n\nlogger = logging.getLogger(__name__)\n\n\nclass StaticHashValidationStrategy:\n    \"\"\"Validates messages using a static constitutional hash.\n\n    Standard implementation that checks for hash consistency.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, strict: bool = True) -> None:\n        \"\"\"Initialize static hash validation.\n\n        Args:\n            strict: If True, reject messages with non-matching hashes\n        \"\"\"\n        self._constitutional_hash = CONSTITUTIONAL_HASH\n        self._strict = strict\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"Validate a message for constitutional compliance.\"\"\"\n        # Check message has content\n        if message.content is None:\n            return False, \"Message content cannot be None\"\n\n        # Validate message_id exists\n        if not message.message_id:\n            return False, \"Message ID is required\"\n\n        # Validate constitutional hash if strict mode\n        if self._strict:\n            if message.constitutional_hash != self._constitutional_hash:\n                return False, f\"Constitutional hash mismatch: expected {self._constitutional_hash}\"\n\n        return True, None\n\n\nclass DynamicPolicyValidationStrategy:\n    \"\"\"Validates messages using a dynamic policy client.\n\n    Retrieves current policies and validates signatures.\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, policy_client: Any) -> None:\n        \"\"\"Initialize with logic client.\"\"\"\n        self._policy_client = policy_client\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"Validate message signature against dynamic policy server.\"\"\"\n        if not self._policy_client:\n            return False, \"Policy client not available\"\n\n        try:\n            result = await self._policy_client.validate_message_signature(message)\n            if not result.is_valid:\n                return False, \"; \".join(result.errors)\n            return True, None\n        except Exception as e:\n            logger.error(f\"Dynamic policy validation error: {e}\")\n            return False, f\"Dynamic validation error: {str(e)}\"\n\n\nclass OPAValidationStrategy:\n    \"\"\"Validates messages using OPA (Open Policy Agent).\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, opa_client: Any) -> None:\n        \"\"\"Initialize with OPA client.\"\"\"\n        self._opa_client = opa_client\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"Validate message against OPA constitutional policies.\"\"\"\n        if not self._opa_client:\n            return False, \"OPA client not available\"\n\n        try:\n            # Evaluate constitutional policies\n            result = await self._opa_client.validate_constitutional(message.to_dict())\n            if not result.is_valid:\n                return False, \"; \".join(result.errors)\n            return True, None\n        except Exception as e:\n            logger.error(f\"OPA validation execution error: {e}\")\n            return False, f\"OPA validation error: {str(e)}\"\n\n\nclass RustValidationStrategy:\n    \"\"\"High-performance validation using the Rust backend.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n\n    SECURITY: This strategy implements fail-closed behavior by default.\n    Validation only returns True when the Rust backend explicitly confirms\n    the message is valid. Any error or unavailability results in rejection.\n    \"\"\"\n\n    def __init__(self, rust_processor: Any, fail_closed: bool = True) -> None:\n        \"\"\"Initialize with Rust processor.\n\n        Args:\n            rust_processor: The Rust processor instance for validation\n            fail_closed: If True, reject on any validation uncertainty (default: True)\n        \"\"\"\n        self._rust_processor = rust_processor\n        self._fail_closed = fail_closed\n        self._constitutional_hash = CONSTITUTIONAL_HASH\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"Validate message using Rust backend.\n\n        SECURITY: Implements fail-closed validation. Only returns True when\n        the Rust backend explicitly confirms validation success.\n        \"\"\"\n        if not self._rust_processor:\n            return False, \"Rust processor not available\"\n\n        try:\n            # Attempt to use Rust processor's validation method\n            # Check for validate_message method (preferred)\n            if hasattr(self._rust_processor, \"validate_message\"):\n                result = await self._rust_processor.validate_message(message.to_dict())\n                if isinstance(result, bool):\n                    if result:\n                        return True, None\n                    return False, \"Rust validation rejected message\"\n                elif isinstance(result, dict):\n                    is_valid = result.get(\"is_valid\", False)\n                    if is_valid:\n                        return True, None\n                    error = result.get(\"error\", \"Rust validation failed\")\n                    return False, error\n\n            # Check for synchronous validate method\n            if hasattr(self._rust_processor, \"validate\"):\n                result = self._rust_processor.validate(message.to_dict())\n                if isinstance(result, bool):\n                    if result:\n                        return True, None\n                    return False, \"Rust validation rejected message\"\n                elif isinstance(result, dict):\n                    is_valid = result.get(\"is_valid\", False)\n                    if is_valid:\n                        return True, None\n                    error = result.get(\"error\", \"Rust validation failed\")\n                    return False, error\n\n            # Check for constitutional_validate method\n            if hasattr(self._rust_processor, \"constitutional_validate\"):\n                result = self._rust_processor.constitutional_validate(\n                    message.constitutional_hash, self._constitutional_hash\n                )\n                if result:\n                    return True, None\n                return False, \"Constitutional hash validation failed in Rust backend\"\n\n            # SECURITY: No validation method available - fail closed\n            logger.warning(\n                \"RustValidationStrategy: No validation method found on Rust processor. \"\n                \"Failing closed for security.\"\n            )\n            return False, \"Rust processor has no validation method - fail closed\"\n\n        except Exception as e:\n            logger.error(f\"Rust validation execution error: {e}\")\n            # SECURITY: Always fail closed on exceptions\n            return False, f\"Rust validation error: {str(e)}\"\n\n\nclass PQCValidationStrategy:\n    \"\"\"\n    Post-Quantum Cryptographic Validation Strategy.\n\n    Validates messages using NIST-approved post-quantum algorithms\n    (CRYSTALS-Kyber and CRYSTALS-Dilithium) for quantum-resistant\n    constitutional hash validation.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, validator: Any = None, hybrid_mode: bool = True) -> None:\n        \"\"\"\n        Initialize PQC validation strategy.\n\n        Args:\n            validator: ConstitutionalHashValidator instance\n            hybrid_mode: Allow fallback to static hash if PQC fails\n        \"\"\"\n        self._hybrid_mode = hybrid_mode\n        self._constitutional_hash = CONSTITUTIONAL_HASH\n\n        # Initialize PQC validator\n        if validator is not None:\n            self._validator = validator\n        else:\n            # Lazy import to avoid circular dependencies\n            try:\n                from quantum_research.post_quantum_crypto import (\n                    ConstitutionalHashValidator,\n                    PQCSignature,\n                    PQCAlgorithm,\n                )\n                self._validator = ConstitutionalHashValidator()\n                self._PQCSignature = PQCSignature\n                self._PQCAlgorithm = PQCAlgorithm\n            except ImportError:\n                logger.warning(\"Post-quantum crypto not available, PQC validation disabled\")\n                self._validator = None\n                self._PQCSignature = None\n                self._PQCAlgorithm = None\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"\n        Validate message using post-quantum cryptography.\n\n        Algorithm:\n        1. Check if message has PQC signature\n        2. If PQC signature present, validate it\n        3. If no PQC signature and hybrid mode enabled, fall back to static hash\n        4. If no PQC signature and hybrid mode disabled, reject\n\n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        # If PQC validator is not available, fall back to static hash in hybrid mode\n        if not self._validator:\n            if self._hybrid_mode:\n                # Fall back to static hash validation when PQC is unavailable\n                if message.constitutional_hash != self._constitutional_hash:\n                    return False, f\"Constitutional hash mismatch: expected {self._constitutional_hash}\"\n                return True, None\n            return False, \"PQC validator not available\"\n\n        # Check if message has PQC signature\n        if not message.pqc_signature:\n            if self._hybrid_mode:\n                # Fall back to static hash validation\n                if message.constitutional_hash != self._constitutional_hash:\n                    return False, f\"Constitutional hash mismatch: expected {self._constitutional_hash}\"\n                return True, None\n            else:\n                return False, \"PQC signature required but not provided\"\n\n        # Validate PQC signature\n        try:\n            # Convert base64 signature and public key back to bytes for validation\n            import base64\n\n            signature_bytes = base64.b64decode(message.pqc_signature)\n\n            # Create decision dict for validation\n            decision = {\n                \"message_id\": message.message_id,\n                \"content\": message.content,\n                \"from_agent\": message.from_agent,\n                \"tenant_id\": message.tenant_id,\n                \"timestamp\": message.created_at.isoformat(),\n                \"constitutional_hash\": message.constitutional_hash,\n            }\n\n            # Parse public key (expecting base64 encoded bytes)\n            if not message.pqc_public_key:\n                return False, \"PQC public key is required for signature verification\"\n\n            try:\n                public_key_bytes = base64.b64decode(message.pqc_public_key)\n            except Exception as e:\n                # Try hex decoding as fallback\n                try:\n                    public_key_bytes = bytes.fromhex(message.pqc_public_key)\n                except Exception:\n                    return False, f\"Invalid PQC public key format: {str(e)}\"\n\n            # Create PQCSignature object for validation\n            if self._PQCSignature is None or self._PQCAlgorithm is None:\n                return False, \"PQC classes not available\"\n\n            signature_obj = self._PQCSignature(\n                algorithm=self._PQCAlgorithm.DILITHIUM_3,\n                signature=signature_bytes,\n                message_hash=hashlib.sha3_256(str(decision).encode()).digest(),\n                signer_key_id=f\"pqc-{message.message_id[:16]}\",\n            )\n\n            # Validate the signature\n            is_valid = self._validator.verify_governance_decision(\n                decision=decision,\n                signature=signature_obj,\n                public_key=public_key_bytes\n            )\n\n            if is_valid:\n                return True, None\n            else:\n                return False, \"PQC signature verification failed\"\n\n        except Exception as e:\n            logger.error(f\"PQC validation error: {e}\")\n            if self._hybrid_mode:\n                # Fall back to static hash in case of PQC errors\n                if message.constitutional_hash == self._constitutional_hash:\n                    return True, None\n            return False, f\"PQC validation error: {str(e)}\"\n\n\nclass CompositeValidationStrategy:\n    \"\"\"\n    Combines multiple validation strategies with intelligent orchestration.\n\n    Features:\n    - Runs all strategies and aggregates results\n    - Prioritizes PQC validation when available\n    - Falls back gracefully on validation failures\n    - Supports hybrid classical/PQC modes\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, strategies: Optional[list] = None, enable_pqc: bool = True) -> None:\n        \"\"\"\n        Initialize with list of validation strategies.\n\n        Args:\n            strategies: List of validation strategies to use\n            enable_pqc: Whether to automatically include PQC validation\n        \"\"\"\n        self._strategies: list = strategies or []\n        self._constitutional_hash = CONSTITUTIONAL_HASH\n        self._enable_pqc = enable_pqc\n\n        # Auto-include PQC validation if enabled and not already present\n        if enable_pqc and not any(isinstance(s, PQCValidationStrategy) for s in self._strategies):\n            try:\n                pqc_strategy = PQCValidationStrategy(hybrid_mode=True)\n                self._strategies.append(pqc_strategy)\n                logger.info(\"PQC validation strategy auto-enabled in composite validation\")\n            except Exception as e:\n                logger.warning(f\"Failed to initialize PQC validation strategy: {e}\")\n\n    def add_strategy(self, strategy: Any) -> None:\n        \"\"\"Add a validation strategy.\"\"\"\n        self._strategies.append(strategy)\n\n    async def validate(self, message: AgentMessage) -> tuple[bool, Optional[str]]:\n        \"\"\"\n        Run all validation strategies with intelligent orchestration.\n\n        Algorithm:\n        1. If PQC signature present, prioritize PQC validation\n        2. Run all strategies and collect results\n        3. Require ALL strategies to pass (fail-closed security)\n        4. Aggregate error messages for debugging\n\n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        errors = []\n        pqc_validated = False\n\n        # Prioritize PQC validation if signature is present\n        for strategy in self._strategies:\n            if isinstance(strategy, PQCValidationStrategy) and message.pqc_signature:\n                is_valid, error = await strategy.validate(message)\n                if not is_valid:\n                    errors.append(f\"PQC: {error}\")\n                else:\n                    pqc_validated = True\n                continue\n\n        # Run remaining strategies\n        for strategy in self._strategies:\n            if isinstance(strategy, PQCValidationStrategy) and message.pqc_signature:\n                continue  # Already handled above\n\n            is_valid, error = await strategy.validate(message)\n            if not is_valid and error:\n                strategy_name = strategy.__class__.__name__.replace(\"ValidationStrategy\", \"\")\n                errors.append(f\"{strategy_name}: {error}\")\n\n        if errors:\n            return False, \"; \".join(errors)\n\n        return True, None\n\n\n__all__ = [\n    \"StaticHashValidationStrategy\",\n    \"DynamicPolicyValidationStrategy\",\n    \"OPAValidationStrategy\",\n    \"RustValidationStrategy\",\n    \"PQCValidationStrategy\",\n    \"CompositeValidationStrategy\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.177419",
  "last_updated": "2026-01-04T05:35:58.507968"
}