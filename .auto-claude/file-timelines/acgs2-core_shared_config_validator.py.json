{
  "file_path": "src/core/shared/config_validator.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "import logging\n\nlogger = logging.getLogger(__name__)\n\"\"\"\nACGS-2 Configuration Validator\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides comprehensive configuration validation for:\n- Environment detection\n- Required variable validation\n- Configuration schema enforcement\n- Cross-environment drift detection\n\"\"\"\n\nimport os\nimport sys\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Set\n\n# Constitutional compliance constant\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\nclass Environment(Enum):\n    \"\"\"Supported deployment environments.\"\"\"\n\n    DEVELOPMENT = \"development\"\n    STAGING = \"staging\"\n    PRODUCTION = \"production\"\n    CI = \"ci\"\n    TEST = \"test\"\n\n\nclass ValidationSeverity(Enum):\n    \"\"\"Severity levels for validation issues.\"\"\"\n\n    ERROR = \"error\"  # Must be fixed\n    WARNING = \"warning\"  # Should be addressed\n    INFO = \"info\"  # Informational\n\n\n@dataclass\nclass ValidationIssue:\n    \"\"\"Represents a configuration validation issue.\"\"\"\n\n    severity: ValidationSeverity\n    category: str\n    message: str\n    fix_suggestion: Optional[str] = None\n    key: Optional[str] = None\n\n\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of configuration validation.\"\"\"\n\n    is_valid: bool\n    environment: Environment\n    issues: List[ValidationIssue] = field(default_factory=list)\n    config_summary: Dict[str, Any] = field(default_factory=dict)\n\n    def add_issue(\n        self,\n        severity: ValidationSeverity,\n        category: str,\n        message: str,\n        fix_suggestion: Optional[str] = None,\n        key: Optional[str] = None,\n    ):\n        \"\"\"Add a validation issue.\"\"\"\n        self.issues.append(\n            ValidationIssue(\n                severity=severity,\n                category=category,\n                message=message,\n                fix_suggestion=fix_suggestion,\n                key=key,\n            )\n        )\n        if severity == ValidationSeverity.ERROR:\n            self.is_valid = False\n\n    @property\n    def errors(self) -> List[ValidationIssue]:\n        \"\"\"Get all errors.\"\"\"\n        return [i for i in self.issues if i.severity == ValidationSeverity.ERROR]\n\n    @property\n    def warnings(self) -> List[ValidationIssue]:\n        \"\"\"Get all warnings.\"\"\"\n        return [i for i in self.issues if i.severity == ValidationSeverity.WARNING]\n\n    def print_report(self, verbose: bool = False):\n        \"\"\"Print a human-readable validation report.\"\"\"\n        logging.info(\"\\n\" + \"=\" * 60)\n        logging.info(\"ACGS-2 Configuration Validation Report\")\n        logging.info(f\"Constitutional Hash: {CONSTITUTIONAL_HASH}\")\n        logging.info(\"=\" * 60)\n        logging.info(f\"\\nEnvironment: {self.environment.value}\")\n        logging.info(f\"Status: {'\u2713 VALID' if self.is_valid else '\u2717 INVALID'}\")\n\n        if self.errors:\n            logging.error(f\"\\n\u274c Errors ({len(self.errors)}):\")\n            for issue in self.errors:\n                logging.info(f\"   \u2022 [{issue.category}] {issue.message}\")\n                if issue.fix_suggestion:\n                    logging.info(f\"     \ud83d\udca1 Fix: {issue.fix_suggestion}\")\n\n        if self.warnings:\n            logging.warning(f\"\\n\u26a0\ufe0f  Warnings ({len(self.warnings)}):\")\n            for issue in self.warnings:\n                logging.info(f\"   \u2022 [{issue.category}] {issue.message}\")\n                if verbose and issue.fix_suggestion:\n                    logging.info(f\"     \ud83d\udca1 Fix: {issue.fix_suggestion}\")\n\n        if verbose:\n            info_issues = [i for i in self.issues if i.severity == ValidationSeverity.INFO]\n            if info_issues:\n                logging.info(f\"\\n\u2139\ufe0f  Info ({len(info_issues)}):\")\n                for issue in info_issues:\n                    logging.info(f\"   \u2022 [{issue.category}] {issue.message}\")\n\n        logging.info(\"\\n\" + \"=\" * 60)\n\n\nclass ConfigValidator:\n    \"\"\"\n    Validates ACGS-2 configuration across environments.\n\n    Usage:\n        validator = ConfigValidator()\n        result = validator.validate()\n        if not result.is_valid:\n            result.print_report()\n            sys.exit(1)\n    \"\"\"\n\n    # Required variables by environment\n    REQUIRED_VARS: Dict[Environment, Set[str]] = {\n        Environment.DEVELOPMENT: {\n            \"REDIS_URL\",\n        },\n        Environment.STAGING: {\n            \"REDIS_URL\",\n            \"OPA_URL\",\n            \"KAFKA_BOOTSTRAP_SERVERS\",\n        },\n        Environment.PRODUCTION: {\n            \"REDIS_URL\",\n            \"REDIS_PASSWORD\",\n            \"OPA_URL\",\n            \"KAFKA_BOOTSTRAP_SERVERS\",\n            \"KAFKA_PASSWORD\",\n            \"JWT_SECRET\",\n            \"API_KEY_INTERNAL\",\n        },\n        Environment.CI: {\n            \"REDIS_URL\",\n        },\n        Environment.TEST: set(),  # No required vars for test\n    }\n\n    # Security-sensitive variables that should never have default values in production\n    SENSITIVE_VARS = {\n        \"JWT_SECRET\",\n        \"API_KEY_INTERNAL\",\n        \"BLOCKCHAIN_PRIVATE_KEY\",\n        \"GITHUB_WEBHOOK_SECRET\",\n        \"REDIS_PASSWORD\",\n        \"KAFKA_PASSWORD\",\n    }\n\n    # Forbidden placeholder values\n    FORBIDDEN_PLACEHOLDERS = {\n        \"PLACEHOLDER\",\n        \"CHANGE_ME\",\n        \"DANGEROUS_DEFAULT\",\n        \"TODO\",\n        \"FIXME\",\n        \"xxx\",\n        \"password\",\n        \"secret\",\n    }\n\n    def __init__(self, project_root: Optional[Path] = None):\n        \"\"\"Initialize validator.\"\"\"\n        self.project_root = project_root or Path.cwd()\n        while self.project_root != self.project_root.parent:\n            if (self.project_root / \"src/core\").exists():\n                break\n            self.project_root = self.project_root.parent\n\n    def detect_environment(self) -> Environment:\n        \"\"\"Detect the current environment.\"\"\"\n        # Check explicit environment variable\n        env_value = os.getenv(\"ACGS_ENV\", os.getenv(\"APP_ENV\", \"\")).lower()\n\n        # Map to Environment enum\n        env_map = {\n            \"production\": Environment.PRODUCTION,\n            \"prod\": Environment.PRODUCTION,\n            \"staging\": Environment.STAGING,\n            \"stage\": Environment.STAGING,\n            \"development\": Environment.DEVELOPMENT,\n            \"dev\": Environment.DEVELOPMENT,\n            \"ci\": Environment.CI,\n            \"test\": Environment.TEST,\n            \"testing\": Environment.TEST,\n        }\n\n        if env_value in env_map:\n            return env_map[env_value]\n\n        # Check CI indicators\n        if os.getenv(\"CI\") or os.getenv(\"GITHUB_ACTIONS\") or os.getenv(\"GITLAB_CI\"):\n            return Environment.CI\n\n        # Check for environment-specific files\n        if (self.project_root / \".env.production\").exists():\n            return Environment.PRODUCTION\n        if (self.project_root / \".env.staging\").exists():\n            return Environment.STAGING\n\n        # Default to development\n        return Environment.DEVELOPMENT\n\n    def validate(self, env: Optional[Environment] = None) -> ValidationResult:\n        \"\"\"Run full configuration validation.\"\"\"\n        detected_env = env or self.detect_environment()\n        result = ValidationResult(is_valid=True, environment=detected_env)\n\n        # Run all validations\n        self._validate_required_vars(result)\n        self._validate_sensitive_vars(result)\n        self._validate_constitutional_hash(result)\n        self._validate_env_files(result)\n        self._validate_docker_config(result)\n        self._validate_service_urls(result)\n\n        return result\n\n    def _validate_required_vars(self, result: ValidationResult):\n        \"\"\"Check that all required variables are set.\"\"\"\n        required = self.REQUIRED_VARS.get(result.environment, set())\n\n        for var in required:\n            value = os.getenv(var)\n            if not value:\n                result.add_issue(\n                    severity=ValidationSeverity.ERROR,\n                    category=\"required\",\n                    message=f\"Required variable '{var}' is not set\",\n                    fix_suggestion=f\"Set {var} in your .env file or environment\",\n                    key=var,\n                )\n            else:\n                result.config_summary[var] = \"***\" if var in self.SENSITIVE_VARS else value\n\n    def _validate_sensitive_vars(self, result: ValidationResult):\n        \"\"\"Check sensitive variables for weak values.\"\"\"\n        for var in self.SENSITIVE_VARS:\n            value = os.getenv(var, \"\")\n            if not value:\n                continue  # Already handled by required check\n\n            # Check for forbidden placeholders\n            value_lower = value.lower()\n            for placeholder in self.FORBIDDEN_PLACEHOLDERS:\n                if placeholder in value_lower:\n                    severity = (\n                        ValidationSeverity.ERROR\n                        if result.environment == Environment.PRODUCTION\n                        else ValidationSeverity.WARNING\n                    )\n                    result.add_issue(\n                        severity=severity,\n                        category=\"security\",\n                        message=f\"Variable '{var}' contains a forbidden placeholder value\",\n                        fix_suggestion=\"Replace with a secure, randomly generated value\",\n                        key=var,\n                    )\n                    break\n\n            # Check minimum length for secrets\n            if var in {\"JWT_SECRET\", \"API_KEY_INTERNAL\"} and len(value) < 32:\n                result.add_issue(\n                    severity=ValidationSeverity.WARNING,\n                    category=\"security\",\n                    message=f\"Variable '{var}' should be at least 32 characters\",\n                    fix_suggestion=\"Generate a longer secret for better security\",\n                    key=var,\n                )\n\n    def _validate_constitutional_hash(self, result: ValidationResult):\n        \"\"\"Verify constitutional hash is correctly configured.\"\"\"\n        config_hash = os.getenv(\"CONSTITUTIONAL_HASH\", CONSTITUTIONAL_HASH)\n\n        if config_hash != CONSTITUTIONAL_HASH:\n            result.add_issue(\n                severity=ValidationSeverity.ERROR,\n                category=\"constitutional\",\n                message=(\n                    f\"Constitutional hash mismatch: expected \"\n                    f\"'{CONSTITUTIONAL_HASH}', got '{config_hash}'\"\n                ),\n                fix_suggestion=\"Ensure CONSTITUTIONAL_HASH is set correctly\",\n            )\n        else:\n            result.add_issue(\n                severity=ValidationSeverity.INFO,\n                category=\"constitutional\",\n                message=f\"Constitutional hash verified: {CONSTITUTIONAL_HASH}\",\n            )\n\n    def _validate_env_files(self, result: ValidationResult):\n        \"\"\"Check environment file configuration.\"\"\"\n        env_file = self.project_root / \".env\"\n        env_dev = self.project_root / \".env.dev\"\n\n        if not env_file.exists() and not env_dev.exists():\n            result.add_issue(\n                severity=ValidationSeverity.WARNING,\n                category=\"config\",\n                message=\"No .env file found\",\n                fix_suggestion=(\n                    \"Create .env from .env.dev template or configure environment variables directly\"\n                ),\n            )\n        elif env_file.exists():\n            result.add_issue(\n                severity=ValidationSeverity.INFO,\n                category=\"config\",\n                message=f\".env file found at {env_file}\",\n            )\n\n    def _validate_docker_config(self, result: ValidationResult):\n        \"\"\"Validate Docker Compose configuration.\"\"\"\n        compose_file = self.project_root / \"docker-compose.dev.yml\"\n\n        if not compose_file.exists():\n            result.add_issue(\n                severity=ValidationSeverity.WARNING,\n                category=\"docker\",\n                message=\"docker-compose.dev.yml not found\",\n                fix_suggestion=\"Ensure Docker Compose file exists for development\",\n            )\n        else:\n            result.add_issue(\n                severity=ValidationSeverity.INFO,\n                category=\"docker\",\n                message=\"Docker Compose configuration found\",\n            )\n\n    def _validate_service_urls(self, result: ValidationResult):\n        \"\"\"Validate service URL configurations.\"\"\"\n        url_vars = {\n            \"REDIS_URL\": \"redis://localhost:6379\",\n            \"OPA_URL\": \"http://localhost:8181\",\n            \"AUDIT_SERVICE_URL\": \"http://localhost:8001\",\n        }\n\n        for var, default in url_vars.items():\n            value = os.getenv(var, default)\n            result.config_summary[var] = value\n\n            # Check for localhost in production\n            if result.environment == Environment.PRODUCTION:\n                if \"localhost\" in value or \"127.0.0.1\" in value:\n                    result.add_issue(\n                        severity=ValidationSeverity.ERROR,\n                        category=\"urls\",\n                        message=f\"Variable '{var}' uses localhost in production\",\n                        fix_suggestion=f\"Configure {var} to use production service address\",\n                        key=var,\n                    )\n\n\ndef validate_config(verbose: bool = False) -> bool:\n    \"\"\"\n    Convenience function to validate configuration.\n\n    Returns:\n        True if configuration is valid, False otherwise\n    \"\"\"\n    validator = ConfigValidator()\n    result = validator.validate()\n    result.print_report(verbose=verbose)\n    return result.is_valid\n\n\n# CLI entry point\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"ACGS-2 Configuration Validator\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"Verbose output\")\n    parser.add_argument(\n        \"--env\",\n        choices=[\"development\", \"staging\", \"production\", \"ci\", \"test\"],\n        help=\"Override environment detection\",\n    )\n    parser.add_argument(\"--json\", action=\"store_true\", help=\"Output as JSON\")\n    args = parser.parse_args()\n\n    validator = ConfigValidator()\n\n    env = None\n    if args.env:\n        env = Environment(args.env)\n\n    result = validator.validate(env)\n\n    if args.json:\n        import json\n\n        output = {\n            \"valid\": result.is_valid,\n            \"environment\": result.environment.value,\n            \"issues\": [\n                {\n                    \"severity\": i.severity.value,\n                    \"category\": i.category,\n                    \"message\": i.message,\n                    \"fix\": i.fix_suggestion,\n                    \"key\": i.key,\n                }\n                for i in result.issues\n            ],\n            \"config\": result.config_summary,\n        }\n        logging.info(json.dumps(output, indent=2))\n    else:\n        result.print_report(verbose=args.verbose)\n\n    sys.exit(0 if result.is_valid else 1)\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.562420",
  "last_updated": "2026-01-04T05:35:51.211754"
}