{
  "file_path": "analytics-dashboard/src/components/charts/ComposedChart.tsx",
  "main_branch_history": [],
  "task_views": {
    "052-replace-recharts-with-lightweight-chart-library": {
      "task_id": "052-replace-recharts-with-lightweight-chart-library",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * ComposedChart Component\n *\n * A flexible chart component that can overlay multiple area and line series.\n * Similar to recharts' ComposedChart but using visx primitives.\n *\n * Features:\n * - Overlay multiple Area and Line series\n * - Gradient fills for areas\n * - Customizable line styles (dashed, solid, width, color)\n * - Interactive tooltips\n * - Time or linear scales\n * - Customizable axes\n *\n * This is the most flexible chart component, suitable for complex visualizations\n * like the PredictionWidget with confidence intervals.\n */\n\nimport { useMemo, useCallback } from 'react';\nimport { AreaClosed, LinePath, Bar, Line } from '@visx/shape';\nimport { scaleTime, scaleLinear } from '@visx/scale';\nimport { AxisBottom, AxisLeft } from '@visx/axis';\nimport { LinearGradient } from '@visx/gradient';\nimport { useTooltip, TooltipWithBounds, defaultStyles } from '@visx/tooltip';\nimport { localPoint } from '@visx/event';\nimport { bisector } from 'd3-array';\nimport type { DataPoint, ChartMargin, AxisConfig, LineSeries, AreaSeries } from './types';\n\nconst DEFAULT_MARGIN: ChartMargin = { top: 10, right: 10, left: 40, bottom: 30 };\n\nconst tooltipStyles = {\n  ...defaultStyles,\n  backgroundColor: 'white',\n  border: '1px solid #E5E7EB',\n  borderRadius: '0.5rem',\n  padding: '0.75rem',\n  fontSize: '0.875rem',\n};\n\nexport interface GradientConfig {\n  id: string;\n  from: string;\n  to: string;\n  fromOpacity?: number;\n  toOpacity?: number;\n}\n\nexport interface ComposedChartProps<T extends DataPoint = DataPoint> {\n  /** Chart data */\n  data: T[];\n  /** Chart width in pixels */\n  width: number;\n  /** Chart height in pixels */\n  height: number;\n  /** Data key for x-axis (should be Date or number) */\n  xKey: keyof T | string;\n  /** Area series to render */\n  areas?: AreaSeries<T>[];\n  /** Line series to render */\n  lines?: LineSeries<T>[];\n  /** Gradient definitions */\n  gradients?: GradientConfig[];\n  /** Chart margins */\n  margin?: Partial<ChartMargin>;\n  /** X-axis configuration */\n  xAxis?: AxisConfig;\n  /** Y-axis configuration */\n  yAxis?: AxisConfig;\n  /** Custom tooltip renderer */\n  tooltip?: (data: T) => React.ReactNode;\n  /** Scale type for x-axis */\n  xScaleType?: 'time' | 'linear';\n  /** Show grid lines */\n  showGrid?: boolean;\n  /** Grid color */\n  gridColor?: string;\n}\n\n/**\n * ComposedChart - Renders overlaid area and line series\n *\n * Combines multiple area bands and line series on a single chart.\n * Perfect for visualizations like confidence intervals with prediction lines.\n */\nexport function ComposedChart<T extends DataPoint = DataPoint>({\n  data,\n  width,\n  height,\n  xKey,\n  areas = [],\n  lines = [],\n  gradients = [],\n  margin: marginOverride,\n  xAxis = {},\n  yAxis = {},\n  tooltip: customTooltip,\n  xScaleType = 'time',\n  showGrid = false,\n  gridColor = '#E5E7EB',\n}: ComposedChartProps<T>): JSX.Element {\n  const margin = { ...DEFAULT_MARGIN, ...marginOverride };\n\n  const {\n    showTooltip,\n    hideTooltip,\n    tooltipData,\n    tooltipLeft = 0,\n    tooltipTop = 0,\n  } = useTooltip<T>();\n\n  // Calculate bounds\n  const xMax = width - margin.left - margin.right;\n  const yMax = height - margin.top - margin.bottom;\n\n  // Get accessor function for x values\n  const getX = useCallback((d: T) => {\n    const value = d[xKey as keyof T];\n    if (value instanceof Date) return value;\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string') return new Date(value);\n    return new Date();\n  }, [xKey]);\n\n  // Create scales\n  const xScale = useMemo(() => {\n    const domain = [\n      Math.min(...data.map((d) => {\n        const val = getX(d);\n        return val instanceof Date ? val.getTime() : val;\n      })),\n      Math.max(...data.map((d) => {\n        const val = getX(d);\n        return val instanceof Date ? val.getTime() : val;\n      })),\n    ];\n\n    if (xScaleType === 'time') {\n      return scaleTime({\n        domain,\n        range: [0, xMax],\n      });\n    }\n\n    return scaleLinear({\n      domain,\n      range: [0, xMax],\n    });\n  }, [data, xMax, xScaleType, getX]);\n\n  const yScale = useMemo(() => {\n    // Collect all y values from areas and lines\n    const allValues: number[] = [];\n\n    areas.forEach((area) => {\n      data.forEach((d) => {\n        const y0 = d[area.dataKeyY0 as keyof T];\n        const y1 = d[area.dataKeyY1 as keyof T];\n        if (typeof y0 === 'number') allValues.push(y0);\n        if (typeof y1 === 'number') allValues.push(y1);\n      });\n    });\n\n    lines.forEach((line) => {\n      data.forEach((d) => {\n        const value = d[line.dataKey as keyof T];\n        if (typeof value === 'number') allValues.push(value);\n      });\n    });\n\n    let domain: [number, number];\n    if (yAxis.domain) {\n      const [min, max] = yAxis.domain;\n      domain = [\n        min === 'auto' || min === 'dataMin' ? Math.min(...allValues) : min,\n        max === 'auto' || max === 'dataMax' ? Math.max(...allValues) : max,\n      ];\n    } else {\n      domain = [Math.min(...allValues), Math.max(...allValues)];\n    }\n\n    return scaleLinear({\n      domain,\n      range: [yMax, 0],\n      nice: true,\n    });\n  }, [data, areas, lines, yMax, yAxis.domain]);\n\n  // Bisector for finding nearest data point\n  const bisectDate = useMemo(\n    () => bisector<T, Date | number>((d) => {\n      const val = getX(d);\n      return val instanceof Date ? val.getTime() : val;\n    }).left,\n    [getX]\n  );\n\n  // Handle mouse move for tooltip\n  const handleTooltip = useCallback(\n    (event: React.TouchEvent<SVGRectElement> | React.MouseEvent<SVGRectElement>) => {\n      const { x } = localPoint(event) || { x: 0 };\n      const x0Val = xScale.invert(x - margin.left);\n      const x0 = x0Val instanceof Date ? x0Val : new Date(x0Val);\n      const index = bisectDate(data, x0, 1);\n      const d0 = data[index - 1];\n      const d1 = data[index];\n      let d = d0;\n      if (d1) {\n        const x0Time = x0 instanceof Date ? x0.getTime() : x0;\n        const d0X = getX(d0);\n        const d1X = getX(d1);\n        const d0Time = d0X instanceof Date ? d0X.getTime() : d0X;\n        const d1Time = d1X instanceof Date ? d1X.getTime() : d1X;\n        d = x0Time - d0Time > d1Time - x0Time ? d1 : d0;\n      }\n\n      const xValue = getX(d);\n      const xPos = xValue instanceof Date ? xScale(xValue) : xScale(xValue);\n\n      // Use the first line series for Y position, or first area middle if no lines\n      let yPos = 0;\n      if (lines.length > 0) {\n        const yValue = d[lines[0].dataKey as keyof T];\n        yPos = typeof yValue === 'number' ? yScale(yValue) : 0;\n      } else if (areas.length > 0) {\n        const y0 = d[areas[0].dataKeyY0 as keyof T];\n        const y1 = d[areas[0].dataKeyY1 as keyof T];\n        const y0Num = typeof y0 === 'number' ? y0 : 0;\n        const y1Num = typeof y1 === 'number' ? y1 : 0;\n        yPos = yScale((y0Num + y1Num) / 2);\n      }\n\n      showTooltip({\n        tooltipData: d,\n        tooltipLeft: xPos,\n        tooltipTop: yPos,\n      });\n    },\n    [showTooltip, xScale, yScale, data, bisectDate, margin.left, lines, areas, getX]\n  );\n\n  // Default tooltip renderer\n  const renderTooltip = useCallback((data: T) => {\n    if (customTooltip) {\n      return customTooltip(data);\n    }\n\n    return (\n      <div>\n        <div className=\"space-y-1 text-xs\">\n          {/* Show line values */}\n          {lines.map((line, i) => {\n            const value = data[line.dataKey as keyof T];\n            return (\n              <div key={`line-${i}`} className=\"flex items-center justify-between gap-4\">\n                <span className=\"text-gray-600\">{line.label || String(line.dataKey)}:</span>\n                <span className=\"font-semibold\" style={{ color: line.stroke }}>\n                  {typeof value === 'number' ? value.toFixed(2) : String(value)}\n                </span>\n              </div>\n            );\n          })}\n          {/* Show area ranges */}\n          {areas.map((area, i) => {\n            const y0 = data[area.dataKeyY0 as keyof T];\n            const y1 = data[area.dataKeyY1 as keyof T];\n            return (\n              <div key={`area-${i}`} className=\"flex items-center justify-between gap-4\">\n                <span className=\"text-gray-600\">{area.label || 'Range'}:</span>\n                <span className=\"font-semibold text-gray-700\">\n                  {typeof y0 === 'number' ? y0.toFixed(2) : y0} -{' '}\n                  {typeof y1 === 'number' ? y1.toFixed(2) : y1}\n                </span>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }, [customTooltip, lines, areas]);\n\n  return (\n    <div style={{ position: 'relative' }}>\n      <svg width={width} height={height}>\n        {/* Gradient definitions */}\n        {gradients.map((gradient) => (\n          <LinearGradient\n            key={gradient.id}\n            id={gradient.id}\n            from={gradient.from}\n            to={gradient.to}\n            fromOpacity={gradient.fromOpacity ?? 0.2}\n            toOpacity={gradient.toOpacity ?? 0.05}\n            vertical\n          />\n        ))}\n\n        <g transform={`translate(${margin.left},${margin.top})`}>\n          {/* Grid lines */}\n          {showGrid && (\n            <g>\n              {yScale.ticks(5).map((tick, i) => (\n                <Line\n                  key={`grid-${i}`}\n                  from={{ x: 0, y: yScale(tick) }}\n                  to={{ x: xMax, y: yScale(tick) }}\n                  stroke={gridColor}\n                  strokeWidth={1}\n                  strokeDasharray=\"2 2\"\n                />\n              ))}\n            </g>\n          )}\n\n          {/* Render area series */}\n          {areas.map((area, i) => (\n            <AreaClosed\n              key={`area-${i}`}\n              data={data}\n              x={(d) => {\n                const xValue = getX(d);\n                return xValue instanceof Date ? xScale(xValue) : xScale(xValue);\n              }}\n              y0={(d) => {\n                const value = d[area.dataKeyY0 as keyof T];\n                return typeof value === 'number' ? yScale(value) : 0;\n              }}\n              y1={(d) => {\n                const value = d[area.dataKeyY1 as keyof T];\n                return typeof value === 'number' ? yScale(value) : 0;\n              }}\n              fill={area.fill}\n              stroke={area.stroke || 'none'}\n              strokeWidth={area.strokeWidth || 0}\n            />\n          ))}\n\n          {/* Render line series */}\n          {lines.map((line, i) => (\n            <LinePath\n              key={`line-${i}`}\n              data={data}\n              x={(d) => {\n                const xValue = getX(d);\n                return xValue instanceof Date ? xScale(xValue) : xScale(xValue);\n              }}\n              y={(d) => {\n                const value = d[line.dataKey as keyof T];\n                return typeof value === 'number' ? yScale(value) : 0;\n              }}\n              stroke={line.stroke}\n              strokeWidth={line.strokeWidth ?? 2}\n              strokeDasharray={line.strokeDasharray}\n            />\n          ))}\n\n          {/* Active dot on hover */}\n          {tooltipData && lines.length > 0 && (\n            <circle\n              cx={tooltipLeft}\n              cy={tooltipTop}\n              r={lines[0].activeDot?.r || 4}\n              fill={lines[0].activeDot?.fill || lines[0].stroke}\n              stroke={lines[0].activeDot?.stroke || 'white'}\n              strokeWidth={lines[0].activeDot?.strokeWidth || 2}\n              pointerEvents=\"none\"\n            />\n          )}\n\n          {/* X-axis */}\n          {(xAxis.show !== false) && (\n            <AxisBottom\n              top={yMax}\n              scale={xScale}\n              stroke={xAxis.stroke || '#E5E7EB'}\n              tickStroke={xAxis.tickStroke || 'transparent'}\n              tickFormat={xAxis.tickFormatter as ((value: Date | { valueOf(): number }) => string) | undefined}\n              tickLabelProps={() => ({\n                fill: xAxis.tickColor || '#6B7280',\n                fontSize: xAxis.tickFontSize || 11,\n                textAnchor: 'middle',\n              })}\n            />\n          )}\n\n          {/* Y-axis */}\n          {(yAxis.show !== false) && (\n            <AxisLeft\n              scale={yScale}\n              stroke={yAxis.stroke || '#E5E7EB'}\n              tickStroke={yAxis.tickStroke || 'transparent'}\n              tickFormat={yAxis.tickFormatter as ((value: number | { valueOf(): number }) => string) | undefined}\n              tickLabelProps={() => ({\n                fill: yAxis.tickColor || '#6B7280',\n                fontSize: yAxis.tickFontSize || 11,\n                textAnchor: 'end',\n                dx: -4,\n              })}\n            />\n          )}\n\n          {/* Invisible overlay for tooltip */}\n          <Bar\n            x={0}\n            y={0}\n            width={xMax}\n            height={yMax}\n            fill=\"transparent\"\n            onTouchStart={handleTooltip}\n            onTouchMove={handleTooltip}\n            onMouseMove={handleTooltip}\n            onMouseLeave={hideTooltip}\n          />\n        </g>\n      </svg>\n\n      {/* Tooltip */}\n      {tooltipData && (\n        <TooltipWithBounds\n          key={Math.random()}\n          top={tooltipTop + margin.top}\n          left={tooltipLeft + margin.left}\n          style={tooltipStyles}\n        >\n          {renderTooltip(tooltipData)}\n        </TooltipWithBounds>\n      )}\n    </div>\n  );\n}\n\nexport default ComposedChart;\n",
        "timestamp": "2026-01-04T05:36:13.611399"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "052-replace-recharts-with-lightweight-chart-library",
        "description": "Replace recharts (~500KB unparsed, ~150KB gzipped) with a lightweight charting library like visx (~40KB) or uPlot (~30KB) to reduce bundle size and improve dashboard performance. Used in PredictionWidget (analytics-dashboard) and MetricsChart (observability dashboard).",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:23.182522",
  "last_updated": "2026-01-04T05:36:13.692684"
}