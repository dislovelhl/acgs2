{
  "file_path": "integration-service/src/integrations/linear/client.py",
  "main_branch_history": [],
  "task_views": {
    "001-connect-your-tools": {
      "task_id": "001-connect-your-tools",
      "branch_point": {
        "commit_hash": "cc53a509f89115bbb36940c140031e6159320791",
        "content": "",
        "timestamp": "2026-01-03T17:00:01.335551"
      },
      "worktree_state": {
        "content": "\"\"\"\nLinear GraphQL Client\n\nProvides async GraphQL client for interacting with Linear.app API.\nSupports issue CRUD operations, comments, and pagination.\n\nFeatures:\n- Async/await support for FastAPI integration\n- Bearer token authentication\n- Rate limiting with exponential backoff\n- Comprehensive error handling\n- Pagination support for large result sets\n\"\"\"\n\nimport logging\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom gql import Client, gql\nfrom gql.transport.aiohttp import AIOHTTPTransport\nfrom gql.transport.exceptions import TransportQueryError, TransportServerError\nfrom tenacity import (\n    before_sleep_log,\n    retry,\n    retry_if_exception_type,\n    stop_after_attempt,\n    wait_exponential,\n)\n\nfrom ...config import LinearConfig, get_linear_config\n\nlogger = logging.getLogger(__name__)\n\n\nclass LinearClientError(Exception):\n    \"\"\"Base exception for Linear client errors\"\"\"\n\n    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):\n        self.message = message\n        self.details = details or {}\n        super().__init__(self.message)\n\n\nclass LinearAuthenticationError(LinearClientError):\n    \"\"\"Raised when authentication with Linear fails\"\"\"\n    pass\n\n\nclass LinearRateLimitError(LinearClientError):\n    \"\"\"Raised when Linear rate limit is exceeded\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        retry_after: Optional[int] = None,\n        details: Optional[Dict[str, Any]] = None,\n    ):\n        super().__init__(message, details)\n        self.retry_after = retry_after\n\n\nclass LinearNotFoundError(LinearClientError):\n    \"\"\"Raised when a requested resource is not found\"\"\"\n    pass\n\n\nclass LinearValidationError(LinearClientError):\n    \"\"\"Raised when request validation fails\"\"\"\n    pass\n\n\nclass LinearClient:\n    \"\"\"\n    Async GraphQL client for Linear.app API.\n\n    Provides methods for issue management, comments, and queries.\n    Uses AIOHTTPTransport for async FastAPI compatibility.\n\n    Usage:\n        config = get_linear_config()\n        client = LinearClient(config)\n        await client.initialize()\n\n        # Create an issue\n        issue = await client.create_issue(\n            title=\"Bug in login\",\n            description=\"Users cannot log in\",\n            team_id=\"TEAM-123\"\n        )\n\n        # Get an issue\n        issue = await client.get_issue(\"ISSUE-123\")\n\n        # List issues\n        issues = await client.list_issues(team_id=\"TEAM-123\")\n\n        # Update an issue\n        await client.update_issue(\n            issue_id=\"abc123\",\n            title=\"Updated title\",\n            state_id=\"state-123\"\n        )\n\n        # Add a comment\n        await client.add_comment(\n            issue_id=\"abc123\",\n            body=\"This is a comment\"\n        )\n\n        await client.close()\n\n    Features:\n        - Automatic retry with exponential backoff\n        - Rate limit handling\n        - Pagination support\n        - Comprehensive error handling\n    \"\"\"\n\n    # Linear API rate limit (conservative estimate)\n    # Linear uses a rolling window rate limit\n    DEFAULT_TIMEOUT = 30.0\n    DEFAULT_MAX_RETRIES = 3\n\n    def __init__(\n        self,\n        config: Optional[LinearConfig] = None,\n        timeout: float = DEFAULT_TIMEOUT,\n        max_retries: int = DEFAULT_MAX_RETRIES,\n    ):\n        \"\"\"\n        Initialize Linear GraphQL client.\n\n        Args:\n            config: Linear configuration (uses get_linear_config() if not provided)\n            timeout: Request timeout in seconds\n            max_retries: Maximum retry attempts for failed requests\n        \"\"\"\n        self.config = config or get_linear_config()\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        self._client: Optional[Client] = None\n        self._transport: Optional[AIOHTTPTransport] = None\n        self._initialized = False\n\n    async def initialize(self) -> None:\n        \"\"\"\n        Initialize the GraphQL client and transport.\n\n        Must be called before making any API requests.\n        Creates the AIOHTTPTransport with authentication headers.\n        \"\"\"\n        if self._initialized:\n            logger.debug(\"Linear client already initialized\")\n            return\n\n        logger.info(f\"Initializing Linear GraphQL client for API: {self.config.linear_api_url}\")\n\n        # Create async HTTP transport with authentication\n        headers = {\n            \"Authorization\": f\"Bearer {self.config.linear_api_key.get_secret_value()}\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        self._transport = AIOHTTPTransport(\n            url=self.config.linear_api_url,\n            headers=headers,\n            timeout=self.timeout,\n        )\n\n        # Create GraphQL client\n        try:\n            self._client = Client(\n                transport=self._transport,\n                fetch_schema_from_transport=False,  # Don't fetch schema on init for performance\n                execute_timeout=self.timeout,\n            )\n            self._initialized = True\n            logger.info(\"Linear GraphQL client initialized successfully\")\n\n        except Exception as e:\n            logger.error(f\"Failed to initialize Linear client: {str(e)}\")\n            raise LinearClientError(f\"Failed to initialize client: {str(e)}\") from e\n\n    async def close(self) -> None:\n        \"\"\"\n        Close the GraphQL client and cleanup resources.\n\n        Should be called when done using the client.\n        \"\"\"\n        if self._client and self._transport:\n            await self._transport.close()\n            self._client = None\n            self._transport = None\n            self._initialized = False\n            logger.info(\"Linear GraphQL client closed\")\n\n    def _ensure_initialized(self) -> None:\n        \"\"\"Ensure the client is initialized before making requests.\"\"\"\n        if not self._initialized or not self._client:\n            raise LinearClientError(\n                \"Client not initialized. Call await client.initialize() first.\"\n            )\n\n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=1, max=16),\n        retry=retry_if_exception_type((httpx.TimeoutException, httpx.NetworkError)),\n        before_sleep=before_sleep_log(logger, logging.WARNING),\n        reraise=True,\n    )\n    async def _execute_query(\n        self,\n        query: str,\n        variable_values: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a GraphQL query with retry logic.\n\n        Args:\n            query: GraphQL query string\n            variable_values: Query variables\n\n        Returns:\n            Query result as dictionary\n\n        Raises:\n            LinearClientError: For general client errors\n            LinearAuthenticationError: For authentication failures\n            LinearRateLimitError: For rate limit errors\n            LinearNotFoundError: For 404 errors\n        \"\"\"\n        self._ensure_initialized()\n\n        try:\n            # Parse and execute the query\n            parsed_query = gql(query)\n            result = await self._client.execute_async(\n                parsed_query,\n                variable_values=variable_values or {},\n            )\n            return result\n\n        except TransportQueryError as e:\n            # GraphQL query errors (validation, not found, etc.)\n            error_message = str(e)\n\n            # Check for specific error types\n            if \"not found\" in error_message.lower():\n                raise LinearNotFoundError(\n                    f\"Resource not found: {error_message}\",\n                    details={\"query\": query, \"variables\": variable_values},\n                ) from e\n            elif (\n                \"unauthorized\" in error_message.lower()\n                or \"authentication\" in error_message.lower()\n            ):\n                raise LinearAuthenticationError(\n                    f\"Authentication failed: {error_message}\",\n                    details={\"query\": query},\n                ) from e\n            elif \"validation\" in error_message.lower():\n                raise LinearValidationError(\n                    f\"Validation failed: {error_message}\",\n                    details={\"query\": query, \"variables\": variable_values},\n                ) from e\n            else:\n                raise LinearClientError(\n                    f\"GraphQL query error: {error_message}\",\n                    details={\"query\": query, \"variables\": variable_values},\n                ) from e\n\n        except TransportServerError as e:\n            # Server errors (500, 429, etc.)\n            error_message = str(e)\n\n            # Check for rate limiting\n            if \"429\" in error_message or \"rate limit\" in error_message.lower():\n                raise LinearRateLimitError(\n                    \"Linear API rate limit exceeded\",\n                    retry_after=60,  # Linear typically uses 60 second windows\n                    details={\"error\": error_message},\n                ) from e\n            else:\n                raise LinearClientError(\n                    f\"Linear API server error: {error_message}\",\n                    details={\"error\": error_message},\n                ) from e\n\n        except httpx.TimeoutException as e:\n            logger.error(f\"Request timed out after {self.timeout}s\")\n            raise LinearClientError(\n                f\"Request timed out after {self.timeout}s\",\n                details={\"timeout\": self.timeout},\n            ) from e\n\n        except httpx.NetworkError as e:\n            logger.error(f\"Network error: {str(e)}\")\n            raise LinearClientError(\n                f\"Network error: {str(e)}\",\n                details={\"error\": str(e)},\n            ) from e\n\n        except Exception as e:\n            logger.error(f\"Unexpected error executing query: {str(e)}\")\n            raise LinearClientError(\n                f\"Unexpected error: {str(e)}\",\n                details={\"error\": str(e)},\n            ) from e\n\n    async def create_issue(\n        self,\n        title: str,\n        team_id: Optional[str] = None,\n        description: Optional[str] = None,\n        priority: Optional[int] = None,\n        state_id: Optional[str] = None,\n        assignee_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Create a new issue in Linear.\n\n        Args:\n            title: Issue title (required)\n            team_id: Team ID (uses config default if not provided)\n            description: Issue description (Markdown supported)\n            priority: Priority level (0=No priority, 1=Urgent, 2=High, 3=Normal, 4=Low)\n            state_id: Workflow state ID\n            assignee_id: User ID to assign the issue to\n            project_id: Project ID (uses config default if not provided)\n            labels: List of label IDs to add to the issue\n\n        Returns:\n            Created issue data including id, identifier, url\n\n        Raises:\n            LinearClientError: If issue creation fails\n        \"\"\"\n        logger.debug(f\"Creating Linear issue: {title}\")\n\n        # Use defaults from config if not provided\n        team_id = team_id or self.config.linear_team_id\n        project_id = project_id or self.config.linear_project_id\n\n        # Build the mutation\n        mutation = \"\"\"\n            mutation IssueCreate($input: IssueCreateInput!) {\n                issueCreate(input: $input) {\n                    success\n                    issue {\n                        id\n                        identifier\n                        title\n                        description\n                        url\n                        createdAt\n                        updatedAt\n                        state {\n                            id\n                            name\n                        }\n                        team {\n                            id\n                            name\n                        }\n                        assignee {\n                            id\n                            name\n                            email\n                        }\n                    }\n                }\n            }\n        \"\"\"\n\n        # Build input variables\n        input_data: Dict[str, Any] = {\n            \"title\": title,\n            \"teamId\": team_id,\n        }\n\n        if description:\n            input_data[\"description\"] = description\n        if priority is not None:\n            input_data[\"priority\"] = priority\n        if state_id:\n            input_data[\"stateId\"] = state_id\n        if assignee_id:\n            input_data[\"assigneeId\"] = assignee_id\n        if project_id:\n            input_data[\"projectId\"] = project_id\n        if labels:\n            input_data[\"labelIds\"] = labels\n\n        variables = {\"input\": input_data}\n\n        try:\n            result = await self._execute_query(mutation, variables)\n\n            if not result.get(\"issueCreate\", {}).get(\"success\"):\n                raise LinearClientError(\n                    \"Issue creation returned success=false\",\n                    details={\"result\": result},\n                )\n\n            issue = result[\"issueCreate\"][\"issue\"]\n            logger.info(f\"Created Linear issue: {issue.get('identifier')} ({issue.get('id')})\")\n            return issue\n\n        except (LinearClientError, LinearAuthenticationError, LinearRateLimitError):\n            raise\n        except Exception as e:\n            raise LinearClientError(\n                f\"Failed to create issue: {str(e)}\",\n                details={\"title\": title},\n            ) from e\n\n    async def get_issue(\n        self,\n        issue_id: str,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get an issue by ID or identifier.\n\n        Args:\n            issue_id: Issue ID (UUID) or identifier (e.g., \"ENG-123\")\n\n        Returns:\n            Issue data\n\n        Raises:\n            LinearNotFoundError: If issue not found\n            LinearClientError: For other errors\n        \"\"\"\n        logger.debug(f\"Fetching Linear issue: {issue_id}\")\n\n        query = \"\"\"\n            query Issue($id: String!) {\n                issue(id: $id) {\n                    id\n                    identifier\n                    title\n                    description\n                    url\n                    priority\n                    createdAt\n                    updatedAt\n                    archivedAt\n                    state {\n                        id\n                        name\n                        type\n                    }\n                    team {\n                        id\n                        name\n                        key\n                    }\n                    assignee {\n                        id\n                        name\n                        email\n                    }\n                    creator {\n                        id\n                        name\n                        email\n                    }\n                    project {\n                        id\n                        name\n                    }\n                    labels {\n                        nodes {\n                            id\n                            name\n                        }\n                    }\n                }\n            }\n        \"\"\"\n\n        variables = {\"id\": issue_id}\n\n        try:\n            result = await self._execute_query(query, variables)\n            issue = result.get(\"issue\")\n\n            if not issue:\n                raise LinearNotFoundError(\n                    f\"Issue not found: {issue_id}\",\n                    details={\"issue_id\": issue_id},\n                )\n\n            logger.debug(f\"Retrieved Linear issue: {issue.get('identifier')}\")\n            return issue\n\n        except (LinearNotFoundError, LinearAuthenticationError, LinearRateLimitError):\n            raise\n        except Exception as e:\n            raise LinearClientError(\n                f\"Failed to get issue: {str(e)}\",\n                details={\"issue_id\": issue_id},\n            ) from e\n\n    async def update_issue(\n        self,\n        issue_id: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        priority: Optional[int] = None,\n        state_id: Optional[str] = None,\n        assignee_id: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Update an existing issue.\n\n        Args:\n            issue_id: Issue ID (UUID) to update\n            title: New title\n            description: New description\n            priority: New priority level\n            state_id: New workflow state ID\n            assignee_id: New assignee user ID\n            labels: New list of label IDs (replaces existing)\n\n        Returns:\n            Updated issue data\n\n        Raises:\n            LinearNotFoundError: If issue not found\n            LinearClientError: For other errors\n        \"\"\"\n        logger.debug(f\"Updating Linear issue: {issue_id}\")\n\n        mutation = \"\"\"\n            mutation IssueUpdate($id: String!, $input: IssueUpdateInput!) {\n                issueUpdate(id: $id, input: $input) {\n                    success\n                    issue {\n                        id\n                        identifier\n                        title\n                        description\n                        priority\n                        updatedAt\n                        state {\n                            id\n                            name\n                        }\n                        assignee {\n                            id\n                            name\n                        }\n                    }\n                }\n            }\n        \"\"\"\n\n        # Build update input\n        input_data: Dict[str, Any] = {}\n\n        if title is not None:\n            input_data[\"title\"] = title\n        if description is not None:\n            input_data[\"description\"] = description\n        if priority is not None:\n            input_data[\"priority\"] = priority\n        if state_id is not None:\n            input_data[\"stateId\"] = state_id\n        if assignee_id is not None:\n            input_data[\"assigneeId\"] = assignee_id\n        if labels is not None:\n            input_data[\"labelIds\"] = labels\n\n        if not input_data:\n            raise LinearValidationError(\n                \"At least one field must be provided to update\",\n                details={\"issue_id\": issue_id},\n            )\n\n        variables = {\n            \"id\": issue_id,\n            \"input\": input_data,\n        }\n\n        try:\n            result = await self._execute_query(mutation, variables)\n\n            if not result.get(\"issueUpdate\", {}).get(\"success\"):\n                raise LinearClientError(\n                    \"Issue update returned success=false\",\n                    details={\"result\": result, \"issue_id\": issue_id},\n                )\n\n            issue = result[\"issueUpdate\"][\"issue\"]\n            logger.info(f\"Updated Linear issue: {issue.get('identifier')}\")\n            return issue\n\n        except (\n            LinearNotFoundError,\n            LinearValidationError,\n            LinearAuthenticationError,\n            LinearRateLimitError,\n        ):\n            raise\n        except Exception as e:\n            raise LinearClientError(\n                f\"Failed to update issue: {str(e)}\",\n                details={\"issue_id\": issue_id},\n            ) from e\n\n    async def list_issues(\n        self,\n        team_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        state_id: Optional[str] = None,\n        assignee_id: Optional[str] = None,\n        first: int = 50,\n        after: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        List issues with optional filters.\n\n        Supports pagination through cursor-based pagination.\n\n        Args:\n            team_id: Filter by team ID (uses config default if not provided)\n            project_id: Filter by project ID\n            state_id: Filter by workflow state ID\n            assignee_id: Filter by assignee user ID\n            first: Number of issues to return (max 250)\n            after: Cursor for pagination (from previous pageInfo.endCursor)\n\n        Returns:\n            Dictionary with:\n                - nodes: List of issues\n                - pageInfo: Pagination info (hasNextPage, endCursor)\n\n        Raises:\n            LinearClientError: If query fails\n        \"\"\"\n        logger.debug(f\"Listing Linear issues (first={first})\")\n\n        # Use default team if not provided\n        team_id = team_id or self.config.linear_team_id\n\n        query = \"\"\"\n            query Issues($filter: IssueFilter, $first: Int, $after: String) {\n                issues(filter: $filter, first: $first, after: $after) {\n                    nodes {\n                        id\n                        identifier\n                        title\n                        description\n                        priority\n                        url\n                        createdAt\n                        updatedAt\n                        state {\n                            id\n                            name\n                        }\n                        team {\n                            id\n                            name\n                        }\n                        assignee {\n                            id\n                            name\n                        }\n                    }\n                    pageInfo {\n                        hasNextPage\n                        endCursor\n                    }\n                }\n            }\n        \"\"\"\n\n        # Build filter\n        filter_data: Dict[str, Any] = {}\n\n        if team_id:\n            filter_data[\"team\"] = {\"id\": {\"eq\": team_id}}\n        if project_id:\n            filter_data[\"project\"] = {\"id\": {\"eq\": project_id}}\n        if state_id:\n            filter_data[\"state\"] = {\"id\": {\"eq\": state_id}}\n        if assignee_id:\n            filter_data[\"assignee\"] = {\"id\": {\"eq\": assignee_id}}\n\n        variables: Dict[str, Any] = {\n            \"first\": min(first, 250),  # Linear max is 250\n        }\n\n        if filter_data:\n            variables[\"filter\"] = filter_data\n        if after:\n            variables[\"after\"] = after\n\n        try:\n            result = await self._execute_query(query, variables)\n            issues_data = result.get(\"issues\", {})\n\n            logger.debug(\n                f\"Retrieved {len(issues_data.get('nodes', []))} issues, \"\n                f\"hasNextPage={issues_data.get('pageInfo', {}).get('hasNextPage', False)}\"\n            )\n\n            return issues_data\n\n        except (LinearAuthenticationError, LinearRateLimitError):\n            raise\n        except Exception as e:\n            raise LinearClientError(\n                f\"Failed to list issues: {str(e)}\",\n                details={\"filters\": filter_data},\n            ) from e\n\n    async def add_comment(\n        self,\n        issue_id: str,\n        body: str,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Add a comment to an issue.\n\n        Args:\n            issue_id: Issue ID (UUID) to comment on\n            body: Comment text (Markdown supported)\n\n        Returns:\n            Created comment data\n\n        Raises:\n            LinearNotFoundError: If issue not found\n            LinearClientError: For other errors\n        \"\"\"\n        logger.debug(f\"Adding comment to Linear issue: {issue_id}\")\n\n        mutation = \"\"\"\n            mutation CommentCreate($input: CommentCreateInput!) {\n                commentCreate(input: $input) {\n                    success\n                    comment {\n                        id\n                        body\n                        createdAt\n                        updatedAt\n                        user {\n                            id\n                            name\n                        }\n                        issue {\n                            id\n                            identifier\n                        }\n                    }\n                }\n            }\n        \"\"\"\n\n        variables = {\n            \"input\": {\n                \"issueId\": issue_id,\n                \"body\": body,\n            }\n        }\n\n        try:\n            result = await self._execute_query(mutation, variables)\n\n            if not result.get(\"commentCreate\", {}).get(\"success\"):\n                raise LinearClientError(\n                    \"Comment creation returned success=false\",\n                    details={\"result\": result, \"issue_id\": issue_id},\n                )\n\n            comment = result[\"commentCreate\"][\"comment\"]\n            logger.info(\n                f\"Added comment to issue {comment.get('issue', {}).get('identifier')}: \"\n                f\"{comment.get('id')}\"\n            )\n            return comment\n\n        except (LinearNotFoundError, LinearAuthenticationError, LinearRateLimitError):\n            raise\n        except Exception as e:\n            raise LinearClientError(\n                f\"Failed to add comment: {str(e)}\",\n                details={\"issue_id\": issue_id},\n            ) from e\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.initialize()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n",
        "last_modified": "2026-01-03T17:00:01.393159"
      },
      "task_intent": {
        "title": "001-connect-your-tools",
        "description": "Implement Linear integration into the ACGS2 integration-service to enable bidirectional synchronization between Linear issues and external tools (GitHub, GitLab, Slack). This will make Linear the source of truth for product development workflows by automatically syncing issue states, comments, and metadata across platforms.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T17:00:01.382445",
  "last_updated": "2026-01-03T17:00:01.384281"
}