{
  "file_path": "analytics-dashboard/src/components/charts/LineChart.tsx",
  "main_branch_history": [],
  "task_views": {
    "052-replace-recharts-with-lightweight-chart-library": {
      "task_id": "052-replace-recharts-with-lightweight-chart-library",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * LineChart Component\n *\n * A reusable line chart component using visx primitives.\n * Supports multiple line series, custom tooltips, and time/linear scales.\n *\n * Features:\n * - Multiple line series with customizable styles\n * - Time or linear scales\n * - Interactive tooltips\n * - Responsive sizing\n * - Customizable axes\n */\n\nimport { useMemo, useCallback } from 'react';\nimport { LinePath, Line, Bar } from '@visx/shape';\nimport { scaleTime, scaleLinear } from '@visx/scale';\nimport { AxisBottom, AxisLeft } from '@visx/axis';\nimport { useTooltip, TooltipWithBounds, defaultStyles } from '@visx/tooltip';\nimport { localPoint } from '@visx/event';\nimport { bisector } from 'd3-array';\nimport type { DataPoint, ChartMargin, AxisConfig, LineSeries } from './types';\n\nconst DEFAULT_MARGIN: ChartMargin = { top: 10, right: 10, left: 40, bottom: 30 };\n\nconst tooltipStyles = {\n  ...defaultStyles,\n  backgroundColor: 'white',\n  border: '1px solid #E5E7EB',\n  borderRadius: '0.5rem',\n  padding: '0.75rem',\n  fontSize: '0.875rem',\n};\n\nexport interface LineChartProps<T extends DataPoint = DataPoint> {\n  /** Chart data */\n  data: T[];\n  /** Chart width in pixels */\n  width: number;\n  /** Chart height in pixels */\n  height: number;\n  /** Data key for x-axis (should be Date or number) */\n  xKey: keyof T | string;\n  /** Line series to render */\n  series: LineSeries<T>[];\n  /** Chart margins */\n  margin?: Partial<ChartMargin>;\n  /** X-axis configuration */\n  xAxis?: AxisConfig;\n  /** Y-axis configuration */\n  yAxis?: AxisConfig;\n  /** Custom tooltip renderer */\n  tooltip?: (data: T) => React.ReactNode;\n  /** Scale type for x-axis */\n  xScaleType?: 'time' | 'linear';\n  /** Show grid lines */\n  showGrid?: boolean;\n  /** Grid color */\n  gridColor?: string;\n}\n\n/**\n * LineChart - Renders a line chart with multiple series\n *\n * Supports time-based and linear x-axes, multiple line series,\n * and interactive tooltips.\n */\nexport function LineChart<T extends DataPoint = DataPoint>({\n  data,\n  width,\n  height,\n  xKey,\n  series,\n  margin: marginOverride,\n  xAxis = {},\n  yAxis = {},\n  tooltip: customTooltip,\n  xScaleType = 'time',\n  showGrid = false,\n  gridColor = '#E5E7EB',\n}: LineChartProps<T>): JSX.Element {\n  const margin = { ...DEFAULT_MARGIN, ...marginOverride };\n\n  const {\n    showTooltip,\n    hideTooltip,\n    tooltipData,\n    tooltipLeft = 0,\n    tooltipTop = 0,\n  } = useTooltip<T>();\n\n  // Calculate bounds\n  const xMax = width - margin.left - margin.right;\n  const yMax = height - margin.top - margin.bottom;\n\n  // Get accessor function for x values\n  const getX = useCallback((d: T) => {\n    const value = d[xKey as keyof T];\n    if (value instanceof Date) return value;\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string') return new Date(value);\n    return new Date();\n  }, [xKey]);\n\n  // Create scales\n  const xScale = useMemo(() => {\n    const domain = [\n      Math.min(...data.map((d) => {\n        const val = getX(d);\n        return val instanceof Date ? val.getTime() : val;\n      })),\n      Math.max(...data.map((d) => {\n        const val = getX(d);\n        return val instanceof Date ? val.getTime() : val;\n      })),\n    ];\n\n    if (xScaleType === 'time') {\n      return scaleTime({\n        domain,\n        range: [0, xMax],\n      });\n    }\n\n    return scaleLinear({\n      domain,\n      range: [0, xMax],\n    });\n  }, [data, xMax, xScaleType, getX]);\n\n  const yScale = useMemo(() => {\n    const allValues = data.flatMap((d) =>\n      series.map((s) => {\n        const value = d[s.dataKey as keyof T];\n        return typeof value === 'number' ? value : 0;\n      })\n    );\n\n    let domain: [number, number];\n    if (yAxis.domain) {\n      const [min, max] = yAxis.domain;\n      domain = [\n        min === 'auto' || min === 'dataMin' ? Math.min(...allValues) : min,\n        max === 'auto' || max === 'dataMax' ? Math.max(...allValues) : max,\n      ];\n    } else {\n      domain = [Math.min(...allValues), Math.max(...allValues)];\n    }\n\n    return scaleLinear({\n      domain,\n      range: [yMax, 0],\n      nice: true,\n    });\n  }, [data, series, yMax, yAxis.domain]);\n\n  // Bisector for finding nearest data point\n  const bisectDate = useMemo(\n    () => bisector<T, Date | number>((d) => {\n      const val = getX(d);\n      return val instanceof Date ? val.getTime() : val;\n    }).left,\n    [getX]\n  );\n\n  // Handle mouse move for tooltip\n  const handleTooltip = useCallback(\n    (event: React.TouchEvent<SVGRectElement> | React.MouseEvent<SVGRectElement>) => {\n      const { x } = localPoint(event) || { x: 0 };\n      const x0Val = xScale.invert(x - margin.left);\n      const x0 = x0Val instanceof Date ? x0Val : new Date(x0Val);\n      const index = bisectDate(data, x0, 1);\n      const d0 = data[index - 1];\n      const d1 = data[index];\n      let d = d0;\n      if (d1) {\n        const x0Time = x0 instanceof Date ? x0.getTime() : x0;\n        const d0X = getX(d0);\n        const d1X = getX(d1);\n        const d0Time = d0X instanceof Date ? d0X.getTime() : d0X;\n        const d1Time = d1X instanceof Date ? d1X.getTime() : d1X;\n        d = x0Time - d0Time > d1Time - x0Time ? d1 : d0;\n      }\n\n      const xValue = getX(d);\n      const xPos = xValue instanceof Date ? xScale(xValue) : xScale(xValue);\n\n      // Use the first series for Y position\n      const yValue = d[series[0].dataKey as keyof T];\n      const yPos = typeof yValue === 'number' ? yScale(yValue) : 0;\n\n      showTooltip({\n        tooltipData: d,\n        tooltipLeft: xPos,\n        tooltipTop: yPos,\n      });\n    },\n    [showTooltip, xScale, yScale, data, bisectDate, margin.left, series, getX]\n  );\n\n  // Default tooltip renderer\n  const renderTooltip = useCallback((data: T) => {\n    if (customTooltip) {\n      return customTooltip(data);\n    }\n\n    return (\n      <div>\n        <div className=\"space-y-1 text-xs\">\n          {series.map((s, i) => {\n            const value = data[s.dataKey as keyof T];\n            return (\n              <div key={i} className=\"flex items-center justify-between gap-4\">\n                <span className=\"text-gray-600\">{s.label || String(s.dataKey)}:</span>\n                <span className=\"font-semibold\" style={{ color: s.stroke }}>\n                  {typeof value === 'number' ? value.toFixed(2) : String(value)}\n                </span>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }, [customTooltip, series]);\n\n  return (\n    <div style={{ position: 'relative' }}>\n      <svg width={width} height={height}>\n        <g transform={`translate(${margin.left},${margin.top})`}>\n          {/* Grid lines */}\n          {showGrid && (\n            <g>\n              {yScale.ticks(5).map((tick, i) => (\n                <Line\n                  key={`grid-${i}`}\n                  from={{ x: 0, y: yScale(tick) }}\n                  to={{ x: xMax, y: yScale(tick) }}\n                  stroke={gridColor}\n                  strokeWidth={1}\n                  strokeDasharray=\"2 2\"\n                />\n              ))}\n            </g>\n          )}\n\n          {/* Render line series */}\n          {series.map((s, i) => (\n            <LinePath\n              key={i}\n              data={data}\n              x={(d) => {\n                const xValue = getX(d);\n                return xValue instanceof Date ? xScale(xValue) : xScale(xValue);\n              }}\n              y={(d) => {\n                const value = d[s.dataKey as keyof T];\n                return typeof value === 'number' ? yScale(value) : 0;\n              }}\n              stroke={s.stroke}\n              strokeWidth={s.strokeWidth ?? 2}\n              strokeDasharray={s.strokeDasharray}\n              curve={s.type === 'step' ? undefined : undefined} // Could add curve functions\n            />\n          ))}\n\n          {/* Active dot on hover */}\n          {tooltipData && (\n            <circle\n              cx={tooltipLeft}\n              cy={tooltipTop}\n              r={4}\n              fill={series[0]?.stroke || '#7C3AED'}\n              stroke=\"white\"\n              strokeWidth={2}\n              pointerEvents=\"none\"\n            />\n          )}\n\n          {/* X-axis */}\n          {(xAxis.show !== false) && (\n            <AxisBottom\n              top={yMax}\n              scale={xScale}\n              stroke={xAxis.stroke || '#E5E7EB'}\n              tickStroke={xAxis.tickStroke || 'transparent'}\n              tickFormat={xAxis.tickFormatter as ((value: Date | { valueOf(): number }) => string) | undefined}\n              tickLabelProps={() => ({\n                fill: xAxis.tickColor || '#6B7280',\n                fontSize: xAxis.tickFontSize || 11,\n                textAnchor: 'middle',\n              })}\n            />\n          )}\n\n          {/* Y-axis */}\n          {(yAxis.show !== false) && (\n            <AxisLeft\n              scale={yScale}\n              stroke={yAxis.stroke || '#E5E7EB'}\n              tickStroke={yAxis.tickStroke || 'transparent'}\n              tickFormat={yAxis.tickFormatter as ((value: number | { valueOf(): number }) => string) | undefined}\n              tickLabelProps={() => ({\n                fill: yAxis.tickColor || '#6B7280',\n                fontSize: yAxis.tickFontSize || 11,\n                textAnchor: 'end',\n                dx: -4,\n              })}\n            />\n          )}\n\n          {/* Invisible overlay for tooltip */}\n          <Bar\n            x={0}\n            y={0}\n            width={xMax}\n            height={yMax}\n            fill=\"transparent\"\n            onTouchStart={handleTooltip}\n            onTouchMove={handleTooltip}\n            onMouseMove={handleTooltip}\n            onMouseLeave={hideTooltip}\n          />\n        </g>\n      </svg>\n\n      {/* Tooltip */}\n      {tooltipData && (\n        <TooltipWithBounds\n          key={Math.random()}\n          top={tooltipTop + margin.top}\n          left={tooltipLeft + margin.left}\n          style={tooltipStyles}\n        >\n          {renderTooltip(tooltipData)}\n        </TooltipWithBounds>\n      )}\n    </div>\n  );\n}\n\nexport default LineChart;\n",
        "timestamp": "2026-01-04T05:36:13.611399"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "052-replace-recharts-with-lightweight-chart-library",
        "description": "Replace recharts (~500KB unparsed, ~150KB gzipped) with a lightweight charting library like visx (~40KB) or uPlot (~30KB) to reduce bundle size and improve dashboard performance. Used in PredictionWidget (analytics-dashboard) and MetricsChart (observability dashboard).",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:23.212329",
  "last_updated": "2026-01-04T05:36:13.650326"
}