{
  "file_path": "src/core/tools/fix_corrupted_syntax.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "#!/usr/bin/env python3\n\"\"\"\nACGS-2 Syntax Repair Tool.\n\nConstitutional Hash: cdd01ef066bc6cf2\n\nFixes corrupted try/except patterns that were incorrectly inserted around:\n- Dataclass field declarations\n- Method definitions\n- Function signatures\n- Class-level variable assignments\n\nThis tool identifies and removes the following invalid patterns:\n    field: Type = value\nAnd restores them to:\n    field: Type = value\n\"\"\"\n\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Tuple\n\n# Constitutional hash validation\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n\ndef fix_corrupted_try_except(content: str) -> Tuple[str, int]:\n    \"\"\"\n    Fix corrupted try/except patterns in Python code.\n\n    Returns:\n        Tuple of (fixed_content, number_of_fixes)\n    \"\"\"\n    fixes = 0\n\n    # Pattern 0a: Named arguments with type annotations (e.g., pattern_type: str = \"value\")\n    # Should be: pattern_type=\"value\"\n    # Note: Pattern defined for reference but applied via fix_named_args below\n\n    # Only apply in function call contexts (after opening paren or comma)\n    def fix_named_args(match):\n        # Check if this looks like a function argument context\n        return f\"{match.group(1)}={match.group(2)}\"\n\n    # Pattern 0b: Corrupted function signatures with extra type annotation\n    # e.g., entry: dict[str, Any] should be entry: dict[str, Any]\n    pattern0b = re.compile(\n        r\"(\\w+:\\s*(?:dict|list|Optional|Union|Any)\\[[^\\]]+\\]):\\s*(?:Any|str|int|float|bool|None)\",\n        re.MULTILINE,\n    )\n\n    while pattern0b.search(content):\n        content = pattern0b.sub(r\"\\1\", content)\n        fixes += 1\n\n    # Pattern 1: try/except around single-line field declarations or assignments\n    # Matches:\n    #     try:\n    #         field: Type = value\n    #     except Exception as e:\n    #         logger.error(f\"Operation failed: {e}\")\n    #         raise\n    pattern1 = re.compile(\n        r\"(\\s*)try:\\s*\\n\"\n        r\"\\1    ([^\\n]+)\\s*\\n\"\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern1.search(content):\n        content = pattern1.sub(r\"\\1\\2\\n\", content)\n        fixes += 1\n\n    # Pattern 2: try/except breaking method definition signatures\n    # Matches:\n    #     @decorator\n    #     try:\n    #         def method_name(self, ...):\n    #     except Exception as e:\n    #         logger.error(...)\n    #         raise\n    pattern2 = re.compile(\n        r\"(\\s*)(@\\w+[^\\n]*\\n)?\"\n        r\"\\1try:\\s*\\n\"\n        r\"\\1    (def \\w+\\([^)]*\\)[^:]*:)\\s*\\n\"\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern2.search(content):\n        match = pattern2.search(content)\n        decorator = match.group(2) if match.group(2) else \"\"\n        content = pattern2.sub(r\"\\1\" + decorator + r\"\\3\\n\", content, count=1)\n        fixes += 1\n\n    # Pattern 3: try/except around function parameters (multi-line)\n    # Matches broken function signatures\n    pattern3 = re.compile(\n        r\"(\\s*)(def \\w+\\()\\s*\\n\"\n        r\"\\1    try:\\s*\\n\"\n        r\"\\1        (self[^)]*)\\s*\\n\"\n        r\"\\1    except Exception as e:\\s*\\n\"\n        r'\\1        logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1        raise\\s*\\n\"\n        r\"\\1    \\)\",\n        re.MULTILINE,\n    )\n\n    while pattern3.search(content):\n        content = pattern3.sub(r\"\\1\\2\\3)\", content)\n        fixes += 1\n\n    # Pattern 4: try/except in dataclass field definition with field factory\n    pattern4 = re.compile(\n        r\"(\\s*)try:\\s*\\n\"\n        r\"\\1    (\\w+:\\s*\\w+\\[.*\\]\\s*=\\s*(?:Field|field)\\([^)]*\\))\\s*\\n\"\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern4.search(content):\n        content = pattern4.sub(r\"\\1\\2\\n\", content)\n        fixes += 1\n\n    # Pattern 5: try/except around simple type-hinted variables\n    pattern5 = re.compile(\n        r\"(\\s*)try:\\s*\\n\"\n        r\"\\1    (\\w+:\\s*\\w+(?:\\[.*?\\])?\\s*=\\s*[^\\n]+)\\s*\\n\"\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern5.search(content):\n        content = pattern5.sub(r\"\\1\\2\\n\", content)\n        fixes += 1\n\n    # Pattern 6: try/except around if statements at class/method level\n    pattern6 = re.compile(\n        r\"(\\s*)try:\\s*\\n\"\n        r\"\\1    (if [^\\n]+:)\\s*\\n\"\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern6.search(content):\n        content = pattern6.sub(r\"\\1\\2\\n\", content)\n        fixes += 1\n\n    # Pattern 7: try/except around simple statements like list/dict items\n    pattern7 = re.compile(\n        r\"(\\s*)try:\\s*\\n\"\n        r'\\1    ([\"\\']?\\w+[\"\\']?\\s*[:=]\\s*[^\\n]+,?)\\s*\\n'\n        r\"\\1except Exception as e:\\s*\\n\"\n        r'\\1    logger\\.error\\(f\"Operation failed: \\{e\\}\"\\)\\s*\\n'\n        r\"\\1    raise\\s*\\n\",\n        re.MULTILINE,\n    )\n\n    while pattern7.search(content):\n        content = pattern7.sub(r\"\\1\\2\\n\", content)\n        fixes += 1\n\n    return content, fixes\n\n\ndef process_file(filepath: Path, dry_run: bool = False) -> Tuple[bool, int]:\n    \"\"\"\n    Process a single file and fix corrupted syntax.\n\n    Returns:\n        Tuple of (was_modified, number_of_fixes)\n    \"\"\"\n    try:\n        content = filepath.read_text(encoding=\"utf-8\")\n    except Exception as e:\n        logging.error(f\"  Error reading {filepath}: {e}\")\n        return False, 0\n\n    fixed_content, fixes = fix_corrupted_try_except(content)\n\n    if fixes > 0:\n        if not dry_run:\n            filepath.write_text(fixed_content, encoding=\"utf-8\")\n        return True, fixes\n\n    return False, 0\n\n\ndef main():\n    \"\"\"Main entry point for syntax repair tool.\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        description=\"Fix corrupted try/except syntax in ACGS-2 codebase\"\n    )\n    parser.add_argument(\n        \"paths\", nargs=\"*\", default=[\".\"], help=\"Paths to process (default: current directory)\"\n    )\n    parser.add_argument(\n        \"--dry-run\", action=\"store_true\", help=\"Show what would be fixed without making changes\"\n    )\n    parser.add_argument(\"--verbose\", \"-v\", action=\"store_true\", help=\"Show detailed output\")\n\n    args = parser.parse_args()\n\n    logging.info(\"ACGS-2 Syntax Repair Tool\")\n    logging.info(f\"Constitutional Hash: {CONSTITUTIONAL_HASH}\")\n    logging.info(\n        f\"{'DRY RUN - No changes will be made' if args.dry_run else 'Processing files...'}\"\n    )\n    logging.info(\"\")\n\n    total_files = 0\n    modified_files = 0\n    total_fixes = 0\n\n    for path_str in args.paths:\n        path = Path(path_str)\n\n        if path.is_file() and path.suffix == \".py\":\n            files = [path]\n        elif path.is_dir():\n            files = list(path.rglob(\"*.py\"))\n        else:\n            logging.info(f\"Skipping invalid path: {path}\")\n            continue\n\n        for filepath in files:\n            # Skip certain directories\n            skip_dirs = [\"__pycache__\", \".git\", \"node_modules\", \".venv\", \"venv\", \"env\"]\n            if any(skip_dir in str(filepath) for skip_dir in skip_dirs):\n                continue\n\n            total_files += 1\n            was_modified, fixes = process_file(filepath, args.dry_run)\n\n            if was_modified:\n                modified_files += 1\n                total_fixes += fixes\n                if args.verbose or args.dry_run:\n                    action = \"Would fix\" if args.dry_run else \"Fixed\"\n                    logging.info(f\"  {action} {fixes} patterns in {filepath}\")\n\n    logging.info(\"\")\n    logging.info(\"Summary:\")\n    logging.info(f\"  Files scanned: {total_files}\")\n    logging.info(f\"  Files {'to be ' if args.dry_run else ''}modified: {modified_files}\")\n    logging.info(f\"  Total fixes {'needed' if args.dry_run else 'applied'}: {total_fixes}\")\n\n    return 0 if total_fixes == 0 or args.dry_run else 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.139030",
  "last_updated": "2026-01-04T05:35:58.394454"
}