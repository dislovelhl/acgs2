{
  "file_path": "integration-service/src/services/servicenow_import_service.py",
  "main_branch_history": [],
  "task_views": {
    "003-import-your-data": {
      "task_id": "003-import-your-data",
      "branch_point": {
        "commit_hash": "cc53a509f89115bbb36940c140031e6159320791",
        "content": "",
        "timestamp": "2026-01-03T17:00:00.287145"
      },
      "worktree_state": {
        "content": "\"\"\"\nServiceNow Import Service\n\nHandles fetching and transforming ServiceNow data for import into ACGS2.\nSupports both preview mode (sample data) and full import operations.\n\nFeatures:\n- Fetches incidents from ServiceNow tables\n- Transforms ServiceNow incidents to ACGS2 format\n- Supports filtering by status, assignment group, and date ranges\n- Handles pagination for large datasets\n- Provides progress tracking for batch operations\n- Rate limit handling\n- Basic and OAuth authentication support\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport httpx\nfrom pydantic import BaseModel, Field, SecretStr, field_validator, model_validator\n\nfrom ..models.import_models import (\n    DuplicateHandling,\n    ImportedItem,\n    ImportProgress,\n    PreviewItem,\n    PreviewResponse,\n    SourceConfig,\n    SourceType,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass ServiceNowAuthType(str):\n    \"\"\"ServiceNow authentication types\"\"\"\n\n    BASIC = \"basic\"\n    OAUTH = \"oauth\"\n\n\nclass ServiceNowImportConfig(BaseModel):\n    \"\"\"Configuration specific to ServiceNow import operations.\"\"\"\n\n    instance: str = Field(..., description=\"ServiceNow instance (e.g., 'your-instance.service-now.com')\")\n\n    # Authentication\n    auth_type: str = Field(\n        default=ServiceNowAuthType.BASIC,\n        description=\"Authentication type (basic or oauth)\"\n    )\n    username: Optional[str] = Field(None, description=\"Username for basic authentication\")\n    password: Optional[SecretStr] = Field(None, description=\"Password for basic authentication\")\n    client_id: Optional[str] = Field(None, description=\"OAuth client ID\")\n    client_secret: Optional[SecretStr] = Field(None, description=\"OAuth client secret\")\n\n    # Import configuration\n    table: str = Field(\n        default=\"incident\",\n        description=\"ServiceNow table to import from (e.g., 'incident', 'change_request')\"\n    )\n\n    # Optional filters\n    query_filter: Optional[str] = Field(\n        None,\n        description=\"Custom sysparm_query filter for advanced filtering\"\n    )\n    states: List[str] = Field(\n        default_factory=list,\n        description=\"Filter by states (e.g., ['1', '2'] for New, In Progress)\"\n    )\n    assignment_groups: List[str] = Field(\n        default_factory=list,\n        description=\"Filter by assignment groups\"\n    )\n\n    @field_validator(\"instance\")\n    @classmethod\n    def validate_instance(cls, v: str) -> str:\n        \"\"\"Validate and normalize instance name.\"\"\"\n        if not v:\n            raise ValueError(\"Instance is required\")\n\n        v = v.strip().lower()\n\n        # Remove protocol if present\n        if v.startswith(\"https://\"):\n            v = v[8:]\n        elif v.startswith(\"http://\"):\n            v = v[7:]\n\n        # Remove trailing slash\n        v = v.rstrip(\"/\")\n\n        # Add .service-now.com if not present\n        if not v.endswith(\".service-now.com\"):\n            v = f\"{v}.service-now.com\"\n\n        return v\n\n    @field_validator(\"table\")\n    @classmethod\n    def validate_table(cls, v: str) -> str:\n        \"\"\"Validate table name format.\"\"\"\n        if not v:\n            raise ValueError(\"Table is required\")\n        v = v.strip().lower()\n        if not v.replace(\"_\", \"\").isalnum():\n            raise ValueError(\"Table name must be alphanumeric (may include _)\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_auth_credentials(self) -> \"ServiceNowImportConfig\":\n        \"\"\"Validate that appropriate credentials are provided for auth type.\"\"\"\n        if self.auth_type == ServiceNowAuthType.BASIC:\n            if not self.username:\n                raise ValueError(\"Username is required for basic authentication\")\n            if not self.password:\n                raise ValueError(\"Password is required for basic authentication\")\n        elif self.auth_type == ServiceNowAuthType.OAUTH:\n            if not self.client_id:\n                raise ValueError(\"Client ID is required for OAuth authentication\")\n            if not self.client_secret:\n                raise ValueError(\"Client secret is required for OAuth authentication\")\n        return self\n\n\nclass ServiceNowImportService:\n    \"\"\"\n    Service for importing data from ServiceNow.\n\n    Handles authentication, data fetching, and transformation of ServiceNow records\n    into ACGS2 import format.\n\n    Usage:\n        config = ServiceNowImportConfig(\n            instance=\"your-instance.service-now.com\",\n            username=\"admin\",\n            password=SecretStr(\"password\"),\n            table=\"incident\",\n        )\n        service = ServiceNowImportService(config)\n        await service.test_connection()\n        preview = await service.preview_import(max_items=10)\n        items = await service.fetch_items(batch_size=100)\n    \"\"\"\n\n    # ServiceNow Table API path\n    TABLE_API_PATH = \"/api/now/table\"\n    OAUTH_TOKEN_PATH = \"/oauth_token.do\"\n\n    # Default limits\n    DEFAULT_PREVIEW_LIMIT = 10\n    DEFAULT_BATCH_SIZE = 100\n    MAX_RESULTS_PER_PAGE = 1000  # ServiceNow API limit\n\n    def __init__(\n        self,\n        config: ServiceNowImportConfig,\n        timeout: float = 30.0,\n        max_retries: int = 3,\n    ):\n        \"\"\"\n        Initialize ServiceNow import service.\n\n        Args:\n            config: ServiceNow import configuration\n            timeout: HTTP request timeout in seconds\n            max_retries: Maximum retry attempts for failed requests\n        \"\"\"\n        self.config = config\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self._client: Optional[httpx.AsyncClient] = None\n        self._access_token: Optional[str] = None\n        self._token_expires_at: Optional[datetime] = None\n\n    @property\n    def base_url(self) -> str:\n        \"\"\"Get the base URL for ServiceNow instance.\"\"\"\n        return f\"https://{self.config.instance}\"\n\n    @property\n    def table_url(self) -> str:\n        \"\"\"Get the Table API URL.\"\"\"\n        return f\"{self.base_url}{self.TABLE_API_PATH}/{self.config.table}\"\n\n    async def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Get authentication headers for ServiceNow API requests.\"\"\"\n        import base64\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        }\n\n        if self.config.auth_type == ServiceNowAuthType.BASIC:\n            credentials = (\n                f\"{self.config.username}:\"\n                f\"{self.config.password.get_secret_value()}\"\n            )\n            encoded = base64.b64encode(credentials.encode()).decode()\n            headers[\"Authorization\"] = f\"Basic {encoded}\"\n        else:\n            # OAuth - ensure token is valid\n            await self._refresh_oauth_token()\n            if not self._access_token:\n                raise Exception(\"No access token available\")\n            headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n\n        return headers\n\n    async def _refresh_oauth_token(self) -> bool:\n        \"\"\"\n        Refresh OAuth access token if needed.\n\n        Returns:\n            True if token was refreshed or is still valid\n        \"\"\"\n        if self.config.auth_type != ServiceNowAuthType.OAUTH:\n            return True\n\n        # Check if token is still valid (with 5 minute buffer)\n        if self._access_token and self._token_expires_at:\n            if datetime.now(timezone.utc) < self._token_expires_at:\n                return True\n\n        logger.debug(\"Refreshing OAuth token for ServiceNow\")\n\n        try:\n            client = await self._get_client()\n            token_url = f\"{self.base_url}{self.OAUTH_TOKEN_PATH}\"\n\n            response = await client.post(\n                token_url,\n                data={\n                    \"grant_type\": \"client_credentials\",\n                    \"client_id\": self.config.client_id,\n                    \"client_secret\": self.config.client_secret.get_secret_value(),\n                },\n            )\n\n            if response.status_code == 200:\n                token_data = response.json()\n                self._access_token = token_data.get(\"access_token\")\n                expires_in = int(token_data.get(\"expires_in\", 3600))\n                # Set expiry with 5 minute buffer\n                from datetime import timedelta\n\n                self._token_expires_at = datetime.now(timezone.utc) + timedelta(seconds=expires_in - 300)\n                logger.debug(\"OAuth token refreshed for ServiceNow\")\n                return True\n            else:\n                logger.error(f\"Failed to refresh OAuth token: HTTP {response.status_code}\")\n                return False\n\n        except Exception as e:\n            logger.error(f\"Error refreshing OAuth token: {str(e)}\")\n            return False\n\n    async def _get_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._client is None:\n            self._client = httpx.AsyncClient(\n                timeout=self.timeout,\n                follow_redirects=True,\n            )\n        return self._client\n\n    async def test_connection(self) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        Test connection to ServiceNow and verify credentials.\n\n        Returns:\n            Tuple of (success, error_message)\n        \"\"\"\n        logger.debug(f\"Testing ServiceNow connection to {self.config.instance}\")\n\n        try:\n            client = await self._get_client()\n\n            # Verify credentials by fetching from sys_user table (limited to 1 result)\n            test_url = f\"{self.base_url}{self.TABLE_API_PATH}/sys_user\"\n            headers = await self._get_auth_headers()\n            params = {\"sysparm_limit\": \"1\"}\n\n            response = await client.get(\n                test_url,\n                headers=headers,\n                params=params,\n            )\n\n            if response.status_code == 200:\n                logger.info(f\"ServiceNow connection successful to {self.config.instance}\")\n                return True, None\n\n            elif response.status_code == 401:\n                error_msg = \"Invalid credentials - check username and password\"\n                logger.error(f\"ServiceNow authentication failed: {error_msg}\")\n                return False, error_msg\n\n            elif response.status_code == 403:\n                error_msg = \"Access denied - check user permissions\"\n                logger.error(f\"ServiceNow authentication failed: {error_msg}\")\n                return False, error_msg\n\n            else:\n                error_msg = f\"Unexpected response: HTTP {response.status_code}\"\n                logger.error(f\"ServiceNow connection test failed: {error_msg}\")\n                return False, error_msg\n\n        except httpx.TimeoutException as e:\n            error_msg = f\"Connection timed out: {str(e)}\"\n            logger.error(f\"ServiceNow connection test failed: {error_msg}\")\n            return False, error_msg\n\n        except httpx.NetworkError as e:\n            error_msg = f\"Network error: {str(e)}\"\n            logger.error(f\"ServiceNow connection test failed: {error_msg}\")\n            return False, error_msg\n\n        except Exception as e:\n            error_msg = f\"Unexpected error: {str(e)}\"\n            logger.error(f\"ServiceNow connection test failed: {error_msg}\")\n            return False, error_msg\n\n    async def preview_import(\n        self,\n        source_config: Optional[SourceConfig] = None,\n        max_items: int = DEFAULT_PREVIEW_LIMIT,\n    ) -> PreviewResponse:\n        \"\"\"\n        Fetch a preview of items available for import.\n\n        Args:\n            source_config: Optional source configuration with filters\n            max_items: Maximum number of items to include in preview\n\n        Returns:\n            PreviewResponse with sample items and statistics\n\n        Raises:\n            Exception: If preview fails\n        \"\"\"\n        logger.debug(\n            f\"Fetching ServiceNow preview for table {self.config.table} \"\n            f\"(max {max_items} items)\"\n        )\n\n        try:\n            # Build query filter\n            query = self._build_query_filter(source_config)\n\n            # Fetch records\n            records, total = await self._fetch_records(\n                query=query,\n                limit=max_items,\n                offset=0,\n            )\n\n            # Transform to preview items\n            preview_items = [\n                self._transform_to_preview_item(record) for record in records\n            ]\n\n            # Collect statistics\n            item_type_counts: Dict[str, int] = {}\n            status_counts: Dict[str, int] = {}\n\n            for item in preview_items:\n                # Count by type\n                item_type = item.item_type\n                item_type_counts[item_type] = item_type_counts.get(item_type, 0) + 1\n\n                # Count by status\n                if item.status:\n                    status_counts[item.status] = status_counts.get(item.status, 0) + 1\n\n            # Collect warnings\n            warnings = []\n            if total > 1000:\n                warnings.append(\n                    f\"Large dataset ({total} items) will be processed in batches\"\n                )\n\n            logger.info(\n                f\"ServiceNow preview successful: {len(preview_items)} items \"\n                f\"({total} total available)\"\n            )\n\n            return PreviewResponse(\n                source_type=SourceType.SERVICENOW,\n                total_available=total,\n                preview_items=preview_items,\n                preview_count=len(preview_items),\n                source_name=f\"{self.config.table.title()} Table\",\n                source_url=f\"{self.base_url}/nav_to.do?uri={self.config.table}_list.do\",\n                item_type_counts=item_type_counts,\n                status_counts=status_counts,\n                warnings=warnings,\n            )\n\n        except Exception as e:\n            logger.error(f\"ServiceNow preview failed: {str(e)}\")\n            raise\n\n    async def fetch_items(\n        self,\n        source_config: Optional[SourceConfig] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n        max_items: Optional[int] = None,\n        progress_callback: Optional[callable] = None,\n    ) -> List[ImportedItem]:\n        \"\"\"\n        Fetch all items for import with batching and progress tracking.\n\n        Args:\n            source_config: Optional source configuration with filters\n            batch_size: Number of items to fetch per batch\n            max_items: Maximum total items to fetch (None = all)\n            progress_callback: Optional callback for progress updates\n                               callback(progress: ImportProgress) -> None\n\n        Returns:\n            List of ImportedItem objects ready for import\n\n        Raises:\n            Exception: If fetch fails\n        \"\"\"\n        logger.debug(\n            f\"Fetching ServiceNow items for table {self.config.table} \"\n            f\"(batch_size={batch_size}, max_items={max_items})\"\n        )\n\n        # Build query filter\n        query = self._build_query_filter(source_config)\n\n        # Get total count first\n        _, total = await self._fetch_records(query=query, limit=0, offset=0)\n\n        # Apply max_items limit\n        if max_items is not None:\n            total = min(total, max_items)\n\n        logger.info(f\"Fetching {total} items from ServiceNow in batches of {batch_size}\")\n\n        # Initialize progress\n        progress = ImportProgress(\n            total_items=total,\n            processed_items=0,\n            successful_items=0,\n            failed_items=0,\n            skipped_items=0,\n            percentage=0.0,\n            total_batches=(total + batch_size - 1) // batch_size if total > 0 else 0,\n            current_batch=0,\n        )\n\n        imported_items: List[ImportedItem] = []\n        offset = 0\n\n        # Fetch in batches\n        while offset < total:\n            current_batch_size = min(batch_size, total - offset)\n            progress.current_batch += 1\n\n            logger.debug(\n                f\"Fetching batch {progress.current_batch}/{progress.total_batches} \"\n                f\"(items {offset + 1}-{offset + current_batch_size})\"\n            )\n\n            try:\n                records, _ = await self._fetch_records(\n                    query=query,\n                    limit=current_batch_size,\n                    offset=offset,\n                )\n\n                # Transform to imported items\n                for record in records:\n                    try:\n                        item = self._transform_to_imported_item(record)\n                        imported_items.append(item)\n                        progress.successful_items += 1\n                    except Exception as e:\n                        logger.error(\n                            f\"Failed to transform record {record.get('number', 'unknown')}: {str(e)}\"\n                        )\n                        progress.failed_items += 1\n\n                progress.processed_items = offset + len(records)\n\n            except Exception as e:\n                logger.error(f\"Batch {progress.current_batch} failed: {str(e)}\")\n                progress.failed_items += current_batch_size\n\n            # Update progress\n            progress.percentage = (\n                (progress.processed_items / total * 100.0) if total > 0 else 100.0\n            )\n\n            # Call progress callback if provided\n            if progress_callback:\n                progress_callback(progress)\n\n            offset += current_batch_size\n\n        logger.info(\n            f\"ServiceNow fetch complete: {progress.successful_items} successful, \"\n            f\"{progress.failed_items} failed\"\n        )\n\n        return imported_items\n\n    def _build_query_filter(self, source_config: Optional[SourceConfig] = None) -> str:\n        \"\"\"\n        Build ServiceNow query filter from configuration.\n\n        Args:\n            source_config: Optional source configuration with filters\n\n        Returns:\n            ServiceNow sysparm_query filter string\n        \"\"\"\n        query_parts = []\n\n        # Add custom query if provided\n        if self.config.query_filter:\n            query_parts.append(self.config.query_filter)\n\n        # Add state filter\n        if self.config.states:\n            states_str = \",\".join(self.config.states)\n            query_parts.append(f\"stateIN{states_str}\")\n\n        # Add assignment group filter\n        if self.config.assignment_groups:\n            groups_str = \",\".join(self.config.assignment_groups)\n            query_parts.append(f\"assignment_groupIN{groups_str}\")\n\n        # Add filters from source_config if provided\n        if source_config:\n            # Status filter (maps to state in ServiceNow)\n            if source_config.status_filter:\n                statuses = \",\".join(source_config.status_filter)\n                query_parts.append(f\"stateIN{statuses}\")\n\n            # Date filters\n            if source_config.date_from:\n                date_str = source_config.date_from.strftime(\"%Y-%m-%d %H:%M:%S\")\n                query_parts.append(f\"sys_created_on>={date_str}\")\n\n            if source_config.date_to:\n                date_str = source_config.date_to.strftime(\"%Y-%m-%d %H:%M:%S\")\n                query_parts.append(f\"sys_created_on<={date_str}\")\n\n        # Join with ^ (AND operator in ServiceNow)\n        query = \"^\".join(query_parts) if query_parts else \"\"\n\n        logger.debug(f\"Built ServiceNow query: {query}\")\n        return query\n\n    async def _fetch_records(\n        self,\n        query: str,\n        limit: int,\n        offset: int = 0,\n    ) -> Tuple[List[Dict[str, Any]], int]:\n        \"\"\"\n        Fetch records from ServiceNow table.\n\n        Args:\n            query: ServiceNow query filter string\n            limit: Maximum number of results to return\n            offset: Pagination offset\n\n        Returns:\n            Tuple of (records list, total count)\n\n        Raises:\n            Exception: If fetch fails\n        \"\"\"\n        client = await self._get_client()\n        headers = await self._get_auth_headers()\n\n        params: Dict[str, Any] = {\n            \"sysparm_offset\": offset,\n            \"sysparm_limit\": min(limit, self.MAX_RESULTS_PER_PAGE) if limit > 0 else 1,\n            \"sysparm_display_value\": \"true\",  # Get display values instead of sys_ids\n            \"sysparm_exclude_reference_link\": \"true\",  # Exclude reference links\n        }\n\n        if query:\n            params[\"sysparm_query\"] = query\n\n        # For count-only requests\n        if limit == 0:\n            params[\"sysparm_count\"] = \"true\"\n\n        response = await client.get(\n            self.table_url,\n            headers=headers,\n            params=params,\n        )\n\n        if response.status_code == 200:\n            # Get total count from headers\n            total = 0\n            if \"x-total-count\" in response.headers:\n                total = int(response.headers[\"x-total-count\"])\n\n            data = response.json()\n            records = data.get(\"result\", [])\n\n            logger.debug(\n                f\"Fetched {len(records)} records (total available: {total})\"\n            )\n\n            return records, total\n\n        elif response.status_code == 401:\n            raise Exception(\"Authentication failed - credentials may be expired\")\n\n        elif response.status_code == 403:\n            raise Exception(\"Access denied - user lacks permission to read table\")\n\n        elif response.status_code == 400:\n            error_msg = \"Invalid query or parameters\"\n            try:\n                error_data = response.json()\n                if \"error\" in error_data:\n                    error_msg = error_data[\"error\"].get(\"message\", error_msg)\n            except Exception:\n                pass\n            raise Exception(error_msg)\n\n        else:\n            raise Exception(f\"Failed to fetch records: HTTP {response.status_code}\")\n\n    def _transform_to_preview_item(self, record: Dict[str, Any]) -> PreviewItem:\n        \"\"\"\n        Transform a ServiceNow record to a PreviewItem.\n\n        Args:\n            record: ServiceNow record data from API\n\n        Returns:\n            PreviewItem for display\n        \"\"\"\n        # Parse dates\n        created_at = None\n        updated_at = None\n\n        if record.get(\"sys_created_on\"):\n            try:\n                created_at = datetime.fromisoformat(\n                    record[\"sys_created_on\"].replace(\" \", \"T\")\n                )\n            except Exception:\n                pass\n\n        if record.get(\"sys_updated_on\"):\n            try:\n                updated_at = datetime.fromisoformat(\n                    record[\"sys_updated_on\"].replace(\" \", \"T\")\n                )\n            except Exception:\n                pass\n\n        # Get assignee (display value)\n        assignee = record.get(\"assigned_to\")\n\n        # Get status/state (display value)\n        status = record.get(\"state\")\n\n        # Get labels/category\n        labels = []\n        if record.get(\"category\"):\n            labels.append(record[\"category\"])\n        if record.get(\"subcategory\"):\n            labels.append(record[\"subcategory\"])\n\n        # Determine item type based on table\n        item_type = self.config.table.replace(\"_\", \" \").title()\n\n        return PreviewItem(\n            external_id=record.get(\"number\", record.get(\"sys_id\", \"\")),\n            item_type=item_type,\n            title=record.get(\"short_description\", \"Untitled\"),\n            status=status,\n            assignee=assignee,\n            created_at=created_at,\n            updated_at=updated_at,\n            labels=labels,\n            metadata={\n                \"priority\": record.get(\"priority\"),\n                \"impact\": record.get(\"impact\"),\n                \"urgency\": record.get(\"urgency\"),\n                \"assignment_group\": record.get(\"assignment_group\"),\n                \"caller\": record.get(\"caller_id\"),\n                \"description\": record.get(\"description\", \"\")[:200],  # First 200 chars\n            },\n        )\n\n    def _transform_to_imported_item(self, record: Dict[str, Any]) -> ImportedItem:\n        \"\"\"\n        Transform a ServiceNow record to an ImportedItem.\n\n        Args:\n            record: ServiceNow record data from API\n\n        Returns:\n            ImportedItem for import processing\n        \"\"\"\n        # Determine item type based on table\n        item_type = self.config.table.replace(\"_\", \" \").title()\n\n        return ImportedItem(\n            external_id=record.get(\"number\", record.get(\"sys_id\", \"\")),\n            internal_id=None,  # Will be set during import\n            item_type=item_type,\n            title=record.get(\"short_description\", \"Untitled\"),\n            status=\"pending\",  # Initial import status\n            error_message=None,\n        )\n\n    async def close(self) -> None:\n        \"\"\"Close the HTTP client and cleanup resources.\"\"\"\n        if self._client is not None:\n            await self._client.aclose()\n            self._client = None\n        self._access_token = None\n        self._token_expires_at = None\n        logger.debug(\"ServiceNow import service closed\")\n\n\nasync def create_servicenow_import_service(\n    source_config: SourceConfig,\n) -> ServiceNowImportService:\n    \"\"\"\n    Factory function to create a ServiceNowImportService from SourceConfig.\n\n    Args:\n        source_config: Generic source configuration\n\n    Returns:\n        Configured ServiceNowImportService\n\n    Raises:\n        ValueError: If required ServiceNow configuration is missing\n    \"\"\"\n    # Validate required fields for ServiceNow\n    if not source_config.instance:\n        raise ValueError(\"instance is required for ServiceNow import\")\n\n    # Determine auth type and validate credentials\n    auth_type = ServiceNowAuthType.BASIC\n    if source_config.username and source_config.password:\n        auth_type = ServiceNowAuthType.BASIC\n    elif source_config.api_token:\n        # Treat api_token as OAuth credentials if formatted as client_id:client_secret\n        token_str = source_config.api_token.get_secret_value()\n        if \":\" in token_str:\n            auth_type = ServiceNowAuthType.OAUTH\n        else:\n            raise ValueError(\n                \"For OAuth, api_token should be in format 'client_id:client_secret', \"\n                \"or use username/password for basic auth\"\n            )\n    else:\n        raise ValueError(\n            \"Either username/password or api_token (OAuth) is required for ServiceNow import\"\n        )\n\n    # Build ServiceNow config\n    config_dict = {\n        \"instance\": source_config.instance,\n        \"auth_type\": auth_type,\n    }\n\n    if auth_type == ServiceNowAuthType.BASIC:\n        config_dict[\"username\"] = source_config.username\n        config_dict[\"password\"] = source_config.password\n    else:\n        # Parse OAuth credentials from api_token\n        token_str = source_config.api_token.get_secret_value()\n        client_id, client_secret = token_str.split(\":\", 1)\n        config_dict[\"client_id\"] = client_id\n        config_dict[\"client_secret\"] = SecretStr(client_secret)\n\n    # Add optional table configuration\n    if source_config.project_key:\n        # Use project_key as table name if provided\n        config_dict[\"table\"] = source_config.project_key\n\n    config = ServiceNowImportConfig(**config_dict)\n\n    return ServiceNowImportService(config)\n",
        "last_modified": "2026-01-03T19:09:00.299895"
      },
      "task_intent": {
        "title": "003-import-your-data",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T17:00:00.309754",
  "last_updated": "2026-01-03T17:00:00.311445"
}