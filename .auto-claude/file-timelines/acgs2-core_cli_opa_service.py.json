{
  "file_path": "src/core/cli/opa_service.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nACGS-2 CLI OPA Service\n\nProvides OPA (Open Policy Agent) integration for CLI policy validation and testing.\nFollows patterns from enhanced_agent_bus/opa_client.py but simplified for CLI use cases.\n\"\"\"\n\nimport json\nimport logging\nimport os\nimport re\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass PolicyValidationResult:\n    \"\"\"Result of policy validation.\"\"\"\n\n    is_valid: bool\n    errors: List[str] = field(default_factory=list)\n    warnings: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    def add_error(self, error: str) -> None:\n        \"\"\"Add an error to the result.\"\"\"\n        self.errors.append(error)\n        self.is_valid = False\n\n    def add_warning(self, warning: str) -> None:\n        \"\"\"Add a warning to the result.\"\"\"\n        self.warnings.append(warning)\n\n\n@dataclass\nclass PolicyEvaluationResult:\n    \"\"\"Result of policy evaluation.\"\"\"\n\n    success: bool\n    result: Any = None\n    allowed: Optional[bool] = None\n    reason: str = \"\"\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\nclass OPAServiceError(Exception):\n    \"\"\"Base exception for OPA service errors.\"\"\"\n\n    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None) -> None:\n        self.message = message\n        self.details = details or {}\n        super().__init__(self.message)\n\n\nclass OPAConnectionError(OPAServiceError):\n    \"\"\"Raised when connection to OPA server fails.\"\"\"\n\n    def __init__(self, opa_url: str, reason: str) -> None:\n        self.opa_url = opa_url\n        self.reason = reason\n        super().__init__(\n            message=f\"Failed to connect to OPA at '{opa_url}': {reason}\",\n            details={\"opa_url\": opa_url, \"reason\": reason},\n        )\n\n\nclass OPAService:\n    \"\"\"\n    OPA Service for CLI policy operations.\n\n    Provides simplified OPA integration for:\n    - Policy syntax validation\n    - Policy evaluation against input data\n    - Health checks\n\n    Follows the patterns from enhanced_agent_bus/opa_client.py\n    but focused on CLI use cases without caching or embedded mode.\n    \"\"\"\n\n    DEFAULT_OPA_URL = \"http://localhost:8181\"\n\n    def __init__(\n        self,\n        opa_url: Optional[str] = None,\n        timeout: float = 10.0,\n    ):\n        \"\"\"\n        Initialize OPA service.\n\n        Args:\n            opa_url: OPA server URL. Defaults to OPA_URL env var or http://localhost:8181\n            timeout: Request timeout in seconds\n        \"\"\"\n        self.opa_url = (opa_url or os.getenv(\"OPA_URL\", self.DEFAULT_OPA_URL)).rstrip(\"/\")\n        self.timeout = timeout\n        self._client: Optional[httpx.Client] = None\n        self._async_client: Optional[httpx.AsyncClient] = None\n\n    def __enter__(self) -> \"OPAService\":\n        \"\"\"Context manager entry - initialize sync client.\"\"\"\n        self._ensure_client()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -> None:\n        \"\"\"Context manager exit - close sync client.\"\"\"\n        self.close()\n\n    async def __aenter__(self) -> \"OPAService\":\n        \"\"\"Async context manager entry - initialize async client.\"\"\"\n        await self._ensure_async_client()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:\n        \"\"\"Async context manager exit - close async client.\"\"\"\n        await self.aclose()\n\n    def _ensure_client(self) -> httpx.Client:\n        \"\"\"Ensure sync HTTP client is initialized.\"\"\"\n        if self._client is None:\n            self._client = httpx.Client(\n                timeout=self.timeout,\n                limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),\n            )\n        return self._client\n\n    async def _ensure_async_client(self) -> httpx.AsyncClient:\n        \"\"\"Ensure async HTTP client is initialized.\"\"\"\n        if self._async_client is None:\n            self._async_client = httpx.AsyncClient(\n                timeout=self.timeout,\n                limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),\n            )\n        return self._async_client\n\n    def close(self) -> None:\n        \"\"\"Close sync HTTP client.\"\"\"\n        if self._client:\n            self._client.close()\n            self._client = None\n\n    async def aclose(self) -> None:\n        \"\"\"Close async HTTP client.\"\"\"\n        if self._async_client:\n            await self._async_client.aclose()\n            self._async_client = None\n\n    def _sanitize_error(self, error: Exception) -> str:\n        \"\"\"Strip sensitive metadata from error messages.\"\"\"\n        error_msg = str(error)\n        error_msg = re.sub(r\"key=[^&\\s]+\", \"key=REDACTED\", error_msg)\n        error_msg = re.sub(r\"token=[^&\\s]+\", \"token=REDACTED\", error_msg)\n        error_msg = re.sub(r\"https?://[^:\\s]+:[^@\\s]+@\", \"http://REDACTED@\", error_msg)\n        return error_msg\n\n    def _parse_opa_error(self, response: httpx.Response) -> List[str]:\n        \"\"\"Parse OPA error response into user-friendly error messages.\"\"\"\n        errors = []\n        try:\n            data = response.json()\n            if \"errors\" in data:\n                for error in data[\"errors\"]:\n                    msg = error.get(\"message\", str(error))\n                    location = error.get(\"location\", {})\n                    if location:\n                        line = location.get(\"row\", \"?\")\n                        col = location.get(\"col\", \"?\")\n                        msg = f\"Line {line}, Col {col}: {msg}\"\n                    errors.append(msg)\n            elif \"error\" in data:\n                errors.append(data[\"error\"])\n            elif \"code\" in data and \"message\" in data:\n                errors.append(f\"{data['code']}: {data['message']}\")\n        except json.JSONDecodeError:\n            errors.append(response.text or f\"HTTP {response.status_code}\")\n        return errors if errors else [f\"OPA error: HTTP {response.status_code}\"]\n\n    def health_check(self) -> Dict[str, Any]:\n        \"\"\"\n        Check OPA server health (sync).\n\n        Returns:\n            Dict with status and details\n        \"\"\"\n        try:\n            client = self._ensure_client()\n            response = client.get(f\"{self.opa_url}/health\", timeout=2.0)\n            if response.status_code == 200:\n                return {\"status\": \"healthy\", \"opa_url\": self.opa_url}\n            return {\n                \"status\": \"unhealthy\",\n                \"opa_url\": self.opa_url,\n                \"http_status\": response.status_code,\n            }\n        except httpx.ConnectError as e:\n            return {\n                \"status\": \"unreachable\",\n                \"opa_url\": self.opa_url,\n                \"error\": self._sanitize_error(e),\n            }\n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"opa_url\": self.opa_url,\n                \"error\": self._sanitize_error(e),\n            }\n\n    async def async_health_check(self) -> Dict[str, Any]:\n        \"\"\"\n        Check OPA server health (async).\n\n        Returns:\n            Dict with status and details\n        \"\"\"\n        try:\n            client = await self._ensure_async_client()\n            response = await client.get(f\"{self.opa_url}/health\", timeout=2.0)\n            if response.status_code == 200:\n                return {\"status\": \"healthy\", \"opa_url\": self.opa_url}\n            return {\n                \"status\": \"unhealthy\",\n                \"opa_url\": self.opa_url,\n                \"http_status\": response.status_code,\n            }\n        except httpx.ConnectError as e:\n            return {\n                \"status\": \"unreachable\",\n                \"opa_url\": self.opa_url,\n                \"error\": self._sanitize_error(e),\n            }\n        except Exception as e:\n            return {\n                \"status\": \"error\",\n                \"opa_url\": self.opa_url,\n                \"error\": self._sanitize_error(e),\n            }\n\n    def validate_policy(self, policy_content: str) -> PolicyValidationResult:\n        \"\"\"\n        Validate Rego policy syntax (sync).\n\n        Uses OPA's /v1/compile endpoint to check policy syntax without\n        actually deploying the policy.\n\n        Args:\n            policy_content: Rego policy content as string\n\n        Returns:\n            PolicyValidationResult with validation status and any errors\n        \"\"\"\n        result = PolicyValidationResult(is_valid=True)\n\n        if not policy_content.strip():\n            result.add_error(\"Policy content is empty\")\n            return result\n\n        try:\n            client = self._ensure_client()\n\n            # Upload policy to a temporary location for full validation\n            temp_policy_id = \"_cli_validation_temp\"\n            put_response = client.put(\n                f\"{self.opa_url}/v1/policies/{temp_policy_id}\",\n                content=policy_content,\n                headers={\"Content-Type\": \"text/plain\"},\n            )\n\n            if put_response.status_code == 200:\n                result.is_valid = True\n                result.metadata[\"validated_via\"] = \"policy_upload\"\n\n                # Clean up temporary policy\n                try:\n                    client.delete(f\"{self.opa_url}/v1/policies/{temp_policy_id}\")\n                except Exception:\n                    pass  # Ignore cleanup errors\n            else:\n                result.is_valid = False\n                result.errors = self._parse_opa_error(put_response)\n                result.metadata[\"validated_via\"] = \"policy_upload\"\n\n        except httpx.ConnectError as e:\n            raise OPAConnectionError(\n                self.opa_url,\n                \"OPA server not reachable. Start with: \"\n                \"docker run -p 8181:8181 openpolicyagent/opa run --server\",\n            ) from e\n        except Exception as e:\n            result.add_error(f\"Validation failed: {self._sanitize_error(e)}\")\n            result.metadata[\"error_type\"] = type(e).__name__\n\n        return result\n\n    async def async_validate_policy(self, policy_content: str) -> PolicyValidationResult:\n        \"\"\"\n        Validate Rego policy syntax (async).\n\n        Uses OPA's /v1/compile endpoint to check policy syntax without\n        actually deploying the policy.\n\n        Args:\n            policy_content: Rego policy content as string\n\n        Returns:\n            PolicyValidationResult with validation status and any errors\n        \"\"\"\n        result = PolicyValidationResult(is_valid=True)\n\n        if not policy_content.strip():\n            result.add_error(\"Policy content is empty\")\n            return result\n\n        try:\n            client = await self._ensure_async_client()\n\n            # Try uploading policy to a temporary location for full validation\n            temp_policy_id = \"_cli_validation_temp\"\n            put_response = await client.put(\n                f\"{self.opa_url}/v1/policies/{temp_policy_id}\",\n                content=policy_content,\n                headers={\"Content-Type\": \"text/plain\"},\n            )\n\n            if put_response.status_code == 200:\n                result.is_valid = True\n                result.metadata[\"validated_via\"] = \"policy_upload\"\n\n                # Clean up temporary policy\n                try:\n                    await client.delete(f\"{self.opa_url}/v1/policies/{temp_policy_id}\")\n                except Exception:\n                    pass  # Ignore cleanup errors\n            else:\n                result.is_valid = False\n                result.errors = self._parse_opa_error(put_response)\n                result.metadata[\"validated_via\"] = \"policy_upload\"\n\n        except httpx.ConnectError as e:\n            raise OPAConnectionError(\n                self.opa_url,\n                \"OPA server not reachable. Start with: \"\n                \"docker run -p 8181:8181 openpolicyagent/opa run --server\",\n            ) from e\n        except Exception as e:\n            result.add_error(f\"Validation failed: {self._sanitize_error(e)}\")\n            result.metadata[\"error_type\"] = type(e).__name__\n\n        return result\n\n    def evaluate_policy(\n        self,\n        policy_content: str,\n        input_data: Dict[str, Any],\n        policy_path: str = \"data\",\n    ) -> PolicyEvaluationResult:\n        \"\"\"\n        Evaluate policy against input data (sync).\n\n        Temporarily uploads the policy, evaluates it, then removes it.\n\n        Args:\n            policy_content: Rego policy content as string\n            input_data: Input data for policy evaluation\n            policy_path: Policy data path to query (default: \"data\")\n\n        Returns:\n            PolicyEvaluationResult with evaluation results\n        \"\"\"\n        result = PolicyEvaluationResult(success=False)\n\n        try:\n            client = self._ensure_client()\n            temp_policy_id = \"_cli_eval_temp\"\n\n            # Upload policy\n            put_response = client.put(\n                f\"{self.opa_url}/v1/policies/{temp_policy_id}\",\n                content=policy_content,\n                headers={\"Content-Type\": \"text/plain\"},\n            )\n\n            if put_response.status_code != 200:\n                result.reason = \"Policy upload failed\"\n                result.metadata[\"errors\"] = self._parse_opa_error(put_response)\n                return result\n\n            try:\n                # Evaluate policy - wrap input in \"input\" key as per OPA API\n                path_parts = policy_path.replace(\"data.\", \"\").replace(\".\", \"/\")\n                eval_url = (\n                    f\"{self.opa_url}/v1/data/{path_parts}\"\n                    if path_parts\n                    else f\"{self.opa_url}/v1/data\"\n                )\n\n                eval_response = client.post(\n                    eval_url,\n                    json={\"input\": input_data},\n                    headers={\"Content-Type\": \"application/json\"},\n                )\n\n                if eval_response.status_code == 200:\n                    data = eval_response.json()\n                    opa_result = data.get(\"result\", {})\n\n                    result.success = True\n                    result.result = opa_result\n                    result.reason = \"Policy evaluated successfully\"\n\n                    # Extract 'allow' if present\n                    if isinstance(opa_result, dict) and \"allow\" in opa_result:\n                        result.allowed = opa_result.get(\"allow\", False)\n                    elif isinstance(opa_result, bool):\n                        result.allowed = opa_result\n\n                    result.metadata[\"policy_path\"] = policy_path\n                else:\n                    result.reason = \"Evaluation failed\"\n                    result.metadata[\"errors\"] = self._parse_opa_error(eval_response)\n\n            finally:\n                # Clean up policy\n                try:\n                    client.delete(f\"{self.opa_url}/v1/policies/{temp_policy_id}\")\n                except Exception:\n                    pass\n\n        except httpx.ConnectError as e:\n            raise OPAConnectionError(\n                self.opa_url,\n                \"OPA server not reachable. Start with: \"\n                \"docker run -p 8181:8181 openpolicyagent/opa run --server\",\n            ) from e\n        except Exception as e:\n            result.reason = f\"Evaluation error: {self._sanitize_error(e)}\"\n            result.metadata[\"error_type\"] = type(e).__name__\n\n        return result\n\n    async def async_evaluate_policy(\n        self,\n        policy_content: str,\n        input_data: Dict[str, Any],\n        policy_path: str = \"data\",\n    ) -> PolicyEvaluationResult:\n        \"\"\"\n        Evaluate policy against input data (async).\n\n        Temporarily uploads the policy, evaluates it, then removes it.\n\n        Args:\n            policy_content: Rego policy content as string\n            input_data: Input data for policy evaluation\n            policy_path: Policy data path to query (default: \"data\")\n\n        Returns:\n            PolicyEvaluationResult with evaluation results\n        \"\"\"\n        result = PolicyEvaluationResult(success=False)\n\n        try:\n            client = await self._ensure_async_client()\n            temp_policy_id = \"_cli_eval_temp\"\n\n            # Upload policy\n            put_response = await client.put(\n                f\"{self.opa_url}/v1/policies/{temp_policy_id}\",\n                content=policy_content,\n                headers={\"Content-Type\": \"text/plain\"},\n            )\n\n            if put_response.status_code != 200:\n                result.reason = \"Policy upload failed\"\n                result.metadata[\"errors\"] = self._parse_opa_error(put_response)\n                return result\n\n            try:\n                # Evaluate policy - wrap input in \"input\" key as per OPA API\n                path_parts = policy_path.replace(\"data.\", \"\").replace(\".\", \"/\")\n                eval_url = (\n                    f\"{self.opa_url}/v1/data/{path_parts}\"\n                    if path_parts\n                    else f\"{self.opa_url}/v1/data\"\n                )\n\n                eval_response = await client.post(\n                    eval_url,\n                    json={\"input\": input_data},\n                    headers={\"Content-Type\": \"application/json\"},\n                )\n\n                if eval_response.status_code == 200:\n                    data = eval_response.json()\n                    opa_result = data.get(\"result\", {})\n\n                    result.success = True\n                    result.result = opa_result\n                    result.reason = \"Policy evaluated successfully\"\n\n                    # Extract 'allow' if present\n                    if isinstance(opa_result, dict) and \"allow\" in opa_result:\n                        result.allowed = opa_result.get(\"allow\", False)\n                    elif isinstance(opa_result, bool):\n                        result.allowed = opa_result\n\n                    result.metadata[\"policy_path\"] = policy_path\n                else:\n                    result.reason = \"Evaluation failed\"\n                    result.metadata[\"errors\"] = self._parse_opa_error(eval_response)\n\n            finally:\n                # Clean up policy\n                try:\n                    await client.delete(f\"{self.opa_url}/v1/policies/{temp_policy_id}\")\n                except Exception:\n                    pass\n\n        except httpx.ConnectError as e:\n            raise OPAConnectionError(\n                self.opa_url,\n                \"OPA server not reachable. Start with: \"\n                \"docker run -p 8181:8181 openpolicyagent/opa run --server\",\n            ) from e\n        except Exception as e:\n            result.reason = f\"Evaluation error: {self._sanitize_error(e)}\"\n            result.metadata[\"error_type\"] = type(e).__name__\n\n        return result\n\n    def get_connection_info(self) -> Dict[str, Any]:\n        \"\"\"Get OPA connection information.\"\"\"\n        return {\n            \"opa_url\": self.opa_url,\n            \"timeout\": self.timeout,\n            \"client_initialized\": self._client is not None,\n            \"async_client_initialized\": self._async_client is not None,\n        }\n\n\n__all__ = [\n    \"OPAService\",\n    \"OPAServiceError\",\n    \"OPAConnectionError\",\n    \"PolicyValidationResult\",\n    \"PolicyEvaluationResult\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.141170",
  "last_updated": "2026-01-04T05:35:59.141803"
}