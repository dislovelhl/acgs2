{
  "file_path": "acgs2-core/enhanced_agent_bus/verification/saga_transaction.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Enhanced Agent Bus - SagaLLM Transactions\nConstitutional Hash: cdd01ef066bc6cf2\n\nImplements compensable transaction guarantees for LLM workflows.\nBypasses self-verification limitations through LIFO rollback and formal checkpoints.\n\"\"\"\n\nimport logging\nimport uuid\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, Awaitable, Callable, Dict, List, Optional\n\ntry:\n    from shared.constants import CONSTITUTIONAL_HASH\nexcept ImportError:\n    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\nlogger = logging.getLogger(__name__)\n\nclass SagaStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    COMPENSATING = \"compensating\"\n    ROLLED_BACK = \"rolled_back\"\n    FAILED = \"failed\"\n\n@dataclass\nclass SagaStep:\n    \"\"\"A step in a Saga transaction.\"\"\"\n    name: str\n    action: Callable[..., Awaitable[Any]]\n    compensation: Optional[Callable[..., Awaitable[None]]] = None\n    status: SagaStatus = SagaStatus.PENDING\n    result: Optional[Any] = None\n    error: Optional[str] = None\n\nclass SagaTransaction:\n    \"\"\"\n    SagaLLM-inspired transaction manager.\n\n    Ensures that multi-step governance decisions are atomic and compensable.\n\n    Constitutional Hash: cdd01ef066bc6cf2\n    \"\"\"\n\n    def __init__(self, transaction_id: Optional[str] = None):\n        self.transaction_id = transaction_id or str(uuid.uuid4())\n        self.steps: List[SagaStep] = []\n        self.status = SagaStatus.PENDING\n        self._completed_steps: List[SagaStep] = []\n\n    def add_step(self, name: str, action: Callable[..., Awaitable[Any]], compensation: Optional[Callable[..., Awaitable[None]]] = None) -> \"SagaTransaction\":\n        \"\"\"Add a step to the transaction.\"\"\"\n        self.steps.append(SagaStep(name=name, action=action, compensation=compensation))\n        return self\n\n    async def execute(self, **kwargs) -> Any:\n        \"\"\"\n        Execute the transaction steps in order.\n        If a step fails, trigger compensation for all completed steps in LIFO order.\n        \"\"\"\n        self.status = SagaStatus.RUNNING\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Starting Saga transaction: {self.transaction_id}\")\n\n        last_result = None\n\n        for step in self.steps:\n            step.status = SagaStatus.RUNNING\n            logger.debug(f\"[{CONSTITUTIONAL_HASH}] Executing step: {step.name}\")\n\n            try:\n                # Execute step action, passing results from previous steps if needed\n                step.result = await step.action(**kwargs, last_result=last_result)\n                step.status = SagaStatus.COMPLETED\n                self._completed_steps.append(step)\n                last_result = step.result\n            except Exception as e:\n                logger.error(f\"[{CONSTITUTIONAL_HASH}] Step {step.name} failed: {e}\")\n                step.status = SagaStatus.FAILED\n                step.error = str(e)\n                await self._compensate()\n                self.status = SagaStatus.ROLLED_BACK\n                raise e\n\n        self.status = SagaStatus.COMPLETED\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Saga transaction completed: {self.transaction_id}\")\n        return last_result\n\n    async def _compensate(self):\n        \"\"\"Compensate completed steps in reverse order (LIFO).\"\"\"\n        self.status = SagaStatus.COMPENSATING\n        logger.warning(f\"[{CONSTITUTIONAL_HASH}] Starting compensation for transaction: {self.transaction_id}\")\n\n        for step in reversed(self._completed_steps):\n            if step.compensation:\n                logger.debug(f\"[{CONSTITUTIONAL_HASH}] Compensating step: {step.name}\")\n                try:\n                    await step.compensation(step.result)\n                except Exception as e:\n                    logger.error(f\"[{CONSTITUTIONAL_HASH}] Compensation for step {step.name} failed: {e}\")\n                    # In a real system, we might retry or escalate to manual intervention\n            else:\n                logger.debug(f\"[{CONSTITUTIONAL_HASH}] No compensation for step: {step.name}\")\n\n        logger.info(f\"[{CONSTITUTIONAL_HASH}] Compensation completed for transaction: {self.transaction_id}\")\n\nclass ConstitutionalSaga(SagaTransaction):\n    \"\"\"\n    Specialized Saga for constitutional governance.\n\n    Includes built-in validation and auditing.\n    \"\"\"\n\n    def __init__(self, auditor: Any = None):\n        super().__init__()\n        self.auditor = auditor\n\n    async def execute_governance(self, decision_data: Dict[str, Any]) -> Any:\n        \"\"\"Helper to run a standard governance transaction.\"\"\"\n        # This would be expanded with real governance steps\n        return await self.execute(data=decision_data)\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.290874",
  "last_updated": "2026-01-04T05:35:58.720891"
}