{
  "file_path": "integration-service/src/services/jira_import_service.py",
  "main_branch_history": [],
  "task_views": {
    "003-import-your-data": {
      "task_id": "003-import-your-data",
      "branch_point": {
        "commit_hash": "cc53a509f89115bbb36940c140031e6159320791",
        "content": "",
        "timestamp": "2026-01-03T17:00:00.287145"
      },
      "worktree_state": {
        "content": "\"\"\"\nJIRA Import Service\n\nHandles fetching and transforming JIRA data for import into ACGS2.\nSupports both preview mode (sample data) and full import operations.\n\nFeatures:\n- Fetches issues from JIRA projects\n- Transforms JIRA issues to ACGS2 format\n- Supports filtering by status, labels, and date ranges\n- Handles pagination for large datasets\n- Provides progress tracking for batch operations\n- Rate limit handling\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport httpx\nfrom pydantic import BaseModel, Field, SecretStr, field_validator\n\nfrom ..models.import_models import (\n    DuplicateHandling,\n    ImportedItem,\n    ImportProgress,\n    PreviewItem,\n    PreviewResponse,\n    SourceConfig,\n    SourceType,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass JiraImportConfig(BaseModel):\n    \"\"\"Configuration specific to JIRA import operations.\"\"\"\n\n    base_url: str = Field(..., description=\"JIRA instance URL\")\n    username: str = Field(..., description=\"JIRA username or email\")\n    api_token: SecretStr = Field(..., description=\"JIRA API token\")\n    project_key: str = Field(..., description=\"JIRA project key to import from\")\n\n    # Optional filters\n    jql_filter: Optional[str] = Field(\n        None,\n        description=\"Custom JQL filter for advanced filtering\"\n    )\n    issue_types: List[str] = Field(\n        default_factory=list,\n        description=\"Filter by issue types (e.g., ['Bug', 'Task'])\"\n    )\n\n    @field_validator(\"base_url\")\n    @classmethod\n    def validate_base_url(cls, v: str) -> str:\n        \"\"\"Validate and normalize base URL.\"\"\"\n        if not v:\n            raise ValueError(\"Base URL is required\")\n        v = v.strip().rstrip(\"/\")\n        if not v.startswith((\"https://\", \"http://\")):\n            raise ValueError(\"Base URL must start with http:// or https://\")\n        return v\n\n    @field_validator(\"project_key\")\n    @classmethod\n    def validate_project_key(cls, v: str) -> str:\n        \"\"\"Validate project key format.\"\"\"\n        if not v:\n            raise ValueError(\"Project key is required\")\n        v = v.strip().upper()\n        if not v.replace(\"_\", \"\").replace(\"-\", \"\").isalnum():\n            raise ValueError(\"Project key must be alphanumeric (may include _ or -)\")\n        return v\n\n\nclass JiraImportService:\n    \"\"\"\n    Service for importing data from JIRA.\n\n    Handles authentication, data fetching, and transformation of JIRA issues\n    into ACGS2 import format.\n\n    Usage:\n        config = JiraImportConfig(\n            base_url=\"https://your-domain.atlassian.net\",\n            username=\"your-email@example.com\",\n            api_token=SecretStr(\"your-api-token\"),\n            project_key=\"PROJ\",\n        )\n        service = JiraImportService(config)\n        await service.test_connection()\n        preview = await service.preview_import(max_items=10)\n        items = await service.fetch_items(batch_size=100)\n    \"\"\"\n\n    # JIRA REST API version\n    API_VERSION = \"3\"  # For JIRA Cloud\n\n    # Default limits\n    DEFAULT_PREVIEW_LIMIT = 10\n    DEFAULT_BATCH_SIZE = 100\n    MAX_RESULTS_PER_PAGE = 100  # JIRA API limit\n\n    def __init__(\n        self,\n        config: JiraImportConfig,\n        timeout: float = 30.0,\n        max_retries: int = 3,\n    ):\n        \"\"\"\n        Initialize JIRA import service.\n\n        Args:\n            config: JIRA import configuration\n            timeout: HTTP request timeout in seconds\n            max_retries: Maximum retry attempts for failed requests\n        \"\"\"\n        self.config = config\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self._client: Optional[httpx.AsyncClient] = None\n\n    @property\n    def api_base_url(self) -> str:\n        \"\"\"Get the base URL for JIRA REST API.\"\"\"\n        return f\"{self.config.base_url}/rest/api/{self.API_VERSION}\"\n\n    def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Get authentication headers for JIRA API requests.\"\"\"\n        import base64\n\n        credentials = (\n            f\"{self.config.username}:\"\n            f\"{self.config.api_token.get_secret_value()}\"\n        )\n        encoded = base64.b64encode(credentials.encode()).decode()\n\n        return {\n            \"Authorization\": f\"Basic {encoded}\",\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        }\n\n    async def _get_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client.\"\"\"\n        if self._client is None:\n            self._client = httpx.AsyncClient(\n                timeout=self.timeout,\n                follow_redirects=True,\n            )\n        return self._client\n\n    async def test_connection(self) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        Test connection to JIRA and verify credentials.\n\n        Returns:\n            Tuple of (success, error_message)\n        \"\"\"\n        logger.debug(f\"Testing JIRA connection to {self.config.base_url}\")\n\n        try:\n            client = await self._get_client()\n\n            # Verify credentials by fetching current user\n            myself_url = f\"{self.api_base_url}/myself\"\n            response = await client.get(\n                myself_url,\n                headers=self._get_auth_headers(),\n            )\n\n            if response.status_code == 200:\n                user_data = response.json()\n                display_name = user_data.get(\"displayName\", \"Unknown\")\n                logger.info(f\"JIRA connection successful (user: {display_name})\")\n                return True, None\n\n            elif response.status_code == 401:\n                error_msg = \"Invalid credentials - check username and API token\"\n                logger.error(f\"JIRA authentication failed: {error_msg}\")\n                return False, error_msg\n\n            elif response.status_code == 403:\n                error_msg = \"Access denied - check user permissions\"\n                logger.error(f\"JIRA authentication failed: {error_msg}\")\n                return False, error_msg\n\n            else:\n                error_msg = f\"Unexpected response: HTTP {response.status_code}\"\n                logger.error(f\"JIRA connection test failed: {error_msg}\")\n                return False, error_msg\n\n        except httpx.TimeoutException as e:\n            error_msg = f\"Connection timed out: {str(e)}\"\n            logger.error(f\"JIRA connection test failed: {error_msg}\")\n            return False, error_msg\n\n        except httpx.NetworkError as e:\n            error_msg = f\"Network error: {str(e)}\"\n            logger.error(f\"JIRA connection test failed: {error_msg}\")\n            return False, error_msg\n\n        except Exception as e:\n            error_msg = f\"Unexpected error: {str(e)}\"\n            logger.error(f\"JIRA connection test failed: {error_msg}\")\n            return False, error_msg\n\n    async def preview_import(\n        self,\n        source_config: Optional[SourceConfig] = None,\n        max_items: int = DEFAULT_PREVIEW_LIMIT,\n    ) -> PreviewResponse:\n        \"\"\"\n        Fetch a preview of items available for import.\n\n        Args:\n            source_config: Optional source configuration with filters\n            max_items: Maximum number of items to include in preview\n\n        Returns:\n            PreviewResponse with sample items and statistics\n\n        Raises:\n            Exception: If preview fails\n        \"\"\"\n        logger.debug(\n            f\"Fetching JIRA preview for project {self.config.project_key} \"\n            f\"(max {max_items} items)\"\n        )\n\n        try:\n            # Build JQL query\n            jql = self._build_jql_query(source_config)\n\n            # Fetch issues\n            issues, total = await self._fetch_issues(\n                jql=jql,\n                max_results=max_items,\n                start_at=0,\n            )\n\n            # Transform to preview items\n            preview_items = [\n                self._transform_to_preview_item(issue) for issue in issues\n            ]\n\n            # Collect statistics\n            item_type_counts: Dict[str, int] = {}\n            status_counts: Dict[str, int] = {}\n\n            for item in preview_items:\n                # Count by type\n                item_type = item.item_type\n                item_type_counts[item_type] = item_type_counts.get(item_type, 0) + 1\n\n                # Count by status\n                if item.status:\n                    status_counts[item.status] = status_counts.get(item.status, 0) + 1\n\n            # Collect warnings\n            warnings = []\n            if total > 1000:\n                warnings.append(\n                    f\"Large dataset ({total} items) will be processed in batches\"\n                )\n\n            logger.info(\n                f\"JIRA preview successful: {len(preview_items)} items \"\n                f\"({total} total available)\"\n            )\n\n            return PreviewResponse(\n                source_type=SourceType.JIRA,\n                total_available=total,\n                preview_items=preview_items,\n                preview_count=len(preview_items),\n                source_name=self.config.project_key,\n                source_url=f\"{self.config.base_url}/browse/{self.config.project_key}\",\n                item_type_counts=item_type_counts,\n                status_counts=status_counts,\n                warnings=warnings,\n            )\n\n        except Exception as e:\n            logger.error(f\"JIRA preview failed: {str(e)}\")\n            raise\n\n    async def fetch_items(\n        self,\n        source_config: Optional[SourceConfig] = None,\n        batch_size: int = DEFAULT_BATCH_SIZE,\n        max_items: Optional[int] = None,\n        progress_callback: Optional[callable] = None,\n    ) -> List[ImportedItem]:\n        \"\"\"\n        Fetch all items for import with batching and progress tracking.\n\n        Args:\n            source_config: Optional source configuration with filters\n            batch_size: Number of items to fetch per batch\n            max_items: Maximum total items to fetch (None = all)\n            progress_callback: Optional callback for progress updates\n                               callback(progress: ImportProgress) -> None\n\n        Returns:\n            List of ImportedItem objects ready for import\n\n        Raises:\n            Exception: If fetch fails\n        \"\"\"\n        logger.debug(\n            f\"Fetching JIRA items for project {self.config.project_key} \"\n            f\"(batch_size={batch_size}, max_items={max_items})\"\n        )\n\n        # Build JQL query\n        jql = self._build_jql_query(source_config)\n\n        # Get total count first\n        _, total = await self._fetch_issues(jql=jql, max_results=0, start_at=0)\n\n        # Apply max_items limit\n        if max_items is not None:\n            total = min(total, max_items)\n\n        logger.info(f\"Fetching {total} items from JIRA in batches of {batch_size}\")\n\n        # Initialize progress\n        progress = ImportProgress(\n            total_items=total,\n            processed_items=0,\n            successful_items=0,\n            failed_items=0,\n            skipped_items=0,\n            percentage=0.0,\n            total_batches=(total + batch_size - 1) // batch_size if total > 0 else 0,\n            current_batch=0,\n        )\n\n        imported_items: List[ImportedItem] = []\n        start_at = 0\n\n        # Fetch in batches\n        while start_at < total:\n            current_batch_size = min(batch_size, total - start_at)\n            progress.current_batch += 1\n\n            logger.debug(\n                f\"Fetching batch {progress.current_batch}/{progress.total_batches} \"\n                f\"(items {start_at + 1}-{start_at + current_batch_size})\"\n            )\n\n            try:\n                issues, _ = await self._fetch_issues(\n                    jql=jql,\n                    max_results=current_batch_size,\n                    start_at=start_at,\n                )\n\n                # Transform to imported items\n                for issue in issues:\n                    try:\n                        item = self._transform_to_imported_item(issue)\n                        imported_items.append(item)\n                        progress.successful_items += 1\n                    except Exception as e:\n                        logger.error(\n                            f\"Failed to transform issue {issue.get('key', 'unknown')}: {str(e)}\"\n                        )\n                        progress.failed_items += 1\n\n                progress.processed_items = start_at + len(issues)\n\n            except Exception as e:\n                logger.error(f\"Batch {progress.current_batch} failed: {str(e)}\")\n                progress.failed_items += current_batch_size\n\n            # Update progress\n            progress.percentage = (\n                (progress.processed_items / total * 100.0) if total > 0 else 100.0\n            )\n\n            # Call progress callback if provided\n            if progress_callback:\n                progress_callback(progress)\n\n            start_at += current_batch_size\n\n        logger.info(\n            f\"JIRA fetch complete: {progress.successful_items} successful, \"\n            f\"{progress.failed_items} failed\"\n        )\n\n        return imported_items\n\n    def _build_jql_query(self, source_config: Optional[SourceConfig] = None) -> str:\n        \"\"\"\n        Build JQL query from configuration and filters.\n\n        Args:\n            source_config: Optional source configuration with filters\n\n        Returns:\n            JQL query string\n        \"\"\"\n        # Start with project filter\n        jql_parts = [f\"project = {self.config.project_key}\"]\n\n        # Add custom JQL if provided\n        if self.config.jql_filter:\n            jql_parts.append(self.config.jql_filter)\n\n        # Add issue type filter\n        if self.config.issue_types:\n            issue_types_str = \", \".join(f'\"{t}\"' for t in self.config.issue_types)\n            jql_parts.append(f\"issuetype IN ({issue_types_str})\")\n\n        # Add filters from source_config if provided\n        if source_config:\n            # Status filter\n            if source_config.status_filter:\n                statuses = \", \".join(f'\"{s}\"' for s in source_config.status_filter)\n                jql_parts.append(f\"status IN ({statuses})\")\n\n            # Label filter\n            if source_config.label_filter:\n                for label in source_config.label_filter:\n                    jql_parts.append(f'labels = \"{label}\"')\n\n            # Date filters\n            if source_config.date_from:\n                date_str = source_config.date_from.strftime(\"%Y-%m-%d\")\n                jql_parts.append(f\"created >= {date_str}\")\n\n            if source_config.date_to:\n                date_str = source_config.date_to.strftime(\"%Y-%m-%d\")\n                jql_parts.append(f\"created <= {date_str}\")\n\n        # Order by created date (oldest first for consistent pagination)\n        jql_parts.append(\"ORDER BY created ASC\")\n\n        jql = \" AND \".join(jql_parts)\n        logger.debug(f\"Built JQL query: {jql}\")\n        return jql\n\n    async def _fetch_issues(\n        self,\n        jql: str,\n        max_results: int,\n        start_at: int = 0,\n    ) -> Tuple[List[Dict[str, Any]], int]:\n        \"\"\"\n        Fetch issues from JIRA using JQL query.\n\n        Args:\n            jql: JQL query string\n            max_results: Maximum number of results to return\n            start_at: Pagination offset\n\n        Returns:\n            Tuple of (issues list, total count)\n\n        Raises:\n            Exception: If fetch fails\n        \"\"\"\n        client = await self._get_client()\n\n        search_url = f\"{self.api_base_url}/search\"\n        params = {\n            \"jql\": jql,\n            \"startAt\": start_at,\n            \"maxResults\": min(max_results, self.MAX_RESULTS_PER_PAGE),\n            \"fields\": [\n                \"summary\",\n                \"description\",\n                \"status\",\n                \"assignee\",\n                \"reporter\",\n                \"priority\",\n                \"issuetype\",\n                \"created\",\n                \"updated\",\n                \"labels\",\n                \"components\",\n                \"resolution\",\n            ],\n        }\n\n        response = await client.get(\n            search_url,\n            headers=self._get_auth_headers(),\n            params=params,\n        )\n\n        if response.status_code == 200:\n            data = response.json()\n            issues = data.get(\"issues\", [])\n            total = data.get(\"total\", 0)\n\n            logger.debug(\n                f\"Fetched {len(issues)} issues (total available: {total})\"\n            )\n\n            return issues, total\n\n        elif response.status_code == 401:\n            raise Exception(\"Authentication failed - token may be expired\")\n\n        elif response.status_code == 400:\n            error_msg = \"Invalid JQL query or parameters\"\n            try:\n                error_data = response.json()\n                if \"errorMessages\" in error_data:\n                    error_msg = \"; \".join(error_data[\"errorMessages\"])\n            except Exception:\n                pass\n            raise Exception(error_msg)\n\n        else:\n            raise Exception(f\"Failed to fetch issues: HTTP {response.status_code}\")\n\n    def _transform_to_preview_item(self, issue: Dict[str, Any]) -> PreviewItem:\n        \"\"\"\n        Transform a JIRA issue to a PreviewItem.\n\n        Args:\n            issue: JIRA issue data from API\n\n        Returns:\n            PreviewItem for display\n        \"\"\"\n        fields = issue.get(\"fields\", {})\n\n        # Parse dates\n        created_at = None\n        updated_at = None\n\n        if fields.get(\"created\"):\n            try:\n                created_at = datetime.fromisoformat(\n                    fields[\"created\"].replace(\"Z\", \"+00:00\")\n                )\n            except Exception:\n                pass\n\n        if fields.get(\"updated\"):\n            try:\n                updated_at = datetime.fromisoformat(\n                    fields[\"updated\"].replace(\"Z\", \"+00:00\")\n                )\n            except Exception:\n                pass\n\n        # Get assignee\n        assignee = None\n        if fields.get(\"assignee\"):\n            assignee = fields[\"assignee\"].get(\"displayName\") or fields[\"assignee\"].get(\"name\")\n\n        # Get status\n        status = None\n        if fields.get(\"status\"):\n            status = fields[\"status\"].get(\"name\")\n\n        # Get labels\n        labels = fields.get(\"labels\", [])\n\n        # Get issue type\n        issue_type = \"Issue\"\n        if fields.get(\"issuetype\"):\n            issue_type = fields[\"issuetype\"].get(\"name\", \"Issue\")\n\n        return PreviewItem(\n            external_id=issue.get(\"key\", \"\"),\n            item_type=issue_type,\n            title=fields.get(\"summary\", \"Untitled\"),\n            status=status,\n            assignee=assignee,\n            created_at=created_at,\n            updated_at=updated_at,\n            labels=labels,\n            metadata={\n                \"priority\": fields.get(\"priority\", {}).get(\"name\") if fields.get(\"priority\") else None,\n                \"reporter\": fields.get(\"reporter\", {}).get(\"displayName\") if fields.get(\"reporter\") else None,\n                \"components\": [c.get(\"name\") for c in fields.get(\"components\", [])],\n                \"resolution\": fields.get(\"resolution\", {}).get(\"name\") if fields.get(\"resolution\") else None,\n            },\n        )\n\n    def _transform_to_imported_item(self, issue: Dict[str, Any]) -> ImportedItem:\n        \"\"\"\n        Transform a JIRA issue to an ImportedItem.\n\n        Args:\n            issue: JIRA issue data from API\n\n        Returns:\n            ImportedItem for import processing\n        \"\"\"\n        fields = issue.get(\"fields\", {})\n\n        # Get issue type\n        issue_type = \"Issue\"\n        if fields.get(\"issuetype\"):\n            issue_type = fields[\"issuetype\"].get(\"name\", \"Issue\")\n\n        return ImportedItem(\n            external_id=issue.get(\"key\", \"\"),\n            internal_id=None,  # Will be set during import\n            item_type=issue_type,\n            title=fields.get(\"summary\", \"Untitled\"),\n            status=\"pending\",  # Initial import status\n            error_message=None,\n        )\n\n    async def close(self) -> None:\n        \"\"\"Close the HTTP client and cleanup resources.\"\"\"\n        if self._client is not None:\n            await self._client.aclose()\n            self._client = None\n        logger.debug(\"JIRA import service closed\")\n\n\nasync def create_jira_import_service(\n    source_config: SourceConfig,\n) -> JiraImportService:\n    \"\"\"\n    Factory function to create a JiraImportService from SourceConfig.\n\n    Args:\n        source_config: Generic source configuration\n\n    Returns:\n        Configured JiraImportService\n\n    Raises:\n        ValueError: If required JIRA configuration is missing\n    \"\"\"\n    # Validate required fields for JIRA\n    if not source_config.base_url:\n        raise ValueError(\"base_url is required for JIRA import\")\n\n    if not source_config.username:\n        raise ValueError(\"username is required for JIRA import\")\n\n    if not source_config.api_key and not source_config.api_token:\n        raise ValueError(\"api_key or api_token is required for JIRA import\")\n\n    if not source_config.project_key:\n        raise ValueError(\"project_key is required for JIRA import\")\n\n    # Build JIRA config\n    api_token = source_config.api_key or source_config.api_token\n\n    config = JiraImportConfig(\n        base_url=source_config.base_url,\n        username=source_config.username,\n        api_token=api_token,  # type: ignore\n        project_key=source_config.project_key,\n    )\n\n    return JiraImportService(config)\n",
        "last_modified": "2026-01-03T19:09:00.299617"
      },
      "task_intent": {
        "title": "003-import-your-data",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T17:00:00.307810",
  "last_updated": "2026-01-03T17:00:00.309510"
}