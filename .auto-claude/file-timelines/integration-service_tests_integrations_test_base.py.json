{
  "file_path": "integration-service/tests/integrations/test_base.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nTests for BaseIntegration batch event processing.\n\nTests cover:\n- send_events_batch() success scenarios (all events succeed)\n- send_events_batch() failure scenarios (authentication, all events fail)\n- send_events_batch() partial success scenarios (some events succeed, some fail)\n- Metrics tracking for batch operations\n- Error handling and retry logic\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, List\n\nimport httpx\nimport pytest\nfrom pydantic import SecretStr\n\nfrom src.integrations.base import (\n    AuthenticationError,\n    BaseIntegration,\n    EventSeverity,\n    IntegrationCredentials,\n    IntegrationEvent,\n    IntegrationResult,\n    IntegrationStatus,\n    IntegrationType,\n)\n\nif TYPE_CHECKING:\n    pass\n\n\n# ============================================================================\n# Test Implementation of BaseIntegration\n# ============================================================================\n\n\nclass TestIntegrationCredentials(IntegrationCredentials):\n    \"\"\"Test credentials for BaseIntegration testing.\"\"\"\n\n    integration_type: IntegrationType = IntegrationType.SIEM\n    api_key: SecretStr = SecretStr(\"test-api-key\")\n\n\nclass TestIntegration(BaseIntegration):\n    \"\"\"\n    Concrete implementation of BaseIntegration for testing.\n\n    Provides mock implementations of abstract methods to test the base class\n    batch processing functionality.\n    \"\"\"\n\n    def __init__(self, credentials: TestIntegrationCredentials, fail_send: bool = False):\n        super().__init__(credentials)\n        self.fail_send = fail_send\n        self._send_event_calls = []\n        self._send_batch_calls = []\n\n    async def _do_authenticate(self) -> IntegrationResult:\n        \"\"\"Mock authentication.\"\"\"\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"authenticate\",\n            external_id=\"test-auth-id\",\n        )\n\n    async def _do_validate(self) -> IntegrationResult:\n        \"\"\"Mock validation.\"\"\"\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"validate\",\n        )\n\n    async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n        \"\"\"Mock single event sending.\"\"\"\n        self._send_event_calls.append(event.event_id)\n\n        if self.fail_send:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"send_event\",\n                error_code=\"SEND_FAILED\",\n                error_message=\"Mock send failure\",\n            )\n\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"send_event\",\n            external_id=f\"ext-{event.event_id}\",\n        )\n\n\nclass TestIntegrationWithCustomBatch(TestIntegration):\n    \"\"\"\n    Test integration that overrides _do_send_events_batch() for custom batch handling.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials: TestIntegrationCredentials,\n        batch_behavior: str = \"success\",  # \"success\", \"failure\", \"partial\"\n    ):\n        super().__init__(credentials)\n        self.batch_behavior = batch_behavior\n\n    async def _do_send_events_batch(\n        self, events: List[IntegrationEvent]\n    ) -> List[IntegrationResult]:\n        \"\"\"Custom batch implementation with configurable behavior.\"\"\"\n        self._send_batch_calls.append([e.event_id for e in events])\n\n        if self.batch_behavior == \"success\":\n            # All events succeed\n            return [\n                IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    external_id=f\"batch-ext-{event.event_id}\",\n                )\n                for event in events\n            ]\n        elif self.batch_behavior == \"failure\":\n            # All events fail\n            return [\n                IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    error_code=\"BATCH_FAILED\",\n                    error_message=\"Mock batch failure\",\n                )\n                for _ in events\n            ]\n        elif self.batch_behavior == \"partial\":\n            # Partial success: even indices succeed, odd indices fail\n            return [\n                IntegrationResult(\n                    success=(i % 2 == 0),\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    external_id=f\"batch-ext-{event.event_id}\" if i % 2 == 0 else None,\n                    error_code=None if i % 2 == 0 else \"SEND_FAILED\",\n                    error_message=None if i % 2 == 0 else f\"Event {i} failed\",\n                )\n                for i, event in enumerate(events)\n            ]\n        else:\n            raise ValueError(f\"Unknown batch_behavior: {self.batch_behavior}\")\n\n\n# ============================================================================\n# Fixtures\n# ============================================================================\n\n\n@pytest.fixture\ndef test_credentials() -> TestIntegrationCredentials:\n    \"\"\"Create test credentials for BaseIntegration testing.\"\"\"\n    return TestIntegrationCredentials(\n        integration_name=\"Test Integration\",\n        api_key=SecretStr(\"test-api-key-12345\"),\n    )\n\n\n@pytest.fixture\ndef test_integration(test_credentials: TestIntegrationCredentials) -> TestIntegration:\n    \"\"\"Create a test integration adapter.\"\"\"\n    return TestIntegration(test_credentials)\n\n\n@pytest.fixture\ndef sample_event() -> IntegrationEvent:\n    \"\"\"Create a sample governance event for testing.\"\"\"\n    return IntegrationEvent(\n        event_id=\"evt-test-001\",\n        event_type=\"policy_violation\",\n        severity=EventSeverity.HIGH,\n        source=\"acgs2\",\n        policy_id=\"POL-001\",\n        resource_id=\"res-123\",\n        resource_type=\"compute\",\n        action=\"create\",\n        outcome=\"blocked\",\n        title=\"Policy Violation Detected\",\n        description=\"Resource creation blocked due to policy violation\",\n        details={\"region\": \"us-east-1\", \"cost_estimate\": 150.00},\n        user_id=\"user-456\",\n        tenant_id=\"tenant-789\",\n        correlation_id=\"corr-123\",\n        tags=[\"security\", \"compliance\"],\n    )\n\n\n@pytest.fixture\ndef sample_events() -> List[IntegrationEvent]:\n    \"\"\"Create a list of sample events for batch testing.\"\"\"\n    return [\n        IntegrationEvent(\n            event_id=f\"evt-test-{i:03d}\",\n            event_type=\"policy_violation\",\n            severity=EventSeverity.HIGH,\n            source=\"acgs2\",\n            title=f\"Test Event {i}\",\n            description=f\"Test event description {i}\",\n        )\n        for i in range(1, 6)  # 5 events\n    ]\n\n\n# ============================================================================\n# Batch Processing Success Tests\n# ============================================================================\n\n\nclass TestBatchProcessingSuccess:\n    \"\"\"Tests for successful batch event processing scenarios.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_successful_batch_all_events_succeed(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test batch processing when all events succeed.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"success\")\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        results = await adapter.send_events_batch(sample_events)\n\n        # Verify all results are successful\n        assert len(results) == 5\n        assert all(r.success for r in results)\n        assert all(r.external_id.startswith(\"batch-ext-\") for r in results)\n\n        # Verify metrics\n        assert adapter._batches_sent == 1\n        assert adapter._batches_failed == 0\n        assert adapter._events_sent == 5\n        assert adapter._events_failed == 0\n        assert adapter._batch_events_total == 5\n        assert adapter._last_success is not None\n        assert adapter._last_failure is None\n\n    @pytest.mark.asyncio\n    async def test_successful_batch_with_default_implementation(\n        self,\n        test_integration: TestIntegration,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test batch processing using default one-by-one implementation.\"\"\"\n        test_integration._authenticated = True\n        test_integration._status = IntegrationStatus.ACTIVE\n\n        results = await test_integration.send_events_batch(sample_events)\n\n        # Verify all results are successful\n        assert len(results) == 5\n        assert all(r.success for r in results)\n\n        # Verify _do_send_event was called for each event (default fallback)\n        assert len(test_integration._send_event_calls) == 5\n        assert test_integration._send_event_calls == [\n            \"evt-test-001\",\n            \"evt-test-002\",\n            \"evt-test-003\",\n            \"evt-test-004\",\n            \"evt-test-005\",\n        ]\n\n        # Verify metrics\n        assert test_integration._batches_sent == 1\n        assert test_integration._batches_failed == 0\n        assert test_integration._events_sent == 5\n        assert test_integration._events_failed == 0\n        assert test_integration._batch_events_total == 5\n\n    @pytest.mark.asyncio\n    async def test_batch_with_empty_list(\n        self,\n        test_integration: TestIntegration,\n    ):\n        \"\"\"Test batch processing with empty event list.\"\"\"\n        test_integration._authenticated = True\n        test_integration._status = IntegrationStatus.ACTIVE\n\n        results = await test_integration.send_events_batch([])\n\n        # Verify empty result\n        assert len(results) == 0\n\n        # Verify no metrics updated\n        assert test_integration._batches_sent == 0\n        assert test_integration._batches_failed == 0\n        assert test_integration._events_sent == 0\n        assert test_integration._events_failed == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_with_single_event(\n        self,\n        test_integration: TestIntegration,\n        sample_event: IntegrationEvent,\n    ):\n        \"\"\"Test batch processing with single event.\"\"\"\n        test_integration._authenticated = True\n        test_integration._status = IntegrationStatus.ACTIVE\n\n        results = await test_integration.send_events_batch([sample_event])\n\n        # Verify result\n        assert len(results) == 1\n        assert results[0].success is True\n        assert results[0].external_id == f\"ext-{sample_event.event_id}\"\n\n        # Verify metrics\n        assert test_integration._batches_sent == 1\n        assert test_integration._events_sent == 1\n        assert test_integration._batch_events_total == 1\n\n\n# ============================================================================\n# Batch Processing Failure Tests\n# ============================================================================\n\n\nclass TestBatchProcessingFailure:\n    \"\"\"Tests for batch event processing failure scenarios.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_batch_requires_authentication(\n        self,\n        test_integration: TestIntegration,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test that batch processing requires authentication.\"\"\"\n        # Don't authenticate\n        test_integration._authenticated = False\n\n        with pytest.raises(AuthenticationError, match=\"not authenticated\"):\n            await test_integration.send_events_batch(sample_events)\n\n        # Verify no metrics updated\n        assert test_integration._batches_sent == 0\n        assert test_integration._events_sent == 0\n\n    @pytest.mark.asyncio\n    async def test_batch_all_events_fail(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test batch processing when all events fail.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"failure\")\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        results = await adapter.send_events_batch(sample_events)\n\n        # Verify all results are failures\n        assert len(results) == 5\n        assert all(not r.success for r in results)\n        assert all(r.error_code == \"BATCH_FAILED\" for r in results)\n        assert all(r.error_message == \"Mock batch failure\" for r in results)\n\n        # Verify metrics - all events failed\n        assert adapter._batches_sent == 0\n        assert adapter._batches_failed == 1\n        assert adapter._events_sent == 0\n        assert adapter._events_failed == 5\n        assert adapter._batch_events_total == 0\n        assert adapter._last_failure is not None\n        assert adapter._last_error == \"Mock batch failure\"\n\n    @pytest.mark.asyncio\n    async def test_batch_with_default_implementation_all_fail(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test batch processing with default implementation when all events fail.\"\"\"\n        adapter = TestIntegration(test_credentials, fail_send=True)\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        results = await adapter.send_events_batch(sample_events)\n\n        # Verify all results are failures\n        assert len(results) == 5\n        assert all(not r.success for r in results)\n\n        # Verify metrics\n        assert adapter._batches_sent == 0\n        assert adapter._batches_failed == 1\n        assert adapter._events_sent == 0\n        assert adapter._events_failed == 5\n\n    @pytest.mark.asyncio\n    async def test_batch_retry_on_network_error(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test that batch processing retries on network errors.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"success\")\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        # Mock _do_send_events_batch to raise network error then succeed\n        call_count = 0\n        original_method = adapter._do_send_events_batch\n\n        async def mock_send_batch_with_retry(events):\n            nonlocal call_count\n            call_count += 1\n            if call_count == 1:\n                raise httpx.NetworkError(\"Connection failed\")\n            return await original_method(events)\n\n        adapter._do_send_events_batch = mock_send_batch_with_retry\n\n        results = await adapter.send_events_batch(sample_events)\n\n        # Verify retry succeeded\n        assert call_count == 2  # First call failed, second succeeded\n        assert len(results) == 5\n        assert all(r.success for r in results)\n\n\n# ============================================================================\n# Batch Processing Partial Success Tests\n# ============================================================================\n\n\nclass TestBatchProcessingPartialSuccess:\n    \"\"\"Tests for partial success scenarios in batch processing.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_batch_partial_success(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test batch processing with partial success (some events succeed, some fail).\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"partial\")\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        results = await adapter.send_events_batch(sample_events)\n\n        # Verify results: even indices succeed, odd indices fail\n        assert len(results) == 5\n        assert results[0].success is True  # Index 0: success\n        assert results[1].success is False  # Index 1: failure\n        assert results[2].success is True  # Index 2: success\n        assert results[3].success is False  # Index 3: failure\n        assert results[4].success is True  # Index 4: success\n\n        # Verify metrics - 3 succeeded, 2 failed\n        assert adapter._batches_sent == 1  # Batch counted as sent (partial success)\n        assert adapter._batches_failed == 0\n        assert adapter._events_sent == 3  # 3 events succeeded\n        assert adapter._events_failed == 2  # 2 events failed\n        assert adapter._batch_events_total == 3  # Only successful events counted\n        assert adapter._last_success is not None\n\n    @pytest.mark.asyncio\n    async def test_batch_partial_success_with_default_implementation(\n        self,\n        test_credentials: TestIntegrationCredentials,\n    ):\n        \"\"\"Test partial success with default one-by-one implementation.\"\"\"\n        # Create custom adapter that fails on odd event IDs\n        class PartialFailAdapter(TestIntegration):\n            async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n                # Fail on odd event numbers\n                event_num = int(event.event_id.split(\"-\")[-1])\n                if event_num % 2 == 1:\n                    return IntegrationResult(\n                        success=False,\n                        integration_name=self.name,\n                        operation=\"send_event\",\n                        error_code=\"SEND_FAILED\",\n                        error_message=f\"Event {event.event_id} failed\",\n                    )\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    external_id=f\"ext-{event.event_id}\",\n                )\n\n        adapter = PartialFailAdapter(test_credentials)\n        adapter._authenticated = True\n        adapter._status = IntegrationStatus.ACTIVE\n\n        events = [\n            IntegrationEvent(\n                event_id=f\"evt-test-{i:03d}\",\n                event_type=\"test\",\n                title=f\"Event {i}\",\n            )\n            for i in range(1, 6)\n        ]\n\n        results = await adapter.send_events_batch(events)\n\n        # Verify partial success: events 1, 3, 5 fail; events 2, 4 succeed\n        assert len(results) == 5\n        assert results[0].success is False  # evt-test-001 (odd)\n        assert results[1].success is True  # evt-test-002 (even)\n        assert results[2].success is False  # evt-test-003 (odd)\n        assert results[3].success is True  # evt-test-004 (even)\n        assert results[4].success is False  # evt-test-005 (odd)\n\n        # Verify metrics\n        assert adapter._batches_sent == 1\n        assert adapter._batches_failed == 0\n        assert adapter._events_sent == 2\n        assert adapter._events_failed == 3\n        assert adapter._batch_events_total == 2\n\n\n# ============================================================================\n# Metrics Tracking Tests\n# ============================================================================\n\n\nclass TestBatchMetricsTracking:\n    \"\"\"Tests for batch operation metrics tracking.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_metrics_tracking_all_success(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test metrics tracking when all events succeed.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"success\")\n        adapter._authenticated = True\n\n        # Initial metrics\n        assert adapter.metrics[\"batches_sent\"] == 0\n        assert adapter.metrics[\"batches_failed\"] == 0\n        assert adapter.metrics[\"events_sent\"] == 0\n        assert adapter.metrics[\"events_failed\"] == 0\n        assert adapter.metrics[\"batch_events_total\"] == 0\n\n        await adapter.send_events_batch(sample_events)\n\n        # Verify metrics after successful batch\n        metrics = adapter.metrics\n        assert metrics[\"batches_sent\"] == 1\n        assert metrics[\"batches_failed\"] == 0\n        assert metrics[\"events_sent\"] == 5\n        assert metrics[\"events_failed\"] == 0\n        assert metrics[\"batch_events_total\"] == 5\n        assert metrics[\"last_success\"] is not None\n        assert metrics[\"last_failure\"] is None\n\n    @pytest.mark.asyncio\n    async def test_metrics_tracking_all_failure(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test metrics tracking when all events fail.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"failure\")\n        adapter._authenticated = True\n\n        await adapter.send_events_batch(sample_events)\n\n        # Verify metrics after failed batch\n        metrics = adapter.metrics\n        assert metrics[\"batches_sent\"] == 0\n        assert metrics[\"batches_failed\"] == 1\n        assert metrics[\"events_sent\"] == 0\n        assert metrics[\"events_failed\"] == 5\n        assert metrics[\"batch_events_total\"] == 0\n        assert metrics[\"last_failure\"] is not None\n\n    @pytest.mark.asyncio\n    async def test_metrics_tracking_partial_success(\n        self,\n        test_credentials: TestIntegrationCredentials,\n        sample_events: List[IntegrationEvent],\n    ):\n        \"\"\"Test metrics tracking for partial success.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"partial\")\n        adapter._authenticated = True\n\n        await adapter.send_events_batch(sample_events)\n\n        # Verify metrics after partial success (3 succeeded, 2 failed)\n        metrics = adapter.metrics\n        assert metrics[\"batches_sent\"] == 1  # Counted as sent (partial success)\n        assert metrics[\"batches_failed\"] == 0\n        assert metrics[\"events_sent\"] == 3\n        assert metrics[\"events_failed\"] == 2\n        assert metrics[\"batch_events_total\"] == 3\n\n    @pytest.mark.asyncio\n    async def test_metrics_accumulation_across_multiple_batches(\n        self,\n        test_credentials: TestIntegrationCredentials,\n    ):\n        \"\"\"Test that metrics accumulate correctly across multiple batch operations.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"success\")\n        adapter._authenticated = True\n\n        # Send first batch (5 events)\n        events1 = [\n            IntegrationEvent(event_id=f\"evt-1-{i}\", event_type=\"test\", title=f\"Event 1-{i}\")\n            for i in range(5)\n        ]\n        await adapter.send_events_batch(events1)\n\n        assert adapter.metrics[\"batches_sent\"] == 1\n        assert adapter.metrics[\"events_sent\"] == 5\n        assert adapter.metrics[\"batch_events_total\"] == 5\n\n        # Send second batch (3 events)\n        events2 = [\n            IntegrationEvent(event_id=f\"evt-2-{i}\", event_type=\"test\", title=f\"Event 2-{i}\")\n            for i in range(3)\n        ]\n        await adapter.send_events_batch(events2)\n\n        # Verify accumulated metrics\n        assert adapter.metrics[\"batches_sent\"] == 2\n        assert adapter.metrics[\"events_sent\"] == 8\n        assert adapter.metrics[\"batch_events_total\"] == 8\n\n    @pytest.mark.asyncio\n    async def test_metrics_mixed_batch_results(\n        self,\n        test_credentials: TestIntegrationCredentials,\n    ):\n        \"\"\"Test metrics tracking with mixed batch results (success, failure, partial).\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"success\")\n        adapter._authenticated = True\n\n        events = [\n            IntegrationEvent(event_id=f\"evt-{i}\", event_type=\"test\", title=f\"Event {i}\")\n            for i in range(3)\n        ]\n\n        # Batch 1: All succeed\n        adapter.batch_behavior = \"success\"\n        await adapter.send_events_batch(events)\n\n        assert adapter.metrics[\"batches_sent\"] == 1\n        assert adapter.metrics[\"batches_failed\"] == 0\n        assert adapter.metrics[\"events_sent\"] == 3\n        assert adapter.metrics[\"events_failed\"] == 0\n\n        # Batch 2: All fail\n        adapter.batch_behavior = \"failure\"\n        await adapter.send_events_batch(events)\n\n        assert adapter.metrics[\"batches_sent\"] == 1\n        assert adapter.metrics[\"batches_failed\"] == 1\n        assert adapter.metrics[\"events_sent\"] == 3\n        assert adapter.metrics[\"events_failed\"] == 3\n\n        # Batch 3: Partial success (2 succeed, 1 fails for 3 events)\n        adapter.batch_behavior = \"partial\"\n        await adapter.send_events_batch(events)\n\n        assert adapter.metrics[\"batches_sent\"] == 2  # Partial counted as sent\n        assert adapter.metrics[\"batches_failed\"] == 1\n        assert adapter.metrics[\"events_sent\"] == 5  # 3 + 2 (from partial)\n        assert adapter.metrics[\"events_failed\"] == 4  # 3 + 1 (from partial)\n\n\n# ============================================================================\n# Error Handling Tests\n# ============================================================================\n\n\nclass TestBatchErrorHandling:\n    \"\"\"Tests for error handling in batch processing.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_batch_handles_exception_in_default_implementation(\n        self,\n        test_credentials: TestIntegrationCredentials,\n    ):\n        \"\"\"Test that exceptions in default implementation are handled gracefully.\"\"\"\n\n        class ExceptionAdapter(TestIntegration):\n            async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n                # Raise exception on second event\n                if event.event_id == \"evt-test-002\":\n                    raise ValueError(\"Simulated error for testing\")\n                return await super()._do_send_event(event)\n\n        adapter = ExceptionAdapter(test_credentials)\n        adapter._authenticated = True\n\n        events = [\n            IntegrationEvent(event_id=f\"evt-test-{i:03d}\", event_type=\"test\", title=f\"Event {i}\")\n            for i in range(1, 4)\n        ]\n\n        results = await adapter.send_events_batch(events)\n\n        # Verify results\n        assert len(results) == 3\n        assert results[0].success is True\n        assert results[1].success is False  # Exception caught\n        assert results[1].error_code == \"SEND_FAILED\"\n        assert \"Simulated error\" in results[1].error_message\n        assert results[2].success is True\n\n    @pytest.mark.asyncio\n    async def test_batch_preserves_event_order(\n        self,\n        test_credentials: TestIntegrationCredentials,\n    ):\n        \"\"\"Test that batch results preserve event order.\"\"\"\n        adapter = TestIntegrationWithCustomBatch(test_credentials, batch_behavior=\"partial\")\n        adapter._authenticated = True\n\n        events = [\n            IntegrationEvent(\n                event_id=f\"evt-test-{i:03d}\",\n                event_type=\"test\",\n                title=f\"Event {i}\",\n            )\n            for i in range(1, 11)  # 10 events\n        ]\n\n        results = await adapter.send_events_batch(events)\n\n        # Verify order is preserved\n        assert len(results) == 10\n        for i, (_event, result) in enumerate(zip(events, results, strict=True)):\n            assert result.integration_name == adapter.name\n            # Even indices succeed, odd indices fail (based on partial behavior)\n            if i % 2 == 0:\n                assert result.success is True\n                assert f\"evt-test-{i+1:03d}\" in result.external_id\n            else:\n                assert result.success is False\n\n    @pytest.mark.asyncio\n    async def test_batch_empty_list_no_error(\n        self,\n        test_integration: TestIntegration,\n    ):\n        \"\"\"Test that empty list doesn't cause errors.\"\"\"\n        test_integration._authenticated = True\n\n        results = await test_integration.send_events_batch([])\n\n        assert results == []\n        assert test_integration._batches_sent == 0\n        assert test_integration._events_sent == 0\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.746298",
  "last_updated": "2026-01-04T00:39:57.749076"
}