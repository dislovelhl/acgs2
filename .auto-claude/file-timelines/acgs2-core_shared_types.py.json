{
  "file_path": "src/core/shared/types.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nType Aliases for ACGS2 Core Shared Modules\n\nThis module defines common type aliases used throughout src/core to replace\nexcessive 'Any' usage with more specific, documented types.\n\nUsage Guidelines:\n    - Use JSONDict for general JSON-like dictionaries with string keys\n    - Use JSONValue for any valid JSON value type\n    - Use ContextData for agent/workflow context data\n    - Use specific Protocol types when you need structural typing\n\nWhen to use 'Any' (sparingly):\n    - Truly dynamic data where structure is completely unknown\n    - Third-party library return types that aren't typed\n    - Generic wrapper functions (prefer TypeVar when possible)\n\nAlways prefer Union types, Protocols, or TypedDict over 'Any' when possible.\n\"\"\"\n\nfrom typing import Any, Callable, Dict, List, Optional, Protocol, TypeVar, Union\n\n# ============================================================================\n# JSON and Data Structure Types\n# ============================================================================\n\n# General JSON types - use these for JSON payloads, API responses, config files\nJSONPrimitive = Union[str, int, float, bool, None]\nJSONValue = Union[JSONPrimitive, \"JSONDict\", \"JSONList\"]\nJSONDict = Dict[str, JSONValue]\nJSONList = List[JSONValue]\n\n# More specific JSON structures\nNestedDict = Dict[str, Any]  # For deeply nested structures where full typing is impractical\nStringDict = Dict[str, str]  # For simple string-to-string mappings\nMetadataDict = Dict[str, JSONValue]  # For metadata fields\nAttributeDict = Dict[str, JSONValue]  # For attribute collections\n\n\n# ============================================================================\n# Agent and Workflow Types\n# ============================================================================\n\n# Agent data structures\nAgentID = str  # Agent identifier\nAgentContext = Dict[str, JSONValue]  # Agent execution context\nAgentState = Dict[str, JSONValue]  # Agent state data\nAgentMetadata = Dict[str, JSONValue]  # Agent metadata\n\n# Workflow data structures\nWorkflowID = str  # Workflow identifier\nWorkflowContext = Dict[str, JSONValue]  # Workflow execution context\nWorkflowState = Dict[str, JSONValue]  # Workflow state data\nStepResult = Dict[str, JSONValue]  # Workflow step result\nStepParameters = Dict[str, JSONValue]  # Workflow step parameters\n\n# Context and memory\nContextData = Dict[str, JSONValue]  # Generic context data\nMemoryData = Dict[str, JSONValue]  # Memory system data\nSessionData = Dict[str, JSONValue]  # Session data\n\n\n# ============================================================================\n# Message and Event Types\n# ============================================================================\n\n# Message bus types\nMessageID = str  # Message identifier\nMessagePayload = Dict[str, JSONValue]  # Message payload\nMessageHeaders = Dict[str, str]  # Message headers\nMessageMetadata = Dict[str, JSONValue]  # Message metadata\n\n# Event types\nEventID = str  # Event identifier\nEventData = Dict[str, JSONValue]  # Event payload data\nEventContext = Dict[str, JSONValue]  # Event context\nEventMetadata = Dict[str, JSONValue]  # Event metadata\n\n# Kafka/messaging\nKafkaMessage = Any  # Kafka consumer message object\nTopicName = str  # Kafka topic name\n\n\n# ============================================================================\n# Policy and Governance Types\n# ============================================================================\n\nPolicyID = str  # Policy identifier\nPolicyData = Dict[str, JSONValue]  # Policy definition data\nPolicyContext = Dict[str, JSONValue]  # Policy evaluation context\nPolicyDecision = Dict[str, JSONValue]  # Policy decision result\n\n# ABAC/RBAC\nAttributeMap = Dict[str, JSONValue]  # Attribute-based access control attributes\nRoleData = Dict[str, JSONValue]  # Role definition\nPermissionSet = set[str]  # Set of permission strings\n\n# Constitutional governance\nConstitutionalContext = Dict[str, JSONValue]  # Constitutional decision context\nDecisionData = Dict[str, JSONValue]  # Decision data\nVerificationResult = Dict[str, JSONValue]  # Verification result\n\n\n# ============================================================================\n# Configuration and Settings Types\n# ============================================================================\n\nConfigDict = Dict[str, JSONValue]  # Configuration dictionaries\nConfigValue = JSONValue  # Individual configuration value\nEnvVars = Dict[str, str]  # Environment variables\nSecretData = Dict[str, str]  # Secret/credential data\n\n\n# ============================================================================\n# Authentication and Security Types\n# ============================================================================\n\n# Auth types\nAuthToken = str  # Authentication token\nAuthCredentials = Dict[str, str]  # Authentication credentials\nAuthContext = Dict[str, JSONValue]  # Authentication context\nUserAttributes = Dict[str, JSONValue]  # User attribute data (SAML, OIDC)\n\n# Security types\nTenantID = str  # Tenant identifier\nCorrelationID = str  # Request correlation ID\nSecurityContext = Dict[str, JSONValue]  # Security context\n\n\n# ============================================================================\n# Cache and Storage Types\n# ============================================================================\n\nCacheKey = str  # Cache key\nCacheValue = JSONValue  # Cached value (prefer more specific types when possible)\nCacheTTL = int  # Cache time-to-live in seconds\nRedisValue = Union[str, bytes, None]  # Redis stored value\n\n\n# ============================================================================\n# Audit and Logging Types\n# ============================================================================\n\nAuditEntry = Dict[str, JSONValue]  # Single audit log entry\nAuditTrail = List[AuditEntry]  # List of audit entries\nLogContext = Dict[str, JSONValue]  # Structured logging context\nLogRecord = Dict[str, JSONValue]  # Log record data\nMetricData = Dict[str, Union[int, float]]  # Metric measurements\n\n\n# ============================================================================\n# Temporal and Time-Series Types\n# ============================================================================\n\nTimestamp = float  # Unix timestamp\nTimelineData = Dict[str, JSONValue]  # Timeline/temporal data\nScheduleData = Dict[str, JSONValue]  # Schedule information\n\n\n# ============================================================================\n# ML and AI Types\n# ============================================================================\n\nModelID = str  # ML model identifier\nModelParameters = Dict[str, Union[int, float, str]]  # Model parameters\nModelMetadata = Dict[str, JSONValue]  # Model metadata\nPredictionResult = Dict[str, JSONValue]  # Prediction output\nFeatureVector = Union[List[float], Dict[str, float]]  # Feature data\nTrainingData = Dict[str, JSONValue]  # Training dataset metadata\n\n\n# ============================================================================\n# Error and Exception Types\n# ============================================================================\n\nErrorDetails = Dict[str, JSONValue]  # Error details for exceptions\nErrorContext = Dict[str, JSONValue]  # Additional error context\nErrorCode = str  # Error code identifier\n\n\n# ============================================================================\n# Validation and Transformation Types\n# ============================================================================\n\nValidationContext = Dict[str, JSONValue]  # Context for validation operations\nValidationErrors = List[Dict[str, str]]  # Validation error list\nTransformFunc = Callable[[Any], Any]  # Generic transformation function\nValidatorFunc = Callable[[Any], bool]  # Generic validator function\n\n\n# ============================================================================\n# Observability and Telemetry Types\n# ============================================================================\n\nSpanContext = Dict[str, JSONValue]  # Distributed tracing span context\nTraceID = str  # Trace identifier\nTelemetryData = Dict[str, Union[int, float, str]]  # Telemetry metrics\nPerformanceMetrics = Dict[str, float]  # Performance measurements\n\n\n# ============================================================================\n# Protocol Types for Structural Typing\n# ============================================================================\n\nclass SupportsCache(Protocol):\n    \"\"\"Protocol for objects that support caching.\"\"\"\n    def get(self, key: str) -> Optional[CacheValue]:\n        \"\"\"Get value from cache.\"\"\"\n        ...\n\n    def set(self, key: str, value: CacheValue, ttl: Optional[int] = None) -> None:\n        \"\"\"Set value in cache.\"\"\"\n        ...\n\n\nclass SupportsValidation(Protocol):\n    \"\"\"Protocol for objects that support validation.\"\"\"\n    def validate(self) -> bool:\n        \"\"\"Validate the object.\"\"\"\n        ...\n\n\nclass SupportsAuthentication(Protocol):\n    \"\"\"Protocol for objects that support authentication.\"\"\"\n    async def authenticate(self) -> bool:\n        \"\"\"Perform authentication.\"\"\"\n        ...\n\n\nclass SupportsSerialization(Protocol):\n    \"\"\"Protocol for objects that support JSON serialization.\"\"\"\n    def to_dict(self) -> JSONDict:\n        \"\"\"Convert to dictionary.\"\"\"\n        ...\n\n    @classmethod\n    def from_dict(cls, data: JSONDict) -> \"SupportsSerialization\":\n        \"\"\"Create from dictionary.\"\"\"\n        ...\n\n\nclass SupportsLogging(Protocol):\n    \"\"\"Protocol for logger-like objects.\"\"\"\n    def info(self, msg: str, **kwargs: Any) -> None:\n        \"\"\"Log info message.\"\"\"\n        ...\n\n    def error(self, msg: str, **kwargs: Any) -> None:\n        \"\"\"Log error message.\"\"\"\n        ...\n\n    def warning(self, msg: str, **kwargs: Any) -> None:\n        \"\"\"Log warning message.\"\"\"\n        ...\n\n    def debug(self, msg: str, **kwargs: Any) -> None:\n        \"\"\"Log debug message.\"\"\"\n        ...\n\n\nclass SupportsMiddleware(Protocol):\n    \"\"\"Protocol for middleware/ASGI applications.\"\"\"\n    async def __call__(self, scope: Dict[str, Any], receive: Callable, send: Callable) -> None:\n        \"\"\"Process ASGI request.\"\"\"\n        ...\n\n\n# ============================================================================\n# Generic Type Variables\n# ============================================================================\n\nT = TypeVar('T')  # Generic type variable\nT_co = TypeVar('T_co', covariant=True)  # Covariant type variable\nT_contra = TypeVar('T_contra', contravariant=True)  # Contravariant type variable\n\n# Specific type variables\nModelT = TypeVar('ModelT')  # For Pydantic models\nConfigT = TypeVar('ConfigT')  # For configuration objects\nResponseT = TypeVar('ResponseT')  # For API responses\nEventT = TypeVar('EventT')  # For event types\nStateT = TypeVar('StateT')  # For state objects\nContextT = TypeVar('ContextT')  # For context objects\n\n\n# ============================================================================\n# Pydantic-specific Types\n# ============================================================================\n\n# For Pydantic validator methods\nValidatorValue = Any  # Input value to validator (use with caution, prefer specific types)\nValidatorContext = Any  # Pydantic validation context object\nModelContext = Any  # Pydantic model_post_init __context parameter\n\n\n# ============================================================================\n# Decorator and Wrapper Types\n# ============================================================================\n\n# For function wrappers and decorators\nArgsType = tuple[Any, ...]  # *args tuple\nKwargsType = Dict[str, Any]  # **kwargs dict\nDecoratorFunc = Callable[[Callable[..., T]], Callable[..., T]]  # Function decorator\nAsyncFunc = Callable[..., Any]  # Async function type\n\n\n# ============================================================================\n# Document and Template Types\n# ============================================================================\n\nTemplateData = Dict[str, JSONValue]  # Template rendering data\nTemplateContext = Dict[str, JSONValue]  # Template context\nDocumentData = Dict[str, JSONValue]  # Document data\n\n\n# ============================================================================\n# Database and ORM Types\n# ============================================================================\n\nDatabaseRow = Dict[str, Any]  # Database row/record\nQueryParams = Dict[str, Any]  # Query parameters\nFilterCriteria = Dict[str, Any]  # Filter/where criteria\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.280771",
  "last_updated": "2026-01-04T05:35:58.609423"
}