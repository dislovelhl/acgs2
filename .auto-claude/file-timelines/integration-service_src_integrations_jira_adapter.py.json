{
  "file_path": "integration-service/src/integrations/jira_adapter.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nJira Integration Adapter\n\nProvides integration with Jira for creating tickets from governance events.\nSupports both Jira Cloud and Jira Server/Data Center deployments.\n\nFeatures:\n- API token authentication (Cloud) and Basic auth (Server)\n- Configurable field mappings for ticket creation\n- Automatic severity to priority mapping\n- Custom field support with field ID discovery\n- Rate limit handling\n- Ticket linking and updates\n\"\"\"\n\nimport json\nimport logging\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom pydantic import Field, SecretStr, field_validator, model_validator\n\n# Import exceptions from centralized exceptions module\nfrom exceptions.auth import AuthenticationError\nfrom exceptions.delivery import DeliveryError\nfrom exceptions.integration import RateLimitError\n\n# Import base integration classes and models\nfrom .base import (\n    BaseIntegration,\n    EventSeverity,\n    IntegrationCredentials,\n    IntegrationEvent,\n    IntegrationResult,\n    IntegrationType,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass JiraDeploymentType(str, Enum):\n    \"\"\"Jira deployment types\"\"\"\n\n    CLOUD = \"cloud\"\n    SERVER = \"server\"\n    DATA_CENTER = \"data_center\"\n\n\n# Default priority mapping from ACGS-2 severity to Jira priority names\nDEFAULT_PRIORITY_MAP: Dict[EventSeverity, str] = {\n    EventSeverity.CRITICAL: \"Highest\",\n    EventSeverity.HIGH: \"High\",\n    EventSeverity.MEDIUM: \"Medium\",\n    EventSeverity.LOW: \"Low\",\n    EventSeverity.INFO: \"Lowest\",\n}\n\n\nclass JiraCredentials(IntegrationCredentials):\n    \"\"\"\n    Credentials for Jira integration.\n\n    Supports both Jira Cloud (API token) and Jira Server/Data Center (Basic auth).\n\n    For Jira Cloud:\n    - base_url: https://your-domain.atlassian.net\n    - username: your-email@example.com\n    - api_token: API token from https://id.atlassian.com/manage/api-tokens\n\n    For Jira Server/Data Center:\n    - base_url: https://jira.your-company.com\n    - username: your-username\n    - api_token: Personal access token or password\n    \"\"\"\n\n    integration_type: IntegrationType = Field(\n        default=IntegrationType.TICKETING,\n        description=\"Integration type (always TICKETING for Jira)\",\n    )\n\n    # Connection settings\n    base_url: str = Field(\n        ...,\n        description=\"Jira instance URL (e.g., https://your-domain.atlassian.net)\",\n    )\n    username: str = Field(\n        ...,\n        description=\"Username or email for authentication\",\n    )\n    api_token: SecretStr = Field(\n        ...,\n        description=\"API token (Cloud) or password (Server/Data Center)\",\n    )\n\n    # Deployment type\n    deployment_type: JiraDeploymentType = Field(\n        default=JiraDeploymentType.CLOUD,\n        description=\"Jira deployment type (cloud, server, data_center)\",\n    )\n\n    # Project configuration\n    project_key: str = Field(\n        ...,\n        description=\"Default Jira project key for ticket creation\",\n    )\n    issue_type: str = Field(\n        default=\"Bug\",\n        description=\"Default issue type for tickets (e.g., Bug, Task, Story)\",\n    )\n\n    # Optional field mappings\n    priority_mapping: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Custom severity to priority mapping (severity -> priority name)\",\n    )\n    custom_fields: Dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Custom field values to set on tickets (field_id -> value)\",\n    )\n    labels: List[str] = Field(\n        default_factory=lambda: [\"governance\", \"acgs2\"],\n        description=\"Labels to add to created tickets\",\n    )\n    components: List[str] = Field(\n        default_factory=list,\n        description=\"Component names to add to tickets\",\n    )\n\n    # Ticket content settings\n    include_event_details: bool = Field(\n        default=True,\n        description=\"Include full event details in ticket description\",\n    )\n    ticket_summary_template: str = Field(\n        default=\"[ACGS-2] {title}\",\n        description=\"Template for ticket summary (supports {title}, {event_type}, {severity})\",\n    )\n\n    @field_validator(\"base_url\")\n    @classmethod\n    def validate_base_url(cls, v: str) -> str:\n        \"\"\"Validate and normalize base URL.\"\"\"\n        if not v:\n            raise ValueError(\"Base URL is required\")\n\n        # Normalize URL\n        v = v.strip().rstrip(\"/\")\n\n        # Must be HTTPS for production (allow HTTP for local testing)\n        if not v.startswith((\"https://\", \"http://\")):\n            raise ValueError(\"Base URL must start with http:// or https://\")\n\n        return v\n\n    @field_validator(\"project_key\")\n    @classmethod\n    def validate_project_key(cls, v: str) -> str:\n        \"\"\"Validate project key format.\"\"\"\n        if not v:\n            raise ValueError(\"Project key is required\")\n\n        v = v.strip().upper()\n\n        # Project keys are typically uppercase alphanumeric\n        if not v.replace(\"_\", \"\").replace(\"-\", \"\").isalnum():\n            raise ValueError(\"Project key must be alphanumeric (may include _ or -)\")\n\n        return v\n\n    @field_validator(\"username\")\n    @classmethod\n    def validate_username(cls, v: str) -> str:\n        \"\"\"Validate username is provided.\"\"\"\n        if not v or not v.strip():\n            raise ValueError(\"Username is required\")\n        return v.strip()\n\n    @model_validator(mode=\"after\")\n    def validate_cloud_requires_email(self) -> \"JiraCredentials\":\n        \"\"\"Validate that Cloud deployment uses email as username.\"\"\"\n        if self.deployment_type == JiraDeploymentType.CLOUD:\n            if \"@\" not in self.username:\n                logger.warning(\n                    f\"Jira Cloud typically requires email as username, \"\n                    f\"got '{self.username}' instead\"\n                )\n        return self\n\n\nclass JiraAdapter(BaseIntegration):\n    \"\"\"\n    Jira ticketing integration adapter.\n\n    Creates tickets in Jira when governance events require remediation.\n    Supports both Jira Cloud and Jira Server/Data Center deployments.\n\n    Usage:\n        credentials = JiraCredentials(\n            integration_name=\"Production Jira\",\n            base_url=\"https://your-domain.atlassian.net\",\n            username=\"your-email@example.com\",\n            api_token=SecretStr(\"your-api-token\"),\n            project_key=\"GOV\",\n        )\n        adapter = JiraAdapter(credentials)\n        await adapter.authenticate()\n        result = await adapter.send_event(event)\n\n    Features:\n        - API token authentication with credential validation\n        - Configurable field mappings (severity -> priority, custom fields)\n        - Automatic ticket description generation\n        - Rate limit handling (Jira Cloud: 10 req/sec)\n        - Project and issue type validation\n        - Detailed error reporting\n    \"\"\"\n\n    # Jira REST API version\n    API_VERSION = \"3\"  # For Jira Cloud\n    API_VERSION_SERVER = \"2\"  # For Jira Server/Data Center\n\n    # Jira Cloud rate limit (conservative estimate)\n    RATE_LIMIT_REQUESTS_PER_SECOND = 10\n\n    def __init__(\n        self,\n        credentials: JiraCredentials,\n        max_retries: int = BaseIntegration.DEFAULT_MAX_RETRIES,\n        timeout: float = BaseIntegration.DEFAULT_TIMEOUT,\n    ):\n        \"\"\"\n        Initialize Jira adapter.\n\n        Args:\n            credentials: Jira credentials and configuration\n            max_retries: Maximum retry attempts for failed operations\n            timeout: HTTP request timeout in seconds\n        \"\"\"\n        super().__init__(credentials, max_retries, timeout)\n        self._jira_credentials = credentials\n        self._project_id: Optional[str] = None\n        self._issue_type_id: Optional[str] = None\n        self._priority_ids: Dict[str, str] = {}\n        self._available_fields: Dict[str, Any] = {}\n\n    @property\n    def jira_credentials(self) -> JiraCredentials:\n        \"\"\"Get typed Jira credentials\"\"\"\n        return self._jira_credentials\n\n    def _get_api_base_url(self) -> str:\n        \"\"\"Get the base URL for Jira REST API\"\"\"\n        if self.jira_credentials.deployment_type == JiraDeploymentType.CLOUD:\n            return f\"{self.jira_credentials.base_url}/rest/api/{self.API_VERSION}\"\n        else:\n            return f\"{self.jira_credentials.base_url}/rest/api/{self.API_VERSION_SERVER}\"\n\n    def _get_auth_headers(self) -> Dict[str, str]:\n        \"\"\"Get authentication headers for Jira API requests\"\"\"\n        import base64\n\n        # Basic auth with username:api_token\n        credentials = (\n            f\"{self.jira_credentials.username}:\"\n            f\"{self.jira_credentials.api_token.get_secret_value()}\"\n        )\n        encoded = base64.b64encode(credentials.encode()).decode()\n\n        return {\n            \"Authorization\": f\"Basic {encoded}\",\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        }\n\n    async def _do_authenticate(self) -> IntegrationResult:\n        \"\"\"\n        Authenticate with Jira and verify credentials.\n\n        Verifies the credentials are valid by fetching the current user profile.\n\n        Returns:\n            IntegrationResult indicating authentication success/failure\n        \"\"\"\n        logger.debug(f\"Authenticating with Jira for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Fetch current user to verify credentials\n            myself_url = f\"{self._get_api_base_url()}/myself\"\n\n            response = await client.get(\n                myself_url,\n                headers=self._get_auth_headers(),\n            )\n\n            if response.status_code == 200:\n                user_data = response.json()\n                account_id = user_data.get(\"accountId\") or user_data.get(\"key\")\n                display_name = user_data.get(\"displayName\", \"Unknown\")\n                logger.info(\n                    f\"Jira authentication successful for '{self.name}' \" f\"(user: {display_name})\"\n                )\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    external_id=account_id,\n                )\n\n            elif response.status_code == 401:\n                error_msg = \"Invalid credentials - check username and API token\"\n                logger.error(f\"Jira authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"AUTH_FAILED\",\n                    error_message=error_msg,\n                )\n\n            elif response.status_code == 403:\n                error_msg = \"Access denied - check user permissions\"\n                logger.error(f\"Jira authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"ACCESS_DENIED\",\n                    error_message=error_msg,\n                )\n\n            else:\n                error_msg = f\"Unexpected response: HTTP {response.status_code}\"\n                logger.error(f\"Jira authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=error_msg,\n                )\n\n        except httpx.TimeoutException as e:\n            raise AuthenticationError(\n                f\"Connection timed out: {str(e)}\",\n                self.name,\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise AuthenticationError(\n                f\"Network error: {str(e)}\",\n                self.name,\n            ) from e\n\n        except Exception as e:\n            error_msg = f\"Unexpected error during authentication: {str(e)}\"\n            logger.error(f\"Jira authentication error: {error_msg}\")\n            raise AuthenticationError(error_msg, self.name) from e\n\n    async def _do_validate(self) -> IntegrationResult:\n        \"\"\"\n        Validate Jira configuration and prerequisites.\n\n        Checks:\n        - Credentials are valid\n        - Project exists and is accessible\n        - Issue type is valid for the project\n        - Required permissions are granted\n\n        Returns:\n            IntegrationResult with validation status and any issues found\n        \"\"\"\n        logger.debug(f\"Validating Jira integration '{self.name}'\")\n\n        validation_issues: List[str] = []\n\n        try:\n            client = await self.get_http_client()\n\n            # Validate project exists and get project ID\n            project_url = (\n                f\"{self._get_api_base_url()}/project/\" f\"{self.jira_credentials.project_key}\"\n            )\n\n            project_response = await client.get(\n                project_url,\n                headers=self._get_auth_headers(),\n            )\n\n            if project_response.status_code == 200:\n                project_data = project_response.json()\n                self._project_id = project_data.get(\"id\")\n                logger.debug(f\"Project '{self.jira_credentials.project_key}' found\")\n            elif project_response.status_code == 401:\n                validation_issues.append(\"Authentication failed - invalid credentials\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"validate\",\n                    error_code=\"AUTH_FAILED\",\n                    error_message=\"; \".join(validation_issues),\n                    error_details={\"issues\": validation_issues},\n                )\n            elif project_response.status_code == 404:\n                validation_issues.append(f\"Project '{self.jira_credentials.project_key}' not found\")\n            elif project_response.status_code == 403:\n                validation_issues.append(\n                    f\"Access denied to project '{self.jira_credentials.project_key}'\"\n                )\n            else:\n                validation_issues.append(\n                    f\"Failed to fetch project: HTTP {project_response.status_code}\"\n                )\n\n            # Validate issue type exists for the project\n            if not validation_issues:\n                # Get issue types from project metadata\n                meta_url = (\n                    f\"{self._get_api_base_url()}/issue/createmeta\"\n                    f\"?projectKeys={self.jira_credentials.project_key}\"\n                    f\"&expand=projects.issuetypes\"\n                )\n\n                meta_response = await client.get(\n                    meta_url,\n                    headers=self._get_auth_headers(),\n                )\n\n                if meta_response.status_code == 200:\n                    meta_data = meta_response.json()\n                    projects = meta_data.get(\"projects\", [])\n                    if projects:\n                        issue_types = projects[0].get(\"issuetypes\", [])\n                        issue_type_names = [it.get(\"name\", \"\").lower() for it in issue_types]\n                        requested_type = self.jira_credentials.issue_type.lower()\n\n                        if requested_type not in issue_type_names:\n                            validation_issues.append(\n                                f\"Issue type '{self.jira_credentials.issue_type}' \"\n                                f\"not found in project. Available types: \"\n                                f\"{', '.join([it.get('name') for it in issue_types])}\"\n                            )\n                        else:\n                            # Get the issue type ID\n                            for it in issue_types:\n                                if it.get(\"name\", \"\").lower() == requested_type:\n                                    self._issue_type_id = it.get(\"id\")\n                                    break\n                else:\n                    logger.warning(\n                        f\"Could not validate issue type: HTTP {meta_response.status_code}\"\n                    )\n\n            # Get available priorities\n            priorities_url = f\"{self._get_api_base_url()}/priority\"\n            priorities_response = await client.get(\n                priorities_url,\n                headers=self._get_auth_headers(),\n            )\n\n            if priorities_response.status_code == 200:\n                priorities = priorities_response.json()\n                self._priority_ids = {p.get(\"name\", \"\").lower(): p.get(\"id\") for p in priorities}\n                logger.debug(f\"Available priorities: {list(self._priority_ids.keys())}\")\n            else:\n                logger.warning(\"Could not fetch priority list\")\n\n        except httpx.TimeoutException:\n            validation_issues.append(\"Connection timed out\")\n\n        except httpx.NetworkError as e:\n            validation_issues.append(f\"Network error: {str(e)}\")\n\n        except Exception as e:\n            validation_issues.append(f\"Validation error: {str(e)}\")\n\n        if validation_issues:\n            error_msg = \"; \".join(validation_issues)\n            logger.warning(f\"Jira validation failed for '{self.name}': {error_msg}\")\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"validate\",\n                error_code=\"VALIDATION_FAILED\",\n                error_message=error_msg,\n                error_details={\"issues\": validation_issues},\n            )\n\n        logger.info(f\"Jira validation successful for '{self.name}'\")\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"validate\",\n        )\n\n    async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n        \"\"\"\n        Create a Jira ticket for the governance event.\n\n        Args:\n            event: The governance event to create a ticket for\n\n        Returns:\n            IntegrationResult with ticket creation status\n\n        Raises:\n            DeliveryError: If ticket creation fails\n            RateLimitError: If rate limited by Jira\n        \"\"\"\n        logger.debug(f\"Creating Jira ticket for event {event.event_id}\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Build the issue payload\n            issue_data = self._build_issue_payload(event)\n\n            # Create the issue\n            create_url = f\"{self._get_api_base_url()}/issue\"\n\n            response = await client.post(\n                create_url,\n                headers=self._get_auth_headers(),\n                json=issue_data,\n            )\n\n            # Handle rate limiting\n            if response.status_code == 429:\n                retry_after = int(response.headers.get(\"Retry-After\", 60))\n                raise RateLimitError(\n                    \"Jira rate limit exceeded\",\n                    self.name,\n                    retry_after=retry_after,\n                )\n\n            # Handle success (201 Created)\n            if response.status_code == 201:\n                issue_response = response.json()\n                issue_key = issue_response.get(\"key\")\n                issue_url = f\"{self.jira_credentials.base_url}/browse/{issue_key}\"\n\n                logger.info(f\"Created Jira ticket {issue_key} for event {event.event_id}\")\n\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    external_id=issue_key,\n                    external_url=issue_url,\n                )\n\n            # Handle errors\n            if response.status_code == 400:\n                try:\n                    error_data = response.json()\n                    errors = error_data.get(\"errors\", {})\n                    error_messages = error_data.get(\"errorMessages\", [])\n                    all_errors = list(errors.values()) + error_messages\n                    error_msg = \"; \".join(str(e) for e in all_errors) or \"Bad request\"\n                except json.JSONDecodeError:\n                    error_msg = \"Invalid request format\"\n\n                raise DeliveryError(\n                    f\"Failed to create ticket: {error_msg}\",\n                    self.name,\n                    details={\"status_code\": 400},\n                )\n\n            elif response.status_code == 401:\n                raise AuthenticationError(\n                    \"Authentication failed - token may be expired\",\n                    self.name,\n                )\n\n            elif response.status_code == 403:\n                raise DeliveryError(\n                    \"Access denied - user lacks permission to create issues\",\n                    self.name,\n                    details={\"status_code\": 403},\n                )\n\n            elif response.status_code == 404:\n                raise DeliveryError(\n                    f\"Project '{self.jira_credentials.project_key}' not found\",\n                    self.name,\n                    details={\"status_code\": 404},\n                )\n\n            else:\n                raise DeliveryError(\n                    f\"Unexpected response: HTTP {response.status_code}\",\n                    self.name,\n                    details={\"status_code\": response.status_code},\n                )\n\n        except (RateLimitError, AuthenticationError, DeliveryError):\n            raise\n\n        except httpx.TimeoutException as e:\n            raise DeliveryError(\n                f\"Request timed out: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise DeliveryError(\n                f\"Network error: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except Exception as e:\n            raise DeliveryError(\n                f\"Unexpected error: {str(e)}\",\n                self.name,\n            ) from e\n\n    def _build_issue_payload(self, event: IntegrationEvent) -> Dict[str, Any]:\n        \"\"\"\n        Build the Jira issue creation payload from an event.\n\n        Args:\n            event: The governance event to convert to a ticket\n\n        Returns:\n            Dictionary formatted for Jira issue creation API\n        \"\"\"\n        # Build summary from template\n        summary = self.jira_credentials.ticket_summary_template.format(\n            title=event.title,\n            event_type=event.event_type,\n            severity=event.severity.value,\n        )\n        # Jira summary max length is 255 characters\n        if len(summary) > 255:\n            summary = summary[:252] + \"...\"\n\n        # Build description\n        description = self._build_description(event)\n\n        # Get priority\n        priority_name = self._get_priority_for_severity(event.severity)\n\n        # Build the base issue payload\n        fields: Dict[str, Any] = {\n            \"project\": {\"key\": self.jira_credentials.project_key},\n            \"summary\": summary,\n            \"issuetype\": {\"name\": self.jira_credentials.issue_type},\n        }\n\n        # Add description based on API version\n        if self.jira_credentials.deployment_type == JiraDeploymentType.CLOUD:\n            # Jira Cloud uses Atlassian Document Format (ADF)\n            fields[\"description\"] = self._convert_to_adf(description)\n        else:\n            # Jira Server uses plain text or wiki markup\n            fields[\"description\"] = description\n\n        # Add priority if we have it mapped\n        if priority_name:\n            priority_id = self._priority_ids.get(priority_name.lower())\n            if priority_id:\n                fields[\"priority\"] = {\"id\": priority_id}\n            else:\n                fields[\"priority\"] = {\"name\": priority_name}\n\n        # Add labels\n        if self.jira_credentials.labels:\n            # Add event-specific labels\n            labels = list(self.jira_credentials.labels)\n            if event.severity:\n                labels.append(f\"severity-{event.severity.value}\")\n            if event.event_type:\n                labels.append(event.event_type.replace(\"_\", \"-\"))\n            fields[\"labels\"] = labels\n\n        # Add components if configured\n        if self.jira_credentials.components:\n            fields[\"components\"] = [{\"name\": c} for c in self.jira_credentials.components]\n\n        # Add custom fields\n        for field_id, value in self.jira_credentials.custom_fields.items():\n            fields[field_id] = value\n\n        return {\"fields\": fields}\n\n    def _build_description(self, event: IntegrationEvent) -> str:\n        \"\"\"\n        Build the ticket description from an event.\n\n        Args:\n            event: The governance event\n\n        Returns:\n            Formatted description string\n        \"\"\"\n        lines = [\n            f\"*Event ID:* {event.event_id}\",\n            f\"*Event Type:* {event.event_type}\",\n            f\"*Severity:* {event.severity.value.upper()}\",\n            f\"*Timestamp:* {event.timestamp.isoformat()}\",\n            f\"*Source:* {event.source}\",\n            \"\",\n        ]\n\n        if event.description:\n            lines.extend([\"*Description:*\", event.description, \"\"])\n\n        # Add policy information\n        if event.policy_id:\n            lines.append(f\"*Policy ID:* {event.policy_id}\")\n\n        # Add resource information\n        if event.resource_id or event.resource_type:\n            lines.append(\"\")\n            lines.append(\"h3. Resource Information\")\n            if event.resource_id:\n                lines.append(f\"* *Resource ID:* {event.resource_id}\")\n            if event.resource_type:\n                lines.append(f\"* *Resource Type:* {event.resource_type}\")\n\n        # Add action/outcome\n        if event.action or event.outcome:\n            lines.append(\"\")\n            lines.append(\"h3. Action Details\")\n            if event.action:\n                lines.append(f\"* *Action:* {event.action}\")\n            if event.outcome:\n                lines.append(f\"* *Outcome:* {event.outcome}\")\n\n        # Add metadata\n        if event.user_id or event.tenant_id or event.correlation_id:\n            lines.append(\"\")\n            lines.append(\"h3. Metadata\")\n            if event.user_id:\n                lines.append(f\"* *User ID:* {event.user_id}\")\n            if event.tenant_id:\n                lines.append(f\"* *Tenant ID:* {event.tenant_id}\")\n            if event.correlation_id:\n                lines.append(f\"* *Correlation ID:* {event.correlation_id}\")\n\n        # Add full event details if configured\n        if self.jira_credentials.include_event_details and event.details:\n            lines.append(\"\")\n            lines.append(\"h3. Event Details\")\n            lines.append(\"{code:json}\")\n            lines.append(json.dumps(event.details, indent=2))\n            lines.append(\"{code}\")\n\n        # Add tags\n        if event.tags:\n            lines.append(\"\")\n            lines.append(f\"*Tags:* {', '.join(event.tags)}\")\n\n        # Footer\n        lines.extend(\n            [\n                \"\",\n                \"----\",\n                \"_This ticket was automatically created by ACGS-2 Governance Platform._\",\n            ]\n        )\n\n        return \"\\n\".join(lines)\n\n    def _convert_to_adf(self, text: str) -> Dict[str, Any]:\n        \"\"\"\n        Convert wiki markup to Atlassian Document Format (ADF) for Jira Cloud.\n\n        This is a simplified conversion that creates a basic document structure.\n        For full wiki markup support, a proper parser would be needed.\n\n        Args:\n            text: Text in wiki markup format\n\n        Returns:\n            ADF document structure\n        \"\"\"\n        # Create a simple paragraph-based ADF document\n        paragraphs = []\n\n        for line in text.split(\"\\n\"):\n            if not line.strip():\n                continue\n\n            # Handle code blocks\n            if line.strip() == \"{code:json}\":\n                continue\n            if line.strip() == \"{code}\":\n                continue\n\n            # Handle headings\n            if line.startswith(\"h3. \"):\n                paragraphs.append(\n                    {\n                        \"type\": \"heading\",\n                        \"attrs\": {\"level\": 3},\n                        \"content\": [{\"type\": \"text\", \"text\": line[4:]}],\n                    }\n                )\n                continue\n\n            # Handle horizontal rule\n            if line.strip() == \"----\":\n                paragraphs.append({\"type\": \"rule\"})\n                continue\n\n            # Handle list items\n            if line.startswith(\"* \"):\n                # For simplicity, convert to paragraph with bullet\n                paragraphs.append(\n                    {\n                        \"type\": \"paragraph\",\n                        \"content\": [{\"type\": \"text\", \"text\": line}],\n                    }\n                )\n                continue\n\n            # Regular paragraph\n            # Handle basic wiki markup: *bold*, _italic_\n            content = []\n            current_text = line\n\n            # Simplified: just add as plain text\n            # A full implementation would parse wiki markup\n            content.append({\"type\": \"text\", \"text\": current_text})\n\n            paragraphs.append(\n                {\n                    \"type\": \"paragraph\",\n                    \"content\": content,\n                }\n            )\n\n        return {\n            \"type\": \"doc\",\n            \"version\": 1,\n            \"content\": paragraphs,\n        }\n\n    def _get_priority_for_severity(self, severity: EventSeverity) -> Optional[str]:\n        \"\"\"\n        Get Jira priority name for a given severity level.\n\n        Uses custom mapping if configured, otherwise uses defaults.\n\n        Args:\n            severity: Event severity level\n\n        Returns:\n            Jira priority name or None\n        \"\"\"\n        # Check custom mapping first\n        custom_priority = self.jira_credentials.priority_mapping.get(severity.value)\n        if custom_priority:\n            return custom_priority\n\n        # Use default mapping\n        return DEFAULT_PRIORITY_MAP.get(severity)\n\n    async def _do_test_connection(self) -> IntegrationResult:\n        \"\"\"\n        Test connection to Jira without authenticating.\n\n        Returns:\n            IntegrationResult indicating connection status\n        \"\"\"\n        logger.debug(f\"Testing Jira connection for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Try to reach the server info endpoint (doesn't require auth)\n            server_info_url = f\"{self.jira_credentials.base_url}/rest/api/2/serverInfo\"\n\n            response = await client.get(server_info_url)\n\n            # Any response indicates the server is reachable\n            if response.status_code < 500:\n                try:\n                    server_info = response.json()\n                    version = server_info.get(\"version\", \"unknown\")\n                    deployment = server_info.get(\"deploymentType\", \"unknown\")\n                    logger.debug(\n                        f\"Jira server reachable: version={version}, \" f\"deployment={deployment}\"\n                    )\n                except json.JSONDecodeError:\n                    pass\n\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                )\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Server returned status {response.status_code}\",\n                )\n\n        except httpx.TimeoutException:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"TIMEOUT\",\n                error_message=f\"Connection timed out after {self.timeout}s\",\n            )\n\n        except httpx.NetworkError as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"NETWORK_ERROR\",\n                error_message=str(e),\n            )\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"UNKNOWN_ERROR\",\n                error_message=str(e),\n            )\n\n    async def get_issue(self, issue_key: str) -> IntegrationResult:\n        \"\"\"\n        Get details of an existing Jira issue.\n\n        Args:\n            issue_key: The issue key (e.g., GOV-123)\n\n        Returns:\n            IntegrationResult with issue details or error\n        \"\"\"\n        if not self._authenticated:\n            raise AuthenticationError(\"Integration is not authenticated\", self.name)\n\n        logger.debug(f\"Fetching Jira issue {issue_key}\")\n\n        try:\n            client = await self.get_http_client()\n\n            issue_url = f\"{self._get_api_base_url()}/issue/{issue_key}\"\n\n            response = await client.get(\n                issue_url,\n                headers=self._get_auth_headers(),\n            )\n\n            if response.status_code == 200:\n                issue_data = response.json()\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"get_issue\",\n                    external_id=issue_key,\n                    external_url=f\"{self.jira_credentials.base_url}/browse/{issue_key}\",\n                    error_details=issue_data,  # Using error_details to pass data\n                )\n\n            elif response.status_code == 404:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"get_issue\",\n                    error_code=\"NOT_FOUND\",\n                    error_message=f\"Issue {issue_key} not found\",\n                )\n\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"get_issue\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Failed to fetch issue: HTTP {response.status_code}\",\n                )\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"get_issue\",\n                error_code=\"ERROR\",\n                error_message=str(e),\n            )\n\n    async def add_comment(self, issue_key: str, comment: str) -> IntegrationResult:\n        \"\"\"\n        Add a comment to an existing Jira issue.\n\n        Args:\n            issue_key: The issue key (e.g., GOV-123)\n            comment: The comment text\n\n        Returns:\n            IntegrationResult with comment details or error\n        \"\"\"\n        if not self._authenticated:\n            raise AuthenticationError(\"Integration is not authenticated\", self.name)\n\n        logger.debug(f\"Adding comment to Jira issue {issue_key}\")\n\n        try:\n            client = await self.get_http_client()\n\n            comment_url = f\"{self._get_api_base_url()}/issue/{issue_key}/comment\"\n\n            # Build comment payload\n            if self.jira_credentials.deployment_type == JiraDeploymentType.CLOUD:\n                comment_body = {\n                    \"body\": self._convert_to_adf(comment),\n                }\n            else:\n                comment_body = {\"body\": comment}\n\n            response = await client.post(\n                comment_url,\n                headers=self._get_auth_headers(),\n                json=comment_body,\n            )\n\n            if response.status_code == 201:\n                comment_data = response.json()\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"add_comment\",\n                    external_id=comment_data.get(\"id\"),\n                )\n\n            else:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"add_comment\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Failed to add comment: HTTP {response.status_code}\",\n                )\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"add_comment\",\n                error_code=\"ERROR\",\n                error_message=str(e),\n            )\n\n    async def close(self) -> None:\n        \"\"\"Close the integration and cleanup resources\"\"\"\n        self._project_id = None\n        self._issue_type_id = None\n        self._priority_ids = {}\n        await super().close()\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.742736",
  "last_updated": "2026-01-04T00:39:57.745664"
}