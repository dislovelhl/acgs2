{
  "file_path": "src/core/shared/secrets_manager.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 Development Secrets Manager\nConstitutional Hash: cdd01ef066bc6cf2\n\nSecure secrets management for development workflows with:\n- Vault integration for production-grade secret storage\n- Encrypted local storage fallback\n- Credential validation and rotation reminders\n- Auto Claude / Claude Code integration support\n\"\"\"\n\nimport base64\nimport hashlib\nimport json\nimport logging\nimport os\nimport re\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone, timedelta\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nlogger = logging.getLogger(__name__)\n\n# Constitutional compliance\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n# Credential patterns for validation\nCREDENTIAL_PATTERNS = {\n    \"CLAUDE_CODE_OAUTH_TOKEN\": r\"^sk-ant-oat\\d{2}-[A-Za-z0-9_-]{60,}$\",\n    \"OPENAI_API_KEY\": r\"^sk-[A-Za-z0-9]{20,}$\",\n    \"OPENROUTER_API_KEY\": r\"^sk-or-v1-[A-Za-z0-9]{60,}$\",\n    \"HF_TOKEN\": r\"^hf_[A-Za-z0-9]{30,}$\",\n    \"ANTHROPIC_API_KEY\": r\"^sk-ant-[A-Za-z0-9_-]{80,}$\",\n    \"AWS_ACCESS_KEY_ID\": r\"^AKIA[A-Z0-9]{16}$\",\n    \"JWT_SECRET\": r\"^[A-Fa-f0-9]{64}$\",\n    \"VAULT_TOKEN\": r\"^(hvs\\.|s\\.)[A-Za-z0-9]{20,}$\",\n}\n\n# Secret categories for organization\nSECRET_CATEGORIES = {\n    \"ai_providers\": [\n        \"CLAUDE_CODE_OAUTH_TOKEN\",\n        \"OPENAI_API_KEY\",\n        \"OPENROUTER_API_KEY\",\n        \"HF_TOKEN\",\n        \"ANTHROPIC_API_KEY\",\n    ],\n    \"security\": [\n        \"JWT_SECRET\",\n        \"API_KEY_INTERNAL\",\n        \"AUDIT_SIGNATURE_KEY\",\n    ],\n    \"infrastructure\": [\n        \"VAULT_TOKEN\",\n        \"REDIS_PASSWORD\",\n        \"DB_USER_PASSWORD\",\n        \"KAFKA_SASL_PASSWORD\",\n    ],\n    \"cloud\": [\n        \"AWS_ACCESS_KEY_ID\",\n        \"AWS_SECRET_ACCESS_KEY\",\n        \"BLOCKCHAIN_PRIVATE_KEY\",\n    ],\n}\n\n\n@dataclass\nclass SecretMetadata:\n    \"\"\"Metadata for a stored secret.\"\"\"\n\n    name: str\n    category: str\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_rotated: Optional[datetime] = None\n    rotation_days: int = 90\n    is_sensitive: bool = True\n    description: str = \"\"\n\n    @property\n    def needs_rotation(self) -> bool:\n        \"\"\"Check if secret needs rotation based on age.\"\"\"\n        reference_date = self.last_rotated or self.created_at\n        age = datetime.now(timezone.utc) - reference_date\n        return age > timedelta(days=self.rotation_days)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"category\": self.category,\n            \"created_at\": self.created_at.isoformat(),\n            \"last_rotated\": self.last_rotated.isoformat() if self.last_rotated else None,\n            \"rotation_days\": self.rotation_days,\n            \"is_sensitive\": self.is_sensitive,\n            \"description\": self.description,\n        }\n\n\nclass SecretsManager:\n    \"\"\"\n    Secure secrets manager with Vault integration and encrypted local storage.\n\n    Usage:\n        manager = SecretsManager()\n\n        # Get a secret\n        api_key = manager.get(\"OPENAI_API_KEY\")\n\n        # Store a secret\n        manager.set(\"OPENAI_API_KEY\", \"sk-...\")\n\n        # Check rotation status\n        for secret in manager.secrets_needing_rotation():\n            print(f\"{secret.name} needs rotation\")\n    \"\"\"\n\n    def __init__(\n        self,\n        vault_enabled: bool = False,\n        vault_path: str = \"secret/acgs2/development\",\n        local_storage_path: Optional[Path] = None,\n        encryption_key: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize secrets manager.\n\n        Args:\n            vault_enabled: Whether to use Vault for storage\n            vault_path: Vault KV path for secrets\n            local_storage_path: Path for encrypted local storage\n            encryption_key: Key for local encryption (derived from env if not provided)\n        \"\"\"\n        self._vault_enabled = vault_enabled\n        self._vault_path = vault_path\n        self._vault_client: Optional[Any] = None\n\n        # Local encrypted storage\n        self._storage_path = local_storage_path or Path.home() / \".acgs2\" / \"secrets.enc\"\n        self._metadata_path = self._storage_path.with_suffix(\".meta.json\")\n\n        # Encryption setup\n        self._fernet = self._setup_encryption(encryption_key)\n\n        # In-memory cache\n        self._cache: Dict[str, str] = {}\n        self._metadata: Dict[str, SecretMetadata] = {}\n\n        # Load existing metadata\n        self._load_metadata()\n\n        # Initialize Vault if enabled\n        if vault_enabled:\n            self._init_vault()\n\n    def _setup_encryption(self, encryption_key: Optional[str]) -> Fernet:\n        \"\"\"Set up Fernet encryption with derived key.\"\"\"\n        if encryption_key:\n            key_bytes = encryption_key.encode()\n        else:\n            # Derive key from constitutional hash + machine ID\n            machine_id = self._get_machine_id()\n            key_source = f\"{CONSTITUTIONAL_HASH}:{machine_id}\"\n            key_bytes = key_source.encode()\n\n        # Use PBKDF2 to derive a proper key\n        salt = hashlib.sha256(CONSTITUTIONAL_HASH.encode()).digest()[:16]\n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=salt,\n            iterations=100000,\n        )\n        key = base64.urlsafe_b64encode(kdf.derive(key_bytes))\n        return Fernet(key)\n\n    def _get_machine_id(self) -> str:\n        \"\"\"Get a stable machine identifier.\"\"\"\n        try:\n            # Try to use machine-id on Linux\n            machine_id_path = Path(\"/etc/machine-id\")\n            if machine_id_path.exists():\n                return machine_id_path.read_text().strip()\n        except Exception:\n            pass\n\n        # Fallback to hostname + username\n        import socket\n\n        return f\"{socket.gethostname()}:{os.getenv('USER', 'unknown')}\"\n\n    def _init_vault(self) -> None:\n        \"\"\"Initialize Vault client.\"\"\"\n        try:\n            from shared.config import settings\n\n            if settings.vault.token:\n                # Use existing Vault infrastructure\n                from services.policy_registry.app.services.vault_http_client import (\n                    VaultHttpClient,\n                )\n                from services.policy_registry.app.services.vault_kv import (\n                    VaultKVOperations,\n                )\n\n                self._vault_client = True  # Mark as available\n                logger.info(\"Vault integration initialized\")\n        except ImportError:\n            logger.warning(\"Vault services not available, using local storage\")\n            self._vault_enabled = False\n\n    def _load_metadata(self) -> None:\n        \"\"\"Load secret metadata from disk.\"\"\"\n        if self._metadata_path.exists():\n            try:\n                data = json.loads(self._metadata_path.read_text())\n                for name, meta in data.items():\n                    self._metadata[name] = SecretMetadata(\n                        name=meta[\"name\"],\n                        category=meta[\"category\"],\n                        created_at=datetime.fromisoformat(meta[\"created_at\"]),\n                        last_rotated=(\n                            datetime.fromisoformat(meta[\"last_rotated\"])\n                            if meta.get(\"last_rotated\")\n                            else None\n                        ),\n                        rotation_days=meta.get(\"rotation_days\", 90),\n                        is_sensitive=meta.get(\"is_sensitive\", True),\n                        description=meta.get(\"description\", \"\"),\n                    )\n            except Exception as e:\n                logger.warning(f\"Failed to load metadata: {e}\")\n\n    def _save_metadata(self) -> None:\n        \"\"\"Save secret metadata to disk.\"\"\"\n        self._metadata_path.parent.mkdir(parents=True, exist_ok=True)\n        data = {name: meta.to_dict() for name, meta in self._metadata.items()}\n        self._metadata_path.write_text(json.dumps(data, indent=2))\n        # Restrict permissions\n        os.chmod(self._metadata_path, 0o600)\n\n    def _get_category(self, name: str) -> str:\n        \"\"\"Determine category for a secret name.\"\"\"\n        for category, secrets in SECRET_CATEGORIES.items():\n            if name in secrets:\n                return category\n        return \"other\"\n\n    def validate_format(self, name: str, value: str) -> bool:\n        \"\"\"\n        Validate credential format against known patterns.\n\n        Args:\n            name: Credential name\n            value: Credential value\n\n        Returns:\n            True if valid or no pattern defined, False if invalid\n        \"\"\"\n        pattern = CREDENTIAL_PATTERNS.get(name)\n        if pattern is None:\n            return True\n        return bool(re.match(pattern, value))\n\n    def get(\n        self,\n        name: str,\n        default: Optional[str] = None,\n        from_env: bool = True,\n    ) -> Optional[str]:\n        \"\"\"\n        Get a secret value.\n\n        Priority:\n        1. In-memory cache\n        2. Environment variable (if from_env=True)\n        3. Vault (if enabled)\n        4. Local encrypted storage\n\n        Args:\n            name: Secret name\n            default: Default value if not found\n            from_env: Whether to check environment variables\n\n        Returns:\n            Secret value or default\n        \"\"\"\n        # Check cache\n        if name in self._cache:\n            return self._cache[name]\n\n        # Check environment\n        if from_env:\n            env_value = os.getenv(name)\n            if env_value:\n                self._cache[name] = env_value\n                return env_value\n\n        # Check Vault\n        if self._vault_enabled and self._vault_client:\n            try:\n                # Would use actual Vault client here\n                pass\n            except Exception as e:\n                logger.warning(f\"Vault lookup failed for {name}: {e}\")\n\n        # Check local storage\n        if self._storage_path.exists():\n            try:\n                encrypted = self._storage_path.read_bytes()\n                decrypted = self._fernet.decrypt(encrypted)\n                secrets = json.loads(decrypted)\n                if name in secrets:\n                    self._cache[name] = secrets[name]\n                    return secrets[name]\n            except Exception as e:\n                logger.warning(f\"Local storage lookup failed: {e}\")\n\n        return default\n\n    def set(\n        self,\n        name: str,\n        value: str,\n        validate: bool = True,\n        rotation_days: int = 90,\n    ) -> bool:\n        \"\"\"\n        Store a secret securely.\n\n        Args:\n            name: Secret name\n            value: Secret value\n            validate: Whether to validate format\n            rotation_days: Days until rotation reminder\n\n        Returns:\n            True if stored successfully\n        \"\"\"\n        # Validate format\n        if validate and not self.validate_format(name, value):\n            logger.error(f\"Invalid format for {name}\")\n            return False\n\n        # Update cache\n        self._cache[name] = value\n\n        # Update metadata\n        category = self._get_category(name)\n        if name in self._metadata:\n            self._metadata[name].last_rotated = datetime.now(timezone.utc)\n        else:\n            self._metadata[name] = SecretMetadata(\n                name=name,\n                category=category,\n                rotation_days=rotation_days,\n            )\n\n        # Store in Vault if enabled\n        if self._vault_enabled and self._vault_client:\n            try:\n                # Would use actual Vault client here\n                pass\n            except Exception as e:\n                logger.error(f\"Vault storage failed: {e}\")\n\n        # Store locally\n        try:\n            # Load existing secrets\n            secrets: Dict[str, str] = {}\n            if self._storage_path.exists():\n                encrypted = self._storage_path.read_bytes()\n                decrypted = self._fernet.decrypt(encrypted)\n                secrets = json.loads(decrypted)\n\n            # Update and save\n            secrets[name] = value\n            encrypted = self._fernet.encrypt(json.dumps(secrets).encode())\n            self._storage_path.parent.mkdir(parents=True, exist_ok=True)\n            self._storage_path.write_bytes(encrypted)\n            os.chmod(self._storage_path, 0o600)\n\n            # Save metadata\n            self._save_metadata()\n\n            return True\n\n        except Exception as e:\n            logger.error(f\"Failed to store secret: {e}\")\n            return False\n\n    def delete(self, name: str) -> bool:\n        \"\"\"\n        Delete a secret.\n\n        Args:\n            name: Secret name\n\n        Returns:\n            True if deleted successfully\n        \"\"\"\n        # Remove from cache\n        self._cache.pop(name, None)\n        self._metadata.pop(name, None)\n\n        # Remove from local storage\n        if self._storage_path.exists():\n            try:\n                encrypted = self._storage_path.read_bytes()\n                decrypted = self._fernet.decrypt(encrypted)\n                secrets = json.loads(decrypted)\n                secrets.pop(name, None)\n                encrypted = self._fernet.encrypt(json.dumps(secrets).encode())\n                self._storage_path.write_bytes(encrypted)\n            except Exception as e:\n                logger.error(f\"Failed to delete from local storage: {e}\")\n                return False\n\n        # Save updated metadata\n        self._save_metadata()\n        return True\n\n    def list_secrets(self) -> List[str]:\n        \"\"\"List all stored secret names.\"\"\"\n        secrets_set = set(self._metadata.keys())\n\n        # Add from local storage\n        if self._storage_path.exists():\n            try:\n                encrypted = self._storage_path.read_bytes()\n                decrypted = self._fernet.decrypt(encrypted)\n                secrets = json.loads(decrypted)\n                secrets_set.update(secrets.keys())\n            except Exception:\n                pass\n\n        return sorted(secrets_set)\n\n    def secrets_needing_rotation(self) -> List[SecretMetadata]:\n        \"\"\"Get list of secrets that need rotation.\"\"\"\n        return [meta for meta in self._metadata.values() if meta.needs_rotation]\n\n    def rotation_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a rotation status report.\n\n        Returns:\n            Report with rotation status for all secrets\n        \"\"\"\n        report = {\n            \"generated_at\": datetime.now(timezone.utc).isoformat(),\n            \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            \"total_secrets\": len(self._metadata),\n            \"needs_rotation\": [],\n            \"ok\": [],\n            \"by_category\": {},\n        }\n\n        for name, meta in self._metadata.items():\n            status = {\n                \"name\": name,\n                \"category\": meta.category,\n                \"age_days\": (\n                    datetime.now(timezone.utc) - (meta.last_rotated or meta.created_at)\n                ).days,\n                \"rotation_days\": meta.rotation_days,\n            }\n\n            if meta.needs_rotation:\n                report[\"needs_rotation\"].append(status)\n            else:\n                report[\"ok\"].append(status)\n\n            # Group by category\n            if meta.category not in report[\"by_category\"]:\n                report[\"by_category\"][meta.category] = []\n            report[\"by_category\"][meta.category].append(status)\n\n        return report\n\n    def export_env_format(self, mask: bool = True) -> str:\n        \"\"\"\n        Export secrets in .env format.\n\n        Args:\n            mask: Whether to mask secret values\n\n        Returns:\n            String in .env format\n        \"\"\"\n        lines = [\n            f\"# ACGS-2 Secrets Export\",\n            f\"# Generated: {datetime.now(timezone.utc).isoformat()}\",\n            f\"# Constitutional Hash: {CONSTITUTIONAL_HASH}\",\n            \"\",\n        ]\n\n        for name in self.list_secrets():\n            value = self.get(name, from_env=False)\n            if value:\n                if mask:\n                    # Show only first 4 and last 4 characters\n                    if len(value) > 12:\n                        masked = f\"{value[:4]}...{value[-4:]}\"\n                    else:\n                        masked = \"***\"\n                    lines.append(f\"{name}={masked}\")\n                else:\n                    lines.append(f\"{name}={value}\")\n\n        return \"\\n\".join(lines)\n\n\n# Singleton instance for convenience\n_manager: Optional[SecretsManager] = None\n\n\ndef get_secrets_manager(\n    vault_enabled: bool = False,\n    **kwargs: Any,\n) -> SecretsManager:\n    \"\"\"Get or create the secrets manager singleton.\"\"\"\n    global _manager\n    if _manager is None:\n        _manager = SecretsManager(vault_enabled=vault_enabled, **kwargs)\n    return _manager\n\n\n__all__ = [\n    \"SecretsManager\",\n    \"SecretMetadata\",\n    \"get_secrets_manager\",\n    \"CREDENTIAL_PATTERNS\",\n    \"SECRET_CATEGORIES\",\n    \"CONSTITUTIONAL_HASH\",\n]\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.157035",
  "last_updated": "2026-01-04T05:35:59.050636"
}