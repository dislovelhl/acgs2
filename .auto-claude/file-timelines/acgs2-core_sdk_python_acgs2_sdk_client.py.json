{
  "file_path": "acgs2-core/sdk/python/acgs2_sdk/client.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 SDK HTTP Client\nConstitutional Hash: cdd01ef066bc6cf2\n\"\"\"\n\nimport logging\nfrom datetime import UTC, datetime\nfrom typing import Any, TypeVar\nfrom uuid import uuid4\n\nimport httpx\nfrom pydantic import BaseModel\nfrom tenacity import (\n    retry,\n    retry_if_exception_type,\n    stop_after_attempt,\n    wait_exponential_jitter,\n)\n\nfrom acgs2_sdk.config import ACGS2Config\nfrom acgs2_sdk.constants import (\n    CONSTITUTIONAL_HASH,\n    HEADER_CONSTITUTIONAL_HASH,\n    HEADER_REQUEST_ID,\n    HEADER_SDK_LANGUAGE,\n    HEADER_SDK_VERSION,\n    HEADER_TENANT_ID,\n    HEALTH_ENDPOINT,\n    SDK_VERSION,\n)\nfrom acgs2_sdk.exceptions import (\n    AuthenticationError,\n    AuthorizationError,\n    ConstitutionalHashMismatchError,\n    NetworkError,\n    RateLimitError,\n    ResourceNotFoundError,\n    TimeoutError,\n    ValidationError,\n)\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar(\"T\", bound=BaseModel)\n\n\nclass ACGS2Client:\n    \"\"\"ACGS-2 API Client with constitutional hash validation.\"\"\"\n\n    def __init__(self, config: ACGS2Config) -> None:\n        \"\"\"Initialize the client.\n\n        Args:\n            config: Client configuration\n        \"\"\"\n        self.config = config\n        self._client: httpx.AsyncClient | None = None\n\n    async def __aenter__(self) -> \"ACGS2Client\":\n        \"\"\"Async context manager entry.\"\"\"\n        await self._ensure_client()\n        return self\n\n    async def __aexit__(self, *args: Any) -> None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n    async def _ensure_client(self) -> httpx.AsyncClient:\n        \"\"\"Ensure HTTP client is initialized.\"\"\"\n        if self._client is None or self._client.is_closed:\n            self._client = httpx.AsyncClient(\n                base_url=str(self.config.base_url),\n                timeout=httpx.Timeout(self.config.timeout),\n                headers=self._get_default_headers(),\n            )\n        return self._client\n\n    def _get_default_headers(self) -> dict[str, str]:\n        \"\"\"Get default request headers.\"\"\"\n        headers = {\n            \"Content-Type\": \"application/json\",\n            HEADER_CONSTITUTIONAL_HASH: CONSTITUTIONAL_HASH,\n            HEADER_SDK_VERSION: SDK_VERSION,\n            HEADER_SDK_LANGUAGE: \"python\",\n            **self.config.get_auth_headers(),\n        }\n        if self.config.tenant_id:\n            headers[HEADER_TENANT_ID] = self.config.tenant_id\n        return headers\n\n    async def close(self) -> None:\n        \"\"\"Close the HTTP client.\"\"\"\n        if self._client:\n            await self._client.aclose()\n            self._client = None\n\n    def _validate_constitutional_hash(self, data: dict[str, Any]) -> None:\n        \"\"\"Validate constitutional hash in response.\"\"\"\n        if not self.config.validate_constitutional_hash:\n            return\n\n        response_hash = data.get(\"constitutionalHash\") or data.get(\"constitutional_hash\")\n        if response_hash and response_hash != CONSTITUTIONAL_HASH:\n            if self.config.on_constitutional_violation:\n                self.config.on_constitutional_violation(CONSTITUTIONAL_HASH, response_hash)\n            raise ConstitutionalHashMismatchError(\n                expected=CONSTITUTIONAL_HASH,\n                received=response_hash,\n            )\n\n    def _handle_error_response(self, response: httpx.Response) -> None:\n        \"\"\"Handle error responses.\"\"\"\n        status = response.status_code\n        try:\n            data = response.json()\n            message = data.get(\"error\", {}).get(\"message\", response.text)\n        except Exception:\n            message = response.text\n\n        if status == 401:\n            raise AuthenticationError(message)\n        elif status == 403:\n            raise AuthorizationError(message)\n        elif status == 404:\n            raise ResourceNotFoundError(message)\n        elif status == 422:\n            raise ValidationError(message)\n        elif status == 429:\n            retry_after = response.headers.get(\"Retry-After\")\n            raise RateLimitError(\n                message,\n                retry_after=int(retry_after) if retry_after else None,\n            )\n        else:\n            raise NetworkError(message, status_code=status)\n\n    async def _request(\n        self,\n        method: str,\n        path: str,\n        params: dict[str, Any] | None = None,\n        json: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Make an HTTP request with retry logic.\"\"\"\n        client = await self._ensure_client()\n\n        @retry(\n            stop=stop_after_attempt(self.config.retry.max_attempts),\n            wait=wait_exponential_jitter(\n                initial=self.config.retry.base_delay,\n                max=self.config.retry.max_delay,\n            ),\n            retry=retry_if_exception_type((NetworkError, RateLimitError)),\n            reraise=True,\n        )\n        async def _do_request() -> dict[str, Any]:\n            headers = {HEADER_REQUEST_ID: str(uuid4())}\n            logger.debug(f\"Request: {method} {path}\")\n\n            try:\n                response = await client.request(\n                    method=method,\n                    url=path,\n                    params=params,\n                    json=json,\n                    headers=headers,\n                )\n            except httpx.TimeoutException as e:\n                raise TimeoutError(str(e)) from e\n            except httpx.RequestError as e:\n                raise NetworkError(str(e)) from e\n\n            logger.debug(f\"Response: {response.status_code}\")\n\n            if response.status_code >= 400:\n                self._handle_error_response(response)\n\n            data = response.json()\n            self._validate_constitutional_hash(data)\n            return data\n\n        return await _do_request()\n\n    async def get(\n        self,\n        path: str,\n        params: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Make a GET request.\"\"\"\n        return await self._request(\"GET\", path, params=params)\n\n    async def post(\n        self,\n        path: str,\n        json: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Make a POST request.\"\"\"\n        return await self._request(\"POST\", path, json=json)\n\n    async def put(\n        self,\n        path: str,\n        json: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Make a PUT request.\"\"\"\n        return await self._request(\"PUT\", path, json=json)\n\n    async def patch(\n        self,\n        path: str,\n        json: dict[str, Any] | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Make a PATCH request.\"\"\"\n        return await self._request(\"PATCH\", path, json=json)\n\n    async def delete(self, path: str) -> dict[str, Any]:\n        \"\"\"Make a DELETE request.\"\"\"\n        return await self._request(\"DELETE\", path)\n\n    async def health_check(self) -> dict[str, Any]:\n        \"\"\"Check API health.\n\n        Returns:\n            Health check response with latency information\n        \"\"\"\n        start = datetime.now(UTC)\n        try:\n            data = await self.get(HEALTH_ENDPOINT)\n            latency_ms = (datetime.now(UTC) - start).total_seconds() * 1000\n            return {\n                \"healthy\": True,\n                \"latency_ms\": latency_ms,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                \"version\": data.get(\"version\"),\n            }\n        except Exception:\n            latency_ms = (datetime.now(UTC) - start).total_seconds() * 1000\n            return {\n                \"healthy\": False,\n                \"latency_ms\": latency_ms,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            }\n\n\ndef create_client(config: ACGS2Config) -> ACGS2Client:\n    \"\"\"Create an ACGS2Client instance.\n\n    Args:\n        config: Client configuration\n\n    Returns:\n        Configured ACGS2Client instance\n    \"\"\"\n    return ACGS2Client(config)\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.315705",
  "last_updated": "2026-01-04T05:35:58.741841"
}