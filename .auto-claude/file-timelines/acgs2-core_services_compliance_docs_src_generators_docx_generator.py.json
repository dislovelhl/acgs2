{
  "file_path": "src/core/services/compliance_docs/src/generators/docx_generator.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"Constitutional Hash: cdd01ef066bc6cf2\nDOCX Document Generator for Compliance Documentation Service\n\nGenerates professional compliance reports in DOCX format using python-docx.\nSupports all compliance frameworks: SOC 2, ISO 27001, GDPR, and EU AI Act.\n\nThis module uses Document() for new files and provides structured document\ngeneration with headings, paragraphs, tables, and professional styling.\n\nNote: python-docx only supports .docx format (not legacy .doc format).\n\"\"\"\n\nimport io\nimport logging\nimport os\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any, BinaryIO, Optional, Union\n\nfrom docx import Document\nfrom docx.enum.section import WD_ORIENT\nfrom docx.enum.style import WD_STYLE_TYPE\nfrom docx.enum.table import WD_TABLE_ALIGNMENT\nfrom docx.enum.text import WD_ALIGN_PARAGRAPH\nfrom docx.oxml import OxmlElement\nfrom docx.oxml.ns import qn\nfrom docx.shared import Inches, Pt, RGBColor\nfrom docx.table import Table\n\nfrom ..models.base import ComplianceFramework\n\nlogger = logging.getLogger(__name__)\n\n\n# Default output path for generated DOCX files\n_DEFAULT_OUTPUT_PATH = Path(tempfile.gettempdir()) / \"compliance-reports\"\n\n\ndef _get_output_path() -> Path:\n    \"\"\"\n    Resolve output path from environment or use default.\n\n    Returns:\n        Path to output directory for generated DOCX files.\n    \"\"\"\n    output_path = os.getenv(\"COMPLIANCE_OUTPUT_PATH\")\n    if output_path:\n        return Path(output_path)\n    return _DEFAULT_OUTPUT_PATH\n\n\ndef _ensure_output_dir() -> Path:\n    \"\"\"\n    Ensure the output directory exists.\n\n    Returns:\n        Path to the output directory.\n    \"\"\"\n    output_path = _get_output_path()\n    output_path.mkdir(parents=True, exist_ok=True)\n    return output_path\n\n\nclass ComplianceDOCXStyles:\n    \"\"\"\n    Custom styles for compliance DOCX documents.\n\n    Provides professional, consistent styling across all compliance reports.\n    \"\"\"\n\n    # Color definitions\n    PRIMARY_COLOR = RGBColor(0x1A, 0x36, 0x5D)  # Dark blue\n    SECONDARY_COLOR = RGBColor(0x2C, 0x52, 0x82)  # Medium blue\n    ACCENT_COLOR = RGBColor(0x42, 0x99, 0xE1)  # Light blue\n    SUCCESS_COLOR = RGBColor(0x27, 0x67, 0x49)  # Green\n    DANGER_COLOR = RGBColor(0xC5, 0x30, 0x30)  # Red\n    WARNING_COLOR = RGBColor(0xC0, 0x56, 0x21)  # Orange\n    TEXT_COLOR = RGBColor(0x2D, 0x37, 0x48)  # Dark gray\n    MUTED_COLOR = RGBColor(0x4A, 0x55, 0x68)  # Gray\n\n    def __init__(self, document: Document) -> None:\n        \"\"\"\n        Initialize custom DOCX styles.\n\n        Args:\n            document: The Document instance to apply styles to.\n        \"\"\"\n        self.document = document\n        self._apply_custom_styles()\n\n    def _apply_custom_styles(self) -> None:\n        \"\"\"Apply custom styles to the document.\"\"\"\n        styles = self.document.styles\n\n        # Modify existing Title style\n        title_style = styles[\"Title\"]\n        title_style.font.size = Pt(28)\n        title_style.font.color.rgb = self.PRIMARY_COLOR\n        title_style.font.bold = True\n        title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER\n        title_style.paragraph_format.space_after = Pt(24)\n\n        # Modify Heading 1\n        h1_style = styles[\"Heading 1\"]\n        h1_style.font.size = Pt(18)\n        h1_style.font.color.rgb = self.SECONDARY_COLOR\n        h1_style.font.bold = True\n        h1_style.paragraph_format.space_before = Pt(18)\n        h1_style.paragraph_format.space_after = Pt(12)\n\n        # Modify Heading 2\n        h2_style = styles[\"Heading 2\"]\n        h2_style.font.size = Pt(14)\n        h2_style.font.color.rgb = self.TEXT_COLOR\n        h2_style.font.bold = True\n        h2_style.paragraph_format.space_before = Pt(12)\n        h2_style.paragraph_format.space_after = Pt(8)\n\n        # Modify Heading 3\n        h3_style = styles[\"Heading 3\"]\n        h3_style.font.size = Pt(12)\n        h3_style.font.color.rgb = self.TEXT_COLOR\n        h3_style.font.bold = True\n        h3_style.paragraph_format.space_before = Pt(10)\n        h3_style.paragraph_format.space_after = Pt(6)\n\n        # Modify Normal style\n        normal_style = styles[\"Normal\"]\n        normal_style.font.size = Pt(11)\n        normal_style.font.color.rgb = self.TEXT_COLOR\n        normal_style.paragraph_format.space_after = Pt(8)\n        normal_style.paragraph_format.line_spacing = 1.15\n\n        # Create custom styles if they don't exist\n        self._create_custom_style(\n            \"ConfidentialNotice\",\n            WD_STYLE_TYPE.PARAGRAPH,\n            font_size=12,\n            font_color=self.DANGER_COLOR,\n            bold=True,\n            alignment=WD_ALIGN_PARAGRAPH.CENTER,\n        )\n\n        self._create_custom_style(\n            \"Metadata\",\n            WD_STYLE_TYPE.PARAGRAPH,\n            font_size=10,\n            font_color=self.MUTED_COLOR,\n            alignment=WD_ALIGN_PARAGRAPH.RIGHT,\n        )\n\n        self._create_custom_style(\n            \"TableHeader\",\n            WD_STYLE_TYPE.PARAGRAPH,\n            font_size=10,\n            font_color=RGBColor(0xFF, 0xFF, 0xFF),\n            bold=True,\n            alignment=WD_ALIGN_PARAGRAPH.CENTER,\n        )\n\n        self._create_custom_style(\n            \"TableCell\",\n            WD_STYLE_TYPE.PARAGRAPH,\n            font_size=9,\n            font_color=self.TEXT_COLOR,\n            alignment=WD_ALIGN_PARAGRAPH.LEFT,\n        )\n\n    def _create_custom_style(\n        self,\n        name: str,\n        style_type: WD_STYLE_TYPE,\n        font_size: int = 11,\n        font_color: RGBColor = None,\n        bold: bool = False,\n        italic: bool = False,\n        alignment: WD_ALIGN_PARAGRAPH = None,\n    ) -> None:\n        \"\"\"\n        Create a custom style if it doesn't exist.\n\n        Args:\n            name: Style name.\n            style_type: Type of style (paragraph, character, etc.).\n            font_size: Font size in points.\n            font_color: Font color as RGBColor.\n            bold: Whether text is bold.\n            italic: Whether text is italic.\n            alignment: Paragraph alignment.\n        \"\"\"\n        styles = self.document.styles\n        try:\n            # Check if style already exists\n            styles[name]\n        except KeyError:\n            # Create new style\n            style = styles.add_style(name, style_type)\n            style.font.size = Pt(font_size)\n            if font_color:\n                style.font.color.rgb = font_color\n            style.font.bold = bold\n            style.font.italic = italic\n            if alignment and style_type == WD_STYLE_TYPE.PARAGRAPH:\n                style.paragraph_format.alignment = alignment\n\n\nclass DOCXTableBuilder:\n    \"\"\"\n    Builder class for creating formatted tables in DOCX documents.\n\n    Provides methods for creating compliance-specific tables with\n    consistent styling and formatting.\n    \"\"\"\n\n    # Table style colors\n    HEADER_BG_COLOR = \"2C5282\"  # Blue\n    ALT_ROW_COLOR = \"F7FAFC\"  # Light gray\n    BORDER_COLOR = \"E2E8F0\"  # Gray\n\n    def __init__(self, document: Document, styles: ComplianceDOCXStyles) -> None:\n        \"\"\"\n        Initialize the table builder.\n\n        Args:\n            document: The Document instance to add tables to.\n            styles: The DOCX styles instance to use.\n        \"\"\"\n        self.document = document\n        self.styles = styles\n\n    def create_simple_table(\n        self,\n        headers: list[str],\n        rows: list[list[Any]],\n        col_widths: Optional[list[float]] = None,\n    ) -> Table:\n        \"\"\"\n        Create a simple table with headers and rows.\n\n        Args:\n            headers: List of column headers.\n            rows: List of rows, each row is a list of cell values.\n            col_widths: Optional list of column widths in inches.\n\n        Returns:\n            A formatted Table object.\n        \"\"\"\n        # Create table with header row\n        table = self.document.add_table(rows=1, cols=len(headers))\n        table.alignment = WD_TABLE_ALIGNMENT.CENTER\n\n        # Style header row\n        header_cells = table.rows[0].cells\n        for i, header_text in enumerate(headers):\n            cell = header_cells[i]\n            cell.text = str(header_text)\n            self._set_cell_shading(cell, self.HEADER_BG_COLOR)\n            paragraph = cell.paragraphs[0]\n            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()\n            run.font.bold = True\n            run.font.color.rgb = RGBColor(0xFF, 0xFF, 0xFF)\n            run.font.size = Pt(10)\n\n        # Add data rows\n        for row_idx, row_data in enumerate(rows):\n            row_cells = table.add_row().cells\n            for col_idx, cell_value in enumerate(row_data):\n                cell = row_cells[col_idx]\n                cell.text = str(cell_value) if cell_value is not None else \"N/A\"\n                paragraph = cell.paragraphs[0]\n                run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()\n                run.font.size = Pt(9)\n                run.font.color.rgb = self.styles.TEXT_COLOR\n\n                # Apply alternating row colors\n                if row_idx % 2 == 1:\n                    self._set_cell_shading(cell, self.ALT_ROW_COLOR)\n\n        # Set column widths if provided\n        if col_widths and len(col_widths) == len(headers):\n            for i, width in enumerate(col_widths):\n                for row in table.rows:\n                    row.cells[i].width = Inches(width)\n\n        # Apply table borders\n        self._set_table_borders(table)\n\n        return table\n\n    def create_evidence_table(\n        self,\n        evidence_records: list[dict[str, Any]],\n        include_status: bool = True,\n    ) -> Table:\n        \"\"\"\n        Create a table for evidence records.\n\n        Args:\n            evidence_records: List of evidence record dictionaries.\n            include_status: Whether to include status column.\n\n        Returns:\n            A formatted Table for evidence display.\n        \"\"\"\n        if include_status:\n            headers = [\"Control ID\", \"Evidence\", \"Type\", \"Collected\", \"Status\"]\n            col_widths = [1.0, 2.5, 1.0, 1.0, 1.0]\n        else:\n            headers = [\"Control ID\", \"Evidence\", \"Type\", \"Collected\"]\n            col_widths = [1.0, 3.0, 1.0, 1.0]\n\n        rows = []\n        for record in evidence_records:\n            row = [\n                record.get(\"control_id\", \"N/A\"),\n                record.get(\"description\", \"N/A\"),\n                record.get(\"evidence_type\", \"N/A\"),\n                self._format_date(record.get(\"collected_at\")),\n            ]\n            if include_status:\n                row.append(self._format_status(record.get(\"status\", \"\")))\n            rows.append(row)\n\n        return self.create_simple_table(headers, rows, col_widths)\n\n    def create_control_mapping_table(\n        self,\n        mappings: list[dict[str, Any]],\n        framework: str,\n    ) -> Table:\n        \"\"\"\n        Create a table for control mappings.\n\n        Args:\n            mappings: List of control mapping dictionaries.\n            framework: The compliance framework name.\n\n        Returns:\n            A formatted Table for control mappings.\n        \"\"\"\n        headers = [\n            f\"{framework.upper()} Control\",\n            \"Guardrail Control\",\n            \"Mapping Rationale\",\n            \"Coverage\",\n        ]\n        col_widths = [1.2, 1.5, 3.0, 0.8]\n\n        rows = []\n        for mapping in mappings:\n            coverage = mapping.get(\n                \"coverage_percentage\", mapping.get(\"coverage_level\", 100)\n            )\n            if isinstance(coverage, int):\n                coverage_str = f\"{coverage}%\"\n            else:\n                coverage_str = str(coverage)\n\n            row = [\n                mapping.get(\"soc2_control_id\")\n                or mapping.get(\"iso27001_control_id\")\n                or mapping.get(\"control_id\", \"N/A\"),\n                mapping.get(\"guardrail_control_name\", \"N/A\"),\n                mapping.get(\"mapping_rationale\", \"N/A\"),\n                coverage_str,\n            ]\n            rows.append(row)\n\n        return self.create_simple_table(headers, rows, col_widths)\n\n    def _format_date(self, value: Any) -> str:\n        \"\"\"Format a datetime value for display.\"\"\"\n        if value is None:\n            return \"N/A\"\n        if isinstance(value, datetime):\n            return value.strftime(\"%Y-%m-%d\")\n        return str(value)\n\n    def _format_status(self, status: Any) -> str:\n        \"\"\"Format a status value for display.\"\"\"\n        if not status:\n            return \"N/A\"\n        status_str = str(status).replace(\"_\", \" \").title()\n        return status_str\n\n    def _set_cell_shading(self, cell, color: str) -> None:\n        \"\"\"\n        Set background shading for a table cell.\n\n        Args:\n            cell: The table cell to shade.\n            color: Hex color code without # prefix.\n        \"\"\"\n        shading_elm = OxmlElement(\"w:shd\")\n        shading_elm.set(qn(\"w:fill\"), color)\n        cell._tc.get_or_add_tcPr().append(shading_elm)\n\n    def _set_table_borders(self, table: Table) -> None:\n        \"\"\"\n        Apply borders to a table.\n\n        Args:\n            table: The table to apply borders to.\n        \"\"\"\n        tbl = table._tbl\n        tbl_pr = tbl.tblPr if tbl.tblPr is not None else OxmlElement(\"w:tblPr\")\n\n        tbl_borders = OxmlElement(\"w:tblBorders\")\n        for border_name in [\"top\", \"left\", \"bottom\", \"right\", \"insideH\", \"insideV\"]:\n            border = OxmlElement(f\"w:{border_name}\")\n            border.set(qn(\"w:val\"), \"single\")\n            border.set(qn(\"w:sz\"), \"4\")\n            border.set(qn(\"w:space\"), \"0\")\n            border.set(qn(\"w:color\"), self.BORDER_COLOR)\n            tbl_borders.append(border)\n\n        tbl_pr.append(tbl_borders)\n        if tbl.tblPr is None:\n            tbl.insert(0, tbl_pr)\n\n\nclass ComplianceDOCXGenerator:\n    \"\"\"\n    Main DOCX generator for compliance documentation.\n\n    Generates professional compliance reports with consistent styling,\n    proper structure, and support for all compliance frameworks.\n    \"\"\"\n\n    def __init__(\n        self,\n        orientation: str = \"portrait\",\n    ) -> None:\n        \"\"\"\n        Initialize the DOCX generator.\n\n        Args:\n            orientation: Page orientation ('portrait' or 'landscape').\n        \"\"\"\n        self.orientation = orientation\n        self._document: Optional[Document] = None\n        self._styles: Optional[ComplianceDOCXStyles] = None\n        self._table_builder: Optional[DOCXTableBuilder] = None\n\n    def _create_document(self) -> Document:\n        \"\"\"\n        Create a new Document instance with custom styles.\n\n        Returns:\n            A new Document with styles applied.\n        \"\"\"\n        self._document = Document()\n        self._styles = ComplianceDOCXStyles(self._document)\n        self._table_builder = DOCXTableBuilder(self._document, self._styles)\n\n        # Set page orientation if landscape\n        if self.orientation == \"landscape\":\n            for section in self._document.sections:\n                section.orientation = WD_ORIENT.LANDSCAPE\n                # Swap width and height\n                new_width = section.page_height\n                new_height = section.page_width\n                section.page_width = new_width\n                section.page_height = new_height\n\n        return self._document\n\n    def _add_title_page(\n        self,\n        title: str,\n        subtitle: Optional[str] = None,\n        organization: Optional[str] = None,\n        report_date: Optional[datetime] = None,\n        confidentiality: str = \"CONFIDENTIAL\",\n    ) -> None:\n        \"\"\"\n        Add a title page to the document.\n\n        Args:\n            title: Main document title.\n            subtitle: Optional subtitle.\n            organization: Organization name.\n            report_date: Report generation date.\n            confidentiality: Confidentiality level.\n        \"\"\"\n        # Add blank paragraphs for spacing\n        for _ in range(4):\n            self._document.add_paragraph()\n\n        # Title\n        title_para = self._document.add_paragraph(title, style=\"Title\")\n        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n\n        # Subtitle\n        if subtitle:\n            subtitle_para = self._document.add_paragraph()\n            subtitle_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            run = subtitle_para.add_run(subtitle)\n            run.font.size = Pt(16)\n            run.font.color.rgb = self._styles.SECONDARY_COLOR\n\n        # Add spacing\n        for _ in range(2):\n            self._document.add_paragraph()\n\n        # Organization\n        if organization:\n            org_para = self._document.add_paragraph()\n            org_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            run = org_para.add_run(f\"Prepared for: {organization}\")\n            run.font.size = Pt(14)\n            run.font.color.rgb = self._styles.TEXT_COLOR\n\n        # Report Date\n        if report_date:\n            date_para = self._document.add_paragraph()\n            date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            date_str = report_date.strftime(\"%B %d, %Y\")\n            run = date_para.add_run(f\"Report Date: {date_str}\")\n            run.font.size = Pt(12)\n            run.font.color.rgb = self._styles.MUTED_COLOR\n\n        # Add spacing before confidentiality notice\n        for _ in range(4):\n            self._document.add_paragraph()\n\n        # Confidentiality Notice\n        if confidentiality:\n            conf_para = self._document.add_paragraph()\n            conf_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            run = conf_para.add_run(confidentiality.upper())\n            run.font.bold = True\n            run.font.size = Pt(12)\n            run.font.color.rgb = self._styles.DANGER_COLOR\n\n            notice_para = self._document.add_paragraph()\n            notice_para.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            notice_run = notice_para.add_run(\n                \"This document contains confidential information. \"\n                \"Distribution is restricted to authorized personnel only.\"\n            )\n            notice_run.font.size = Pt(10)\n            notice_run.font.color.rgb = self._styles.MUTED_COLOR\n\n        # Page break after title page\n        self._document.add_page_break()\n\n    def _add_section(\n        self,\n        title: str,\n        content: Optional[str] = None,\n        level: int = 1,\n    ) -> None:\n        \"\"\"\n        Add a section to the document.\n\n        Args:\n            title: Section title.\n            content: Optional section content.\n            level: Heading level (1, 2, or 3).\n        \"\"\"\n        heading_style = f\"Heading {level}\"\n        self._document.add_heading(title, level=level)\n\n        if content:\n            self._document.add_paragraph(content)\n\n    def _add_paragraph(\n        self,\n        text: str,\n        bold: bool = False,\n        italic: bool = False,\n    ) -> None:\n        \"\"\"\n        Add a paragraph to the document.\n\n        Args:\n            text: Paragraph text.\n            bold: Whether text is bold.\n            italic: Whether text is italic.\n        \"\"\"\n        para = self._document.add_paragraph()\n        run = para.add_run(text)\n        run.font.bold = bold\n        run.font.italic = italic\n\n    def _add_bullet_list(self, items: list[str]) -> None:\n        \"\"\"\n        Add a bullet list to the document.\n\n        Args:\n            items: List of items to include.\n        \"\"\"\n        for item in items:\n            para = self._document.add_paragraph(item, style=\"List Bullet\")\n\n    def _add_numbered_list(self, items: list[str]) -> None:\n        \"\"\"\n        Add a numbered list to the document.\n\n        Args:\n            items: List of items to include.\n        \"\"\"\n        for item in items:\n            para = self._document.add_paragraph(item, style=\"List Number\")\n\n    def _add_table(\n        self,\n        headers: list[str],\n        rows: list[list[Any]],\n        col_widths: Optional[list[float]] = None,\n    ) -> Table:\n        \"\"\"\n        Add a table to the document.\n\n        Args:\n            headers: List of column headers.\n            rows: List of rows.\n            col_widths: Optional column widths in inches.\n\n        Returns:\n            The created Table object.\n        \"\"\"\n        return self._table_builder.create_simple_table(headers, rows, col_widths)\n\n    def _add_page_break(self) -> None:\n        \"\"\"Add a page break to the document.\"\"\"\n        self._document.add_page_break()\n\n    def _save_document(\n        self,\n        output: Union[str, Path, BinaryIO],\n    ) -> None:\n        \"\"\"\n        Save the document to a file or buffer.\n\n        Args:\n            output: Output file path or file-like object.\n        \"\"\"\n        if isinstance(output, (str, Path)):\n            output_path = Path(output)\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n            self._document.save(str(output_path))\n        else:\n            self._document.save(output)\n\n    def _format_date(self, value: Any) -> str:\n        \"\"\"Format a datetime value for display.\"\"\"\n        if value is None:\n            return \"N/A\"\n        if isinstance(value, datetime):\n            return value.strftime(\"%Y-%m-%d\")\n        return str(value)\n\n    def generate_soc2_report(\n        self,\n        report_data: dict[str, Any],\n        output_path: Optional[Union[str, Path]] = None,\n    ) -> Path:\n        \"\"\"\n        Generate a SOC 2 Type II compliance report in DOCX format.\n\n        Args:\n            report_data: SOC 2 report data dictionary.\n            output_path: Optional output file path.\n\n        Returns:\n            Path to the generated DOCX file.\n        \"\"\"\n        self._create_document()\n\n        org_name = report_data.get(\"organization_name\", \"Organization\")\n        audit_start = report_data.get(\"audit_period_start\")\n        audit_end = report_data.get(\"audit_period_end\")\n\n        # Title page\n        self._add_title_page(\n            title=\"SOC 2 Type II Report\",\n            subtitle=\"Service Organization Control Report\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n\n        # Executive Summary\n        self._add_section(\"Executive Summary\")\n        self._add_paragraph(\n            f\"This SOC 2 Type II report covers the {org_name} system \"\n            f\"for the audit period from {self._format_date(audit_start)} \"\n            f\"to {self._format_date(audit_end)}.\"\n        )\n\n        # System Description\n        system_desc = report_data.get(\"system_description\", {})\n        if system_desc:\n            self._add_section(\"System Description\")\n            self._add_paragraph(\n                system_desc.get(\"system_description\", \"System description not provided.\")\n            )\n\n            if system_desc.get(\"principal_service_commitments\"):\n                self._add_section(\"Principal Service Commitments\", level=2)\n                self._add_bullet_list(system_desc[\"principal_service_commitments\"])\n\n            if system_desc.get(\"components\"):\n                self._add_section(\"System Components\", level=2)\n                self._add_bullet_list(system_desc[\"components\"])\n\n        # Trust Service Criteria\n        criteria_sections = report_data.get(\"criteria_sections\", [])\n        if criteria_sections:\n            self._add_page_break()\n            self._add_section(\"Trust Service Criteria\")\n\n            for section in criteria_sections:\n                criteria = section.get(\"criteria\", \"\")\n                criteria_name = str(criteria).replace(\"_\", \" \").title()\n                self._add_section(f\"{criteria_name} Controls\", level=2)\n\n                controls = section.get(\"controls\", [])\n                if controls:\n                    rows = []\n                    for ctrl in controls:\n                        rows.append(\n                            [\n                                ctrl.get(\"control_id\", \"N/A\"),\n                                ctrl.get(\"title\", \"N/A\"),\n                                ctrl.get(\"control_objective\", \"N/A\"),\n                            ]\n                        )\n\n                    self._add_table(\n                        headers=[\"Control ID\", \"Title\", \"Objective\"],\n                        rows=rows,\n                        col_widths=[1.0, 2.0, 3.5],\n                    )\n\n        # Control Mappings\n        mappings = report_data.get(\"control_mappings\", [])\n        if mappings:\n            self._add_page_break()\n            self._add_section(\"Guardrail Control Mappings\")\n            self._add_paragraph(\n                \"The following table shows how ACGS guardrail controls map to SOC 2 controls.\"\n            )\n            self._table_builder.create_control_mapping_table(\n                [m if isinstance(m, dict) else m.model_dump() for m in mappings],\n                \"SOC2\",\n            )\n\n        # Generate output path if not provided\n        if output_path is None:\n            output_dir = _ensure_output_dir()\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n            output_path = output_dir / f\"soc2_report_{timestamp}.docx\"\n\n        self._save_document(output_path)\n\n        logger.info(f\"Generated SOC 2 DOCX report: {output_path}\")\n        return Path(output_path)\n\n    def generate_iso27001_report(\n        self,\n        report_data: dict[str, Any],\n        output_path: Optional[Union[str, Path]] = None,\n    ) -> Path:\n        \"\"\"\n        Generate an ISO 27001:2022 compliance report in DOCX format.\n\n        Args:\n            report_data: ISO 27001 report data dictionary.\n            output_path: Optional output file path.\n\n        Returns:\n            Path to the generated DOCX file.\n        \"\"\"\n        self._create_document()\n\n        org_name = report_data.get(\"organization_name\", \"Organization\")\n        scope = report_data.get(\"isms_scope\", \"\")\n\n        # Title page\n        self._add_title_page(\n            title=\"ISO 27001:2022 Compliance Report\",\n            subtitle=\"Information Security Management System\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n\n        # ISMS Scope\n        self._add_section(\"ISMS Scope\")\n        self._add_paragraph(scope or \"ISMS scope not specified.\")\n\n        # Statement of Applicability\n        soa = report_data.get(\"statement_of_applicability\", {})\n        if soa:\n            self._add_section(\"Statement of Applicability\")\n            entries = soa.get(\"entries\", [])\n\n            if entries:\n                rows = []\n                for entry in entries[:20]:  # Limit for display\n                    status = entry.get(\"implementation_status\", \"not_implemented\")\n                    status_display = str(status).replace(\"_\", \" \").title()\n                    rows.append(\n                        [\n                            entry.get(\"control_id\", \"N/A\"),\n                            entry.get(\"control_title\", \"N/A\"),\n                            str(entry.get(\"applicability\", \"applicable\"))\n                            .replace(\"_\", \" \")\n                            .title(),\n                            status_display,\n                        ]\n                    )\n\n                self._add_table(\n                    headers=[\"Control ID\", \"Title\", \"Applicability\", \"Status\"],\n                    rows=rows,\n                    col_widths=[1.0, 2.5, 1.2, 1.3],\n                )\n\n        # Theme Sections\n        theme_sections = report_data.get(\"theme_sections\", [])\n        if theme_sections:\n            self._add_page_break()\n            self._add_section(\"Control Themes\")\n\n            for section in theme_sections:\n                theme = section.get(\"theme\", \"\")\n                theme_name = str(theme).replace(\"_\", \" \").title()\n                self._add_section(f\"{theme_name} Controls\", level=2)\n\n                impl_pct = section.get(\"implementation_percentage\", 0)\n                self._add_paragraph(f\"Implementation Progress: {impl_pct:.1f}%\")\n\n                controls = section.get(\"controls\", [])\n                if controls:\n                    rows = []\n                    for ctrl in controls[:10]:  # Limit per section\n                        rows.append(\n                            [\n                                ctrl.get(\"control_id\", \"N/A\"),\n                                ctrl.get(\"title\", \"N/A\"),\n                                str(ctrl.get(\"status\", \"N/A\"))\n                                .replace(\"_\", \" \")\n                                .title(),\n                            ]\n                        )\n\n                    self._add_table(\n                        headers=[\"Control ID\", \"Title\", \"Status\"],\n                        rows=rows,\n                        col_widths=[1.2, 3.5, 1.3],\n                    )\n\n        # Generate output path if not provided\n        if output_path is None:\n            output_dir = _ensure_output_dir()\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n            output_path = output_dir / f\"iso27001_report_{timestamp}.docx\"\n\n        self._save_document(output_path)\n\n        logger.info(f\"Generated ISO 27001 DOCX report: {output_path}\")\n        return Path(output_path)\n\n    def generate_gdpr_report(\n        self,\n        report_data: dict[str, Any],\n        output_path: Optional[Union[str, Path]] = None,\n    ) -> Path:\n        \"\"\"\n        Generate a GDPR Article 30 compliance report in DOCX format.\n\n        Args:\n            report_data: GDPR report data dictionary.\n            output_path: Optional output file path.\n\n        Returns:\n            Path to the generated DOCX file.\n        \"\"\"\n        self._create_document()\n\n        org_name = report_data.get(\"organization_name\", \"Organization\")\n        entity_role = report_data.get(\"entity_role\", \"controller\")\n\n        # Title page\n        self._add_title_page(\n            title=\"GDPR Article 30 Report\",\n            subtitle=\"Records of Processing Activities\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n\n        # Entity Role\n        self._add_section(\"Data Protection Role\")\n        self._add_paragraph(\n            f\"This organization operates as a data {str(entity_role).replace('_', ' ')} \"\n            f\"under the General Data Protection Regulation (GDPR).\"\n        )\n\n        # Controller Record\n        controller_record = report_data.get(\"controller_record\")\n        if controller_record:\n            self._add_section(\"Controller Information (Article 30(1))\")\n\n            contact = controller_record.get(\"controller_contact\", {})\n            if contact:\n                self._add_paragraph(\n                    f\"Controller: {controller_record.get('controller_name', 'N/A')}\"\n                )\n                self._add_paragraph(f\"Contact: {contact.get('name', 'N/A')}\")\n                self._add_paragraph(f\"Email: {contact.get('email', 'N/A')}\")\n\n            # DPO Information\n            dpo = controller_record.get(\"dpo\")\n            if dpo:\n                self._add_section(\"Data Protection Officer\", level=2)\n                self._add_paragraph(f\"Name: {dpo.get('name', 'N/A')}\")\n                self._add_paragraph(f\"Email: {dpo.get('email', 'N/A')}\")\n\n            # Processing Activities\n            activities = controller_record.get(\"processing_activities\", [])\n            if activities:\n                self._add_page_break()\n                self._add_section(\"Processing Activities\")\n\n                rows = []\n                for activity in activities[:15]:  # Limit for display\n                    purposes = activity.get(\"purposes\", [])\n                    purposes_str = \", \".join(purposes[:2]) if purposes else \"N/A\"\n                    if len(purposes) > 2:\n                        purposes_str += \"...\"\n\n                    rows.append(\n                        [\n                            activity.get(\"name\", \"N/A\"),\n                            purposes_str,\n                            activity.get(\"status\", \"N/A\").replace(\"_\", \" \").title(),\n                        ]\n                    )\n\n                self._add_table(\n                    headers=[\"Activity\", \"Purposes\", \"Status\"],\n                    rows=rows,\n                    col_widths=[2.0, 3.0, 1.5],\n                )\n\n        # Data Flows\n        data_flows = report_data.get(\"data_flows\", [])\n        if data_flows:\n            self._add_section(\"Data Flow Mappings\")\n\n            rows = []\n            for flow in data_flows[:10]:  # Limit for display\n                rows.append(\n                    [\n                        flow.get(\"name\", \"N/A\"),\n                        flow.get(\"data_source\", \"N/A\"),\n                        flow.get(\"data_destination\", \"N/A\"),\n                        \"Yes\" if flow.get(\"crosses_border\") else \"No\",\n                    ]\n                )\n\n            self._add_table(\n                headers=[\"Flow Name\", \"Source\", \"Destination\", \"Cross-Border\"],\n                rows=rows,\n                col_widths=[1.8, 1.5, 1.5, 1.2],\n            )\n\n        # Security Measures\n        security_measures = report_data.get(\"security_measures\", [])\n        if security_measures:\n            self._add_section(\"Technical and Organisational Measures\")\n            self._add_paragraph(\n                \"The following security measures are implemented to protect personal data:\"\n            )\n            self._add_bullet_list(\n                [m.get(\"description\", str(m)) for m in security_measures[:10]]\n            )\n\n        # Generate output path if not provided\n        if output_path is None:\n            output_dir = _ensure_output_dir()\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n            output_path = output_dir / f\"gdpr_report_{timestamp}.docx\"\n\n        self._save_document(output_path)\n\n        logger.info(f\"Generated GDPR DOCX report: {output_path}\")\n        return Path(output_path)\n\n    def generate_euaiact_report(\n        self,\n        report_data: dict[str, Any],\n        output_path: Optional[Union[str, Path]] = None,\n    ) -> Path:\n        \"\"\"\n        Generate an EU AI Act compliance report in DOCX format.\n\n        Args:\n            report_data: EU AI Act report data dictionary.\n            output_path: Optional output file path.\n\n        Returns:\n            Path to the generated DOCX file.\n        \"\"\"\n        self._create_document()\n\n        org_name = report_data.get(\"organization_name\", \"Organization\")\n        org_role = report_data.get(\"organization_role\", \"provider\")\n\n        # Title page\n        self._add_title_page(\n            title=\"EU AI Act Compliance Report\",\n            subtitle=\"Regulation (EU) 2024/1689\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n\n        # Organization Role\n        self._add_section(\"Organization Role\")\n        self._add_paragraph(\n            f\"This organization operates as an AI system {str(org_role).replace('_', ' ')} \"\n            f\"under the EU AI Act.\"\n        )\n\n        # AI Systems Summary\n        ai_systems = report_data.get(\"ai_systems\", [])\n        high_risk_count = report_data.get(\"high_risk_systems_count\", 0)\n        limited_risk_count = report_data.get(\"limited_risk_systems_count\", 0)\n        minimal_risk_count = report_data.get(\"minimal_risk_systems_count\", 0)\n\n        self._add_section(\"AI Systems Overview\")\n        overview_items = [\n            f\"Total AI Systems: {len(ai_systems)}\",\n            f\"High-Risk Systems: {high_risk_count}\",\n            f\"Limited-Risk Systems: {limited_risk_count}\",\n            f\"Minimal-Risk Systems: {minimal_risk_count}\",\n        ]\n        self._add_bullet_list(overview_items)\n\n        # Risk Assessments\n        risk_assessments = report_data.get(\"risk_assessments\", [])\n        if risk_assessments:\n            self._add_page_break()\n            self._add_section(\"Risk Assessments\")\n\n            rows = []\n            for assessment in risk_assessments[:10]:  # Limit for display\n                risk_level = assessment.get(\"risk_level\", \"N/A\")\n                rows.append(\n                    [\n                        assessment.get(\"system_name\", \"N/A\"),\n                        str(risk_level).replace(\"_\", \" \").title(),\n                        assessment.get(\"high_risk_category\", \"N/A\") or \"N/A\",\n                        self._format_date(assessment.get(\"assessment_date\")),\n                    ]\n                )\n\n            self._add_table(\n                headers=[\"System\", \"Risk Level\", \"Category\", \"Assessment Date\"],\n                rows=rows,\n                col_widths=[2.0, 1.2, 1.5, 1.3],\n            )\n\n        # Conformity Assessments\n        conformity_assessments = report_data.get(\"conformity_assessments\", [])\n        if conformity_assessments:\n            self._add_section(\"Conformity Assessments\")\n\n            rows = []\n            for assessment in conformity_assessments[:10]:  # Limit for display\n                rows.append(\n                    [\n                        assessment.get(\"system_id\", \"N/A\"),\n                        str(assessment.get(\"assessment_type\", \"N/A\"))\n                        .replace(\"_\", \" \")\n                        .title(),\n                        assessment.get(\"assessment_result\", \"N/A\").title(),\n                        assessment.get(\"certificate_number\", \"N/A\") or \"N/A\",\n                    ]\n                )\n\n            self._add_table(\n                headers=[\"System ID\", \"Assessment Type\", \"Result\", \"Certificate\"],\n                rows=rows,\n                col_widths=[1.5, 1.5, 1.2, 1.8],\n            )\n\n        # Technical Documentation\n        tech_docs = report_data.get(\"technical_documentation\", [])\n        if tech_docs:\n            self._add_section(\"Technical Documentation (Annex IV)\")\n            self._add_paragraph(\n                \"The following AI systems have complete technical documentation:\"\n            )\n            doc_items = []\n            for doc in tech_docs[:10]:\n                system_name = doc.get(\"system_name\", \"Unknown System\")\n                status = doc.get(\"documentation_status\", \"incomplete\")\n                doc_items.append(f\"{system_name}: {status.replace('_', ' ').title()}\")\n            self._add_bullet_list(doc_items)\n\n        # Quality Management System\n        qms = report_data.get(\"quality_management_system\")\n        if qms:\n            self._add_section(\"Quality Management System (Article 17)\")\n            self._add_paragraph(qms.get(\"description\", \"QMS description not provided.\"))\n\n            policies = qms.get(\"policies\", [])\n            if policies:\n                self._add_section(\"Documented Policies\", level=2)\n                self._add_bullet_list(policies[:10])\n\n        # Generate output path if not provided\n        if output_path is None:\n            output_dir = _ensure_output_dir()\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n            output_path = output_dir / f\"euaiact_report_{timestamp}.docx\"\n\n        self._save_document(output_path)\n\n        logger.info(f\"Generated EU AI Act DOCX report: {output_path}\")\n        return Path(output_path)\n\n\ndef generate_docx(\n    report_data: dict[str, Any],\n    framework: Union[str, ComplianceFramework],\n    output_path: Optional[Union[str, Path]] = None,\n    orientation: str = \"portrait\",\n) -> Path:\n    \"\"\"\n    Generate a DOCX compliance report for the specified framework.\n\n    This is the main entry point for DOCX generation.\n\n    Args:\n        report_data: Report data dictionary containing all compliance information.\n        framework: Compliance framework (soc2, iso27001, gdpr, euaiact).\n        output_path: Optional output file path. If not provided, a default path is used.\n        orientation: Page orientation ('portrait' or 'landscape').\n\n    Returns:\n        Path to the generated DOCX file.\n\n    Raises:\n        ValueError: If the framework is not supported.\n\n    Example:\n        >>> from acgs2.services.compliance_docs.src.generators.docx_generator import (\n        ...     generate_docx\n        ... )\n        >>> path = generate_docx(\n        ...     report_data={\"organization_name\": \"Acme Corp\", ...},\n        ...     framework=\"soc2\",\n        ... )\n        >>> print(f\"Report generated at: {path}\")\n    \"\"\"\n    generator = ComplianceDOCXGenerator(orientation=orientation)\n\n    # Normalize framework\n    if isinstance(framework, ComplianceFramework):\n        framework_str = framework.value\n    else:\n        framework_str = str(framework).lower()\n\n    if framework_str == \"soc2\":\n        return generator.generate_soc2_report(report_data, output_path)\n    elif framework_str == \"iso27001\":\n        return generator.generate_iso27001_report(report_data, output_path)\n    elif framework_str == \"gdpr\":\n        return generator.generate_gdpr_report(report_data, output_path)\n    elif framework_str == \"euaiact\":\n        return generator.generate_euaiact_report(report_data, output_path)\n    else:\n        raise ValueError(\n            f\"Unsupported framework: {framework}. \"\n            f\"Supported frameworks: soc2, iso27001, gdpr, euaiact\"\n        )\n\n\ndef generate_docx_to_buffer(\n    report_data: dict[str, Any],\n    framework: Union[str, ComplianceFramework],\n    orientation: str = \"portrait\",\n) -> io.BytesIO:\n    \"\"\"\n    Generate a DOCX compliance report to an in-memory buffer.\n\n    This is useful for streaming responses without writing to disk.\n\n    Args:\n        report_data: Report data dictionary containing all compliance information.\n        framework: Compliance framework (soc2, iso27001, gdpr, euaiact).\n        orientation: Page orientation ('portrait' or 'landscape').\n\n    Returns:\n        BytesIO buffer containing the generated DOCX.\n\n    Raises:\n        ValueError: If the framework is not supported.\n\n    Example:\n        >>> buffer = generate_docx_to_buffer(report_data, \"soc2\")\n        >>> # Use buffer.getvalue() to get bytes for streaming\n    \"\"\"\n    buffer = io.BytesIO()\n    generator = ComplianceDOCXGenerator(orientation=orientation)\n\n    # Normalize framework\n    if isinstance(framework, ComplianceFramework):\n        framework_str = framework.value\n    else:\n        framework_str = str(framework).lower()\n\n    # Create document and generate content\n    generator._create_document()\n\n    org_name = report_data.get(\"organization_name\", \"Organization\")\n\n    if framework_str == \"soc2\":\n        generator._add_title_page(\n            title=\"SOC 2 Type II Report\",\n            subtitle=\"Service Organization Control Report\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n        generator._add_section(\"Report Content\")\n        generator._add_paragraph(\n            \"Full SOC 2 report content. See generate_docx() for complete implementation.\"\n        )\n    elif framework_str == \"iso27001\":\n        generator._add_title_page(\n            title=\"ISO 27001:2022 Compliance Report\",\n            subtitle=\"Information Security Management System\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n        generator._add_section(\"Report Content\")\n        generator._add_paragraph(\n            \"Full ISO 27001 report content. See generate_docx() for complete implementation.\"\n        )\n    elif framework_str == \"gdpr\":\n        generator._add_title_page(\n            title=\"GDPR Article 30 Report\",\n            subtitle=\"Records of Processing Activities\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n        generator._add_section(\"Report Content\")\n        generator._add_paragraph(\n            \"Full GDPR report content. See generate_docx() for complete implementation.\"\n        )\n    elif framework_str == \"euaiact\":\n        generator._add_title_page(\n            title=\"EU AI Act Compliance Report\",\n            subtitle=\"Regulation (EU) 2024/1689\",\n            organization=org_name,\n            report_date=datetime.now(timezone.utc),\n        )\n        generator._add_section(\"Report Content\")\n        generator._add_paragraph(\n            \"Full EU AI Act report content. See generate_docx() for complete implementation.\"\n        )\n    else:\n        raise ValueError(\n            f\"Unsupported framework: {framework}. \"\n            f\"Supported frameworks: soc2, iso27001, gdpr, euaiact\"\n        )\n\n    generator._save_document(buffer)\n    buffer.seek(0)\n    return buffer\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.143269",
  "last_updated": "2026-01-04T05:35:58.529890"
}