{
  "file_path": "src/core/shared/auth/oidc_handler.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nACGS-2 OpenID Connect (OIDC) Handler Service\nConstitutional Hash: cdd01ef066bc6cf2\n\nProvides enterprise-grade OIDC Relying Party (RP) implementation using Authlib.\nSupports multiple identity providers including Google Workspace, Azure AD, and Okta.\n\nFeatures:\n    - Auto-discovery via .well-known/openid-configuration\n    - PKCE (Proof Key for Code Exchange) support\n    - Token exchange and validation\n    - User info retrieval\n    - Session management support\n    - Multiple provider configuration\n\nUsage:\n    from shared.auth.oidc_handler import OIDCHandler\n\n    # Create handler\n    handler = OIDCHandler()\n\n    # Register a provider\n    handler.register_provider(\n        name=\"google\",\n        client_id=\"your-client-id\",\n        client_secret=\"your-secret\",\n        server_metadata_url=\"https://accounts.google.com/.well-known/openid-configuration\"\n    )\n\n    # Initiate login\n    auth_url, state = await handler.initiate_login(\"google\", \"https://app/callback\")\n\n    # Handle callback\n    user_info = await handler.handle_callback(\"google\", code, state)\n\"\"\"\n\nimport hashlib\nimport logging\nimport secrets\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Any, Optional\n\ntry:\n    from authlib.integrations.httpx_client import AsyncOAuth2Client\n    from authlib.jose import jwt\n    from authlib.jose.errors import JoseError\n\n    HAS_AUTHLIB = True\nexcept ImportError:\n    HAS_AUTHLIB = False\n    AsyncOAuth2Client = None  # type: ignore[misc, assignment]\n    jwt = None  # type: ignore[assignment]\n    JoseError = Exception  # type: ignore[misc, assignment]\n\ntry:\n    import httpx\n\n    HAS_HTTPX = True\nexcept ImportError:\n    HAS_HTTPX = False\n    httpx = None  # type: ignore[assignment]\n\nlogger = logging.getLogger(__name__)\n\n# Constitutional hash constant\nCONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\"\n\n# Default OIDC scopes\nDEFAULT_SCOPES = [\"openid\", \"profile\", \"email\"]\n\n\nclass OIDCError(Exception):\n    \"\"\"Base exception for OIDC-related errors.\"\"\"\n\n    pass\n\n\nclass OIDCConfigurationError(OIDCError):\n    \"\"\"Configuration error for OIDC provider.\"\"\"\n\n    pass\n\n\nclass OIDCAuthenticationError(OIDCError):\n    \"\"\"Authentication failed during OIDC flow.\"\"\"\n\n    pass\n\n\nclass OIDCTokenError(OIDCError):\n    \"\"\"Token exchange or validation failed.\"\"\"\n\n    pass\n\n\nclass OIDCProviderError(OIDCError):\n    \"\"\"Error communicating with OIDC provider.\"\"\"\n\n    pass\n\n\n@dataclass\nclass OIDCProviderConfig:\n    \"\"\"Configuration for an OIDC identity provider.\n\n    Attributes:\n        name: Unique provider name (e.g., 'google', 'azure', 'okta')\n        client_id: OAuth 2.0 client ID from the IdP\n        client_secret: OAuth 2.0 client secret\n        server_metadata_url: OpenID Connect discovery URL\n        scopes: OAuth scopes to request\n        use_pkce: Whether to use PKCE for enhanced security\n        extra_params: Additional parameters for authorization requests\n    \"\"\"\n\n    name: str\n    client_id: str\n    client_secret: str\n    server_metadata_url: str\n    scopes: list[str] = field(default_factory=lambda: list(DEFAULT_SCOPES))\n    use_pkce: bool = True\n    extra_params: dict[str, str] = field(default_factory=dict)\n\n    def __post_init__(self) -> None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        if not self.name:\n            raise OIDCConfigurationError(\"Provider name is required\")\n        if not self.client_id:\n            raise OIDCConfigurationError(\"Client ID is required\")\n        if not self.server_metadata_url:\n            raise OIDCConfigurationError(\"Server metadata URL is required\")\n\n\n@dataclass\nclass OIDCTokenResponse:\n    \"\"\"Token response from OIDC provider.\n\n    Attributes:\n        access_token: OAuth 2.0 access token\n        token_type: Token type (typically 'Bearer')\n        expires_in: Token expiration time in seconds\n        refresh_token: Optional refresh token\n        id_token: OIDC ID token (JWT)\n        scope: Granted scopes\n        raw_response: Full token response dict\n    \"\"\"\n\n    access_token: str\n    token_type: str = \"Bearer\"\n    expires_in: Optional[int] = None\n    refresh_token: Optional[str] = None\n    id_token: Optional[str] = None\n    scope: Optional[str] = None\n    raw_response: dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"OIDCTokenResponse\":\n        \"\"\"Create token response from dictionary.\n\n        Args:\n            data: Token response dictionary from IdP\n\n        Returns:\n            OIDCTokenResponse instance\n        \"\"\"\n        return cls(\n            access_token=data.get(\"access_token\", \"\"),\n            token_type=data.get(\"token_type\", \"Bearer\"),\n            expires_in=data.get(\"expires_in\"),\n            refresh_token=data.get(\"refresh_token\"),\n            id_token=data.get(\"id_token\"),\n            scope=data.get(\"scope\"),\n            raw_response=data,\n        )\n\n\n@dataclass\nclass OIDCUserInfo:\n    \"\"\"User information from OIDC provider.\n\n    Attributes:\n        sub: Subject identifier (unique user ID from IdP)\n        email: User's email address\n        email_verified: Whether email is verified\n        name: Full name\n        given_name: First name\n        family_name: Last name\n        picture: Profile picture URL\n        locale: User's locale\n        groups: Group memberships (if available)\n        raw_claims: Full claims dict from IdP\n    \"\"\"\n\n    sub: str\n    email: Optional[str] = None\n    email_verified: bool = False\n    name: Optional[str] = None\n    given_name: Optional[str] = None\n    family_name: Optional[str] = None\n    picture: Optional[str] = None\n    locale: Optional[str] = None\n    groups: list[str] = field(default_factory=list)\n    raw_claims: dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_claims(cls, claims: dict[str, Any]) -> \"OIDCUserInfo\":\n        \"\"\"Create user info from OIDC claims.\n\n        Args:\n            claims: Claims dictionary from ID token or userinfo endpoint\n\n        Returns:\n            OIDCUserInfo instance\n        \"\"\"\n        # Extract groups from various claim formats\n        groups = []\n        if \"groups\" in claims:\n            groups = claims[\"groups\"]\n        elif \"roles\" in claims:\n            groups = claims[\"roles\"]\n        elif \"https://schemas.microsoft.com/claims/groups\" in claims:\n            # Azure AD group claims\n            groups = claims[\"https://schemas.microsoft.com/claims/groups\"]\n\n        return cls(\n            sub=claims.get(\"sub\", \"\"),\n            email=claims.get(\"email\"),\n            email_verified=claims.get(\"email_verified\", False),\n            name=claims.get(\"name\"),\n            given_name=claims.get(\"given_name\"),\n            family_name=claims.get(\"family_name\"),\n            picture=claims.get(\"picture\"),\n            locale=claims.get(\"locale\"),\n            groups=groups if isinstance(groups, list) else [],\n            raw_claims=claims,\n        )\n\n\nclass OIDCHandler:\n    \"\"\"OpenID Connect handler for enterprise SSO authentication.\n\n    This handler manages OIDC authentication flows for multiple identity\n    providers. It supports:\n    - Auto-discovery via .well-known/openid-configuration\n    - PKCE (Proof Key for Code Exchange)\n    - Token exchange and validation\n    - User info retrieval\n    - Multiple simultaneous providers\n\n    Example:\n        handler = OIDCHandler()\n        handler.register_provider(\n            name=\"google\",\n            client_id=\"your-client-id\",\n            client_secret=\"your-secret\",\n            server_metadata_url=\"https://accounts.google.com/.well-known/openid-configuration\"\n        )\n\n        # Start login\n        auth_url, state = await handler.initiate_login(\"google\", \"https://app/callback\")\n\n        # After user authenticates, handle callback\n        user_info = await handler.handle_callback(\"google\", code, state)\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize OIDC handler.\"\"\"\n        self._providers: dict[str, OIDCProviderConfig] = {}\n        self._metadata_cache: dict[str, dict[str, Any]] = {}\n        self._metadata_timestamps: dict[str, datetime] = {}\n        self._pending_states: dict[str, dict[str, Any]] = {}\n        self._http_client: Optional[Any] = None\n\n        logger.info(\n            \"OIDC handler initialized\",\n            extra={\"constitutional_hash\": CONSTITUTIONAL_HASH},\n        )\n\n    def register_provider(\n        self,\n        name: str,\n        client_id: str,\n        client_secret: str,\n        server_metadata_url: str,\n        scopes: Optional[list[str]] = None,\n        use_pkce: bool = True,\n        extra_params: Optional[dict[str, str]] = None,\n    ) -> None:\n        \"\"\"Register an OIDC provider.\n\n        Args:\n            name: Unique provider name (e.g., 'google', 'azure', 'okta')\n            client_id: OAuth 2.0 client ID\n            client_secret: OAuth 2.0 client secret\n            server_metadata_url: OpenID Connect discovery URL\n            scopes: OAuth scopes to request (default: openid, profile, email)\n            use_pkce: Whether to use PKCE (default: True)\n            extra_params: Additional authorization request parameters\n\n        Raises:\n            OIDCConfigurationError: If configuration is invalid\n        \"\"\"\n        config = OIDCProviderConfig(\n            name=name,\n            client_id=client_id,\n            client_secret=client_secret,\n            server_metadata_url=server_metadata_url,\n            scopes=scopes or list(DEFAULT_SCOPES),\n            use_pkce=use_pkce,\n            extra_params=extra_params or {},\n        )\n\n        self._providers[name] = config\n        logger.info(\n            \"OIDC provider registered\",\n            extra={\n                \"provider\": name,\n                \"metadata_url\": server_metadata_url,\n                \"use_pkce\": use_pkce,\n                \"scopes\": config.scopes,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n    def register_provider_from_model(\n        self,\n        provider: Any,  # SSOProvider model\n    ) -> None:\n        \"\"\"Register an OIDC provider from database model.\n\n        Args:\n            provider: SSOProvider model instance\n\n        Raises:\n            OIDCConfigurationError: If provider is not OIDC or config is invalid\n        \"\"\"\n        if not provider.is_oidc:\n            raise OIDCConfigurationError(f\"Provider '{provider.name}' is not an OIDC provider\")\n\n        # Validate required fields\n        errors = provider.validate_oidc_config()\n        if errors:\n            raise OIDCConfigurationError(\n                f\"Invalid OIDC configuration for '{provider.name}': {'; '.join(errors)}\"\n            )\n\n        self.register_provider(\n            name=provider.name,\n            client_id=provider.oidc_client_id,\n            client_secret=provider.oidc_client_secret,\n            server_metadata_url=provider.oidc_metadata_url,\n            scopes=provider.oidc_scope_list,\n            use_pkce=True,\n            extra_params=provider.get_config(),\n        )\n\n    def get_provider(self, name: str) -> OIDCProviderConfig:\n        \"\"\"Get a registered provider configuration.\n\n        Args:\n            name: Provider name\n\n        Returns:\n            Provider configuration\n\n        Raises:\n            OIDCConfigurationError: If provider not found\n        \"\"\"\n        if name not in self._providers:\n            raise OIDCConfigurationError(f\"OIDC provider '{name}' not registered\")\n        return self._providers[name]\n\n    def list_providers(self) -> list[str]:\n        \"\"\"List all registered provider names.\n\n        Returns:\n            List of provider names\n        \"\"\"\n        return list(self._providers.keys())\n\n    async def _get_http_client(self) -> Any:\n        \"\"\"Get or create HTTP client.\n\n        Returns:\n            httpx AsyncClient instance\n        \"\"\"\n        if self._http_client is None:\n            if not HAS_HTTPX:\n                raise OIDCError(\"httpx library is required for OIDC operations\")\n            self._http_client = httpx.AsyncClient(timeout=30.0)\n        return self._http_client\n\n    async def _fetch_metadata(\n        self, provider: OIDCProviderConfig, force_refresh: bool = False\n    ) -> dict[str, Any]:\n        \"\"\"Fetch OpenID Connect metadata from discovery endpoint.\n\n        Args:\n            provider: Provider configuration\n            force_refresh: Force metadata refresh even if cached\n\n        Returns:\n            Provider metadata dictionary\n\n        Raises:\n            OIDCProviderError: If metadata fetch fails\n        \"\"\"\n        cache_key = provider.name\n\n        # Check cache validity (24 hours)\n        if not force_refresh and cache_key in self._metadata_cache:\n            cached_at = self._metadata_timestamps.get(cache_key)\n            if cached_at:\n                age = datetime.now(timezone.utc) - cached_at\n                if age.total_seconds() < 86400:  # 24 hours\n                    return self._metadata_cache[cache_key]\n\n        try:\n            client = await self._get_http_client()\n            response = await client.get(provider.server_metadata_url)\n            response.raise_for_status()\n            metadata = response.json()\n\n            # Cache the metadata\n            self._metadata_cache[cache_key] = metadata\n            self._metadata_timestamps[cache_key] = datetime.now(timezone.utc)\n\n            logger.info(\n                \"OIDC metadata fetched\",\n                extra={\n                    \"provider\": provider.name,\n                    \"issuer\": metadata.get(\"issuer\"),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return metadata\n\n        except Exception as e:\n            # Try to use cached metadata on error\n            if cache_key in self._metadata_cache:\n                logger.warning(\n                    \"Failed to refresh OIDC metadata, using cached version\",\n                    extra={\n                        \"provider\": provider.name,\n                        \"error\": str(e),\n                        \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                    },\n                )\n                return self._metadata_cache[cache_key]\n\n            raise OIDCProviderError(\n                f\"Failed to fetch OIDC metadata for '{provider.name}': {e}\"\n            ) from e\n\n    def _generate_state(self) -> str:\n        \"\"\"Generate a cryptographically secure state parameter.\n\n        Returns:\n            Random state string\n        \"\"\"\n        return secrets.token_urlsafe(32)\n\n    def _generate_code_verifier(self) -> str:\n        \"\"\"Generate PKCE code verifier.\n\n        Returns:\n            Random code verifier string\n        \"\"\"\n        return secrets.token_urlsafe(64)\n\n    def _generate_code_challenge(self, verifier: str) -> str:\n        \"\"\"Generate PKCE code challenge from verifier.\n\n        Args:\n            verifier: Code verifier string\n\n        Returns:\n            Base64url-encoded SHA256 hash of verifier\n        \"\"\"\n        digest = hashlib.sha256(verifier.encode()).digest()\n        # Convert to base64url without padding\n        import base64\n\n        return base64.urlsafe_b64encode(digest).rstrip(b\"=\").decode(\"ascii\")\n\n    async def initiate_login(\n        self,\n        provider_name: str,\n        redirect_uri: str,\n        nonce: Optional[str] = None,\n    ) -> tuple[str, str]:\n        \"\"\"Initiate OIDC login flow.\n\n        This generates the authorization URL that the user should be\n        redirected to for authentication.\n\n        Args:\n            provider_name: Name of the registered provider\n            redirect_uri: Callback URL after authentication\n            nonce: Optional nonce for replay attack prevention\n\n        Returns:\n            Tuple of (authorization_url, state)\n\n        Raises:\n            OIDCConfigurationError: If provider not found\n            OIDCProviderError: If metadata fetch fails\n        \"\"\"\n        provider = self.get_provider(provider_name)\n        metadata = await self._fetch_metadata(provider)\n\n        authorization_endpoint = metadata.get(\"authorization_endpoint\")\n        if not authorization_endpoint:\n            raise OIDCProviderError(\n                f\"Authorization endpoint not found in metadata for '{provider_name}'\"\n            )\n\n        # Generate state and PKCE values\n        state = self._generate_state()\n        code_verifier = self._generate_code_verifier() if provider.use_pkce else None\n        code_challenge = self._generate_code_challenge(code_verifier) if code_verifier else None\n\n        # Store pending state for callback verification\n        self._pending_states[state] = {\n            \"provider\": provider_name,\n            \"redirect_uri\": redirect_uri,\n            \"code_verifier\": code_verifier,\n            \"nonce\": nonce or secrets.token_urlsafe(16),\n            \"created_at\": datetime.now(timezone.utc).isoformat(),\n        }\n\n        # Build authorization URL\n        params = {\n            \"client_id\": provider.client_id,\n            \"response_type\": \"code\",\n            \"redirect_uri\": redirect_uri,\n            \"scope\": \" \".join(provider.scopes),\n            \"state\": state,\n            \"nonce\": self._pending_states[state][\"nonce\"],\n        }\n\n        # Add PKCE parameters\n        if provider.use_pkce and code_challenge:\n            params[\"code_challenge\"] = code_challenge\n            params[\"code_challenge_method\"] = \"S256\"\n\n        # Add extra provider-specific parameters\n        params.update(provider.extra_params)\n\n        # Construct URL\n        from urllib.parse import urlencode\n\n        auth_url = f\"{authorization_endpoint}?{urlencode(params)}\"\n\n        logger.info(\n            \"OIDC login initiated\",\n            extra={\n                \"provider\": provider_name,\n                \"state\": state[:8] + \"...\",  # Log partial state for security\n                \"use_pkce\": provider.use_pkce,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n        return auth_url, state\n\n    async def handle_callback(\n        self,\n        provider_name: str,\n        code: str,\n        state: str,\n        redirect_uri: Optional[str] = None,\n    ) -> OIDCUserInfo:\n        \"\"\"Handle OIDC callback after IdP authentication.\n\n        This exchanges the authorization code for tokens and retrieves\n        user information.\n\n        Args:\n            provider_name: Name of the registered provider\n            code: Authorization code from callback\n            state: State parameter from callback\n            redirect_uri: Optional redirect URI (uses stored value if not provided)\n\n        Returns:\n            User information from IdP\n\n        Raises:\n            OIDCAuthenticationError: If state validation fails\n            OIDCTokenError: If token exchange fails\n            OIDCProviderError: If user info retrieval fails\n        \"\"\"\n        # Validate state\n        if state not in self._pending_states:\n            raise OIDCAuthenticationError(\n                \"Invalid or expired state parameter. Possible CSRF attack.\"\n            )\n\n        stored = self._pending_states.pop(state)\n\n        # Verify provider matches\n        if stored[\"provider\"] != provider_name:\n            raise OIDCAuthenticationError(\n                f\"Provider mismatch: expected '{stored['provider']}', got '{provider_name}'\"\n            )\n\n        provider = self.get_provider(provider_name)\n        callback_redirect_uri = redirect_uri or stored[\"redirect_uri\"]\n\n        # Exchange code for tokens\n        tokens = await self._exchange_code(\n            provider=provider,\n            code=code,\n            redirect_uri=callback_redirect_uri,\n            code_verifier=stored.get(\"code_verifier\"),\n        )\n\n        # Get user info (prefer ID token claims, fallback to userinfo endpoint)\n        user_info = await self._get_user_info(provider, tokens)\n\n        logger.info(\n            \"OIDC authentication successful\",\n            extra={\n                \"provider\": provider_name,\n                \"user_sub\": user_info.sub[:8] + \"...\" if user_info.sub else \"N/A\",\n                \"email\": user_info.email,\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n        return user_info\n\n    async def _exchange_code(\n        self,\n        provider: OIDCProviderConfig,\n        code: str,\n        redirect_uri: str,\n        code_verifier: Optional[str] = None,\n    ) -> OIDCTokenResponse:\n        \"\"\"Exchange authorization code for tokens.\n\n        Args:\n            provider: Provider configuration\n            code: Authorization code\n            redirect_uri: Callback URI used in authorization request\n            code_verifier: PKCE code verifier (if used)\n\n        Returns:\n            Token response from IdP\n\n        Raises:\n            OIDCTokenError: If token exchange fails\n        \"\"\"\n        metadata = await self._fetch_metadata(provider)\n        token_endpoint = metadata.get(\"token_endpoint\")\n\n        if not token_endpoint:\n            raise OIDCTokenError(f\"Token endpoint not found in metadata for '{provider.name}'\")\n\n        try:\n            client = await self._get_http_client()\n\n            data = {\n                \"grant_type\": \"authorization_code\",\n                \"client_id\": provider.client_id,\n                \"client_secret\": provider.client_secret,\n                \"code\": code,\n                \"redirect_uri\": redirect_uri,\n            }\n\n            if code_verifier:\n                data[\"code_verifier\"] = code_verifier\n\n            response = await client.post(\n                token_endpoint,\n                data=data,\n                headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n            )\n\n            if response.status_code != 200:\n                error_data = response.json() if response.content else {}\n                error_msg = error_data.get(\n                    \"error_description\", error_data.get(\"error\", \"Unknown error\")\n                )\n                raise OIDCTokenError(f\"Token exchange failed for '{provider.name}': {error_msg}\")\n\n            token_data = response.json()\n            return OIDCTokenResponse.from_dict(token_data)\n\n        except OIDCTokenError:\n            raise\n        except Exception as e:\n            raise OIDCTokenError(f\"Token exchange failed for '{provider.name}': {e}\") from e\n\n    async def _get_user_info(\n        self,\n        provider: OIDCProviderConfig,\n        tokens: OIDCTokenResponse,\n    ) -> OIDCUserInfo:\n        \"\"\"Get user information from tokens or userinfo endpoint.\n\n        Args:\n            provider: Provider configuration\n            tokens: Token response from exchange\n\n        Returns:\n            User information\n        \"\"\"\n        # First, try to extract claims from ID token\n        if tokens.id_token:\n            try:\n                claims = self._decode_id_token(tokens.id_token)\n                if claims.get(\"sub\"):\n                    return OIDCUserInfo.from_claims(claims)\n            except Exception as e:\n                logger.warning(\n                    \"Failed to decode ID token, falling back to userinfo endpoint\",\n                    extra={\n                        \"provider\": provider.name,\n                        \"error\": str(e),\n                        \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                    },\n                )\n\n        # Fallback to userinfo endpoint\n        return await self._fetch_userinfo(provider, tokens.access_token)\n\n    def _decode_id_token(self, id_token: str) -> dict[str, Any]:\n        \"\"\"Decode ID token without full validation.\n\n        Note: In production, you should validate the token signature\n        against the IdP's JWKS. This method only decodes the claims\n        for user info extraction.\n\n        Args:\n            id_token: JWT ID token\n\n        Returns:\n            Token claims dictionary\n        \"\"\"\n        # Simple JWT payload extraction (header.payload.signature)\n        import base64\n        import json\n\n        parts = id_token.split(\".\")\n        if len(parts) != 3:\n            raise OIDCTokenError(\"Invalid ID token format\")\n\n        # Decode payload (second part)\n        payload = parts[1]\n        # Add padding if needed\n        padding = 4 - len(payload) % 4\n        if padding != 4:\n            payload += \"=\" * padding\n\n        try:\n            decoded = base64.urlsafe_b64decode(payload)\n            return json.loads(decoded)\n        except Exception as e:\n            raise OIDCTokenError(f\"Failed to decode ID token: {e}\") from e\n\n    async def _fetch_userinfo(\n        self,\n        provider: OIDCProviderConfig,\n        access_token: str,\n    ) -> OIDCUserInfo:\n        \"\"\"Fetch user info from userinfo endpoint.\n\n        Args:\n            provider: Provider configuration\n            access_token: Access token for API call\n\n        Returns:\n            User information\n\n        Raises:\n            OIDCProviderError: If userinfo request fails\n        \"\"\"\n        metadata = await self._fetch_metadata(provider)\n        userinfo_endpoint = metadata.get(\"userinfo_endpoint\")\n\n        if not userinfo_endpoint:\n            raise OIDCProviderError(\n                f\"Userinfo endpoint not found in metadata for '{provider.name}'\"\n            )\n\n        try:\n            client = await self._get_http_client()\n            response = await client.get(\n                userinfo_endpoint,\n                headers={\"Authorization\": f\"Bearer {access_token}\"},\n            )\n\n            if response.status_code != 200:\n                raise OIDCProviderError(\n                    f\"Userinfo request failed for '{provider.name}': {response.status_code}\"\n                )\n\n            claims = response.json()\n            return OIDCUserInfo.from_claims(claims)\n\n        except OIDCProviderError:\n            raise\n        except Exception as e:\n            raise OIDCProviderError(f\"Userinfo request failed for '{provider.name}': {e}\") from e\n\n    async def refresh_token(\n        self,\n        provider_name: str,\n        refresh_token: str,\n    ) -> OIDCTokenResponse:\n        \"\"\"Refresh an access token using a refresh token.\n\n        Args:\n            provider_name: Name of the registered provider\n            refresh_token: Refresh token from initial token exchange\n\n        Returns:\n            New token response\n\n        Raises:\n            OIDCTokenError: If refresh fails\n        \"\"\"\n        provider = self.get_provider(provider_name)\n        metadata = await self._fetch_metadata(provider)\n        token_endpoint = metadata.get(\"token_endpoint\")\n\n        if not token_endpoint:\n            raise OIDCTokenError(f\"Token endpoint not found in metadata for '{provider_name}'\")\n\n        try:\n            client = await self._get_http_client()\n\n            response = await client.post(\n                token_endpoint,\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"client_id\": provider.client_id,\n                    \"client_secret\": provider.client_secret,\n                    \"refresh_token\": refresh_token,\n                },\n                headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n            )\n\n            if response.status_code != 200:\n                error_data = response.json() if response.content else {}\n                error_msg = error_data.get(\n                    \"error_description\", error_data.get(\"error\", \"Unknown error\")\n                )\n                raise OIDCTokenError(f\"Token refresh failed for '{provider_name}': {error_msg}\")\n\n            token_data = response.json()\n\n            logger.info(\n                \"OIDC token refreshed\",\n                extra={\n                    \"provider\": provider_name,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n            return OIDCTokenResponse.from_dict(token_data)\n\n        except OIDCTokenError:\n            raise\n        except Exception as e:\n            raise OIDCTokenError(f\"Token refresh failed for '{provider_name}': {e}\") from e\n\n    async def logout(\n        self,\n        provider_name: str,\n        id_token_hint: Optional[str] = None,\n        post_logout_redirect_uri: Optional[str] = None,\n    ) -> Optional[str]:\n        \"\"\"Get logout URL for OIDC RP-initiated logout.\n\n        Args:\n            provider_name: Name of the registered provider\n            id_token_hint: ID token for logout hint\n            post_logout_redirect_uri: Where to redirect after logout\n\n        Returns:\n            Logout URL (or None if provider doesn't support RP-initiated logout)\n        \"\"\"\n        provider = self.get_provider(provider_name)\n        metadata = await self._fetch_metadata(provider)\n\n        logout_endpoint = metadata.get(\"end_session_endpoint\")\n        if not logout_endpoint:\n            logger.info(\n                \"Provider does not support RP-initiated logout\",\n                extra={\n                    \"provider\": provider_name,\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n            return None\n\n        from urllib.parse import urlencode\n\n        params = {\"client_id\": provider.client_id}\n\n        if id_token_hint:\n            params[\"id_token_hint\"] = id_token_hint\n        if post_logout_redirect_uri:\n            params[\"post_logout_redirect_uri\"] = post_logout_redirect_uri\n\n        logout_url = f\"{logout_endpoint}?{urlencode(params)}\"\n\n        logger.info(\n            \"OIDC logout URL generated\",\n            extra={\n                \"provider\": provider_name,\n                \"has_id_token_hint\": bool(id_token_hint),\n                \"constitutional_hash\": CONSTITUTIONAL_HASH,\n            },\n        )\n\n        return logout_url\n\n    def validate_state(self, state: str) -> bool:\n        \"\"\"Validate a pending state parameter.\n\n        Args:\n            state: State to validate\n\n        Returns:\n            True if state is valid and pending\n        \"\"\"\n        return state in self._pending_states\n\n    def clear_expired_states(self, max_age_seconds: int = 600) -> int:\n        \"\"\"Clear expired pending states.\n\n        Args:\n            max_age_seconds: Maximum age of pending states (default: 10 minutes)\n\n        Returns:\n            Number of states cleared\n        \"\"\"\n        now = datetime.now(timezone.utc)\n        expired = []\n\n        for state, data in self._pending_states.items():\n            created = datetime.fromisoformat(data[\"created_at\"])\n            if (now - created).total_seconds() > max_age_seconds:\n                expired.append(state)\n\n        for state in expired:\n            del self._pending_states[state]\n\n        if expired:\n            logger.info(\n                \"Cleared expired OIDC states\",\n                extra={\n                    \"count\": len(expired),\n                    \"constitutional_hash\": CONSTITUTIONAL_HASH,\n                },\n            )\n\n        return len(expired)\n\n    async def close(self) -> None:\n        \"\"\"Close HTTP client and clean up resources.\"\"\"\n        if self._http_client is not None:\n            await self._http_client.aclose()\n            self._http_client = None\n\n        logger.info(\n            \"OIDC handler closed\",\n            extra={\"constitutional_hash\": CONSTITUTIONAL_HASH},\n        )\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.145885",
  "last_updated": "2026-01-04T05:35:58.933225"
}