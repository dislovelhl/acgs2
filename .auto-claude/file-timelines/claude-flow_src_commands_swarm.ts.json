{
  "file_path": "claude-flow/src/commands/swarm.ts",
  "main_branch_history": [],
  "task_views": {
    "059-add-jsdoc-coverage-for-claude-flow-typescript-serv": {
      "task_id": "059-add-jsdoc-coverage-for-claude-flow-typescript-serv",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "/**\n * Swarm Command Module\n *\n * This module provides CLI commands for managing ACGS-2 agent swarms, including:\n * - Initializing swarms with various topologies and strategies\n * - Monitoring swarm status and health\n * - Real-time swarm activity monitoring\n *\n * @module swarm\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { initializeSwarm, getSwarmStatus } from '../services/swarmService';\nimport { getLogger } from '../../../sdk/typescript/src/utils/logger';\nconst logger = getLogger('swarm');\n\n/**\n * Main swarm command that provides subcommands for swarm management.\n * Use this command to initialize, monitor, and manage agent swarms.\n *\n * Available subcommands:\n * - init: Initialize a new swarm with specified topology and configuration\n * - status: Check the current status of the active swarm\n * - monitor: Monitor swarm activity in real-time\n *\n * @example\n * ```bash\n * # Initialize a hierarchical swarm with 8 max agents\n * npx claude-flow swarm init --topology hierarchical --max-agents 8\n *\n * # Check swarm status\n * npx claude-flow swarm status --verbose\n * ```\n */\nexport const swarmCommand = new Command('swarm')\n  .description('Manage agent swarms');\n\n// Valid topologies and strategies\nconst VALID_TOPOLOGIES = ['mesh', 'hierarchical', 'ring', 'star'] as const;\nconst VALID_STRATEGIES = ['balanced', 'parallel', 'sequential'] as const;\n\n/**\n * Valid swarm topology types.\n *\n * - mesh: Research, exploration, brainstorming (all agents communicate peer-to-peer)\n * - hierarchical: Development, structured tasks (coordinator-worker pattern)\n * - ring: Pipeline processing, sequential workflows (agents in circular chain)\n * - star: Simple tasks, centralized control (hub-and-spoke pattern)\n */\ntype Topology = typeof VALID_TOPOLOGIES[number];\n\n/**\n * Valid execution strategy types.\n *\n * - balanced: Distribute work evenly across available agents\n * - parallel: Execute tasks concurrently across multiple agents\n * - sequential: Execute tasks one at a time in order\n */\ntype Strategy = typeof VALID_STRATEGIES[number];\n\n/**\n * Validates if a string is a valid swarm topology type.\n *\n * @param topology - The topology string to validate\n * @returns True if the topology is valid (mesh, hierarchical, ring, or star)\n *\n * @example\n * ```typescript\n * if (validateTopology('mesh')) {\n *   console.log('Valid topology');\n * }\n * ```\n */\nfunction validateTopology(topology: string): topology is Topology {\n  return VALID_TOPOLOGIES.includes(topology as Topology);\n}\n\n/**\n * Validates if a string is a valid execution strategy type.\n *\n * @param strategy - The strategy string to validate\n * @returns True if the strategy is valid (balanced, parallel, or sequential)\n *\n * @example\n * ```typescript\n * if (validateStrategy('parallel')) {\n *   console.log('Valid strategy');\n * }\n * ```\n */\nfunction validateStrategy(strategy: string): strategy is Strategy {\n  return VALID_STRATEGIES.includes(strategy as Strategy);\n}\n\n/**\n * Validates and parses the maximum agents value.\n *\n * @param maxAgents - The max agents value as a string\n * @returns The parsed number if valid\n * @throws {Error} If the value is not a number between 1 and 100\n *\n * @example\n * ```typescript\n * try {\n *   const max = validateMaxAgents('8');\n *   console.log(`Max agents: ${max}`);\n * } catch (error) {\n *   console.error('Invalid max agents value');\n * }\n * ```\n */\nfunction validateMaxAgents(maxAgents: string): number {\n  const num = parseInt(maxAgents, 10);\n  if (isNaN(num) || num < 1 || num > 100) {\n    throw new Error('Maximum agents must be a number between 1 and 100');\n  }\n  return num;\n}\n\nconst initCommand = new Command('init')\n  .description('Initialize a Claude Flow swarm with specified topology and configuration')\n  .option('-t, --topology <type>', `Swarm topology (${VALID_TOPOLOGIES.join(', ')})`, 'hierarchical')\n  .option('-m, --max-agents <number>', 'Maximum number of agents', '8')\n  .option('-s, --strategy <type>', `Execution strategy (${VALID_STRATEGIES.join(', ')})`, 'parallel')\n  .option('--auto-spawn', 'Automatically spawn agents based on task complexity', false)\n  .option('--memory', 'Enable cross-session memory persistence', false)\n  .option('--github', 'Enable GitHub integration features', false)\n  .action(async (options) => {\n    const spinner = ora('Initializing swarm...').start();\n\n        logger.info(chalk.yellow(`\\n\ud83d\udccb Valid topologies: ${VALID_TOPOLOGIES.join(', ')}`);\n        logger.info(chalk.gray(`\\n\ud83d\udca1 Choose based on your use case:`);\n        logger.info(chalk.gray(`   \u2022 mesh: Research, exploration, brainstorming`);\n        logger.info(chalk.gray(`   \u2022 hierarchical: Development, structured tasks`);\n        logger.info(chalk.gray(`   \u2022 ring: Pipeline processing, sequential workflows`);\n        logger.info(chalk.gray(`   \u2022 star: Simple tasks, centralized control`);\n        console.log(chalk.gray(`   \u2022 mesh: Research, exploration, brainstorming`));\n        console.log(chalk.gray(`   \u2022 hierarchical: Development, structured tasks`));\n        console.log(chalk.gray(`   \u2022 ring: Pipeline processing, sequential workflows`));\n        console.log(chalk.gray(`   \u2022 star: Simple tasks, centralized control`));\n        process.exit(1);\n      }\n        logger.info(chalk.yellow(`\\n\ud83d\udccb Valid strategies: ${VALID_STRATEGIES.join(', ')}`);\n      // Validate strategy\n      if (!validateStrategy(options.strategy)) {\n        spinner.fail(chalk.red(`\u274c Invalid strategy: ${options.strategy}`));\n        logger.warn('invalid_strategy', { strategy: options.strategy });\n        cliOutput(chalk.yellow(`\\n\ud83d\udccb Valid strategies: ${VALID_STRATEGIES.join(', ')}`));\n        process.exit(1);\n      }\n\n      // Validate max agents\n      let maxAgents: number;\n        logger.info(chalk.yellow(`\\n\ud83d\udca1 Maximum agents should be between 1 and 100`);\n        maxAgents = validateMaxAgents(options.maxAgents);\n      } catch (error) {\n        spinner.fail(chalk.red(`\u274c ${error instanceof Error ? error.message : 'Invalid max agents'}`));\n        logger.warn('invalid_max_agents', { maxAgents: options.maxAgents });\n        cliOutput(chalk.yellow(`\\n\ud83d\udca1 Maximum agents should be between 1 and 100`));\n        process.exit(1);\n      }\n\n      spinner.text = `Initializing ${options.topology} swarm with ${maxAgents} max agents...`;\n      logger.info('swarm_init_started', { topology: options.topology, maxAgents, strategy: options.strategy });\n\n      // Initialize the swarm\n      const result = await initializeSwarm({\n        topology: options.topology,\n        maxAgents,\n        strategy: options.strategy,\n        autoSpawn: options.autoSpawn,\n        memory: options.memory,\n        github: options.github\n      });\n        logger.info(chalk.blue(`\\n\ud83d\udc1d Swarm Configuration:`);\n        logger.info(chalk.gray(`   Topology: ${options.topology}`);\n        logger.info(chalk.gray(`   Max Agents: ${maxAgents}`);\n        logger.info(chalk.gray(`   Strategy: ${options.strategy}`);\n        logger.info(chalk.gray(`   Auto-spawn: ${options.autoSpawn ? 'enabled' : 'disabled'}`);\n        logger.info(chalk.gray(`   Memory: ${options.memory ? 'enabled' : 'disabled'}`);\n        logger.info(chalk.gray(`   GitHub: ${options.github ? 'enabled' : 'disabled'}`);\n        console.log(chalk.gray(`   Strategy: ${options.strategy}`));\n        console.log(chalk.gray(`   Auto-spawn: ${options.autoSpawn ? 'enabled' : 'disabled'}`));\n          logger.info(chalk.gray(`   Swarm ID: ${result.swarmId}`);\n        console.log(chalk.gray(`   GitHub: ${options.github ? 'enabled' : 'disabled'}`));\n\n        logger.info(chalk.green(`\\n\ud83d\ude80 Swarm is ready for agent spawning and task orchestration!`);\n          console.log(chalk.gray(`   Swarm ID: ${result.swarmId}`));\n        }\n        logger.info(chalk.cyan(`\\n\ud83d\udcdd Next steps:`);\n        logger.info(chalk.gray(`   \u2022 Spawn agents: npx claude-flow agent spawn --type coder`);\n        logger.info(chalk.gray(`   \u2022 Check status: npx claude-flow swarm status`);\n        logger.info(chalk.gray(`   \u2022 Start monitoring: npx claude-flow swarm monitor`);\n        console.log(chalk.cyan(`\\n\ud83d\udcdd Next steps:`));\n        console.log(chalk.gray(`   \u2022 Spawn agents: npx claude-flow agent spawn --type coder`));\n        console.log(chalk.gray(`   \u2022 Check status: npx claude-flow swarm status`));\n        logger.info(chalk.red(`\\nError: ${result.error}`);\n\n      } else {\n        spinner.fail(chalk.red(`\u274c Failed to initialize swarm`));\n        logger.error('swarm_init_failed', { error: result.error });\n        cliOutput(chalk.red(`\\nError: ${result.error}`));\n        process.exit(1);\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.info(chalk.yellow(`\\n\ud83d\udca1 Make sure Python 3 is installed and available in PATH`);\n\n        logger.info(chalk.yellow(`\\n\ud83d\udca1 Make sure the ACGS-2 core is properly installed`);\n      if (errorMessage.includes('python3')) {\n        cliOutput(chalk.yellow(`\\n\ud83d\udca1 Make sure Python 3 is installed and available in PATH`));\n      } else if (errorMessage.includes('EnhancedAgentBus')) {\n        cliOutput(chalk.yellow(`\\n\ud83d\udca1 Make sure the ACGS-2 core is properly installed`));\n      }\n\n      process.exit(1);\n    }\n  });\n\nconst statusCommand = new Command('status')\n  .description('Check the current status of the swarm')\n  .option('-v, --verbose', 'Show detailed status information', false)\n  .action(async (options) => {\n    const spinner = ora('Checking swarm status...').start();\n\n    try {\n        logger.info(chalk.gray(`\\n\ud83d\udca1 Initialize a swarm first: npx claude-flow swarm init`);\n\n      if (!status || Object.keys(status).length === 0) {\n        spinner.warn(chalk.yellow(`\u26a0\ufe0f  No active swarm found`));\n        logger.info('no_active_swarm');\n        cliOutput(chalk.gray(`\\n\ud83d\udca1 Initialize a swarm first: npx claude-flow swarm init`));\n        return;\n      logger.info(chalk.blue(`\\n\ud83d\udc1d Swarm Status:`);\n\n      spinner.succeed(chalk.green(`\u2705 Swarm status retrieved!`));\n      logger.info('swarm_status_retrieved', { swarmId: status.swarm_id });\n\n        logger.info(chalk.gray(`   Swarm ID: ${status.swarm_id}`);\n\n      // Show basic information\n        logger.info(chalk.gray(`   Topology: ${status.topology}`);\n        console.log(chalk.gray(`   Swarm ID: ${status.swarm_id}`));\n      }\n        logger.info(chalk.gray(`   Max Agents: ${status.max_agents}`);\n        console.log(chalk.gray(`   Topology: ${status.topology}`));\n      }\n        logger.info(chalk.gray(`   Active Agents: ${status.active_agents}`);\n        console.log(chalk.gray(`   Max Agents: ${status.max_agents}`));\n      }\n        logger.info(chalk.gray(`   Strategy: ${status.strategy}`);\n        console.log(chalk.gray(`   Active Agents: ${status.active_agents}`));\n      }\n      if (status.strategy) {\n        cliOutput(chalk.gray(`   Strategy: ${status.strategy}`));\n      }\n\n      // Show feature flags\n      const features = [];\n        logger.info(chalk.gray(`   Features: ${features.join(', ')}`);\n      if (status.memory_enabled) features.push('Memory');\n      if (status.github_enabled) features.push('GitHub');\n      if (features.length > 0) {\n        console.log(chalk.gray(`   Features: ${features.join(', ')}`));\n        logger.info(chalk.gray(`   Created: ${created.toLocaleString()}`);\n\n      if (status.created_at) {\n        const created = new Date(status.created_at * 1000);\n        logger.info(chalk.gray(`   Coordinator: ${status.coordinator_agent}`);\n      }\n\n      if (status.coordinator_agent) {\n        logger.info(chalk.blue(`\\n\ud83d\udcca Detailed Information:`);\n      }\n          logger.info(chalk.gray(`   Tenant: ${status.tenant_id}`);\n      if (options.verbose) {\n        console.log(chalk.blue(`\\n\ud83d\udcca Detailed Information:`));\n          logger.info(chalk.gray(`   Memory Backend: ${status.memory_backend}`);\n          console.log(chalk.gray(`   Tenant: ${status.tenant_id}`));\n        }\n          logger.info(chalk.gray(`   GitHub Webhook: ${status.github_webhook_url}`);\n          console.log(chalk.gray(`   Memory Backend: ${status.memory_backend}`));\n        logger.info(chalk.gray(`   Constitutional Hash: ${status.constitutional_hash || 'cdd01ef066bc6cf2'}`);\n        if (status.github_webhook_url) {\n          cliOutput(chalk.gray(`   GitHub Webhook: ${status.github_webhook_url}`));\n        }\n        cliOutput(chalk.gray(`   Constitutional Hash: ${status.constitutional_hash || 'cdd01ef066bc6cf2'}`));\n      }\n\n      // Show health indicators\n      logger.info(chalk.blue(`\\n\ud83c\udfe5 Health Status:`);\n      logger.info(chalk.gray(`   Agent Utilization: ${activeAgents}/${maxAgents} (${utilization}%)`);\n      const utilization = maxAgents > 0 ? Math.round((activeAgents / maxAgents) * 100) : 0;\n\n        logger.info(chalk.yellow(`   Status: Swarm initialized but no agents active`);\n      console.log(chalk.gray(`   Agent Utilization: ${activeAgents}/${maxAgents} (${utilization}%)`));\n        logger.info(chalk.green(`   Status: Swarm healthy with available capacity`);\n      if (utilization === 0) {\n        logger.info(chalk.yellow(`   Status: Swarm busy, consider scaling`);\n      } else if (utilization < 50) {\n        logger.info(chalk.red(`   Status: Swarm at capacity, monitor closely`);\n      } else if (utilization < 90) {\n        cliOutput(chalk.yellow(`   Status: Swarm busy, consider scaling`));\n      } else {\n        cliOutput(chalk.red(`   Status: Swarm at capacity, monitor closely`));\n      }\n\n    } catch (error) {\n        logger.info(chalk.yellow(`\\n\ud83d\udca1 Make sure Python 3 is installed and available in PATH`);\n      spinner.fail(chalk.red(`\u274c Failed to get swarm status: ${errorMessage}`));\n        logger.info(chalk.yellow(`\\n\ud83d\udca1 Make sure the ACGS-2 core is properly installed`);\n      if (errorMessage.includes('python3')) {\n        cliOutput(chalk.yellow(`\\n\ud83d\udca1 Make sure Python 3 is installed and available in PATH`));\n      } else if (errorMessage.includes('EnhancedAgentBus')) {\n        cliOutput(chalk.yellow(`\\n\ud83d\udca1 Make sure the ACGS-2 core is properly installed`));\n      }\n    }\n  });\n\nconst monitorCommand = new Command('monitor')\n  .description('Monitor swarm activity in real-time')\n  .option('-i, --interval <seconds>', 'Monitoring interval in seconds', '5')\n  .option('-l, --limit <count>', 'Maximum number of updates to show', '10')\n  .option('--metrics', 'Show detailed metrics instead of summary', false)\n  .action(async (options) => {\n      logger.info(chalk.red(`\u274c Invalid interval: ${options.interval}. Must be a positive number.`);\n    const limit = parseInt(options.limit, 10);\n\n    if (isNaN(interval) || interval < 1) {\n      console.log(chalk.red(`\u274c Invalid interval: ${options.interval}. Must be a positive number.`));\n      logger.info(chalk.red(`\u274c Invalid limit: ${options.limit}. Must be a positive number.`);\n    }\n\n    if (isNaN(limit) || limit < 1) {\n    logger.info(chalk.blue(`\ud83d\udc1d Starting swarm monitoring...`);\n    logger.info(chalk.gray(`   Interval: ${interval}s | Updates: ${limit}`);\n    logger.info(chalk.gray(`   Press Ctrl+C to stop monitoring`);\n\n    cliOutput(chalk.blue(`\ud83d\udc1d Starting swarm monitoring...`));\n    cliOutput(chalk.gray(`   Interval: ${interval}s | Updates: ${limit}`));\n    cliOutput(chalk.gray(`   Press Ctrl+C to stop monitoring`));\n    cliOutput('');\n\n    logger.info('swarm_monitor_started', { interval, limit, metrics: options.metrics });\n\n    let updateCount = 0;\n\n    const monitor = async () => {\n          logger.info(chalk.yellow(`\u26a0\ufe0f  No active swarm detected`);\n        const status = await getSwarmStatus();\n\n        if (!status || Object.keys(status).length === 0) {\n          cliOutput(chalk.yellow(`\u26a0\ufe0f  No active swarm detected`));\n          return;\n        }\n\n          logger.info(chalk.blue(`\ud83d\udcca Update ${updateCount} - ${new Date().toLocaleTimeString()}`);\n          logger.info(chalk.gray(`   Active Agents: ${status.active_agents || 0}/${status.max_agents || 8}`);\n          logger.info(chalk.gray(`   Utilization: ${Math.round(status.utilization_percent || 0)}%`);\n          logger.info(chalk.gray(`   Topology: ${status.topology || 'unknown'}`);\n          logger.info(chalk.gray(`   Strategy: ${status.strategy || 'unknown'}`);\n          console.log(chalk.gray(`   Active Agents: ${status.active_agents || 0}/${status.max_agents || 8}`));\n          console.log(chalk.gray(`   Utilization: ${Math.round(status.utilization_percent || 0)}%`));\n          console.log(chalk.gray(`   Topology: ${status.topology || 'unknown'}`));\n          console.log(chalk.gray(`   Strategy: ${status.strategy || 'unknown'}`));\n          console.log();\n        } else {\n          // Summary view\n          const utilization = Math.round(status.utilization_percent || 0);\n          logger.info(`${statusEmoji} ${new Date().toLocaleTimeString()} - ${activeAgents}/${maxAgents} agents (${utilization}%)`;\n          const maxAgents = status.max_agents || 8;\n          const statusEmoji = utilization < 50 ? '\ud83d\udfe2' : utilization < 90 ? '\ud83d\udfe1' : '\ud83d\udd34';\n\n          logger.info(chalk.green(`\\n\u2705 Monitoring complete - ${limit} updates shown`);\n        }\n\n        if (updateCount >= limit) {\n          console.log(chalk.green(`\\n\u2705 Monitoring complete - ${limit} updates shown`));\n        logger.info(chalk.red(`\u274c Monitoring error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n\n      } catch (error) {\n        cliOutput(chalk.red(`\u274c Monitoring error: ${error instanceof Error ? error.message : String(error)}`));\n        logger.error('swarm_monitor_error', { error: error instanceof Error ? error.message : String(error) });\n      }\n    };\n\n    // Initial monitoring\n    await monitor();\n\n    // Set up interval monitoring\n      logger.info(chalk.green(`\\n\ud83d\uded1 Monitoring stopped by user`);\n\n    // Handle graceful shutdown\n    process.on('SIGINT', () => {\n      cliOutput(chalk.green(`\\n\ud83d\uded1 Monitoring stopped by user`));\n      logger.info('swarm_monitor_stopped_by_user');\n      clearInterval(monitoringInterval);\n      logger.info(chalk.green(`\\n\ud83d\uded1 Monitoring stopped`);\n    });\n\n    process.on('SIGTERM', () => {\n      cliOutput(chalk.green(`\\n\ud83d\uded1 Monitoring stopped`));\n      logger.info('swarm_monitor_stopped');\n      clearInterval(monitoringInterval);\n      process.exit(0);\n    });\n  });\n\nswarmCommand.addCommand(initCommand);\nswarmCommand.addCommand(statusCommand);\nswarmCommand.addCommand(monitorCommand);\n",
        "timestamp": "2026-01-04T05:35:52.969195"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Add JSDoc coverage for claude-flow TypeScript service public exports",
        "description": "Add comprehensive JSDoc documentation to the 45 exported functions/classes across 17 TypeScript files in the claude-flow CLI tool to improve API documentation for enterprise users",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T05:35:53.059376",
  "last_updated": "2026-01-04T05:35:53.061633"
}