{
  "file_path": "integration-service/src/api/webhooks.py",
  "main_branch_history": [],
  "task_views": {
    "060-document-error-codes-and-troubleshooting-for-commo": {
      "task_id": "060-document-error-codes-and-troubleshooting-for-commo",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhooks API endpoints for managing webhook subscriptions.\n\nProvides CRUD operations for webhook endpoint configuration,\ndelivery status monitoring, and subscription management.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional\nfrom uuid import uuid4\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom pydantic import BaseModel, ConfigDict, Field, SecretStr, field_validator\n\nfrom ..types import JSONDict, ValidatorValue\nfrom ..webhooks.models import (\n    WebhookAuthType,\n    WebhookConfig,\n    WebhookDeliveryStatus,\n    WebhookEventType,\n    WebhookSignatureAlgorithm,\n    WebhookState,\n    WebhookSubscription,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create router\nrouter = APIRouter(prefix=\"/api/webhooks\", tags=[\"Webhooks\"])\n\n\n# In-memory storage for webhook subscriptions (for development)\n# In production, this would be replaced with a database repository\n_webhook_subscriptions: Dict[str, WebhookSubscription] = {}\n\n\n# Request/Response Models\nclass WebhookConfigCreate(BaseModel):\n    \"\"\"Configuration for a webhook endpoint.\"\"\"\n\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    method: str = Field(default=\"POST\", description=\"HTTP method for webhook delivery\")\n    auth_type: WebhookAuthType = Field(\n        default=WebhookAuthType.NONE, description=\"Authentication type\"\n    )\n    auth_header: str = Field(default=\"Authorization\", description=\"Header name for authentication\")\n    auth_value: Optional[str] = Field(\n        None, description=\"Authentication value (token, API key, etc.)\"\n    )\n    hmac_secret: Optional[str] = Field(None, description=\"HMAC secret for signature verification\")\n    hmac_header: str = Field(default=\"X-Webhook-Signature\", description=\"Header for HMAC signature\")\n    hmac_algorithm: WebhookSignatureAlgorithm = Field(\n        default=WebhookSignatureAlgorithm.SHA256, description=\"HMAC algorithm\"\n    )\n    content_type: str = Field(default=\"application/json\", description=\"Content-Type header value\")\n    custom_headers: Dict[str, str] = Field(\n        default_factory=dict, description=\"Additional headers to include\"\n    )\n    timeout_seconds: float = Field(\n        default=30.0, ge=1.0, le=120.0, description=\"Request timeout in seconds\"\n    )\n    verify_ssl: bool = Field(default=True, description=\"Verify SSL certificates\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n    @field_validator(\"url\", mode=\"before\")\n    @classmethod\n    def validate_url(cls, v: str) -> str:\n        \"\"\"Validate webhook URL format.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            raise ValueError(\"Webhook URL must start with http:// or https://\")\n        return v.rstrip(\"/\")\n\n    def to_webhook_config(self) -> WebhookConfig:\n        \"\"\"Convert to WebhookConfig model with SecretStr handling.\"\"\"\n        return WebhookConfig(\n            url=self.url,\n            method=self.method,\n            auth_type=self.auth_type,\n            auth_header=self.auth_header,\n            auth_value=SecretStr(self.auth_value) if self.auth_value else None,\n            hmac_secret=SecretStr(self.hmac_secret) if self.hmac_secret else None,\n            hmac_header=self.hmac_header,\n            hmac_algorithm=self.hmac_algorithm,\n            content_type=self.content_type,\n            custom_headers=self.custom_headers,\n            timeout_seconds=self.timeout_seconds,\n            verify_ssl=self.verify_ssl,\n        )\n\n\nclass WebhookCreateRequest(BaseModel):\n    \"\"\"Request model for creating a webhook subscription.\"\"\"\n\n    name: str = Field(\n        ..., min_length=1, max_length=255, description=\"Display name for the subscription\"\n    )\n    description: Optional[str] = Field(\n        None, max_length=1000, description=\"Description of this webhook\"\n    )\n\n    # Endpoint configuration - can be inline or via config object\n    url: Optional[str] = Field(None, description=\"Webhook endpoint URL (shorthand)\")\n    auth_type: Optional[WebhookAuthType] = Field(\n        None, description=\"Authentication type (shorthand)\"\n    )\n    config: Optional[WebhookConfigCreate] = Field(\n        None, description=\"Full webhook endpoint configuration\"\n    )\n\n    # Event filtering\n    event_types: List[WebhookEventType] = Field(\n        default_factory=lambda: [WebhookEventType.POLICY_VIOLATION],\n        description=\"Event types to subscribe to\",\n    )\n    severity_filter: List[str] = Field(\n        default_factory=lambda: [\"critical\", \"high\", \"medium\", \"low\", \"info\"],\n        description=\"Filter events by severity levels\",\n    )\n    resource_filters: Dict[str, List[str]] = Field(\n        default_factory=dict,\n        description=\"Filter events by resource attributes\",\n    )\n    tag_filters: List[str] = Field(\n        default_factory=list,\n        description=\"Filter events by tags\",\n    )\n\n    # Retry settings\n    max_retries: int = Field(default=3, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(\n        default=1.0, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n\n    # Rate limiting\n    rate_limit_per_minute: Optional[int] = Field(\n        None, ge=1, le=1000, description=\"Maximum deliveries per minute\"\n    )\n\n    # Metadata\n    tags: List[str] = Field(default_factory=list, description=\"Tags for categorization\")\n\n    # Multi-tenant support\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID for multi-tenant deployments\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n    @field_validator(\"severity_filter\", mode=\"before\")\n    @classmethod\n    def validate_severity_filter(cls, v: ValidatorValue) -> List[str]:\n        \"\"\"Validate severity filter values.\"\"\"\n        if v is None:\n            return [\"critical\", \"high\", \"medium\", \"low\", \"info\"]\n\n        valid_severities = {\"critical\", \"high\", \"medium\", \"low\", \"info\"}\n        if isinstance(v, str):\n            v = [v]\n\n        invalid = set(v) - valid_severities\n        if invalid:\n            raise ValueError(f\"Invalid severity values: {invalid}\")\n        return list(v)\n\n\nclass WebhookUpdateRequest(BaseModel):\n    \"\"\"Request model for updating a webhook subscription.\"\"\"\n\n    name: Optional[str] = Field(None, min_length=1, max_length=255, description=\"Display name\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Description\")\n    config: Optional[WebhookConfigCreate] = Field(\n        None, description=\"Webhook endpoint configuration\"\n    )\n    event_types: Optional[List[WebhookEventType]] = Field(\n        None, description=\"Event types to subscribe to\"\n    )\n    severity_filter: Optional[List[str]] = Field(\n        None, description=\"Filter events by severity levels\"\n    )\n    resource_filters: Optional[Dict[str, List[str]]] = Field(\n        None, description=\"Filter events by resource attributes\"\n    )\n    tag_filters: Optional[List[str]] = Field(None, description=\"Filter events by tags\")\n    max_retries: Optional[int] = Field(None, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: Optional[float] = Field(\n        None, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n    rate_limit_per_minute: Optional[int] = Field(\n        None, ge=1, le=1000, description=\"Maximum deliveries per minute\"\n    )\n    tags: Optional[List[str]] = Field(None, description=\"Tags for categorization\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n\nclass WebhookResponse(BaseModel):\n    \"\"\"Response model for webhook subscription.\"\"\"\n\n    id: str = Field(..., description=\"Unique webhook subscription ID\")\n    name: str = Field(..., description=\"Display name\")\n    description: Optional[str] = Field(None, description=\"Description\")\n    state: WebhookState = Field(..., description=\"Current subscription state\")\n    owner_id: Optional[str] = Field(None, description=\"Owner user/service ID\")\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID\")\n\n    # Endpoint config (with secrets redacted)\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    auth_type: WebhookAuthType = Field(..., description=\"Authentication type\")\n    method: str = Field(..., description=\"HTTP method\")\n\n    # Filters\n    event_types: List[WebhookEventType] = Field(..., description=\"Subscribed event types\")\n    severity_filter: List[str] = Field(..., description=\"Severity filter\")\n\n    # Retry settings\n    max_retries: int = Field(..., description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(..., description=\"Initial retry delay\")\n\n    # Rate limiting\n    rate_limit_per_minute: Optional[int] = Field(None, description=\"Rate limit\")\n\n    # Metadata\n    tags: List[str] = Field(..., description=\"Tags\")\n    created_at: datetime = Field(..., description=\"Creation timestamp\")\n    updated_at: datetime = Field(..., description=\"Last update timestamp\")\n    last_triggered_at: Optional[datetime] = Field(None, description=\"Last trigger time\")\n\n    # Statistics\n    total_deliveries: int = Field(..., description=\"Total deliveries\")\n    successful_deliveries: int = Field(..., description=\"Successful deliveries\")\n    failed_deliveries: int = Field(..., description=\"Failed deliveries\")\n    consecutive_failures: int = Field(..., description=\"Consecutive failures\")\n\n    model_config = ConfigDict(\n        from_attributes=True,\n    )\n\n    @classmethod\n    def from_subscription(cls, subscription: WebhookSubscription) -> \"WebhookResponse\":\n        \"\"\"Create response from WebhookSubscription model.\"\"\"\n        return cls(\n            id=subscription.id,\n            name=subscription.name,\n            description=subscription.description,\n            state=subscription.state,\n            owner_id=subscription.owner_id,\n            tenant_id=subscription.tenant_id,\n            url=subscription.config.url,\n            auth_type=subscription.config.auth_type,\n            method=subscription.config.method,\n            event_types=subscription.event_types,\n            severity_filter=subscription.severity_filter,\n            max_retries=subscription.max_retries,\n            retry_delay_seconds=subscription.retry_delay_seconds,\n            rate_limit_per_minute=subscription.rate_limit_per_minute,\n            tags=subscription.tags,\n            created_at=subscription.created_at,\n            updated_at=subscription.updated_at,\n            last_triggered_at=subscription.last_triggered_at,\n            total_deliveries=subscription.total_deliveries,\n            successful_deliveries=subscription.successful_deliveries,\n            failed_deliveries=subscription.failed_deliveries,\n            consecutive_failures=subscription.consecutive_failures,\n        )\n\n\nclass WebhookListResponse(BaseModel):\n    \"\"\"Response model for listing webhooks.\"\"\"\n\n    webhooks: List[WebhookResponse] = Field(..., description=\"List of webhooks\")\n    total: int = Field(..., description=\"Total number of webhooks\")\n    page: int = Field(..., description=\"Current page number\")\n    page_size: int = Field(..., description=\"Number of items per page\")\n    has_more: bool = Field(..., description=\"Whether more pages exist\")\n\n\nclass WebhookTestRequest(BaseModel):\n    \"\"\"Request model for testing a webhook.\"\"\"\n\n    event_type: WebhookEventType = Field(\n        default=WebhookEventType.SYSTEM_ALERT,\n        description=\"Event type for test event\",\n    )\n    payload: Optional[JSONDict] = Field(None, description=\"Custom test payload\")\n\n\nclass WebhookTestResponse(BaseModel):\n    \"\"\"Response model for webhook test.\"\"\"\n\n    success: bool = Field(..., description=\"Whether test delivery succeeded\")\n    delivery_id: str = Field(..., description=\"Delivery attempt ID\")\n    status_code: Optional[int] = Field(None, description=\"HTTP status code\")\n    duration_ms: int = Field(..., description=\"Delivery duration in milliseconds\")\n    error: Optional[str] = Field(None, description=\"Error message if failed\")\n\n\n# Dependency for getting webhook service (can be extended later)\ndef get_webhook_storage() -> Dict[str, WebhookSubscription]:\n    \"\"\"Get webhook subscription storage.\"\"\"\n    return _webhook_subscriptions\n\n\n# API Endpoints\n@router.post(\n    \"\",\n    response_model=WebhookResponse,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create a webhook subscription\",\n    description=\"Create a new webhook subscription to receive governance events\",\n)\nasync def create_webhook(\n    request: WebhookCreateRequest,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"\n    Create a new webhook subscription.\n\n    The webhook will start in PENDING_VERIFICATION state until the endpoint\n    is verified or manually activated.\n    \"\"\"\n    try:\n        # Build webhook config\n        if request.config:\n            config = request.config.to_webhook_config()\n        elif request.url:\n            # Use shorthand URL and auth_type\n            config = WebhookConfig(\n                url=request.url,\n                auth_type=request.auth_type or WebhookAuthType.NONE,\n            )\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Either 'url' or 'config' must be provided\",\n            )\n\n        # Create subscription\n        subscription_id = str(uuid4())\n        subscription = WebhookSubscription(\n            id=subscription_id,\n            name=request.name,\n            description=request.description,\n            state=WebhookState.PENDING_VERIFICATION,\n            config=config,\n            event_types=request.event_types,\n            severity_filter=request.severity_filter,\n            resource_filters=request.resource_filters,\n            tag_filters=request.tag_filters,\n            max_retries=request.max_retries,\n            retry_delay_seconds=request.retry_delay_seconds,\n            rate_limit_per_minute=request.rate_limit_per_minute,\n            tags=request.tags,\n            tenant_id=request.tenant_id,\n            verification_token=str(uuid4()),\n        )\n\n        # Store subscription\n        storage[subscription_id] = subscription\n\n        logger.info(f\"Created webhook subscription: {subscription_id} for URL: {config.url}\")\n\n        return WebhookResponse.from_subscription(subscription)\n\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        ) from None\n    except Exception as e:\n        logger.exception(f\"Error creating webhook: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook creation failed. Please verify your request and try again.\",\n        ) from None\n\n\n@router.get(\n    \"\",\n    response_model=WebhookListResponse,\n    summary=\"List webhook subscriptions\",\n    description=\"List all webhook subscriptions with optional filtering\",\n)\nasync def list_webhooks(\n    state: Optional[WebhookState] = Query(None, description=\"Filter by subscription state\"),\n    event_type: Optional[WebhookEventType] = Query(None, description=\"Filter by event type\"),\n    tenant_id: Optional[str] = Query(None, description=\"Filter by tenant ID\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(20, ge=1, le=100, description=\"Items per page\"),\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookListResponse:\n    \"\"\"\n    List all webhook subscriptions.\n\n    Supports filtering by state, event type, and tenant ID.\n    Results are paginated.\n    \"\"\"\n    # Filter subscriptions\n    subscriptions = list(storage.values())\n\n    if state:\n        subscriptions = [s for s in subscriptions if s.state == state]\n\n    if event_type:\n        subscriptions = [s for s in subscriptions if event_type in s.event_types]\n\n    if tenant_id:\n        subscriptions = [s for s in subscriptions if s.tenant_id == tenant_id]\n\n    # Sort by creation time (newest first)\n    subscriptions.sort(key=lambda s: s.created_at, reverse=True)\n\n    # Paginate\n    total = len(subscriptions)\n    start_idx = (page - 1) * page_size\n    end_idx = start_idx + page_size\n    page_subscriptions = subscriptions[start_idx:end_idx]\n    has_more = end_idx < total\n\n    return WebhookListResponse(\n        webhooks=[WebhookResponse.from_subscription(s) for s in page_subscriptions],\n        total=total,\n        page=page,\n        page_size=page_size,\n        has_more=has_more,\n    )\n\n\n@router.get(\n    \"/{webhook_id}\",\n    response_model=WebhookResponse,\n    summary=\"Get webhook subscription\",\n    description=\"Get a specific webhook subscription by ID\",\n)\nasync def get_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Get a webhook subscription by ID.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.put(\n    \"/{webhook_id}\",\n    response_model=WebhookResponse,\n    summary=\"Update webhook subscription\",\n    description=\"Update an existing webhook subscription\",\n)\nasync def update_webhook(\n    webhook_id: str,\n    request: WebhookUpdateRequest,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Update a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    try:\n        # Update fields if provided\n        if request.name is not None:\n            subscription.name = request.name\n        if request.description is not None:\n            subscription.description = request.description\n        if request.config is not None:\n            subscription.config = request.config.to_webhook_config()\n        if request.event_types is not None:\n            subscription.event_types = request.event_types\n        if request.severity_filter is not None:\n            subscription.severity_filter = request.severity_filter\n        if request.resource_filters is not None:\n            subscription.resource_filters = request.resource_filters\n        if request.tag_filters is not None:\n            subscription.tag_filters = request.tag_filters\n        if request.max_retries is not None:\n            subscription.max_retries = request.max_retries\n        if request.retry_delay_seconds is not None:\n            subscription.retry_delay_seconds = request.retry_delay_seconds\n        if request.rate_limit_per_minute is not None:\n            subscription.rate_limit_per_minute = request.rate_limit_per_minute\n        if request.tags is not None:\n            subscription.tags = request.tags\n\n        # Update timestamp\n        subscription.updated_at = datetime.now(timezone.utc)\n\n        logger.info(f\"Updated webhook subscription: {webhook_id}\")\n\n        return WebhookResponse.from_subscription(subscription)\n\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        ) from None\n    except Exception as e:\n        logger.exception(f\"Error updating webhook: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook update failed. Please verify your request and try again.\",\n        ) from None\n\n\n@router.delete(\n    \"/{webhook_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete webhook subscription\",\n    description=\"Delete a webhook subscription\",\n)\nasync def delete_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> None:\n    \"\"\"Delete a webhook subscription.\"\"\"\n    if webhook_id not in storage:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    del storage[webhook_id]\n    logger.info(f\"Deleted webhook subscription: {webhook_id}\")\n\n\n@router.post(\n    \"/{webhook_id}/activate\",\n    response_model=WebhookResponse,\n    summary=\"Activate webhook subscription\",\n    description=\"Activate a webhook subscription to start receiving events\",\n)\nasync def activate_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Activate a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    if subscription.state == WebhookState.ACTIVE:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook is already active\",\n        )\n\n    subscription.state = WebhookState.ACTIVE\n    subscription.updated_at = datetime.now(timezone.utc)\n    subscription.verified_at = datetime.now(timezone.utc)\n\n    logger.info(f\"Activated webhook subscription: {webhook_id}\")\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.post(\n    \"/{webhook_id}/deactivate\",\n    response_model=WebhookResponse,\n    summary=\"Deactivate webhook subscription\",\n    description=\"Deactivate a webhook subscription to stop receiving events\",\n)\nasync def deactivate_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Deactivate a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    if subscription.state == WebhookState.INACTIVE:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook is already inactive\",\n        )\n\n    subscription.state = WebhookState.INACTIVE\n    subscription.updated_at = datetime.now(timezone.utc)\n\n    logger.info(f\"Deactivated webhook subscription: {webhook_id}\")\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.post(\n    \"/{webhook_id}/test\",\n    response_model=WebhookTestResponse,\n    summary=\"Test webhook delivery\",\n    description=\"Send a test event to verify webhook endpoint\",\n)\nasync def test_webhook(\n    webhook_id: str,\n    request: Optional[WebhookTestRequest] = None,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookTestResponse:\n    \"\"\"\n    Test a webhook endpoint by sending a test event.\n\n    This will send a test event to the configured endpoint to verify\n    connectivity and authentication.\n    \"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    # For now, return a mock test response\n    # In production, this would actually send a test event using the delivery engine\n    delivery_id = str(uuid4())\n\n    # TODO: Integrate with WebhookDeliveryEngine for actual test delivery\n    logger.info(f\"Test delivery initiated for webhook {webhook_id} to {subscription.config.url}\")\n\n    return WebhookTestResponse(\n        success=True,\n        delivery_id=delivery_id,\n        status_code=200,\n        duration_ms=150,\n        error=None,\n    )\n\n\n@router.get(\n    \"/{webhook_id}/deliveries\",\n    response_model=JSONDict,\n    summary=\"Get webhook delivery history\",\n    description=\"Get delivery history for a webhook subscription\",\n)\nasync def get_webhook_deliveries(\n    webhook_id: str,\n    status_filter: Optional[WebhookDeliveryStatus] = Query(\n        None, description=\"Filter by delivery status\"\n    ),\n    limit: int = Query(50, ge=1, le=200, description=\"Maximum number of deliveries\"),\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> JSONDict:\n    \"\"\"Get delivery history for a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    # For now, return subscription statistics\n    # In production, this would query actual delivery records from database\n    return {\n        \"webhook_id\": webhook_id,\n        \"statistics\": {\n            \"total_deliveries\": subscription.total_deliveries,\n            \"successful_deliveries\": subscription.successful_deliveries,\n            \"failed_deliveries\": subscription.failed_deliveries,\n            \"consecutive_failures\": subscription.consecutive_failures,\n            \"last_triggered_at\": (\n                subscription.last_triggered_at.isoformat()\n                if subscription.last_triggered_at\n                else None\n            ),\n        },\n        \"deliveries\": [],  # Would be populated from database\n    }\n",
        "timestamp": "2026-01-04T05:35:51.134105"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "060-document-error-codes-and-troubleshooting-for-commo",
        "description": "The codebase has 13 TODO/FIXME comments across critical files including webhooks.py, approval_chain_engine.py, and config_validator.py. Additionally, there's no centralized documentation for error codes, failure modes, or troubleshooting guides. Users encountering errors have no reference for resolution.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nWebhooks API endpoints for managing webhook subscriptions.\n\nProvides CRUD operations for webhook endpoint configuration,\ndelivery status monitoring, and subscription management.\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional\nfrom uuid import uuid4\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom pydantic import BaseModel, ConfigDict, Field, SecretStr, field_validator\n\nfrom ..types import JSONDict, ValidatorValue\nfrom ..webhooks.models import (\n    WebhookAuthType,\n    WebhookConfig,\n    WebhookDeliveryStatus,\n    WebhookEventType,\n    WebhookSignatureAlgorithm,\n    WebhookState,\n    WebhookSubscription,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create router\nrouter = APIRouter(prefix=\"/api/webhooks\", tags=[\"Webhooks\"])\n\n\n# In-memory storage for webhook subscriptions (for development)\n# In production, this would be replaced with a database repository\n_webhook_subscriptions: Dict[str, WebhookSubscription] = {}\n\n\n# Request/Response Models\nclass WebhookConfigCreate(BaseModel):\n    \"\"\"Configuration for a webhook endpoint.\"\"\"\n\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    method: str = Field(default=\"POST\", description=\"HTTP method for webhook delivery\")\n    auth_type: WebhookAuthType = Field(\n        default=WebhookAuthType.NONE, description=\"Authentication type\"\n    )\n    auth_header: str = Field(default=\"Authorization\", description=\"Header name for authentication\")\n    auth_value: Optional[str] = Field(\n        None, description=\"Authentication value (token, API key, etc.)\"\n    )\n    hmac_secret: Optional[str] = Field(None, description=\"HMAC secret for signature verification\")\n    hmac_header: str = Field(default=\"X-Webhook-Signature\", description=\"Header for HMAC signature\")\n    hmac_algorithm: WebhookSignatureAlgorithm = Field(\n        default=WebhookSignatureAlgorithm.SHA256, description=\"HMAC algorithm\"\n    )\n    content_type: str = Field(default=\"application/json\", description=\"Content-Type header value\")\n    custom_headers: Dict[str, str] = Field(\n        default_factory=dict, description=\"Additional headers to include\"\n    )\n    timeout_seconds: float = Field(\n        default=30.0, ge=1.0, le=120.0, description=\"Request timeout in seconds\"\n    )\n    verify_ssl: bool = Field(default=True, description=\"Verify SSL certificates\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n    @field_validator(\"url\", mode=\"before\")\n    @classmethod\n    def validate_url(cls, v: str) -> str:\n        \"\"\"Validate webhook URL format.\"\"\"\n        if not v.startswith((\"http://\", \"https://\")):\n            raise ValueError(\"Webhook URL must start with http:// or https://\")\n        return v.rstrip(\"/\")\n\n    def to_webhook_config(self) -> WebhookConfig:\n        \"\"\"Convert to WebhookConfig model with SecretStr handling.\"\"\"\n        return WebhookConfig(\n            url=self.url,\n            method=self.method,\n            auth_type=self.auth_type,\n            auth_header=self.auth_header,\n            auth_value=SecretStr(self.auth_value) if self.auth_value else None,\n            hmac_secret=SecretStr(self.hmac_secret) if self.hmac_secret else None,\n            hmac_header=self.hmac_header,\n            hmac_algorithm=self.hmac_algorithm,\n            content_type=self.content_type,\n            custom_headers=self.custom_headers,\n            timeout_seconds=self.timeout_seconds,\n            verify_ssl=self.verify_ssl,\n        )\n\n\nclass WebhookCreateRequest(BaseModel):\n    \"\"\"Request model for creating a webhook subscription.\"\"\"\n\n    name: str = Field(\n        ..., min_length=1, max_length=255, description=\"Display name for the subscription\"\n    )\n    description: Optional[str] = Field(\n        None, max_length=1000, description=\"Description of this webhook\"\n    )\n\n    # Endpoint configuration - can be inline or via config object\n    url: Optional[str] = Field(None, description=\"Webhook endpoint URL (shorthand)\")\n    auth_type: Optional[WebhookAuthType] = Field(\n        None, description=\"Authentication type (shorthand)\"\n    )\n    config: Optional[WebhookConfigCreate] = Field(\n        None, description=\"Full webhook endpoint configuration\"\n    )\n\n    # Event filtering\n    event_types: List[WebhookEventType] = Field(\n        default_factory=lambda: [WebhookEventType.POLICY_VIOLATION],\n        description=\"Event types to subscribe to\",\n    )\n    severity_filter: List[str] = Field(\n        default_factory=lambda: [\"critical\", \"high\", \"medium\", \"low\", \"info\"],\n        description=\"Filter events by severity levels\",\n    )\n    resource_filters: Dict[str, List[str]] = Field(\n        default_factory=dict,\n        description=\"Filter events by resource attributes\",\n    )\n    tag_filters: List[str] = Field(\n        default_factory=list,\n        description=\"Filter events by tags\",\n    )\n\n    # Retry settings\n    max_retries: int = Field(default=3, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(\n        default=1.0, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n\n    # Rate limiting\n    rate_limit_per_minute: Optional[int] = Field(\n        None, ge=1, le=1000, description=\"Maximum deliveries per minute\"\n    )\n\n    # Metadata\n    tags: List[str] = Field(default_factory=list, description=\"Tags for categorization\")\n\n    # Multi-tenant support\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID for multi-tenant deployments\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n    @field_validator(\"severity_filter\", mode=\"before\")\n    @classmethod\n    def validate_severity_filter(cls, v: ValidatorValue) -> List[str]:\n        \"\"\"Validate severity filter values.\"\"\"\n        if v is None:\n            return [\"critical\", \"high\", \"medium\", \"low\", \"info\"]\n\n        valid_severities = {\"critical\", \"high\", \"medium\", \"low\", \"info\"}\n        if isinstance(v, str):\n            v = [v]\n\n        invalid = set(v) - valid_severities\n        if invalid:\n            raise ValueError(f\"Invalid severity values: {invalid}\")\n        return list(v)\n\n\nclass WebhookUpdateRequest(BaseModel):\n    \"\"\"Request model for updating a webhook subscription.\"\"\"\n\n    name: Optional[str] = Field(None, min_length=1, max_length=255, description=\"Display name\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"Description\")\n    config: Optional[WebhookConfigCreate] = Field(\n        None, description=\"Webhook endpoint configuration\"\n    )\n    event_types: Optional[List[WebhookEventType]] = Field(\n        None, description=\"Event types to subscribe to\"\n    )\n    severity_filter: Optional[List[str]] = Field(\n        None, description=\"Filter events by severity levels\"\n    )\n    resource_filters: Optional[Dict[str, List[str]]] = Field(\n        None, description=\"Filter events by resource attributes\"\n    )\n    tag_filters: Optional[List[str]] = Field(None, description=\"Filter events by tags\")\n    max_retries: Optional[int] = Field(None, ge=0, le=10, description=\"Maximum delivery attempts\")\n    retry_delay_seconds: Optional[float] = Field(\n        None, ge=0.5, le=60, description=\"Initial retry delay\"\n    )\n    rate_limit_per_minute: Optional[int] = Field(\n        None, ge=1, le=1000, description=\"Maximum deliveries per minute\"\n    )\n    tags: Optional[List[str]] = Field(None, description=\"Tags for categorization\")\n\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n    )\n\n\nclass WebhookResponse(BaseModel):\n    \"\"\"Response model for webhook subscription.\"\"\"\n\n    id: str = Field(..., description=\"Unique webhook subscription ID\")\n    name: str = Field(..., description=\"Display name\")\n    description: Optional[str] = Field(None, description=\"Description\")\n    state: WebhookState = Field(..., description=\"Current subscription state\")\n    owner_id: Optional[str] = Field(None, description=\"Owner user/service ID\")\n    tenant_id: Optional[str] = Field(None, description=\"Tenant ID\")\n\n    # Endpoint config (with secrets redacted)\n    url: str = Field(..., description=\"Webhook endpoint URL\")\n    auth_type: WebhookAuthType = Field(..., description=\"Authentication type\")\n    method: str = Field(..., description=\"HTTP method\")\n\n    # Filters\n    event_types: List[WebhookEventType] = Field(..., description=\"Subscribed event types\")\n    severity_filter: List[str] = Field(..., description=\"Severity filter\")\n\n    # Retry settings\n    max_retries: int = Field(..., description=\"Maximum delivery attempts\")\n    retry_delay_seconds: float = Field(..., description=\"Initial retry delay\")\n\n    # Rate limiting\n    rate_limit_per_minute: Optional[int] = Field(None, description=\"Rate limit\")\n\n    # Metadata\n    tags: List[str] = Field(..., description=\"Tags\")\n    created_at: datetime = Field(..., description=\"Creation timestamp\")\n    updated_at: datetime = Field(..., description=\"Last update timestamp\")\n    last_triggered_at: Optional[datetime] = Field(None, description=\"Last trigger time\")\n\n    # Statistics\n    total_deliveries: int = Field(..., description=\"Total deliveries\")\n    successful_deliveries: int = Field(..., description=\"Successful deliveries\")\n    failed_deliveries: int = Field(..., description=\"Failed deliveries\")\n    consecutive_failures: int = Field(..., description=\"Consecutive failures\")\n\n    model_config = ConfigDict(\n        from_attributes=True,\n    )\n\n    @classmethod\n    def from_subscription(cls, subscription: WebhookSubscription) -> \"WebhookResponse\":\n        \"\"\"Create response from WebhookSubscription model.\"\"\"\n        return cls(\n            id=subscription.id,\n            name=subscription.name,\n            description=subscription.description,\n            state=subscription.state,\n            owner_id=subscription.owner_id,\n            tenant_id=subscription.tenant_id,\n            url=subscription.config.url,\n            auth_type=subscription.config.auth_type,\n            method=subscription.config.method,\n            event_types=subscription.event_types,\n            severity_filter=subscription.severity_filter,\n            max_retries=subscription.max_retries,\n            retry_delay_seconds=subscription.retry_delay_seconds,\n            rate_limit_per_minute=subscription.rate_limit_per_minute,\n            tags=subscription.tags,\n            created_at=subscription.created_at,\n            updated_at=subscription.updated_at,\n            last_triggered_at=subscription.last_triggered_at,\n            total_deliveries=subscription.total_deliveries,\n            successful_deliveries=subscription.successful_deliveries,\n            failed_deliveries=subscription.failed_deliveries,\n            consecutive_failures=subscription.consecutive_failures,\n        )\n\n\nclass WebhookListResponse(BaseModel):\n    \"\"\"Response model for listing webhooks.\"\"\"\n\n    webhooks: List[WebhookResponse] = Field(..., description=\"List of webhooks\")\n    total: int = Field(..., description=\"Total number of webhooks\")\n    page: int = Field(..., description=\"Current page number\")\n    page_size: int = Field(..., description=\"Number of items per page\")\n    has_more: bool = Field(..., description=\"Whether more pages exist\")\n\n\nclass WebhookTestRequest(BaseModel):\n    \"\"\"Request model for testing a webhook.\"\"\"\n\n    event_type: WebhookEventType = Field(\n        default=WebhookEventType.SYSTEM_ALERT,\n        description=\"Event type for test event\",\n    )\n    payload: Optional[JSONDict] = Field(None, description=\"Custom test payload\")\n\n\nclass WebhookTestResponse(BaseModel):\n    \"\"\"Response model for webhook test.\"\"\"\n\n    success: bool = Field(..., description=\"Whether test delivery succeeded\")\n    delivery_id: str = Field(..., description=\"Delivery attempt ID\")\n    status_code: Optional[int] = Field(None, description=\"HTTP status code\")\n    duration_ms: int = Field(..., description=\"Delivery duration in milliseconds\")\n    error: Optional[str] = Field(None, description=\"Error message if failed\")\n\n\n# Dependency for getting webhook service (can be extended later)\ndef get_webhook_storage() -> Dict[str, WebhookSubscription]:\n    \"\"\"Get webhook subscription storage.\"\"\"\n    return _webhook_subscriptions\n\n\n# API Endpoints\n@router.post(\n    \"\",\n    response_model=WebhookResponse,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create a webhook subscription\",\n    description=\"Create a new webhook subscription to receive governance events\",\n)\nasync def create_webhook(\n    request: WebhookCreateRequest,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"\n    Create a new webhook subscription.\n\n    The webhook will start in PENDING_VERIFICATION state until the endpoint\n    is verified or manually activated.\n    \"\"\"\n    try:\n        # Build webhook config\n        if request.config:\n            config = request.config.to_webhook_config()\n        elif request.url:\n            # Use shorthand URL and auth_type\n            config = WebhookConfig(\n                url=request.url,\n                auth_type=request.auth_type or WebhookAuthType.NONE,\n            )\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Either 'url' or 'config' must be provided\",\n            )\n\n        # Create subscription\n        subscription_id = str(uuid4())\n        subscription = WebhookSubscription(\n            id=subscription_id,\n            name=request.name,\n            description=request.description,\n            state=WebhookState.PENDING_VERIFICATION,\n            config=config,\n            event_types=request.event_types,\n            severity_filter=request.severity_filter,\n            resource_filters=request.resource_filters,\n            tag_filters=request.tag_filters,\n            max_retries=request.max_retries,\n            retry_delay_seconds=request.retry_delay_seconds,\n            rate_limit_per_minute=request.rate_limit_per_minute,\n            tags=request.tags,\n            tenant_id=request.tenant_id,\n            verification_token=str(uuid4()),\n        )\n\n        # Store subscription\n        storage[subscription_id] = subscription\n\n        logger.info(f\"Created webhook subscription: {subscription_id} for URL: {config.url}\")\n\n        return WebhookResponse.from_subscription(subscription)\n\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        ) from None\n    except Exception as e:\n        logger.exception(f\"Error creating webhook: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook creation failed. Please verify your request and try again.\",\n        ) from None\n\n\n@router.get(\n    \"\",\n    response_model=WebhookListResponse,\n    summary=\"List webhook subscriptions\",\n    description=\"List all webhook subscriptions with optional filtering\",\n)\nasync def list_webhooks(\n    state: Optional[WebhookState] = Query(None, description=\"Filter by subscription state\"),\n    event_type: Optional[WebhookEventType] = Query(None, description=\"Filter by event type\"),\n    tenant_id: Optional[str] = Query(None, description=\"Filter by tenant ID\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(20, ge=1, le=100, description=\"Items per page\"),\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookListResponse:\n    \"\"\"\n    List all webhook subscriptions.\n\n    Supports filtering by state, event type, and tenant ID.\n    Results are paginated.\n    \"\"\"\n    # Filter subscriptions\n    subscriptions = list(storage.values())\n\n    if state:\n        subscriptions = [s for s in subscriptions if s.state == state]\n\n    if event_type:\n        subscriptions = [s for s in subscriptions if event_type in s.event_types]\n\n    if tenant_id:\n        subscriptions = [s for s in subscriptions if s.tenant_id == tenant_id]\n\n    # Sort by creation time (newest first)\n    subscriptions.sort(key=lambda s: s.created_at, reverse=True)\n\n    # Paginate\n    total = len(subscriptions)\n    start_idx = (page - 1) * page_size\n    end_idx = start_idx + page_size\n    page_subscriptions = subscriptions[start_idx:end_idx]\n    has_more = end_idx < total\n\n    return WebhookListResponse(\n        webhooks=[WebhookResponse.from_subscription(s) for s in page_subscriptions],\n        total=total,\n        page=page,\n        page_size=page_size,\n        has_more=has_more,\n    )\n\n\n@router.get(\n    \"/{webhook_id}\",\n    response_model=WebhookResponse,\n    summary=\"Get webhook subscription\",\n    description=\"Get a specific webhook subscription by ID\",\n)\nasync def get_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Get a webhook subscription by ID.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.put(\n    \"/{webhook_id}\",\n    response_model=WebhookResponse,\n    summary=\"Update webhook subscription\",\n    description=\"Update an existing webhook subscription\",\n)\nasync def update_webhook(\n    webhook_id: str,\n    request: WebhookUpdateRequest,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Update a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    try:\n        # Update fields if provided\n        if request.name is not None:\n            subscription.name = request.name\n        if request.description is not None:\n            subscription.description = request.description\n        if request.config is not None:\n            subscription.config = request.config.to_webhook_config()\n        if request.event_types is not None:\n            subscription.event_types = request.event_types\n        if request.severity_filter is not None:\n            subscription.severity_filter = request.severity_filter\n        if request.resource_filters is not None:\n            subscription.resource_filters = request.resource_filters\n        if request.tag_filters is not None:\n            subscription.tag_filters = request.tag_filters\n        if request.max_retries is not None:\n            subscription.max_retries = request.max_retries\n        if request.retry_delay_seconds is not None:\n            subscription.retry_delay_seconds = request.retry_delay_seconds\n        if request.rate_limit_per_minute is not None:\n            subscription.rate_limit_per_minute = request.rate_limit_per_minute\n        if request.tags is not None:\n            subscription.tags = request.tags\n\n        # Update timestamp\n        subscription.updated_at = datetime.now(timezone.utc)\n\n        logger.info(f\"Updated webhook subscription: {webhook_id}\")\n\n        return WebhookResponse.from_subscription(subscription)\n\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        ) from None\n    except Exception as e:\n        logger.exception(f\"Error updating webhook: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook update failed. Please verify your request and try again.\",\n        ) from None\n\n\n@router.delete(\n    \"/{webhook_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete webhook subscription\",\n    description=\"Delete a webhook subscription\",\n)\nasync def delete_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> None:\n    \"\"\"Delete a webhook subscription.\"\"\"\n    if webhook_id not in storage:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    del storage[webhook_id]\n    logger.info(f\"Deleted webhook subscription: {webhook_id}\")\n\n\n@router.post(\n    \"/{webhook_id}/activate\",\n    response_model=WebhookResponse,\n    summary=\"Activate webhook subscription\",\n    description=\"Activate a webhook subscription to start receiving events\",\n)\nasync def activate_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Activate a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    if subscription.state == WebhookState.ACTIVE:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook is already active\",\n        )\n\n    subscription.state = WebhookState.ACTIVE\n    subscription.updated_at = datetime.now(timezone.utc)\n    subscription.verified_at = datetime.now(timezone.utc)\n\n    logger.info(f\"Activated webhook subscription: {webhook_id}\")\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.post(\n    \"/{webhook_id}/deactivate\",\n    response_model=WebhookResponse,\n    summary=\"Deactivate webhook subscription\",\n    description=\"Deactivate a webhook subscription to stop receiving events\",\n)\nasync def deactivate_webhook(\n    webhook_id: str,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookResponse:\n    \"\"\"Deactivate a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    if subscription.state == WebhookState.INACTIVE:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Webhook is already inactive\",\n        )\n\n    subscription.state = WebhookState.INACTIVE\n    subscription.updated_at = datetime.now(timezone.utc)\n\n    logger.info(f\"Deactivated webhook subscription: {webhook_id}\")\n\n    return WebhookResponse.from_subscription(subscription)\n\n\n@router.post(\n    \"/{webhook_id}/test\",\n    response_model=WebhookTestResponse,\n    summary=\"Test webhook delivery\",\n    description=\"Send a test event to verify webhook endpoint\",\n)\nasync def test_webhook(\n    webhook_id: str,\n    request: Optional[WebhookTestRequest] = None,\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> WebhookTestResponse:\n    \"\"\"\n    Test a webhook endpoint by sending a test event.\n\n    This will send a test event to the configured endpoint to verify\n    connectivity and authentication.\n    \"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    # For now, return a mock test response\n    # In production, this would actually send a test event using the delivery engine\n    delivery_id = str(uuid4())\n\n    # TODO: Integrate with WebhookDeliveryEngine for actual test delivery\n    logger.info(f\"Test delivery initiated for webhook {webhook_id} to {subscription.config.url}\")\n\n    return WebhookTestResponse(\n        success=True,\n        delivery_id=delivery_id,\n        status_code=200,\n        duration_ms=150,\n        error=None,\n    )\n\n\n@router.get(\n    \"/{webhook_id}/deliveries\",\n    response_model=JSONDict,\n    summary=\"Get webhook delivery history\",\n    description=\"Get delivery history for a webhook subscription\",\n)\nasync def get_webhook_deliveries(\n    webhook_id: str,\n    status_filter: Optional[WebhookDeliveryStatus] = Query(\n        None, description=\"Filter by delivery status\"\n    ),\n    limit: int = Query(50, ge=1, le=200, description=\"Maximum number of deliveries\"),\n    storage: Dict[str, WebhookSubscription] = Depends(get_webhook_storage),\n) -> JSONDict:\n    \"\"\"Get delivery history for a webhook subscription.\"\"\"\n    subscription = storage.get(webhook_id)\n    if not subscription:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Webhook subscription not found: {webhook_id}\",\n        )\n\n    # For now, return subscription statistics\n    # In production, this would query actual delivery records from database\n    return {\n        \"webhook_id\": webhook_id,\n        \"statistics\": {\n            \"total_deliveries\": subscription.total_deliveries,\n            \"successful_deliveries\": subscription.successful_deliveries,\n            \"failed_deliveries\": subscription.failed_deliveries,\n            \"consecutive_failures\": subscription.consecutive_failures,\n            \"last_triggered_at\": (\n                subscription.last_triggered_at.isoformat()\n                if subscription.last_triggered_at\n                else None\n            ),\n        },\n        \"deliveries\": [],  # Would be populated from database\n    }\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), acgs2-core/breakthrough (79 occurrences), and acgs2-core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:08.576365",
  "last_updated": "2026-01-04T05:35:59.163321"
}