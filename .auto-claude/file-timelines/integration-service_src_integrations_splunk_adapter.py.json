{
  "file_path": "integration-service/src/integrations/splunk_adapter.py",
  "main_branch_history": [],
  "task_views": {
    "037-add-batch-event-processing-to-baseintegration": {
      "task_id": "037-add-batch-event-processing-to-baseintegration",
      "branch_point": {
        "commit_hash": "2fb699cec90aaf3419af3108057ed29ae4213e1b",
        "content": "\"\"\"\nSplunk Integration Adapter\n\nProvides integration with Splunk SIEM using the HTTP Event Collector (HEC)\nfor real-time governance event ingestion.\n\nFeatures:\n- HEC token authentication\n- High-performance batch event processing (newline-delimited JSON)\n- Single event and batch API support\n- Automatic event formatting for Splunk\n- Index validation\n- Rate limit handling with Retry-After support\n- SSL certificate verification options\n- Configurable batch size (default 100, max 1000 events per batch)\n\nBatch Processing:\nThis adapter implements native batch processing using Splunk HEC's newline-delimited\nJSON format. Batches are sent as a single HTTP request, reducing API overhead and\nimproving throughput for high-volume event ingestion. Use send_events_batch() for\noptimal performance when sending multiple events.\n\nPerformance:\n- Batch processing can reduce API calls by up to 100x (for batch_size=100)\n- All-or-nothing batch semantics: entire batch succeeds or fails together\n- Automatic retry with exponential backoff for transient failures\n\"\"\"\n\nimport json\nimport logging\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom pydantic import Field, SecretStr, field_validator, model_validator\n\n# Import exceptions from centralized exceptions module\nfrom exceptions.auth import AuthenticationError\nfrom exceptions.delivery import DeliveryError\nfrom exceptions.integration import RateLimitError\n\n# Import base integration classes and models\nfrom .base import (\n    BaseIntegration,\n    EventSeverity,\n    IntegrationCredentials,\n    IntegrationEvent,\n    IntegrationResult,\n    IntegrationType,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass SplunkDeploymentType(str, Enum):\n    \"\"\"Splunk deployment types with different auth requirements\"\"\"\n\n    ON_PREMISE = \"on_premise\"\n    CLOUD = \"cloud\"\n\n\nclass SplunkCredentials(IntegrationCredentials):\n    \"\"\"\n    Credentials for Splunk HEC integration.\n\n    Supports both on-premise and Splunk Cloud deployments with HEC token\n    authentication. Includes configuration for index, sourcetype, and\n    SSL verification.\n    \"\"\"\n\n    integration_type: IntegrationType = Field(\n        default=IntegrationType.SIEM,\n        description=\"Integration type (always SIEM for Splunk)\",\n    )\n\n    # Splunk-specific fields\n    hec_url: str = Field(\n        ...,\n        description=\"Splunk HEC endpoint URL (e.g., https://splunk.example.com:8088)\",\n    )\n    hec_token: SecretStr = Field(\n        ...,\n        description=\"Splunk HEC token for authentication\",\n    )\n    index: str = Field(\n        default=\"main\",\n        description=\"Target Splunk index for governance events\",\n    )\n    source: str = Field(\n        default=\"acgs2\",\n        description=\"Source identifier for events\",\n    )\n    sourcetype: str = Field(\n        default=\"acgs2:governance\",\n        description=\"Sourcetype for governance events\",\n    )\n\n    # Deployment configuration\n    deployment_type: SplunkDeploymentType = Field(\n        default=SplunkDeploymentType.ON_PREMISE,\n        description=\"Splunk deployment type (on_premise or cloud)\",\n    )\n\n    # SSL/TLS settings\n    verify_ssl: bool = Field(\n        default=True,\n        description=\"Whether to verify SSL certificates\",\n    )\n    ssl_cert_path: Optional[str] = Field(\n        None,\n        description=\"Path to custom CA certificate bundle\",\n    )\n\n    # Performance settings\n    batch_size: int = Field(\n        default=100,\n        ge=1,\n        le=1000,\n        description=\"Maximum events per batch submission\",\n    )\n    batch_timeout_seconds: float = Field(\n        default=5.0,\n        ge=0.1,\n        le=60.0,\n        description=\"Maximum seconds to wait before sending incomplete batch\",\n    )\n\n    @field_validator(\"hec_url\")\n    @classmethod\n    def validate_hec_url(cls, v: str) -> str:\n        \"\"\"Validate HEC URL format\"\"\"\n        if not v:\n            raise ValueError(\"HEC URL is required\")\n        if not v.startswith((\"http://\", \"https://\")):\n            raise ValueError(\"HEC URL must start with http:// or https://\")\n        # Remove trailing slash\n        return v.rstrip(\"/\")\n\n    @field_validator(\"index\")\n    @classmethod\n    def validate_index(cls, v: str) -> str:\n        \"\"\"Validate index name\"\"\"\n        if not v:\n            raise ValueError(\"Index name is required\")\n        # Splunk index naming rules\n        if not v.replace(\"_\", \"\").replace(\"-\", \"\").isalnum():\n            raise ValueError(\"Index name must be alphanumeric (with underscores/hyphens)\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_ssl_settings(self) -> \"SplunkCredentials\":\n        \"\"\"Validate SSL settings are consistent\"\"\"\n        if not self.verify_ssl and self.deployment_type == SplunkDeploymentType.CLOUD:\n            logger.warning(\n                \"SSL verification is disabled for Splunk Cloud deployment. \"\n                \"This is not recommended for production.\"\n            )\n        return self\n\n\nclass SplunkAdapter(BaseIntegration):\n    \"\"\"\n    Splunk SIEM integration adapter using HTTP Event Collector (HEC).\n\n    This adapter sends governance events to Splunk via the HEC endpoint,\n    supporting both single event submission and high-performance batch processing.\n    Implements native Splunk HEC batch format (newline-delimited JSON) for\n    optimal throughput.\n\n    Single Event Usage:\n        credentials = SplunkCredentials(\n            integration_name=\"Production Splunk\",\n            hec_url=\"https://splunk.example.com:8088\",\n            hec_token=SecretStr(\"your-hec-token\"),\n            index=\"governance_events\",\n        )\n        adapter = SplunkAdapter(credentials)\n        await adapter.authenticate()\n        result = await adapter.send_event(event)\n\n    Batch Processing Usage:\n        # Send multiple events in a single API call\n        events = [event1, event2, event3]\n        results = await adapter.send_events_batch(events)\n\n        # Check batch metrics\n        metrics = adapter.metrics\n        print(f\"Batches sent: {metrics['batches_sent']}\")\n        print(f\"Events via batch: {metrics['batch_events_total']}\")\n\n    Features:\n        - Native HEC batch processing (newline-delimited JSON format)\n        - All-or-nothing batch semantics for data consistency\n        - Rate limit handling with Retry-After header support\n        - Index existence validation\n        - SSL certificate verification\n        - Comprehensive error reporting with Splunk-specific error codes\n        - Configurable batch size (default 100, max 1000)\n        - Automatic retry with exponential backoff\n\n    Batch Performance:\n        - Reduces API calls by batch_size factor (e.g., 100x for batch_size=100)\n        - Lower latency for high-volume event ingestion\n        - Maintains event order within batches\n        - Single authentication check per batch (vs per-event)\n\n    Note:\n        This adapter overrides _do_send_events_batch() to provide native Splunk\n        HEC batch support. The base class handles authentication, retry logic,\n        and metrics tracking.\n    \"\"\"\n\n    # Splunk-specific constants\n    HEC_ENDPOINT = \"/services/collector/event\"\n    HEC_HEALTH_ENDPOINT = \"/services/collector/health\"\n    HEC_ACK_ENDPOINT = \"/services/collector/ack\"\n\n    # Severity mapping from ACGS-2 to Splunk\n    SEVERITY_MAP: Dict[EventSeverity, int] = {\n        EventSeverity.CRITICAL: 1,\n        EventSeverity.HIGH: 2,\n        EventSeverity.MEDIUM: 3,\n        EventSeverity.LOW: 4,\n        EventSeverity.INFO: 5,\n    }\n\n    def __init__(\n        self,\n        credentials: SplunkCredentials,\n        max_retries: int = BaseIntegration.DEFAULT_MAX_RETRIES,\n        timeout: float = BaseIntegration.DEFAULT_TIMEOUT,\n    ):\n        \"\"\"\n        Initialize Splunk adapter.\n\n        Args:\n            credentials: Splunk HEC credentials and configuration\n            max_retries: Maximum retry attempts for failed operations\n            timeout: HTTP request timeout in seconds\n        \"\"\"\n        super().__init__(credentials, max_retries, timeout)\n        self._splunk_credentials = credentials\n        self._event_batch: List[Dict[str, Any]] = []\n        self._batch_start_time: Optional[datetime] = None\n\n    @property\n    def splunk_credentials(self) -> SplunkCredentials:\n        \"\"\"Get typed Splunk credentials\"\"\"\n        return self._splunk_credentials\n\n    async def get_http_client(self) -> httpx.AsyncClient:\n        \"\"\"Get or create HTTP client with Splunk-specific configuration\"\"\"\n        if self._http_client is None or self._http_client.is_closed:\n            verify = self.splunk_credentials.verify_ssl\n            if self.splunk_credentials.ssl_cert_path:\n                verify = self.splunk_credentials.ssl_cert_path\n\n            self._http_client = httpx.AsyncClient(\n                timeout=self.timeout,\n                follow_redirects=True,\n                verify=verify,\n            )\n        return self._http_client\n\n    def _get_hec_headers(self) -> Dict[str, str]:\n        \"\"\"Get HEC request headers with authentication\"\"\"\n        return {\n            \"Authorization\": f\"Splunk {self.splunk_credentials.hec_token.get_secret_value()}\",\n            \"Content-Type\": \"application/json\",\n            \"X-Splunk-Request-Channel\": self.credentials.integration_id,\n        }\n\n    async def _do_authenticate(self) -> IntegrationResult:\n        \"\"\"\n        Authenticate with Splunk HEC endpoint.\n\n        Verifies the HEC token is valid by checking the health endpoint.\n        This does not fully validate write permissions or index access.\n\n        Returns:\n            IntegrationResult indicating authentication success/failure\n        \"\"\"\n        logger.debug(f\"Authenticating with Splunk HEC at {self.splunk_credentials.hec_url}\")\n\n        try:\n            client = await self.get_http_client()\n            health_url = f\"{self.splunk_credentials.hec_url}{self.HEC_HEALTH_ENDPOINT}\"\n\n            response = await client.get(\n                health_url,\n                headers=self._get_hec_headers(),\n            )\n\n            if response.status_code == 200:\n                logger.info(f\"Splunk HEC authentication successful for '{self.name}'\")\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                )\n            elif response.status_code == 400:\n                # HEC returns 400 for invalid token format\n                error_msg = \"Invalid HEC token format\"\n                logger.error(f\"Splunk authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"INVALID_TOKEN_FORMAT\",\n                    error_message=error_msg,\n                )\n            elif response.status_code == 401:\n                error_msg = \"HEC token authentication failed - token may be invalid or disabled\"\n                logger.error(f\"Splunk authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"AUTH_FAILED\",\n                    error_message=error_msg,\n                )\n            elif response.status_code == 403:\n                error_msg = \"HEC token lacks required permissions\"\n                logger.error(f\"Splunk authentication failed: {error_msg}\")\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_code=\"INSUFFICIENT_PERMISSIONS\",\n                    error_message=error_msg,\n                )\n            else:\n                error_msg = f\"Unexpected response from HEC health check: {response.status_code}\"\n                logger.warning(f\"Splunk authentication: {error_msg}\")\n                # Some Splunk configurations don't expose health endpoint\n                # Try to authenticate anyway\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"authenticate\",\n                    error_message=(\n                        f\"Health check returned {response.status_code}, proceeding anyway\"\n                    ),\n                )\n\n        except httpx.TimeoutException as e:\n            error_msg = f\"Connection timed out: {str(e)}\"\n            logger.error(f\"Splunk authentication timeout: {error_msg}\")\n            raise AuthenticationError(error_msg, self.name) from e\n\n        except httpx.NetworkError as e:\n            error_msg = f\"Network error: {str(e)}\"\n            logger.error(f\"Splunk authentication network error: {error_msg}\")\n            raise AuthenticationError(error_msg, self.name) from e\n\n        except Exception as e:\n            error_msg = f\"Unexpected error during authentication: {str(e)}\"\n            logger.error(f\"Splunk authentication error: {error_msg}\")\n            raise AuthenticationError(error_msg, self.name) from e\n\n    async def _do_validate(self) -> IntegrationResult:\n        \"\"\"\n        Validate Splunk configuration and prerequisites.\n\n        Checks:\n        - HEC endpoint is accessible\n        - Token has write permissions\n        - Target index exists and is writable\n        - Connection parameters are valid\n\n        Returns:\n            IntegrationResult with validation status and any issues found\n        \"\"\"\n        logger.debug(f\"Validating Splunk integration '{self.name}'\")\n\n        validation_issues: List[str] = []\n\n        try:\n            client = await self.get_http_client()\n\n            # Test 1: Send a test event to validate write access\n            test_event = {\n                \"event\": {\n                    \"type\": \"validation_test\",\n                    \"message\": \"ACGS-2 integration validation test\",\n                    \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                },\n                \"index\": self.splunk_credentials.index,\n                \"source\": self.splunk_credentials.source,\n                \"sourcetype\": self.splunk_credentials.sourcetype,\n                \"time\": datetime.now(timezone.utc).timestamp(),\n            }\n\n            event_url = f\"{self.splunk_credentials.hec_url}{self.HEC_ENDPOINT}\"\n\n            response = await client.post(\n                event_url,\n                headers=self._get_hec_headers(),\n                json=test_event,\n            )\n\n            response_data = {}\n            try:\n                response_data = response.json()\n            except json.JSONDecodeError:\n                pass\n\n            if response.status_code == 200:\n                # Check Splunk response for success\n                if response_data.get(\"code\") == 0:\n                    logger.info(f\"Splunk validation successful for '{self.name}'\")\n                    return IntegrationResult(\n                        success=True,\n                        integration_name=self.name,\n                        operation=\"validate\",\n                        external_id=str(response_data.get(\"ackId\")),\n                    )\n                else:\n                    error_msg = response_data.get(\"text\", \"Unknown validation error\")\n                    validation_issues.append(f\"HEC response error: {error_msg}\")\n\n            elif response.status_code == 400:\n                # Parse Splunk error response\n                error_text = response_data.get(\"text\", \"Bad request\")\n                error_code = response_data.get(\"code\", 0)\n\n                if error_code == 7:\n                    validation_issues.append(\n                        f\"Index '{self.splunk_credentials.index}' does not exist \"\n                        \"or HEC token does not have access to it\"\n                    )\n                elif error_code == 6:\n                    validation_issues.append(\"Invalid event data format\")\n                else:\n                    validation_issues.append(f\"HEC error: {error_text}\")\n\n            elif response.status_code == 401:\n                validation_issues.append(\"HEC token authentication failed\")\n\n            elif response.status_code == 403:\n                validation_issues.append(\n                    f\"HEC token lacks permission to write to index \"\n                    f\"'{self.splunk_credentials.index}'\"\n                )\n\n            elif response.status_code == 503:\n                validation_issues.append(\"Splunk HEC is temporarily unavailable\")\n\n            else:\n                validation_issues.append(f\"Unexpected response: HTTP {response.status_code}\")\n\n        except httpx.TimeoutException:\n            validation_issues.append(\"Connection timed out\")\n\n        except httpx.NetworkError as e:\n            validation_issues.append(f\"Network error: {str(e)}\")\n\n        except Exception as e:\n            validation_issues.append(f\"Validation error: {str(e)}\")\n\n        if validation_issues:\n            error_msg = \"; \".join(validation_issues)\n            logger.warning(f\"Splunk validation failed for '{self.name}': {error_msg}\")\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"validate\",\n                error_code=\"VALIDATION_FAILED\",\n                error_message=error_msg,\n                error_details={\"issues\": validation_issues},\n            )\n\n        return IntegrationResult(\n            success=True,\n            integration_name=self.name,\n            operation=\"validate\",\n        )\n\n    async def _do_send_event(self, event: IntegrationEvent) -> IntegrationResult:\n        \"\"\"\n        Send a governance event to Splunk HEC.\n\n        Formats the event for Splunk and submits it via the HEC endpoint.\n        Handles rate limiting, retries, and provides detailed error reporting.\n\n        Args:\n            event: The governance event to send\n\n        Returns:\n            IntegrationResult with delivery status\n\n        Raises:\n            DeliveryError: If delivery fails after retries\n            RateLimitError: If rate limited by Splunk\n        \"\"\"\n        logger.debug(f\"Sending event {event.event_id} to Splunk\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Format event for Splunk HEC\n            splunk_event = self._format_event_for_splunk(event)\n\n            event_url = f\"{self.splunk_credentials.hec_url}{self.HEC_ENDPOINT}\"\n\n            response = await client.post(\n                event_url,\n                headers=self._get_hec_headers(),\n                json=splunk_event,\n            )\n\n            response_data = {}\n            try:\n                response_data = response.json()\n            except json.JSONDecodeError:\n                pass\n\n            # Handle rate limiting\n            if response.status_code == 429:\n                retry_after = int(response.headers.get(\"Retry-After\", 60))\n                raise RateLimitError(\n                    \"Splunk HEC rate limit exceeded\",\n                    self.name,\n                    retry_after=retry_after,\n                )\n\n            # Handle success\n            if response.status_code == 200:\n                splunk_code = response_data.get(\"code\", 0)\n                if splunk_code == 0:\n                    ack_id = response_data.get(\"ackId\")\n                    logger.debug(f\"Event {event.event_id} sent to Splunk, ack: {ack_id}\")\n                    return IntegrationResult(\n                        success=True,\n                        integration_name=self.name,\n                        operation=\"send_event\",\n                        external_id=str(ack_id) if ack_id else event.event_id,\n                    )\n                else:\n                    # Splunk returned success status but with error code\n                    error_text = response_data.get(\"text\", \"Unknown error\")\n                    raise DeliveryError(\n                        f\"Splunk returned error: {error_text}\",\n                        self.name,\n                        details={\"code\": splunk_code, \"text\": error_text},\n                    )\n\n            # Handle errors\n            if response.status_code == 400:\n                error_text = response_data.get(\"text\", \"Bad request\")\n                error_code = response_data.get(\"code\", 0)\n\n                if error_code == 7:\n                    raise DeliveryError(\n                        f\"Index '{self.splunk_credentials.index}' not found\",\n                        self.name,\n                        details={\"splunk_code\": error_code},\n                    )\n                elif error_code == 6:\n                    raise DeliveryError(\n                        \"Invalid event data format\",\n                        self.name,\n                        details={\"splunk_code\": error_code},\n                    )\n                else:\n                    raise DeliveryError(\n                        f\"HEC error: {error_text}\",\n                        self.name,\n                        details={\"splunk_code\": error_code, \"text\": error_text},\n                    )\n\n            elif response.status_code == 401:\n                raise AuthenticationError(\n                    \"HEC token authentication failed\",\n                    self.name,\n                )\n\n            elif response.status_code == 403:\n                raise DeliveryError(\n                    \"HEC token lacks write permission\",\n                    self.name,\n                    details={\"status_code\": 403},\n                )\n\n            elif response.status_code == 503:\n                raise DeliveryError(\n                    \"Splunk HEC is temporarily unavailable\",\n                    self.name,\n                    details={\"status_code\": 503, \"should_retry\": True},\n                )\n\n            else:\n                raise DeliveryError(\n                    f\"Unexpected response: HTTP {response.status_code}\",\n                    self.name,\n                    details={\n                        \"status_code\": response.status_code,\n                        \"response\": response_data,\n                    },\n                )\n\n        except (RateLimitError, AuthenticationError):\n            # Re-raise these specific exceptions\n            raise\n\n        except DeliveryError:\n            # Re-raise delivery errors\n            raise\n\n        except httpx.TimeoutException as e:\n            raise DeliveryError(\n                f\"Request timed out: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise DeliveryError(\n                f\"Network error: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except Exception as e:\n            raise DeliveryError(\n                f\"Unexpected error: {str(e)}\",\n                self.name,\n            ) from e\n\n    def _format_event_for_splunk(self, event: IntegrationEvent) -> Dict[str, Any]:\n        \"\"\"\n        Format an IntegrationEvent for Splunk HEC submission.\n\n        Converts the governance event to Splunk's expected format with\n        proper field mapping, severity translation, and metadata.\n\n        Args:\n            event: The governance event to format\n\n        Returns:\n            Dictionary formatted for Splunk HEC\n        \"\"\"\n        # Build the event payload\n        event_data = {\n            # Core event fields\n            \"event_id\": event.event_id,\n            \"event_type\": event.event_type,\n            \"severity\": event.severity.value,\n            \"severity_level\": self.SEVERITY_MAP.get(event.severity, 5),\n            \"source_system\": event.source,\n            # Content\n            \"title\": event.title,\n            \"description\": event.description,\n            # Context\n            \"policy_id\": event.policy_id,\n            \"resource_id\": event.resource_id,\n            \"resource_type\": event.resource_type,\n            \"action\": event.action,\n            \"outcome\": event.outcome,\n            # Metadata\n            \"user_id\": event.user_id,\n            \"tenant_id\": event.tenant_id,\n            \"correlation_id\": event.correlation_id,\n            \"tags\": event.tags,\n            # Additional details\n            **event.details,\n        }\n\n        # Remove None values for cleaner Splunk indexing\n        event_data = {k: v for k, v in event_data.items() if v is not None}\n\n        # Build HEC payload\n        splunk_payload = {\n            \"event\": event_data,\n            \"time\": event.timestamp.timestamp(),\n            \"source\": self.splunk_credentials.source,\n            \"sourcetype\": self.splunk_credentials.sourcetype,\n            \"index\": self.splunk_credentials.index,\n            \"host\": event.source,\n        }\n\n        return splunk_payload\n\n    async def _do_send_events_batch(\n        self,\n        events: List[IntegrationEvent],\n    ) -> List[IntegrationResult]:\n        \"\"\"\n        Send multiple events to Splunk in a batch using HEC.\n\n        Implements Splunk-specific batch delivery using newline-delimited JSON\n        format for the HEC endpoint. This is the recommended way to send multiple\n        events for optimal performance.\n\n        Batch Format:\n            Events are formatted as newline-delimited JSON objects, which is the\n            native batch format supported by Splunk HEC:\n            {\"event\": {...}, \"time\": 123, ...}\n            {\"event\": {...}, \"time\": 124, ...}\n            {\"event\": {...}, \"time\": 125, ...}\n\n        Batch Semantics:\n            All-or-nothing: If Splunk accepts the batch (HTTP 200 + code 0),\n            all events are considered successful. If the batch fails, all events\n            are marked as failed. There is no partial success in Splunk HEC batch\n            processing.\n\n        Performance:\n            - Sends all events in a single HTTP POST request\n            - Reduces authentication overhead (one token check vs N checks)\n            - Significantly lower latency for multiple events\n            - No rate limit advantage, but better throughput\n\n        Args:\n            events: List of governance events to send (recommended: 10-100 events)\n\n        Returns:\n            List of IntegrationResults, one per event. All will have same success\n            status due to all-or-nothing semantics.\n\n        Raises:\n            RateLimitError: If rate limited by Splunk (HTTP 429)\n            DeliveryError: If batch delivery fails (invalid data, permissions, etc.)\n            AuthenticationError: If HEC token is invalid (HTTP 401)\n\n        Note:\n            This method is called by BaseIntegration.send_events_batch() which\n            handles authentication checks, retry logic, and metrics tracking.\n            Do not call this method directly.\n\n        See Also:\n            - BaseIntegration.send_events_batch() - Public batch API\n            - BaseIntegration._do_send_events_batch() - Default implementation\n        \"\"\"\n        if not events:\n            return []\n\n        logger.debug(f\"Sending batch of {len(events)} events to Splunk HEC\")\n\n        try:\n            client = await self.get_http_client()\n\n            # Format all events for Splunk\n            splunk_events = [self._format_event_for_splunk(e) for e in events]\n\n            # Splunk HEC accepts newline-delimited JSON for batch\n            batch_payload = \"\\n\".join(json.dumps(e) for e in splunk_events)\n\n            event_url = f\"{self.splunk_credentials.hec_url}{self.HEC_ENDPOINT}\"\n\n            headers = self._get_hec_headers()\n            headers[\"Content-Type\"] = \"application/json\"\n\n            response = await client.post(\n                event_url,\n                headers=headers,\n                content=batch_payload.encode(\"utf-8\"),\n            )\n\n            response_data = {}\n            try:\n                response_data = response.json()\n            except json.JSONDecodeError:\n                pass\n\n            # Handle rate limiting\n            if response.status_code == 429:\n                retry_after = int(response.headers.get(\"Retry-After\", 60))\n                raise RateLimitError(\n                    \"Splunk HEC rate limit exceeded\",\n                    self.name,\n                    retry_after=retry_after,\n                )\n\n            # Handle success\n            if response.status_code == 200 and response_data.get(\"code\") == 0:\n                # All events succeeded\n                logger.debug(f\"Batch of {len(events)} events sent to Splunk successfully\")\n                return [\n                    IntegrationResult(\n                        success=True,\n                        integration_name=self.name,\n                        operation=\"send_event\",\n                        external_id=event.event_id,\n                    )\n                    for event in events\n                ]\n\n            # Handle errors\n            error_msg = response_data.get(\"text\", \"Batch delivery failed\")\n            error_code = response_data.get(\"code\", 0)\n\n            if response.status_code == 400:\n                if error_code == 7:\n                    raise DeliveryError(\n                        f\"Index '{self.splunk_credentials.index}' not found\",\n                        self.name,\n                        details={\"splunk_code\": error_code},\n                    )\n                elif error_code == 6:\n                    raise DeliveryError(\n                        \"Invalid event data format\",\n                        self.name,\n                        details={\"splunk_code\": error_code},\n                    )\n                else:\n                    raise DeliveryError(\n                        f\"HEC error: {error_msg}\",\n                        self.name,\n                        details={\"splunk_code\": error_code, \"text\": error_msg},\n                    )\n\n            elif response.status_code == 401:\n                raise AuthenticationError(\n                    \"HEC token authentication failed\",\n                    self.name,\n                )\n\n            elif response.status_code == 403:\n                raise DeliveryError(\n                    \"HEC token lacks write permission\",\n                    self.name,\n                    details={\"status_code\": 403},\n                )\n\n            elif response.status_code == 503:\n                raise DeliveryError(\n                    \"Splunk HEC is temporarily unavailable\",\n                    self.name,\n                    details={\"status_code\": 503, \"should_retry\": True},\n                )\n\n            # Generic error case\n            logger.warning(\n                f\"Splunk batch delivery failed with status {response.status_code}: {error_msg}\"\n            )\n            return [\n                IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"send_event\",\n                    error_code=\"BATCH_FAILED\",\n                    error_message=error_msg,\n                )\n                for _ in events\n            ]\n\n        except (RateLimitError, AuthenticationError, DeliveryError):\n            # Re-raise these specific exceptions for retry logic\n            raise\n\n        except httpx.TimeoutException as e:\n            raise DeliveryError(\n                f\"Request timed out: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except httpx.NetworkError as e:\n            raise DeliveryError(\n                f\"Network error: {str(e)}\",\n                self.name,\n                details={\"should_retry\": True},\n            ) from e\n\n        except Exception as e:\n            raise DeliveryError(\n                f\"Unexpected error during batch delivery: {str(e)}\",\n                self.name,\n            ) from e\n\n    async def _do_test_connection(self) -> IntegrationResult:\n        \"\"\"\n        Test connection to Splunk HEC endpoint.\n\n        Performs a lightweight health check to verify connectivity\n        without authenticating or sending events.\n\n        Returns:\n            IntegrationResult indicating connection status\n        \"\"\"\n        logger.debug(f\"Testing Splunk connection for '{self.name}'\")\n\n        try:\n            client = await self.get_http_client()\n            health_url = f\"{self.splunk_credentials.hec_url}{self.HEC_HEALTH_ENDPOINT}\"\n\n            # Use GET request to health endpoint\n            response = await client.get(health_url)\n\n            if response.status_code in (200, 400, 401):\n                # Any of these indicate the server is responding\n                # (400/401 just mean we didn't auth, but server is up)\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                )\n            elif response.status_code >= 500:\n                return IntegrationResult(\n                    success=False,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                    error_code=f\"HTTP_{response.status_code}\",\n                    error_message=f\"Splunk server error: {response.status_code}\",\n                )\n            else:\n                return IntegrationResult(\n                    success=True,\n                    integration_name=self.name,\n                    operation=\"test_connection\",\n                    error_message=f\"Unexpected status: {response.status_code}\",\n                )\n\n        except httpx.TimeoutException:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"TIMEOUT\",\n                error_message=f\"Connection timed out after {self.timeout}s\",\n            )\n\n        except httpx.NetworkError as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"NETWORK_ERROR\",\n                error_message=str(e),\n            )\n\n        except Exception as e:\n            return IntegrationResult(\n                success=False,\n                integration_name=self.name,\n                operation=\"test_connection\",\n                error_code=\"UNKNOWN_ERROR\",\n                error_message=str(e),\n            )\n",
        "timestamp": "2026-01-04T00:39:57.715547"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "037-add-batch-event-processing-to-baseintegration",
        "description": "Extend BaseIntegration with send_events_batch() method to efficiently send multiple events in a single API call where supported. Reduces API calls and improves throughput for high-volume governance event scenarios.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-04T00:39:57.724344",
  "last_updated": "2026-01-04T00:39:57.727832"
}