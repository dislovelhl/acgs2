{
  "file_path": "integration-service/src/integrations/ticket_mapping.py",
  "main_branch_history": [],
  "task_views": {
    "056-reduce-excessive-any-type-usage-in-python-codebase": {
      "task_id": "056-reduce-excessive-any-type-usage-in-python-codebase",
      "branch_point": {
        "commit_hash": "fc6e42927298263034acf989773f3200e422ad17",
        "content": "\"\"\"\nTicket Field Mapping Configuration and Validation\n\nProvides a comprehensive framework for mapping governance events to ticketing\nsystem fields (Jira, ServiceNow). Supports template-based field values,\nseverity/priority mapping, custom field transformations, and validation.\n\nFeatures:\n- Template-based field value generation using event data\n- Severity to priority/impact/urgency mapping\n- Custom field transformations\n- Field validation for ticketing system requirements\n- Reusable mapping configurations for Jira and ServiceNow\n\"\"\"\n\nimport logging\nimport re\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Callable, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel, ConfigDict, Field, model_validator\n\nfrom ..types import ConfigDict as ConfigDictType\nfrom ..types import JSONDict, JSONValue\nfrom .base import EventSeverity, IntegrationEvent\n\nlogger = logging.getLogger(__name__)\n\n\n# ============================================================================\n# Enums\n# ============================================================================\n\n\nclass TicketingProvider(str, Enum):\n    \"\"\"Supported ticketing providers.\"\"\"\n\n    JIRA = \"jira\"\n    SERVICENOW = \"servicenow\"\n    PAGERDUTY = \"pagerduty\"\n\n\nclass FieldMappingType(str, Enum):\n    \"\"\"Types of field mapping.\"\"\"\n\n    STATIC = \"static\"  # Fixed value\n    TEMPLATE = \"template\"  # Template with placeholders\n    EVENT_FIELD = \"event_field\"  # Direct mapping from event field\n    TRANSFORM = \"transform\"  # Transform using a function\n    CONDITIONAL = \"conditional\"  # Conditional based on event data\n\n\nclass FieldValidationType(str, Enum):\n    \"\"\"Types of field validation.\"\"\"\n\n    REQUIRED = \"required\"\n    MAX_LENGTH = \"max_length\"\n    MIN_LENGTH = \"min_length\"\n    REGEX = \"regex\"\n    ALLOWED_VALUES = \"allowed_values\"\n    NUMERIC_RANGE = \"numeric_range\"\n    DATE_FORMAT = \"date_format\"\n\n\nclass JiraPriority(str, Enum):\n    \"\"\"Standard Jira priority levels.\"\"\"\n\n    HIGHEST = \"Highest\"\n    HIGH = \"High\"\n    MEDIUM = \"Medium\"\n    LOW = \"Low\"\n    LOWEST = \"Lowest\"\n\n\nclass ServiceNowImpactUrgency(str, Enum):\n    \"\"\"ServiceNow impact/urgency values.\"\"\"\n\n    HIGH = \"1\"\n    MEDIUM = \"2\"\n    LOW = \"3\"\n\n\nclass PagerDutyUrgency(str, Enum):\n    \"\"\"\n    PagerDuty urgency levels.\n\n    PagerDuty uses a simplified two-level urgency system (high/low) compared\n    to Jira's five-level priority or ServiceNow's three-level impact/urgency.\n    High urgency incidents trigger immediate notifications and escalation.\n    \"\"\"\n\n    HIGH = \"high\"\n    LOW = \"low\"\n\n\n# ============================================================================\n# Default Mappings\n# ============================================================================\n\n\n# Severity to Jira Priority mapping\nDEFAULT_JIRA_PRIORITY_MAP: Dict[EventSeverity, JiraPriority] = {\n    EventSeverity.CRITICAL: JiraPriority.HIGHEST,\n    EventSeverity.HIGH: JiraPriority.HIGH,\n    EventSeverity.MEDIUM: JiraPriority.MEDIUM,\n    EventSeverity.LOW: JiraPriority.LOW,\n    EventSeverity.INFO: JiraPriority.LOWEST,\n}\n\n# Severity to ServiceNow Impact mapping\nDEFAULT_SERVICENOW_IMPACT_MAP: Dict[EventSeverity, ServiceNowImpactUrgency] = {\n    EventSeverity.CRITICAL: ServiceNowImpactUrgency.HIGH,\n    EventSeverity.HIGH: ServiceNowImpactUrgency.HIGH,\n    EventSeverity.MEDIUM: ServiceNowImpactUrgency.MEDIUM,\n    EventSeverity.LOW: ServiceNowImpactUrgency.LOW,\n    EventSeverity.INFO: ServiceNowImpactUrgency.LOW,\n}\n\n# Severity to ServiceNow Urgency mapping\nDEFAULT_SERVICENOW_URGENCY_MAP: Dict[EventSeverity, ServiceNowImpactUrgency] = {\n    EventSeverity.CRITICAL: ServiceNowImpactUrgency.HIGH,\n    EventSeverity.HIGH: ServiceNowImpactUrgency.MEDIUM,\n    EventSeverity.MEDIUM: ServiceNowImpactUrgency.MEDIUM,\n    EventSeverity.LOW: ServiceNowImpactUrgency.LOW,\n    EventSeverity.INFO: ServiceNowImpactUrgency.LOW,\n}\n\n# Severity to PagerDuty Urgency mapping\n# PagerDuty uses a two-level urgency system (high/low). CRITICAL and HIGH severity\n# violations map to 'high' urgency to ensure immediate notifications and escalation.\n# MEDIUM, LOW, and INFO map to 'low' urgency for standard processing.\nDEFAULT_PAGERDUTY_URGENCY_MAP: Dict[EventSeverity, PagerDutyUrgency] = {\n    EventSeverity.CRITICAL: PagerDutyUrgency.HIGH,\n    EventSeverity.HIGH: PagerDutyUrgency.HIGH,\n    EventSeverity.MEDIUM: PagerDutyUrgency.LOW,\n    EventSeverity.LOW: PagerDutyUrgency.LOW,\n    EventSeverity.INFO: PagerDutyUrgency.LOW,\n}\n\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\n\nclass FieldValidationRule(BaseModel):\n    \"\"\"Validation rule for a ticket field.\"\"\"\n\n    validation_type: FieldValidationType = Field(..., description=\"Type of validation to perform\")\n    value: Optional[JSONValue] = Field(\n        None, description=\"Value for the validation (e.g., max length, regex pattern)\"\n    )\n    error_message: Optional[str] = Field(\n        None, description=\"Custom error message for validation failure\"\n    )\n\n    model_config = ConfigDict(frozen=True)\n\n\nclass FieldMapping(BaseModel):\n    \"\"\"Configuration for mapping a single field.\"\"\"\n\n    target_field: str = Field(..., description=\"Name of the target field in the ticketing system\")\n    mapping_type: FieldMappingType = Field(\n        default=FieldMappingType.STATIC,\n        description=\"How the field value should be determined\",\n    )\n\n    # Value configuration based on mapping type\n    static_value: Optional[JSONValue] = Field(\n        None, description=\"Static value to use (for STATIC type)\"\n    )\n    template: Optional[str] = Field(\n        None,\n        description=\"Template string with {placeholders} (for TEMPLATE type)\",\n    )\n    source_field: Optional[str] = Field(\n        None, description=\"Event field to map from (for EVENT_FIELD type)\"\n    )\n    transform_name: Optional[str] = Field(\n        None, description=\"Name of the transform function (for TRANSFORM type)\"\n    )\n    transform_params: Dict[str, JSONValue] = Field(\n        default_factory=dict,\n        description=\"Parameters for the transform function\",\n    )\n\n    # Conditional mapping\n    conditions: List[JSONDict] = Field(\n        default_factory=list,\n        description=\"Conditions for CONDITIONAL mapping [{field, operator, value, result}]\",\n    )\n    default_value: Optional[JSONValue] = Field(\n        None, description=\"Default value if no condition matches\"\n    )\n\n    # Validation\n    validation_rules: List[FieldValidationRule] = Field(\n        default_factory=list, description=\"Validation rules for this field\"\n    )\n    required: bool = Field(default=False, description=\"Whether this field is required\")\n\n    # Metadata\n    description: Optional[str] = Field(None, description=\"Description of this field mapping\")\n    provider_specific: JSONDict = Field(\n        default_factory=dict,\n        description=\"Provider-specific configuration\",\n    )\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    @model_validator(mode=\"after\")\n    def validate_mapping_config(self) -> \"FieldMapping\":\n        \"\"\"Validate that appropriate values are provided for the mapping type.\"\"\"\n        if self.mapping_type == FieldMappingType.STATIC:\n            if self.static_value is None:\n                raise ValueError(\"static_value is required for STATIC mapping type\")\n        elif self.mapping_type == FieldMappingType.TEMPLATE:\n            if not self.template:\n                raise ValueError(\"template is required for TEMPLATE mapping type\")\n        elif self.mapping_type == FieldMappingType.EVENT_FIELD:\n            if not self.source_field:\n                raise ValueError(\"source_field is required for EVENT_FIELD mapping type\")\n        elif self.mapping_type == FieldMappingType.TRANSFORM:\n            if not self.transform_name:\n                raise ValueError(\"transform_name is required for TRANSFORM mapping type\")\n        elif self.mapping_type == FieldMappingType.CONDITIONAL:\n            if not self.conditions:\n                raise ValueError(\"conditions are required for CONDITIONAL mapping type\")\n        return self\n\n\nclass SeverityMapping(BaseModel):\n    \"\"\"Mapping configuration for severity to priority/impact/urgency.\"\"\"\n\n    critical: str = Field(..., description=\"Value for CRITICAL severity\")\n    high: str = Field(..., description=\"Value for HIGH severity\")\n    medium: str = Field(..., description=\"Value for MEDIUM severity\")\n    low: str = Field(..., description=\"Value for LOW severity\")\n    info: str = Field(..., description=\"Value for INFO severity\")\n\n    model_config = ConfigDict(frozen=True)\n\n    def get_value(self, severity: EventSeverity) -> str:\n        \"\"\"Get the mapped value for a severity level.\"\"\"\n        mapping = {\n            EventSeverity.CRITICAL: self.critical,\n            EventSeverity.HIGH: self.high,\n            EventSeverity.MEDIUM: self.medium,\n            EventSeverity.LOW: self.low,\n            EventSeverity.INFO: self.info,\n        }\n        return mapping.get(severity, self.medium)\n\n\nclass TicketMappingConfig(BaseModel):\n    \"\"\"Complete ticket field mapping configuration.\"\"\"\n\n    id: str = Field(\n        default=\"\",\n        description=\"Unique identifier for this mapping configuration\",\n    )\n    name: str = Field(..., description=\"Name of this mapping configuration\")\n    provider: TicketingProvider = Field(\n        ..., description=\"Ticketing provider this configuration is for\"\n    )\n    description: Optional[str] = Field(\n        None, description=\"Description of this mapping configuration\"\n    )\n\n    # Field mappings\n    field_mappings: List[FieldMapping] = Field(\n        default_factory=list,\n        description=\"List of field mappings to apply\",\n    )\n\n    # Priority/Impact/Urgency mappings\n    severity_mapping: Optional[SeverityMapping] = Field(\n        None, description=\"Custom severity to priority/impact mapping\"\n    )\n\n    # Template settings\n    summary_template: str = Field(\n        default=\"[ACGS-2] {title}\",\n        description=\"Template for ticket summary/short description\",\n    )\n    description_template: Optional[str] = Field(\n        None, description=\"Template for ticket description (if not using default)\"\n    )\n\n    # Provider-specific settings\n    jira_settings: ConfigDictType = Field(\n        default_factory=dict,\n        description=\"Jira-specific settings (e.g., project_key, issue_type)\",\n    )\n    servicenow_settings: ConfigDictType = Field(\n        default_factory=dict,\n        description=\"ServiceNow-specific settings (e.g., category, subcategory)\",\n    )\n\n    # Metadata\n    enabled: bool = Field(default=True, description=\"Whether this mapping is enabled\")\n    created_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Creation timestamp\",\n    )\n    updated_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description=\"Last update timestamp\",\n    )\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    def get_field_mapping(self, target_field: str) -> Optional[FieldMapping]:\n        \"\"\"Get the mapping for a specific target field.\"\"\"\n        for mapping in self.field_mappings:\n            if mapping.target_field == target_field:\n                return mapping\n        return None\n\n\nclass FieldMappingResult(BaseModel):\n    \"\"\"Result of applying a field mapping.\"\"\"\n\n    field_name: str = Field(..., description=\"Name of the mapped field\")\n    value: Optional[JSONValue] = Field(None, description=\"Computed value for the field\")\n    success: bool = Field(default=True, description=\"Whether mapping succeeded\")\n    error_message: Optional[str] = Field(None, description=\"Error message if mapping failed\")\n    validation_errors: List[str] = Field(\n        default_factory=list, description=\"List of validation errors\"\n    )\n\n    model_config = ConfigDict(validate_assignment=True)\n\n\nclass TicketMappingResult(BaseModel):\n    \"\"\"Result of applying all field mappings for a ticket.\"\"\"\n\n    success: bool = Field(default=True, description=\"Whether all required mappings succeeded\")\n    fields: Dict[str, JSONValue] = Field(default_factory=dict, description=\"Mapped field values\")\n    field_results: List[FieldMappingResult] = Field(\n        default_factory=list, description=\"Individual field mapping results\"\n    )\n    validation_errors: List[str] = Field(\n        default_factory=list, description=\"Overall validation errors\"\n    )\n    warnings: List[str] = Field(default_factory=list, description=\"Non-fatal warnings\")\n\n    model_config = ConfigDict(validate_assignment=True)\n\n\n# ============================================================================\n# Field Validators\n# ============================================================================\n\n\nclass FieldValidator:\n    \"\"\"Validates field values against rules.\"\"\"\n\n    @staticmethod\n    def validate(\n        value: JSONValue,\n        rules: List[FieldValidationRule],\n        field_name: str,\n    ) -> List[str]:\n        \"\"\"\n        Validate a value against a list of rules.\n\n        Args:\n            value: The value to validate\n            rules: List of validation rules\n            field_name: Name of the field (for error messages)\n\n        Returns:\n            List of validation error messages (empty if valid)\n        \"\"\"\n        errors = []\n\n        for rule in rules:\n            error = FieldValidator._validate_rule(value, rule, field_name)\n            if error:\n                errors.append(error)\n\n        return errors\n\n    @staticmethod\n    def _validate_rule(\n        value: JSONValue,\n        rule: FieldValidationRule,\n        field_name: str,\n    ) -> Optional[str]:\n        \"\"\"Validate a single rule.\"\"\"\n        if rule.validation_type == FieldValidationType.REQUIRED:\n            if value is None or (isinstance(value, str) and not value.strip()):\n                return rule.error_message or f\"Field '{field_name}' is required\"\n\n        elif rule.validation_type == FieldValidationType.MAX_LENGTH:\n            if value is not None and isinstance(value, str):\n                max_len = int(rule.value)\n                if len(value) > max_len:\n                    return (\n                        rule.error_message\n                        or f\"Field '{field_name}' exceeds maximum length of {max_len}\"\n                    )\n\n        elif rule.validation_type == FieldValidationType.MIN_LENGTH:\n            if value is not None and isinstance(value, str):\n                min_len = int(rule.value)\n                if len(value) < min_len:\n                    return (\n                        rule.error_message\n                        or f\"Field '{field_name}' is shorter than minimum length of {min_len}\"\n                    )\n\n        elif rule.validation_type == FieldValidationType.REGEX:\n            if value is not None and isinstance(value, str):\n                pattern = str(rule.value)\n                if not re.match(pattern, value):\n                    return (\n                        rule.error_message\n                        or f\"Field '{field_name}' does not match required pattern\"\n                    )\n\n        elif rule.validation_type == FieldValidationType.ALLOWED_VALUES:\n            if value is not None and rule.value is not None:\n                allowed = rule.value if isinstance(rule.value, list) else [rule.value]\n                if value not in allowed:\n                    allowed_str = \", \".join(str(v) for v in allowed)\n                    return (\n                        rule.error_message or f\"Field '{field_name}' must be one of: {allowed_str}\"\n                    )\n\n        elif rule.validation_type == FieldValidationType.NUMERIC_RANGE:\n            if value is not None:\n                try:\n                    num_value = float(value)\n                    if isinstance(rule.value, dict):\n                        min_val = rule.value.get(\"min\")\n                        max_val = rule.value.get(\"max\")\n                        if min_val is not None and num_value < min_val:\n                            return (\n                                rule.error_message or f\"Field '{field_name}' must be >= {min_val}\"\n                            )\n                        if max_val is not None and num_value > max_val:\n                            return (\n                                rule.error_message or f\"Field '{field_name}' must be <= {max_val}\"\n                            )\n                except (ValueError, TypeError):\n                    return rule.error_message or f\"Field '{field_name}' must be a valid number\"\n\n        return None\n\n\n# ============================================================================\n# Field Transformers\n# ============================================================================\n\n\n# Type for transform functions\nTransformFunc = Callable[[IntegrationEvent, Dict[str, JSONValue]], JSONValue]\n\n\nclass FieldTransformers:\n    \"\"\"Collection of built-in field transformer functions.\"\"\"\n\n    _registry: Dict[str, TransformFunc] = {}\n\n    @classmethod\n    def register(cls, name: str) -> Callable[[TransformFunc], TransformFunc]:\n        \"\"\"Decorator to register a transform function.\"\"\"\n\n        def decorator(func: TransformFunc) -> TransformFunc:\n            cls._registry[name] = func\n            return func\n\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -> Optional[TransformFunc]:\n        \"\"\"Get a registered transform function by name.\"\"\"\n        return cls._registry.get(name)\n\n    @classmethod\n    def list_transforms(cls) -> List[str]:\n        \"\"\"List all registered transform names.\"\"\"\n        return list(cls._registry.keys())\n\n\n# Built-in transforms\n@FieldTransformers.register(\"severity_to_jira_priority\")\ndef severity_to_jira_priority(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Convert event severity to Jira priority name.\"\"\"\n    custom_map = params.get(\"mapping\", {})\n    if custom_map and event.severity.value in custom_map:\n        return str(custom_map[event.severity.value])\n    return DEFAULT_JIRA_PRIORITY_MAP.get(event.severity, JiraPriority.MEDIUM).value\n\n\n@FieldTransformers.register(\"severity_to_servicenow_impact\")\ndef severity_to_servicenow_impact(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Convert event severity to ServiceNow impact value.\"\"\"\n    custom_map = params.get(\"mapping\", {})\n    if custom_map and event.severity.value in custom_map:\n        return str(custom_map[event.severity.value])\n    return DEFAULT_SERVICENOW_IMPACT_MAP.get(event.severity, ServiceNowImpactUrgency.MEDIUM).value\n\n\n@FieldTransformers.register(\"severity_to_servicenow_urgency\")\ndef severity_to_servicenow_urgency(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Convert event severity to ServiceNow urgency value.\"\"\"\n    custom_map = params.get(\"mapping\", {})\n    if custom_map and event.severity.value in custom_map:\n        return str(custom_map[event.severity.value])\n    return DEFAULT_SERVICENOW_URGENCY_MAP.get(event.severity, ServiceNowImpactUrgency.MEDIUM).value\n\n\n@FieldTransformers.register(\"severity_to_pagerduty_urgency\")\ndef severity_to_pagerduty_urgency(event: IntegrationEvent, params: Dict[str, Any]) -> str:\n    \"\"\"Convert event severity to PagerDuty urgency value.\"\"\"\n    custom_map = params.get(\"mapping\", {})\n    if custom_map and event.severity.value in custom_map:\n        return custom_map[event.severity.value]\n    return DEFAULT_PAGERDUTY_URGENCY_MAP.get(event.severity, PagerDutyUrgency.LOW).value\n\n\n@FieldTransformers.register(\"format_timestamp\")\ndef format_timestamp(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Format event timestamp to a specific format.\"\"\"\n    fmt = params.get(\"format\", \"%Y-%m-%d %H:%M:%S\")\n    return event.timestamp.strftime(str(fmt))\n\n\n@FieldTransformers.register(\"format_tags\")\ndef format_tags(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Format event tags as a string.\"\"\"\n    separator = params.get(\"separator\", \", \")\n    return str(separator).join(event.tags)\n\n\n@FieldTransformers.register(\"build_labels\")\ndef build_labels(event: IntegrationEvent, params: Dict[str, JSONValue]) -> List[str]:\n    \"\"\"Build a list of labels from event data.\"\"\"\n    base_labels_param = params.get(\"base_labels\", [\"governance\", \"acgs2\"])\n    # Ensure base_labels is a list\n    if isinstance(base_labels_param, list):\n        base_labels = [str(label) for label in base_labels_param]\n    else:\n        base_labels = [\"governance\", \"acgs2\"]\n\n    labels = list(base_labels)\n\n    if params.get(\"include_severity\", True):\n        labels.append(f\"severity-{event.severity.value}\")\n\n    if params.get(\"include_event_type\", True) and event.event_type:\n        labels.append(event.event_type.replace(\"_\", \"-\").replace(\" \", \"-\").lower())\n\n    if params.get(\"include_tags\", False):\n        labels.extend(event.tags)\n\n    return labels\n\n\n@FieldTransformers.register(\"truncate\")\ndef truncate(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Truncate a field value to max length.\"\"\"\n    source_field = params.get(\"source_field\", \"title\")\n    max_length_param = params.get(\"max_length\", 255)\n    max_length = int(max_length_param) if isinstance(max_length_param, (int, float, str)) else 255\n    suffix = params.get(\"suffix\", \"...\")\n\n    value = getattr(event, str(source_field), \"\") or \"\"\n    if len(value) > max_length:\n        return value[: max_length - len(str(suffix))] + str(suffix)\n    return value\n\n\n@FieldTransformers.register(\"json_details\")\ndef json_details(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Format event details as JSON string.\"\"\"\n    import json\n\n    indent_param = params.get(\"indent\", 2)\n    indent = int(indent_param) if isinstance(indent_param, (int, float, str)) else 2\n    include_fields = params.get(\"include_fields\", None)\n\n    if include_fields and isinstance(include_fields, list):\n        details = {k: v for k, v in event.details.items() if k in include_fields}\n    else:\n        details = event.details\n\n    return json.dumps(details, indent=indent, default=str)\n\n\n@FieldTransformers.register(\"concatenate\")\ndef concatenate(event: IntegrationEvent, params: Dict[str, JSONValue]) -> str:\n    \"\"\"Concatenate multiple event fields.\"\"\"\n    fields_param = params.get(\"fields\", [])\n    fields = fields_param if isinstance(fields_param, list) else []\n    separator = params.get(\"separator\", \" \")\n\n    values = []\n    for field in fields:\n        value = getattr(event, str(field), None)\n        if value is not None:\n            values.append(str(value))\n\n    return str(separator).join(values)\n\n\n@FieldTransformers.register(\"map_value\")\ndef map_value(event: IntegrationEvent, params: Dict[str, JSONValue]) -> JSONValue:\n    \"\"\"Map a field value using a lookup table.\"\"\"\n    source_field = params.get(\"source_field\", \"\")\n    mapping_param = params.get(\"mapping\", {})\n    mapping = mapping_param if isinstance(mapping_param, dict) else {}\n    default = params.get(\"default\", None)\n\n    value = getattr(event, str(source_field), None)\n    if value is not None and isinstance(mapping, dict):\n        return mapping.get(str(value), default)\n    return default\n\n\n# ============================================================================\n# Ticket Field Mapper\n# ============================================================================\n\n\nclass TicketFieldMapper:\n    \"\"\"\n    Maps governance events to ticket fields using configurable mappings.\n\n    Supports template-based field generation, severity mapping, custom\n    transformations, and field validation.\n\n    Usage:\n        mapper = TicketFieldMapper(config)\n        result = mapper.map_event(event)\n        if result.success:\n            fields = result.fields\n    \"\"\"\n\n    # Template placeholder pattern\n    TEMPLATE_PATTERN = re.compile(r\"\\{(\\w+(?:\\.\\w+)*)\\}\")\n\n    def __init__(self, config: TicketMappingConfig):\n        \"\"\"\n        Initialize the mapper with a configuration.\n\n        Args:\n            config: Ticket mapping configuration\n        \"\"\"\n        self.config = config\n        self._custom_transforms: Dict[str, TransformFunc] = {}\n\n    @property\n    def provider(self) -> TicketingProvider:\n        \"\"\"Get the ticketing provider for this mapper.\"\"\"\n        return self.config.provider\n\n    def register_transform(self, name: str, func: TransformFunc) -> None:\n        \"\"\"\n        Register a custom transform function.\n\n        Args:\n            name: Name of the transform\n            func: Transform function (event, params) -> value\n        \"\"\"\n        self._custom_transforms[name] = func\n\n    def map_event(self, event: IntegrationEvent) -> TicketMappingResult:\n        \"\"\"\n        Map an event to ticket fields using the configured mappings.\n\n        Args:\n            event: The governance event to map\n\n        Returns:\n            TicketMappingResult with mapped fields and any errors\n        \"\"\"\n        result = TicketMappingResult()\n        all_errors = []\n\n        # Process each field mapping\n        for mapping in self.config.field_mappings:\n            field_result = self._map_field(event, mapping)\n            result.field_results.append(field_result)\n\n            if field_result.success:\n                result.fields[field_result.field_name] = field_result.value\n            else:\n                if mapping.required:\n                    all_errors.append(\n                        f\"Required field '{mapping.target_field}' mapping failed: \"\n                        f\"{field_result.error_message}\"\n                    )\n                else:\n                    result.warnings.append(\n                        f\"Optional field '{mapping.target_field}' mapping failed: \"\n                        f\"{field_result.error_message}\"\n                    )\n\n            # Add validation errors\n            if field_result.validation_errors:\n                if mapping.required:\n                    all_errors.extend(field_result.validation_errors)\n                else:\n                    result.warnings.extend(field_result.validation_errors)\n\n        result.validation_errors = all_errors\n        result.success = len(all_errors) == 0\n\n        return result\n\n    def _map_field(self, event: IntegrationEvent, mapping: FieldMapping) -> FieldMappingResult:\n        \"\"\"Map a single field.\"\"\"\n        try:\n            value = self._compute_value(event, mapping)\n\n            # Validate the computed value\n            validation_errors = FieldValidator.validate(\n                value, mapping.validation_rules, mapping.target_field\n            )\n\n            # Check required\n            if mapping.required and (value is None or value == \"\"):\n                validation_errors.append(\n                    f\"Field '{mapping.target_field}' is required but has no value\"\n                )\n\n            return FieldMappingResult(\n                field_name=mapping.target_field,\n                value=value,\n                success=len(validation_errors) == 0,\n                validation_errors=validation_errors,\n            )\n\n        except Exception as e:\n            logger.warning(f\"Error mapping field '{mapping.target_field}': {str(e)}\")\n            return FieldMappingResult(\n                field_name=mapping.target_field,\n                value=None,\n                success=False,\n                error_message=str(e),\n            )\n\n    def _compute_value(self, event: IntegrationEvent, mapping: FieldMapping) -> JSONValue:\n        \"\"\"Compute the field value based on mapping type.\"\"\"\n        if mapping.mapping_type == FieldMappingType.STATIC:\n            return mapping.static_value\n\n        elif mapping.mapping_type == FieldMappingType.TEMPLATE:\n            return self._apply_template(event, mapping.template or \"\")\n\n        elif mapping.mapping_type == FieldMappingType.EVENT_FIELD:\n            return self._get_event_field(event, mapping.source_field or \"\")\n\n        elif mapping.mapping_type == FieldMappingType.TRANSFORM:\n            return self._apply_transform(\n                event, mapping.transform_name or \"\", mapping.transform_params\n            )\n\n        elif mapping.mapping_type == FieldMappingType.CONDITIONAL:\n            return self._apply_conditional(event, mapping.conditions, mapping.default_value)\n\n        return None\n\n    def _apply_template(self, event: IntegrationEvent, template: str) -> str:\n        \"\"\"\n        Apply a template with event field placeholders.\n\n        Supports placeholders like {title}, {severity}, {details.key}, etc.\n\n        Args:\n            event: The event to get values from\n            template: Template string with {placeholders}\n\n        Returns:\n            Rendered template string\n        \"\"\"\n\n        def replace_placeholder(match: re.Match) -> str:\n            path = match.group(1)\n            value = self._get_event_field(event, path)\n            return str(value) if value is not None else \"\"\n\n        return self.TEMPLATE_PATTERN.sub(replace_placeholder, template)\n\n    def _get_event_field(self, event: IntegrationEvent, field_path: str) -> JSONValue:\n        \"\"\"\n        Get a field value from an event, supporting nested paths.\n\n        Args:\n            event: The event to get value from\n            field_path: Field path (e.g., \"title\", \"details.key\")\n\n        Returns:\n            Field value or None if not found\n        \"\"\"\n        parts = field_path.split(\".\")\n        value: Union[IntegrationEvent, JSONValue] = event\n\n        for part in parts:\n            if hasattr(value, part):\n                value = getattr(value, part)\n            elif isinstance(value, dict) and part in value:\n                value = value[part]\n            else:\n                return None\n\n        # Ensure we return a JSONValue type\n        if isinstance(value, (str, int, float, bool, dict, list, type(None))):\n            return value  # type: ignore[return-value]\n        return str(value)\n\n    def _apply_transform(\n        self,\n        event: IntegrationEvent,\n        transform_name: str,\n        params: Dict[str, JSONValue],\n    ) -> JSONValue:\n        \"\"\"\n        Apply a transform function to compute a field value.\n\n        Args:\n            event: The event to transform\n            transform_name: Name of the transform function\n            params: Parameters for the transform\n\n        Returns:\n            Transformed value\n        \"\"\"\n        # Check custom transforms first\n        if transform_name in self._custom_transforms:\n            return self._custom_transforms[transform_name](event, params)\n\n        # Check built-in transforms\n        transform_func = FieldTransformers.get(transform_name)\n        if transform_func:\n            return transform_func(event, params)\n\n        raise ValueError(f\"Unknown transform: {transform_name}\")\n\n    def _apply_conditional(\n        self,\n        event: IntegrationEvent,\n        conditions: List[JSONDict],\n        default: JSONValue,\n    ) -> JSONValue:\n        \"\"\"\n        Apply conditional logic to determine field value.\n\n        Each condition has: {field, operator, value, result}\n\n        Supported operators:\n        - eq: equals\n        - ne: not equals\n        - gt, gte, lt, lte: comparison\n        - in: value in list\n        - contains: string contains\n        - regex: regex match\n\n        Args:\n            event: The event to evaluate\n            conditions: List of condition dictionaries\n            default: Default value if no condition matches\n\n        Returns:\n            Result from matching condition or default\n        \"\"\"\n        for condition in conditions:\n            field = str(condition.get(\"field\", \"\"))\n            operator = str(condition.get(\"operator\", \"eq\"))\n            expected = condition.get(\"value\")\n            result = condition.get(\"result\")\n\n            actual = self._get_event_field(event, field)\n\n            if self._evaluate_condition(actual, operator, expected):\n                return result\n\n        return default\n\n    def _evaluate_condition(self, actual: JSONValue, operator: str, expected: JSONValue) -> bool:\n        \"\"\"Evaluate a single condition.\"\"\"\n        if actual is None:\n            return operator == \"eq\" and expected is None\n\n        if operator == \"eq\":\n            return actual == expected\n        elif operator == \"ne\":\n            return actual != expected\n        elif operator == \"gt\":\n            return actual > expected  # type: ignore[operator]\n        elif operator == \"gte\":\n            return actual >= expected  # type: ignore[operator]\n        elif operator == \"lt\":\n            return actual < expected  # type: ignore[operator]\n        elif operator == \"lte\":\n            return actual <= expected  # type: ignore[operator]\n        elif operator == \"in\":\n            expected_list = expected if isinstance(expected, list) else []\n            return actual in expected_list\n        elif operator == \"contains\":\n            return str(expected) in str(actual)\n        elif operator == \"regex\":\n            return bool(re.match(str(expected), str(actual)))\n\n        return False\n\n    def get_summary(self, event: IntegrationEvent) -> str:\n        \"\"\"\n        Get the ticket summary using the configured template.\n\n        Args:\n            event: The governance event\n\n        Returns:\n            Formatted summary string\n        \"\"\"\n        return self._apply_template(event, self.config.summary_template)\n\n    def get_priority(self, severity: EventSeverity) -> str:\n        \"\"\"\n        Get the priority value for a severity level.\n\n        Uses custom mapping if configured, otherwise uses defaults.\n\n        Args:\n            severity: Event severity level\n\n        Returns:\n            Priority/impact value as string\n        \"\"\"\n        if self.config.severity_mapping:\n            return self.config.severity_mapping.get_value(severity)\n\n        if self.config.provider == TicketingProvider.JIRA:\n            return DEFAULT_JIRA_PRIORITY_MAP.get(severity, JiraPriority.MEDIUM).value\n        else:\n            return DEFAULT_SERVICENOW_IMPACT_MAP.get(severity, ServiceNowImpactUrgency.MEDIUM).value\n\n    def validate_config(self) -> List[str]:\n        \"\"\"\n        Validate the mapping configuration.\n\n        Returns:\n            List of validation errors (empty if valid)\n        \"\"\"\n        errors = []\n\n        # Check field mappings\n        for i, mapping in enumerate(self.config.field_mappings):\n            prefix = f\"field_mappings[{i}] ({mapping.target_field})\"\n\n            # Validate transform exists\n            if mapping.mapping_type == FieldMappingType.TRANSFORM:\n                transform_name = mapping.transform_name or \"\"\n                if (\n                    transform_name not in self._custom_transforms\n                    and FieldTransformers.get(transform_name) is None\n                ):\n                    errors.append(f\"{prefix}: Unknown transform '{transform_name}'\")\n\n            # Validate template placeholders\n            if mapping.mapping_type == FieldMappingType.TEMPLATE:\n                template = mapping.template or \"\"\n                placeholders = self.TEMPLATE_PATTERN.findall(template)\n                for placeholder in placeholders:\n                    root_field = placeholder.split(\".\")[0]\n                    if not hasattr(IntegrationEvent, root_field) and root_field != \"details\":\n                        errors.append(f\"{prefix}: Unknown event field '{placeholder}' in template\")\n\n            # Validate conditional operators\n            if mapping.mapping_type == FieldMappingType.CONDITIONAL:\n                valid_operators = {\"eq\", \"ne\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\", \"contains\", \"regex\"}\n                for j, cond in enumerate(mapping.conditions):\n                    op = cond.get(\"operator\", \"eq\")\n                    if op not in valid_operators:\n                        errors.append(f\"{prefix}: conditions[{j}] has invalid operator '{op}'\")\n\n        return errors\n\n\n# ============================================================================\n# Factory Functions\n# ============================================================================\n\n\ndef create_jira_mapping_config(\n    name: str = \"Default Jira Mapping\",\n    project_key: str = \"GOV\",\n    issue_type: str = \"Bug\",\n    labels: Optional[List[str]] = None,\n    summary_template: str = \"[ACGS-2] {title}\",\n    severity_mapping: Optional[Dict[str, str]] = None,\n    custom_fields: Optional[Dict[str, JSONValue]] = None,\n) -> TicketMappingConfig:\n    \"\"\"\n    Create a default Jira ticket mapping configuration.\n\n    Args:\n        name: Configuration name\n        project_key: Jira project key\n        issue_type: Jira issue type\n        labels: Labels to add to tickets\n        summary_template: Template for ticket summary\n        severity_mapping: Custom severity to priority mapping\n        custom_fields: Additional custom field mappings\n\n    Returns:\n        TicketMappingConfig for Jira\n    \"\"\"\n    if labels is None:\n        labels = [\"governance\", \"acgs2\"]\n\n    field_mappings = [\n        FieldMapping(\n            target_field=\"project\",\n            mapping_type=FieldMappingType.STATIC,\n            static_value={\"key\": project_key},\n            required=True,\n        ),\n        FieldMapping(\n            target_field=\"issuetype\",\n            mapping_type=FieldMappingType.STATIC,\n            static_value={\"name\": issue_type},\n            required=True,\n        ),\n        FieldMapping(\n            target_field=\"summary\",\n            mapping_type=FieldMappingType.TEMPLATE,\n            template=summary_template,\n            required=True,\n            validation_rules=[\n                FieldValidationRule(\n                    validation_type=FieldValidationType.MAX_LENGTH,\n                    value=255,\n                    error_message=\"Jira summary must be 255 characters or less\",\n                ),\n            ],\n        ),\n        FieldMapping(\n            target_field=\"priority\",\n            mapping_type=FieldMappingType.TRANSFORM,\n            transform_name=\"severity_to_jira_priority\",\n            transform_params={\"mapping\": severity_mapping or {}},\n        ),\n        FieldMapping(\n            target_field=\"labels\",\n            mapping_type=FieldMappingType.TRANSFORM,\n            transform_name=\"build_labels\",\n            transform_params={\n                \"base_labels\": labels,\n                \"include_severity\": True,\n                \"include_event_type\": True,\n            },\n        ),\n    ]\n\n    # Add custom field mappings\n    if custom_fields:\n        for field_id, value in custom_fields.items():\n            field_mappings.append(\n                FieldMapping(\n                    target_field=field_id,\n                    mapping_type=FieldMappingType.STATIC,\n                    static_value=value,\n                )\n            )\n\n    return TicketMappingConfig(\n        name=name,\n        provider=TicketingProvider.JIRA,\n        summary_template=summary_template,\n        field_mappings=field_mappings,\n        jira_settings={\n            \"project_key\": project_key,\n            \"issue_type\": issue_type,\n        },\n    )\n\n\ndef create_servicenow_mapping_config(\n    name: str = \"Default ServiceNow Mapping\",\n    category: str = \"Governance\",\n    subcategory: Optional[str] = None,\n    assignment_group: Optional[str] = None,\n    summary_template: str = \"[ACGS-2] {title}\",\n    severity_mapping: Optional[Dict[str, str]] = None,\n    additional_fields: Optional[Dict[str, JSONValue]] = None,\n) -> TicketMappingConfig:\n    \"\"\"\n    Create a default ServiceNow incident mapping configuration.\n\n    Args:\n        name: Configuration name\n        category: Incident category\n        subcategory: Incident subcategory\n        assignment_group: Assignment group for incidents\n        summary_template: Template for short description\n        severity_mapping: Custom severity to impact/urgency mapping\n        additional_fields: Additional field mappings\n\n    Returns:\n        TicketMappingConfig for ServiceNow\n    \"\"\"\n    field_mappings = [\n        FieldMapping(\n            target_field=\"short_description\",\n            mapping_type=FieldMappingType.TEMPLATE,\n            template=summary_template,\n            required=True,\n            validation_rules=[\n                FieldValidationRule(\n                    validation_type=FieldValidationType.MAX_LENGTH,\n                    value=160,\n                    error_message=\"ServiceNow short_description must be 160 characters or less\",\n                ),\n            ],\n        ),\n        FieldMapping(\n            target_field=\"category\",\n            mapping_type=FieldMappingType.STATIC,\n            static_value=category,\n        ),\n        FieldMapping(\n            target_field=\"impact\",\n            mapping_type=FieldMappingType.TRANSFORM,\n            transform_name=\"severity_to_servicenow_impact\",\n            transform_params={\"mapping\": severity_mapping or {}},\n        ),\n        FieldMapping(\n            target_field=\"urgency\",\n            mapping_type=FieldMappingType.TRANSFORM,\n            transform_name=\"severity_to_servicenow_urgency\",\n            transform_params={\"mapping\": severity_mapping or {}},\n        ),\n    ]\n\n    if subcategory:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"subcategory\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=subcategory,\n            )\n        )\n\n    if assignment_group:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"assignment_group\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=assignment_group,\n            )\n        )\n\n    # Add additional field mappings\n    if additional_fields:\n        for field_name, value in additional_fields.items():\n            field_mappings.append(\n                FieldMapping(\n                    target_field=field_name,\n                    mapping_type=FieldMappingType.STATIC,\n                    static_value=value,\n                )\n            )\n\n    return TicketMappingConfig(\n        name=name,\n        provider=TicketingProvider.SERVICENOW,\n        summary_template=summary_template,\n        field_mappings=field_mappings,\n        servicenow_settings={\n            \"category\": category,\n            \"subcategory\": subcategory,\n            \"assignment_group\": assignment_group,\n        },\n    )\n\n\ndef create_pagerduty_mapping_config(\n    name: str = \"Default PagerDuty Mapping\",\n    routing_key: Optional[str] = None,\n    event_action: str = \"trigger\",\n    summary_template: str = \"[ACGS-2] {title}\",\n    severity_mapping: Optional[Dict[str, str]] = None,\n    source: str = \"ACGS-2\",\n    client: Optional[str] = None,\n    client_url: Optional[str] = None,\n    additional_fields: Optional[Dict[str, Any]] = None,\n) -> TicketMappingConfig:\n    \"\"\"\n    Create a default PagerDuty incident mapping configuration.\n\n    Args:\n        name: Configuration name\n        routing_key: PagerDuty integration/routing key (can be set later)\n        event_action: Event action (trigger, acknowledge, resolve)\n        summary_template: Template for incident summary\n        severity_mapping: Custom severity to PagerDuty severity mapping\n        source: Source identifier for events\n        client: Name of monitoring client\n        client_url: URL to link back to monitoring client\n        additional_fields: Additional custom_details fields\n\n    Returns:\n        TicketMappingConfig for PagerDuty\n    \"\"\"\n    field_mappings = [\n        FieldMapping(\n            target_field=\"summary\",\n            mapping_type=FieldMappingType.TEMPLATE,\n            template=summary_template,\n            required=True,\n            validation_rules=[\n                FieldValidationRule(\n                    validation_type=FieldValidationType.MAX_LENGTH,\n                    value=1024,\n                    error_message=\"PagerDuty summary must be 1024 characters or less\",\n                ),\n            ],\n        ),\n        FieldMapping(\n            target_field=\"severity\",\n            mapping_type=FieldMappingType.TRANSFORM,\n            transform_name=\"severity_to_pagerduty_urgency\",\n            transform_params={\"mapping\": severity_mapping or {}},\n            required=True,\n        ),\n        FieldMapping(\n            target_field=\"source\",\n            mapping_type=FieldMappingType.STATIC,\n            static_value=source,\n            required=True,\n            validation_rules=[\n                FieldValidationRule(\n                    validation_type=FieldValidationType.MAX_LENGTH,\n                    value=255,\n                    error_message=\"PagerDuty source must be 255 characters or less\",\n                ),\n            ],\n        ),\n        FieldMapping(\n            target_field=\"timestamp\",\n            mapping_type=FieldMappingType.EVENT_FIELD,\n            source_field=\"timestamp\",\n        ),\n    ]\n\n    # Add event action if specified\n    if event_action:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"event_action\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=event_action,\n                required=True,\n                validation_rules=[\n                    FieldValidationRule(\n                        validation_type=FieldValidationType.ALLOWED_VALUES,\n                        value=[\"trigger\", \"acknowledge\", \"resolve\"],\n                        error_message=\"event_action must be 'trigger', 'acknowledge', or 'resolve'\",\n                    ),\n                ],\n            )\n        )\n\n    # Add routing key if specified\n    if routing_key:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"routing_key\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=routing_key,\n                required=True,\n            )\n        )\n\n    # Add client information if specified\n    if client:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"client\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=client,\n            )\n        )\n\n    if client_url:\n        field_mappings.append(\n            FieldMapping(\n                target_field=\"client_url\",\n                mapping_type=FieldMappingType.STATIC,\n                static_value=client_url,\n            )\n        )\n\n    # Add additional custom_details field mappings\n    if additional_fields:\n        for field_name, value in additional_fields.items():\n            field_mappings.append(\n                FieldMapping(\n                    target_field=f\"custom_details.{field_name}\",\n                    mapping_type=FieldMappingType.STATIC,\n                    static_value=value,\n                )\n            )\n\n    return TicketMappingConfig(\n        name=name,\n        provider=TicketingProvider.PAGERDUTY,\n        summary_template=summary_template,\n        field_mappings=field_mappings,\n    )\n",
        "timestamp": "2026-01-04T05:35:58.374613"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "056-reduce-excessive-any-type-usage-in-python-codebase",
        "description": "Found 373 occurrences of ': Any' type annotations across 120+ Python files, with high concentrations in integration-service (16 occurrences), src/core/breakthrough (79 occurrences), and src/core/enhanced_agent_bus (50+ occurrences). Excessive use of 'Any' defeats the purpose of type hints and can mask type-related bugs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-03T19:36:18.317769",
  "last_updated": "2026-01-04T05:35:58.436956"
}