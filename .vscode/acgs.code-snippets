{
	"Constitutional Header": {
		"scope": "python",
		"prefix": "chash",
		"body": [
			"\"\"\"",
			"${1:File Description}",
			"Constitutional Hash: cdd01ef066bc6cf2",
			"\"\"\"",
			""
		],
		"description": "Add constitutional hash header"
	},
	"Constitutional Hash Import": {
		"scope": "python",
		"prefix": "himp",
		"body": [
			"try:",
			"    from shared.constants import CONSTITUTIONAL_HASH",
			"except ImportError:",
			"    # Fallback for standalone usage",
			"    CONSTITUTIONAL_HASH = \"cdd01ef066bc6cf2\""
		],
		"description": "Import constitutional hash with fallback"
	},
	"Constitutional Hash Validation": {
		"scope": "python",
		"prefix": "hval",
		"body": [
			"from enhanced_agent_bus.validators import validate_constitutional_hash",
			"from enhanced_agent_bus.exceptions import ConstitutionalHashMismatchError",
			"",
			"result = validate_constitutional_hash(",
			"    provided_hash=${1:message.constitutional_hash},",
			"    expected_hash=CONSTITUTIONAL_HASH",
			")",
			"if not result.is_valid:",
			"    raise ConstitutionalHashMismatchError(",
			"        expected=CONSTITUTIONAL_HASH,",
			"        actual=${1:message.constitutional_hash}",
			"    )"
		],
		"description": "Validate constitutional hash"
	},
	"Async Constitutional Test": {
		"scope": "python",
		"prefix": "atest",
		"body": [
			"@pytest.mark.asyncio",
			"@pytest.mark.constitutional",
			"async def test_${1:feature}_${2:scenario}(${3:mocker}):",
			"    \"\"\"Test ${1:feature} ${2:scenario} with constitutional compliance.\"\"\"",
			"    # Arrange",
			"    $0",
			"    ",
			"    # Act",
			"    ",
			"    # Assert"
		],
		"description": "Async constitutional test template"
	},
	"Agent Message": {
		"scope": "python",
		"prefix": "amsg",
		"body": [
			"from enhanced_agent_bus.models import AgentMessage, MessageType, Priority",
			"",
			"message = AgentMessage(",
			"    from_agent=\"${1:sender}\",",
			"    to_agent=\"${2:receiver}\",",
			"    message_type=MessageType.${3|COMMAND,QUERY,EVENT,NOTIFICATION,GOVERNANCE_REQUEST,TASK_REQUEST|},",
			"    content={",
			"        \"${4:key}\": \"${5:value}\"",
			"    },",
			"    priority=Priority.${6|MEDIUM,HIGH,CRITICAL,LOW|},",
			"    tenant_id=\"${7:default}\",",
			"    constitutional_hash=CONSTITUTIONAL_HASH",
			")"
		],
		"description": "Create an AgentMessage instance"
	},
	"Circuit Breaker Decorator": {
		"scope": "python",
		"prefix": "cb",
		"body": [
			"from shared.circuit_breaker import with_circuit_breaker",
			"",
			"",
			"def _${1:service}_fallback(*args, **kwargs):",
			"    \"\"\"Fallback when ${1:service} circuit is open.\"\"\"",
			"    return {\"status\": \"unavailable\", \"service\": \"${1:service}\"}",
			"",
			"",
			"@with_circuit_breaker('${1:service}', fallback=_${1:service}_fallback)",
			"async def call_${1:service}(${2:params}):",
			"    \"\"\"Call ${1:service} with circuit breaker protection.\"\"\"",
			"    $0"
		],
		"description": "Wrap function with circuit breaker and fallback"
	},
	"Impact Scoring": {
		"scope": "python",
		"prefix": "score",
		"body": [
			"from enhanced_agent_bus.deliberation_layer.impact_scorer import ImpactScorer",
			"from enhanced_agent_bus.deliberation_layer.adaptive_router import AdaptiveRouter",
			"",
			"scorer = ImpactScorer()",
			"router = AdaptiveRouter(threshold=0.8)",
			"",
			"impact_score = await scorer.calculate_impact(${1:message})",
			"if router.should_deliberate(impact_score):",
			"    # Route to deliberation layer",
			"    ${2:pass}",
			"else:",
			"    # Fast lane processing",
			"    ${3:pass}"
		],
		"description": "Calculate decision impact score with routing"
	},
	"Custom Exception": {
		"scope": "python",
		"prefix": "exc",
		"body": [
			"class ${1:Custom}Error(AgentBusError):",
			"    \"\"\"Raised when ${2:description}.\"\"\"",
			"",
			"    def __init__(",
			"        self,",
			"        ${3:param}: ${4:str},",
			"        ${5:reason}: str,",
			"    ):",
			"        self.${3:param} = ${3:param}",
			"        self.${5:reason} = ${5:reason}",
			"        super().__init__(",
			"            message=f\"${1:Custom} error for '{${3:param}}': {${5:reason}}\",",
			"            details={",
			"                \"${3:param}\": ${3:param},",
			"                \"${5:reason}\": ${5:reason},",
			"            },",
			"        )"
		],
		"description": "Create a custom exception class"
	},
	"Dataclass Model": {
		"scope": "python",
		"prefix": "dcls",
		"body": [
			"from dataclasses import dataclass, field",
			"from datetime import datetime, timezone",
			"from typing import Any, Dict, List, Optional",
			"",
			"",
			"@dataclass",
			"class ${1:ModelName}:",
			"    \"\"\"${2:Model description}.\"\"\"",
			"    ${3:field_name}: ${4:str}",
			"    constitutional_hash: str = CONSTITUTIONAL_HASH",
			"    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))",
			"    metadata: Dict[str, Any] = field(default_factory=dict)",
			"",
			"    def to_dict(self) -> Dict[str, Any]:",
			"        \"\"\"Convert to dictionary.\"\"\"",
			"        return {",
			"            \"${3:field_name}\": self.${3:field_name},",
			"            \"constitutional_hash\": self.constitutional_hash,",
			"            \"created_at\": self.created_at.isoformat(),",
			"            \"metadata\": self.metadata,",
			"        }"
		],
		"description": "Create a dataclass with constitutional compliance"
	},
	"Logging with Context": {
		"scope": "python",
		"prefix": "logc",
		"body": [
			"import logging",
			"",
			"logger = logging.getLogger(__name__)",
			"",
			"logger.${1|info,warning,error,debug|}(",
			"    f\"[{CONSTITUTIONAL_HASH}] ${2:message}\",",
			"    extra={",
			"        \"constitutional_hash\": CONSTITUTIONAL_HASH,",
			"        \"${3:context_key}\": ${4:context_value},",
			"    }",
			")"
		],
		"description": "Log with constitutional context"
	},
	"Async Message Handler": {
		"scope": "python",
		"prefix": "handler",
		"body": [
			"async def handle_${1:message_type}(message: AgentMessage) -> Dict[str, Any]:",
			"    \"\"\"",
			"    Handle ${1:message_type} messages.",
			"    Constitutional Hash: cdd01ef066bc6cf2",
			"    \"\"\"",
			"    logger.info(",
			"        f\"[{CONSTITUTIONAL_HASH}] Processing {message.message_id}\",",
			"        extra={\"message_type\": \"${1:message_type}\", \"from\": message.from_agent}",
			"    )",
			"    ",
			"    try:",
			"        $0",
			"        return {\"status\": \"success\", \"message_id\": message.message_id}",
			"    except Exception as e:",
			"        logger.error(f\"[{CONSTITUTIONAL_HASH}] Handler failed: {e}\")",
			"        raise HandlerExecutionError(",
			"            handler_name=\"handle_${1:message_type}\",",
			"            message_id=message.message_id,",
			"            original_error=e",
			"        )"
		],
		"description": "Async message handler with error handling"
	},
	"OPA Policy Evaluation": {
		"scope": "python",
		"prefix": "opa",
		"body": [
			"from enhanced_agent_bus.opa_client import OPAClient",
			"from enhanced_agent_bus.exceptions import PolicyEvaluationError",
			"",
			"opa_client = OPAClient(opa_url=\"${1:http://localhost:8181}\")",
			"",
			"policy_input = {",
			"    \"agent_id\": ${2:agent_id},",
			"    \"action\": \"${3:action}\",",
			"    \"constitutional_hash\": CONSTITUTIONAL_HASH,",
			"}",
			"",
			"result = await opa_client.evaluate(",
			"    policy_path=\"${4:acgs/governance}\",",
			"    input_data=policy_input",
			")",
			"",
			"if not result.get(\"allow\", False):",
			"    raise PolicyEvaluationError(",
			"        policy_path=\"${4:acgs/governance}\",",
			"        reason=result.get(\"reason\", \"Policy denied\"),",
			"        input_data=policy_input",
			"    )"
		],
		"description": "Evaluate OPA policy with error handling"
	},
	"Decision Log": {
		"scope": "python",
		"prefix": "dlog",
		"body": [
			"from enhanced_agent_bus.models import DecisionLog",
			"import uuid",
			"",
			"decision_log = DecisionLog(",
			"    trace_id=str(uuid.uuid4()),",
			"    span_id=str(uuid.uuid4()),",
			"    agent_id=\"${1:agent_id}\",",
			"    tenant_id=\"${2:tenant_id}\",",
			"    policy_version=\"${3:v1.0.0}\",",
			"    risk_score=${4:0.5},",
			"    decision=\"${5|approve,deny,escalate|}\",",
			"    compliance_tags=[\"${6:governance}\"],",
			"    metadata={\"${7:key}\": \"${8:value}\"}",
			")"
		],
		"description": "Create a structured decision log"
	},
	"Redis Connection": {
		"scope": "python",
		"prefix": "redis",
		"body": [
			"import redis.asyncio as redis",
			"from shared.constants import DEFAULT_REDIS_URL",
			"",
			"redis_client = redis.from_url(",
			"    \"${1:$DEFAULT_REDIS_URL}\",",
			"    encoding=\"utf-8\",",
			"    decode_responses=True",
			")",
			"",
			"try:",
			"    await redis_client.ping()",
			"    logger.info(f\"[{CONSTITUTIONAL_HASH}] Redis connected\")",
			"except redis.ConnectionError as e:",
			"    logger.error(f\"[{CONSTITUTIONAL_HASH}] Redis connection failed: {e}\")",
			"    raise"
		],
		"description": "Async Redis connection with health check"
	},
	"Performance Metrics": {
		"scope": "python",
		"prefix": "perf",
		"body": [
			"import time",
			"from contextlib import asynccontextmanager",
			"",
			"@asynccontextmanager",
			"async def measure_${1:operation}():",
			"    \"\"\"Measure ${1:operation} performance.\"\"\"",
			"    start = time.perf_counter()",
			"    try:",
			"        yield",
			"    finally:",
			"        elapsed_ms = (time.perf_counter() - start) * 1000",
			"        logger.info(",
			"            f\"[{CONSTITUTIONAL_HASH}] ${1:operation} completed in {elapsed_ms:.2f}ms\",",
			"            extra={\"operation\": \"${1:operation}\", \"elapsed_ms\": elapsed_ms}",
			"        )",
			"        # P99 target: <5ms",
			"        if elapsed_ms > 5:",
			"            logger.warning(f\"[{CONSTITUTIONAL_HASH}] ${1:operation} exceeded P99 target\")"
		],
		"description": "Performance measurement context manager"
	},
	"HITL Approval": {
		"scope": "python",
		"prefix": "hitl",
		"body": [
			"from enhanced_agent_bus.deliberation_layer.hitl_manager import HITLManager",
			"",
			"hitl = HITLManager()",
			"",
			"approval_request = {",
			"    \"decision_id\": ${1:decision_id},",
			"    \"message\": ${2:message},",
			"    \"impact_score\": ${3:impact_score},",
			"    \"required_approvers\": [\"${4:reviewer}\"],",
			"    \"constitutional_hash\": CONSTITUTIONAL_HASH,",
			"}",
			"",
			"approval = await hitl.request_approval(approval_request)",
			"if approval.approved:",
			"    $0",
			"else:",
			"    logger.warning(f\"[{CONSTITUTIONAL_HASH}] Decision {${1:decision_id}} rejected\")"
		],
		"description": "Human-in-the-loop approval workflow"
	},
	"Pytest Fixture": {
		"scope": "python",
		"prefix": "fix",
		"body": [
			"@pytest.fixture",
			"def ${1:fixture_name}():",
			"    \"\"\"Provide ${2:description}.\"\"\"",
			"    ${3:resource} = ${4:setup_code}",
			"    yield ${3:resource}",
			"    # Teardown",
			"    ${5:cleanup_code}"
		],
		"description": "Pytest fixture with setup/teardown"
	},
	"Async Pytest Fixture": {
		"scope": "python",
		"prefix": "afix",
		"body": [
			"@pytest.fixture",
			"async def ${1:fixture_name}():",
			"    \"\"\"Provide ${2:description}.\"\"\"",
			"    ${3:resource} = await ${4:async_setup_code}",
			"    yield ${3:resource}",
			"    # Teardown",
			"    await ${5:async_cleanup_code}"
		],
		"description": "Async pytest fixture with setup/teardown"
	},
	"Import All Exceptions": {
		"scope": "python",
		"prefix": "excimp",
		"body": [
			"from enhanced_agent_bus.exceptions import (",
			"    AgentBusError,",
			"    ConstitutionalError,",
			"    ConstitutionalHashMismatchError,",
			"    ConstitutionalValidationError,",
			"    MessageValidationError,",
			"    MessageDeliveryError,",
			"    PolicyEvaluationError,",
			"    BusNotStartedError,",
			"    HandlerExecutionError,",
			")"
		],
		"description": "Import common exception classes"
	},
	"Routing Context": {
		"scope": "python",
		"prefix": "rctx",
		"body": [
			"from enhanced_agent_bus.models import RoutingContext",
			"",
			"routing = RoutingContext(",
			"    source_agent_id=\"${1:source}\",",
			"    target_agent_id=\"${2:target}\",",
			"    routing_key=\"${3:key}\",",
			"    routing_tags=[\"${4:tag}\"],",
			"    max_retries=${5:3},",
			"    timeout_ms=${6:5000},",
			")"
		],
		"description": "Create routing context for message delivery"
	},
	"OPA Rego Policy": {
		"scope": "rego",
		"prefix": "opapol",
		"body": [
			"package acgs.${1:governance}",
			"",
			"import future.keywords.if",
			"import future.keywords.in",
			"",
			"default allow := false",
			"",
			"allow if {",
			"    input.constitutional_hash == \"cdd01ef066bc6cf2\"",
			"    ${2:additional_conditions}",
			"}"
		],
		"description": "Create a new OPA Rego policy"
	},
	"Prometheus Counter": {
		"scope": "python",
		"prefix": "metcount",
		"body": [
			"from prometheus_client import Counter",
			"",
			"${1:METRIC_NAME} = Counter(",
			"    \"acgs_${1:metric_name}_total\",",
			"    \"${2:Description}\",",
			"    [\"agent_id\", \"status\"]",
			")",
			"",
			"${1:METRIC_NAME}.labels(agent_id=${3:agent_id}, status=\"${4:success}\").inc()"
		],
		"description": "Create and increment a Prometheus counter"
	},
	"Prometheus Histogram": {
		"scope": "python",
		"prefix": "methist",
		"body": [
			"from prometheus_client import Histogram",
			"",
			"${1:METRIC_NAME} = Histogram(",
			"    \"acgs_${1:metric_name}_seconds\",",
			"    \"${2:Description}\",",
			"    buckets=(.005, .01, .025, .05, .075, .1, .25, .5, .75, 1.0, 2.5, 5.0, 7.5, 10.0, float(\"inf\"))",
			")",
			"",
			"with ${1:METRIC_NAME}.time():",
			"    $0"
		],
		"description": "Create a Prometheus histogram for timing"
	},
	"FastAPI Route": {
		"scope": "python",
		"prefix": "fastroute",
		"body": [
			"from fastapi import APIRouter, HTTPException, Depends, status",
			"from pydantic import BaseModel",
			"",
			"router = APIRouter(prefix=\"/${1:resource}\", tags=[\"${1:resource}\"])",
			"",
			"",
			"class ${2:Resource}Response(BaseModel):",
			"    id: str",
			"    ${3:field}: ${4:str}",
			"",
			"",
			"@router.get(\"/{item_id}\", response_model=${2:Resource}Response)",
			"async def get_${1:resource}(item_id: str):",
			"    \"\"\"Get ${1:resource} by ID.\"\"\"",
			"    try:",
			"        $0",
			"        return ${2:Resource}Response(id=item_id, ${3:field}=\"\")",
			"    except Exception as e:",
			"        raise HTTPException(",
			"            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
			"            detail=str(e)",
			"        )"
		],
		"description": "FastAPI route with error handling"
	},
	"Pydantic Model": {
		"scope": "python",
		"prefix": "pydmod",
		"body": [
			"from pydantic import BaseModel, Field, field_validator",
			"from typing import Optional, List",
			"from datetime import datetime",
			"",
			"",
			"class ${1:ModelName}(BaseModel):",
			"    \"\"\"${2:Model description}.\"\"\"",
			"    ${3:field_name}: ${4:str} = Field(..., description=\"${5:Field description}\")",
			"    created_at: datetime = Field(default_factory=datetime.utcnow)",
			"    metadata: Optional[dict] = None",
			"",
			"    @field_validator(\"${3:field_name}\")",
			"    @classmethod",
			"    def validate_${3:field_name}(cls, v: ${4:str}) -> ${4:str}:",
			"        if not v:",
			"            raise ValueError(\"${3:field_name} cannot be empty\")",
			"        return v",
			"",
			"    model_config = {",
			"        \"json_schema_extra\": {",
			"            \"example\": {",
			"                \"${3:field_name}\": \"example_value\"",
			"            }",
			"        }",
			"    }"
		],
		"description": "Pydantic model with validators"
	},
	"Structured Logger": {
		"scope": "python",
		"prefix": "slog",
		"body": [
			"import structlog",
			"",
			"logger = structlog.get_logger(__name__)",
			"",
			"logger.${1|info,warning,error,debug|}(",
			"    \"${2:event_message}\",",
			"    ${3:key}=${4:value},",
			"    constitutional_hash=CONSTITUTIONAL_HASH,",
			")"
		],
		"description": "Structured logging with context"
	},
	"Async Retry": {
		"scope": "python",
		"prefix": "aretry",
		"body": [
			"import asyncio",
			"from functools import wraps",
			"from typing import TypeVar, Callable",
			"",
			"T = TypeVar(\"T\")",
			"",
			"",
			"def async_retry(",
			"    max_attempts: int = 3,",
			"    base_delay: float = 0.1,",
			"    max_delay: float = 10.0,",
			"):",
			"    \"\"\"Retry async function with exponential backoff.\"\"\"",
			"    def decorator(func: Callable[..., T]) -> Callable[..., T]:",
			"        @wraps(func)",
			"        async def wrapper(*args, **kwargs) -> T:",
			"            for attempt in range(max_attempts):",
			"                try:",
			"                    return await func(*args, **kwargs)",
			"                except Exception as e:",
			"                    if attempt == max_attempts - 1:",
			"                        raise",
			"                    delay = min(base_delay * (2 ** attempt), max_delay)",
			"                    await asyncio.sleep(delay)",
			"            raise RuntimeError(\"Unreachable\")",
			"        return wrapper",
			"    return decorator",
			"",
			"",
			"@async_retry(max_attempts=${1:3})",
			"async def ${2:function_name}():",
			"    $0"
		],
		"description": "Async retry with exponential backoff"
	},
	"SQLAlchemy Async Session": {
		"scope": "python",
		"prefix": "dbsess",
		"body": [
			"from contextlib import asynccontextmanager",
			"from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker",
			"",
			"engine = create_async_engine(",
			"    \"${1:postgresql+asyncpg://user:pass@localhost/db}\",",
			"    echo=${2:False},",
			")",
			"",
			"async_session = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)",
			"",
			"",
			"@asynccontextmanager",
			"async def get_session():",
			"    \"\"\"Provide async database session.\"\"\"",
			"    async with async_session() as session:",
			"        try:",
			"            yield session",
			"            await session.commit()",
			"        except Exception:",
			"            await session.rollback()",
			"            raise"
		],
		"description": "SQLAlchemy async session context manager"
	},
	"Mock Async Function": {
		"scope": "python",
		"prefix": "mockasync",
		"body": [
			"from unittest.mock import AsyncMock, patch",
			"",
			"mock_${1:function} = AsyncMock(return_value=${2:expected_result})",
			"",
			"with patch(\"${3:module.path}.${1:function}\", mock_${1:function}):",
			"    result = await ${4:function_under_test}()",
			"    mock_${1:function}.assert_called_once_with($5)",
			"    assert result == ${2:expected_result}"
		],
		"description": "Mock async function with assertions"
	},
	"Parametrized Test": {
		"scope": "python",
		"prefix": "paramtest",
		"body": [
			"@pytest.mark.parametrize(",
			"    \"${1:input_param},${2:expected}\",",
			"    [",
			"        (${3:value1}, ${4:expected1}),",
			"        (${5:value2}, ${6:expected2}),",
			"        (${7:value3}, ${8:expected3}),",
			"    ],",
			")",
			"def test_${9:feature}(${1:input_param}, ${2:expected}):",
			"    \"\"\"Test ${9:feature} with various inputs.\"\"\"",
			"    result = ${10:function}(${1:input_param})",
			"    assert result == ${2:expected}"
		],
		"description": "Parametrized test with multiple cases"
	},
	"React Custom Hook": {
		"scope": "typescriptreact,typescript",
		"prefix": "rhook",
		"body": [
			"import { useState, useEffect, useCallback } from 'react';",
			"",
			"interface Use${1:HookName}Options {",
			"  ${2:option}?: ${3:string};",
			"}",
			"",
			"interface Use${1:HookName}Return {",
			"  ${4:data}: ${5:unknown};",
			"  loading: boolean;",
			"  error: Error | null;",
			"  refetch: () => void;",
			"}",
			"",
			"export function use${1:HookName}(options?: Use${1:HookName}Options): Use${1:HookName}Return {",
			"  const [${4:data}, set${4/(.*)/${1:/capitalize}/}] = useState<${5:unknown}>(null);",
			"  const [loading, setLoading] = useState(true);",
			"  const [error, setError] = useState<Error | null>(null);",
			"",
			"  const fetchData = useCallback(async () => {",
			"    setLoading(true);",
			"    setError(null);",
			"    try {",
			"      $0",
			"      // set${4/(.*)/${1:/capitalize}/}(result);",
			"    } catch (e) {",
			"      setError(e instanceof Error ? e : new Error('Unknown error'));",
			"    } finally {",
			"      setLoading(false);",
			"    }",
			"  }, [options?.${2:option}]);",
			"",
			"  useEffect(() => {",
			"    fetchData();",
			"  }, [fetchData]);",
			"",
			"  return { ${4:data}, loading, error, refetch: fetchData };",
			"}"
		],
		"description": "React custom hook template"
	},
	"API Fetch GET": {
		"scope": "typescriptreact,typescript",
		"prefix": "apiget",
		"body": [
			"async function fetch${1:Resource}(id: string): Promise<${2:ResponseType}> {",
			"  const response = await fetch(`${${3:/api/${1:/downcase}}}/${id}`, {",
			"    method: 'GET',",
			"    headers: {",
			"      'Content-Type': 'application/json',",
			"    },",
			"  });",
			"",
			"  if (!response.ok) {",
			"    throw new Error(`Failed to fetch ${1:Resource}: ${response.statusText}`);",
			"  }",
			"",
			"  return response.json();",
			"}"
		],
		"description": "Fetch API GET request"
	},
	"DAG Executor": {
		"scope": "python",
		"prefix": "dag",
		"body": [
			"from .agent.workflows import DAGExecutor, DAGNode, WorkflowContext",
			"",
			"dag = DAGExecutor(\"${1:workflow-id}\")",
			"dag.add_node(DAGNode(\"${2:node_id}\", \"${3:Node Name}\", ${4:execute_async_func}))",
			"dag.add_node(DAGNode(\"${5:node_id_2}\", \"${6:Node Name 2}\", ${7:execute_async_func_2}, dependencies=[\"${2:node_id}\"]))",
			"",
			"context = WorkflowContext.create()",
			"result = await dag.execute(context)"
		],
		"description": "Create and execute a DAG workflow"
	},
	"Saga Pattern": {
		"scope": "python",
		"prefix": "saga",
		"body": [
			"from .agent.workflows import BaseSaga, SagaStep, WorkflowContext",
			"",
			"saga = BaseSaga(\"${1:saga-id}\")",
			"saga.add_step(SagaStep(\"${2:step_name}\", ${3:execute_func}, ${4:compensate_func}))",
			"saga.add_step(SagaStep(\"${5:step_name_2}\", ${6:execute_func_2}, ${7:compensate_func_2}))",
			"",
			"context = WorkflowContext.create()",
			"result = await saga.execute(context, {\"${8:key}\": \"${9:value}\"})"
		],
		"description": "Create and execute a Saga workflow with compensation"
	},
	"Voting Workflow": {
		"scope": "python",
		"prefix": "vote",
		"body": [
			"from .agent.workflows import VotingWorkflow, VotingStrategy",
			"",
			"workflow = VotingWorkflow(",
			"    eligible_agents=[\"${1:agent1}\", \"${2:agent2}\"],",
			"    strategy=VotingStrategy.${3|MAJORITY,SUPERMAJORITY,UNANIMOUS,WEIGHTED,QUORUM|},",
			"    quorum_percentage=${4:0.66}",
			")",
			"result = await workflow.run({\"proposal\": \"${5:proposal_text}\"})"
		],
		"description": "Create and run a Multi-Agent Voting workflow"
	},
	"Handoff Workflow": {
		"scope": "python",
		"prefix": "handoff",
		"body": [
			"from .agent.workflows import HandoffWorkflow",
			"",
			"handoff = HandoffWorkflow(",
			"    source_agent=\"${1:source}\",",
			"    target_agent=\"${2:target}\",",
			"    context=${3:context}",
			")",
			"result = await handoff.execute({\"task\": \"${4:task_description}\"})"
		],
		"description": "Create and execute an Agent-to-Agent Handoff workflow"
	},
	"Constitutional Validation Workflow": {
		"scope": "python",
		"prefix": "valflow",
		"body": [
			"from .agent.workflows import ConstitutionalValidationWorkflow",
			"",
			"validation = ConstitutionalValidationWorkflow()",
			"result = await validation.run({",
			"    \"constitutional_hash\": CONSTITUTIONAL_HASH,",
			"    \"${1:resource_type}\": ${2:resource_data}",
			"})",
			"if not result.is_valid:",
			"    logger.error(f\"Validation failed: {result.errors}\")"
		],
		"description": "Run a Constitutional Validation workflow"
	}
}
